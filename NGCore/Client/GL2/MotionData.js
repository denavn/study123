var Core = require ('../Core').Core;

/*#if TYPECHECK
var T = Core.TypeCheck;
#endif*/

var MotionData = exports.MotionData = Core.Class.subclass(
/** @lends GL2.MotionData.prototype */
{
	classname: 'MotionData',

    /**
     * @class
     * MotionData The `MotionData` class stores animation keyframe data that multiple `{@link GL2.MotionController}` objects can reference. A `MotionData` object
     * can store multiple animations. Each animation has a unique name, stored as a string.
     *
     * Animation keyframe data is stored as a JSON object with the following properties:
     *
     * + `motions`: This key is the root property of an animation. Each animation object has a unique name and contains the subsequent `Keyframe` and `source` elements.
     * + name: A unique string that identifies the animation.
     * + `Keyframe`: An array of keyframe definitions. Each keyframe has the following properties:
     *     + `x`: X position coordinate relative to the coordinates in the `source` field. The `source` field coordinates are generated by calling `{@link GL2.Node.setPosition}`.
     *     + `y`: Y position coordinate relative to the coordinates in the `source` field. The `source` field coordinates are generated by calling `{@link GL2.Node.setPosition}`.
     *     + `scaleX`: A positive horizontal scale multiplication factor.
     *     + `scaleY`: A positive vertical scale multiplication factor.
     *     + `index`: The frame this keyframe represents. An index of 0 represents the first frame of the animation.
     *     + `alpha`: A value from 0 to 1 indicating the opacity percentage of the alpha channel.
     *     + `rotation`: A rotation value from -180 degrees to 180 degrees.
     * + `source`: A source object defines properties of the animation and has the following properties:
     *     + `framerate`: An integer that specifies how many animation frames play per second. The value of `framerate` and the highest `index` value of any element in the `Keyframe`
     *        array define the duration of the animation. An animation with a `framerate` value of 30 and a `Keyframe` with the highest `index` value of 60 takes 2 seconds to play, for example.
     *     + `x`: X position coordinate generated by calling `{@link GL2.Node.setPosition}`.
     *     + `y`: Y position coordinate generated by calling `{@link GL2.Node.setPosition}`.
     *     + `scaleX`: A positive horizontal scale multiplication factor.
     *     + `scaleY`: A positive vertical scale multiplication factor.
     *     + `alpha`: A value from 0 to 1 indicating the opacity percentage of the alpha channel.
     *     + `rotation`: A rotation value from -180 degrees to 180 degrees.
     *
     * **Example animation JSON block**
     *
     * <pre>
     * {
     *     "motions": {
     *         "alphafade": {
     *             "Keyframe": [{
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 0,
     *                 "alpha": 1,
     *                 "rotation": 0
     *             }, {
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 15,
     *                 "alpha": 0,
     *                 "rotation": 0
     *             }, {
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 30,
     *                 "alpha": 1,
     *                 "rotation": 0
     *             }],
     *             "source": [{
     *                 "frameRate": 30,
     *                 "x": 100.84,
     *                 "scaleX": 1,
     *                 "y": -94.2,
     *                 "scaleY": 1,
     *                 "rotation": 0,
     *                 "alpha": 1
     *             }]
     *         }
     *     }
     * }
     * </pre>
     *
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     *     var mc;
     *     if (error) {
     *         console.log('error');
     *     } else {
     *         mc = new GL2.MotionController(md);
     *     }
     * });
     * @constructs Create a MotionData instance.
     * @since 1.7
     */
	initialize: function ()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._callbackIndexCounter = 1;
		this._callbacks = [];
	},

    /**
     * @function
     *
     * Destroy this `MotionData` object.
     * Destroy all `{@link GL2.MotionController}` instances that reference a `MotionData` object before calling this method.
     * When you call this method on a `MotionData` object that is referred to by existing `{@link GL2.MotionController}`
     * objects, the `MotionData` object is not destroyed until the last referring `{@link GL2.MotionController}` object is destroyed.
     *
     * @returns {void}
     * @since 1.7
     */
	destroy: function ()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

    /**
     * @function
     *
     * Verifies that a given `MotionData.DataFormat` enum has a legal value.
     * @example
     * md = new GL2.MotionData();
     * if (md.isDataFormatSupported(GL2.MotionData.DataFormat.FlashClassicTween)) {
     * 	console.log('Flash Classic Tween is supported!');
     * }
     * @param {GL2.MotionData.DataFormat} dataFormat The data format to test.
     * @returns {Boolean} true when the given dataFormat enum has a legal value. This method returns <code>false</code> in all other cases.
     * @since 1.7
     */
	isDataFormatSupported: function (dataFormat)
	{
		if (Core.Capabilities.meetsBinaryVersion && Core.Capabilities.meetsBinaryVersion([1,7,0,0,0])) {
			return dataFormat === MotionData.DataFormat.FlashClassicTween;
		} else {
			return false;
		}
	},

    /**
     * @function
     *
     * Initialize this `MotionData` object with keyframe data in the given format. This method loads the data in JavaScript.
     * @param {Object|String} dataOrJSONString Animation data. This parameter can be a raw JavaScript object or a JSON string.
     * @param {GL2.MotionData.DataFormat} dataFormat The format for the keyframe data.
     * @cb {Function} callback The function to call after creating the transaction.
     * @cb-param {String} error The error string. This parameter is undefined if there is no error.
     * @cb-param {MotionData} object This <code>MotionData</code> object.
     * @cb-returns {void}
     * @example
     * var data = {
     * 	motions: {
     * 		left_to_right: {
     * 			Kefyrame: [{x: 0, y: 120, scaleX: 1, scaleY: 1, rotation: 0, index: 0},
     * 					   {x: 320, y: 120, scaleX: 1, scaleY: 1, rotation: 0, index: 30}],
     * 			source: [{x: 0, y: 0, scaleX: 1, scaleY: 1, rotation: 0}]
     * 		}
     * 	}
     * };
     * md = new GL2.MotionData();
     * md.initFromData(data, GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     * 	if (error) {
     * 		console.log('error');
     * 	} else {
     * 		console.log('success');
     * 	}
     * });
     * @returns {this}
     * @since 1.7
     */
    initFromData: function (dataOrJSONString, dataFormat, callback)
	{
/*#if TYPECHECK
		T.validateArgs(arguments, [T.Arg('any'), T.Arg('integer'), T.Arg('function')]);
#endif*/
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof dataOrJSONString === 'string' || typeof dataOrJSONString === 'object') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				if (typeof dataOrJSONString === 'string') {
					this._initFromDataSendGen(dataOrJSONString, dataFormat, id);
				} else {
					this._initFromDataSendGen(JSON.stringify(dataOrJSONString), dataFormat, id);
				}
			} else {
				if (callback && typeof callback === 'function') {
					callback("Expected Object or String");
				}
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback("Data Format Not Supported");
			}
		}
		return this;
	},

    /**
     * @function
     *
     * Initialize this `MotionData` object with keyframe data from a JSON file. This method loads the data in native code.
     * @param {String} filename The file where the animation data is stored in JSON format.
     * @param {GL2.MotionData.DataFormat} dataFormat The format for the keyframe data.
     * @cb {Function} callback The function to call after creating the transaction.
     * @cb-param {String} error The error string. This parameter is undefined if there is no error.
     * @cb-param {GL2.MotionData} object This <code>MotionData</code> object.
     * @cb-returns {void}
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     * 	if (error) {
     * 		console.log('error');
     * 	} else {
     * 		console.log('success');
     * 	}
     * });
     * @returns {this}
     * @since 1.7
     */
	initFromJSONFile: function (filename, dataFormat, callback)
	{
/*#if TYPECHECK
		T.validateArgs(arguments, [T.Arg('string'), T.Arg('integer'), T.Arg('function')]);
#endif*/
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof filename === 'string') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				this._initFromJSONFileSendGen(filename, dataFormat, id);
			} else {
				callback("Invalid filename");
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback("Data Format Not Supported");
			}
		}
		return this;
	},

	/**
	 * @private
     */
	_invokeCallbackRecv: function (cmd) {
		var msg = {};
		if (!this._invokeCallbackRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		var err = msg.error;
		if (!id) {
			NgLogE("GL2.MotionData._invokeCallbackRecv command : bad id = " + id);
			return;
		}
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("GL2.MotionData._invokeCallbackRecv command : No registered callback found, id = " + id);
			return;
		}
		delete this._callbacks[id];
		cb(err, this);
	},

    /**
     * Enumerated values for `MotionData` objects.
     * @name DataFormat
     * @fieldOf GL2.MotionData#
     */

    /**
     * The Flash Classic Tween animation format
     * @name DataFormat.FlashClassicTween
     * @fieldOf GL2.MotionData#
     * @constant
     */

// {{?Wg Generated Code}}
	
	// Enums.
	DataFormat:
	{ 
		FlashClassicTween: 0
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 364,
	// Method create = -1
	// Method destroy = 2
	// Method initFromData = 3
	// Method initFromJSONFile = 4
	// Method invokeCallback = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MotionData._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MotionData._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[364] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( id )
	{
/*#if TYPECHECK
        Core.TypeCheck.validateArgs(arguments, [Core.TypeCheck.Arg('integer'), ]);
#endif*/
		Core.Proc.appendToCommandString( 0x16cffff, [ +id ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
/*#if TYPECHECK
        Core.TypeCheck.validateArgs(arguments, []);
#endif*/
		Core.Proc.appendToCommandString( 0x16c0002, this );
	},
	
	/** @private */
	_initFromDataSendGen: function( animData, dataFormat, callbackId )
	{
/*#if TYPECHECK
        Core.TypeCheck.validateArgs(arguments, [Core.TypeCheck.Arg('string'), Core.TypeCheck.Arg('integer'), Core.TypeCheck.Arg('integer'), ]);
#endif*/
		Core.Proc.appendToCommandString( 0x16c0003, this, [ Core.Proc.encodeString( animData ), +dataFormat, +callbackId ] );
	},
	
	/** @private */
	_initFromJSONFileSendGen: function( filename, dataFormat, callbackId )
	{
/*#if TYPECHECK
        Core.TypeCheck.validateArgs(arguments, [Core.TypeCheck.Arg('string'), Core.TypeCheck.Arg('integer'), Core.TypeCheck.Arg('integer'), ]);
#endif*/
		Core.Proc.appendToCommandString( 0x16c0004, this, [ Core.Proc.encodeString( filename ), +dataFormat, +callbackId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( id ) {}
	
	// destroy: function(  ) {}
	
	// initFromData: function( animData, dataFormat, callbackId ) {}
	
	// initFromJSONFile: function( filename, dataFormat, callbackId ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
