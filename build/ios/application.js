var $ng__COMBINED = true;
var $MODULE_FACTORY_REGISTRY = typeof $MODULE_FACTORY_REGISTRY !== 'undefined' ? $MODULE_FACTORY_REGISTRY : {};
var $MODULE_REGISTRY = typeof $MODULE_REGISTRY !== 'undefined' ? $MODULE_REGISTRY : {};

var assert = typeof assert !== 'undefined' ? assert : function(x, y) { if(!x) throw new Error(y ? y:'Assertion Failed'); };

// override the require function anyway.
var require = function(path) {
    if (!$MODULE_FACTORY_REGISTRY[path]) {
        var e = new Error("RequireError: Module Missing or not yet Loaded ["+JSON.stringify(path)+"]");
        e.relatedFile = path;
        throw e;
    } else if (!require.cache[path]) {
        require.cache[path] = $MODULE_FACTORY_REGISTRY[path]();
    }
    return require.cache[path];
}

require.resolve = require.resolve || function(path) {return path;}
require.cache = require.cache || $MODULE_REGISTRY;
if (typeof(console) === 'undefined'){console = { log: (typeof __underscore_SysLog == 'function') ? __underscore_SysLog: function(str) {} };}
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/NGJSEnvironmentSupport.js';

/**

 # NGJSEnvironmentSupport.js
 # webgame
 #
 # Created by Frederic Barthelemy on 10/01/10.
 # Copyright 2010 ngmoco:). All rights reserved.

 */

/**
 * Provides Environmental support for features missing on certain platforms.
 */


/**
 * setTimeout and setInterval implementation for platforms that don't have it.
 *	It fires timers at the beginning of the first frame past the requested millisecond,
 *	before it processes messages for a particular frame.
 *
 * Platform Consumers:
 *	- Android
 *
 * Note:
 *	- Only accurate to within the frame.
 *	- Does behaves like webkit in that it lets clearInterval and clearTimeout
 *		clear timers created by each other's constructor style.
 *
 */
var NGSetTimeoutCustom = false;
var NGSetTimeoutCallbacks = {};
var NGSetTimeoutUIDGenerator = 0;

exports.NGSetTimeoutRunTimers = function() {
	if(NGSetTimeoutCustom) {
		var timersToExecute = [];
		var curTime = new Date().getTime();
		for (var tk in NGSetTimeoutCallbacks) {
			if (NGSetTimeoutCallbacks.hasOwnProperty(tk) && NGSetTimeoutCallbacks[tk].shouldExecute(curTime)) {
				timersToExecute.push(NGSetTimeoutCallbacks[tk]);
			}
		}

		for (var i in timersToExecute) {
			if (timersToExecute.hasOwnProperty(i)) {
				timersToExecute[i].execute();
			}
		}
	}
};

if(typeof(setTimeout) != "function") {
	NGSetTimeoutCustom = true;

	var NGSingleTimeoutInstance = function(fptr, timeMs) {
		this.uid = NGSetTimeoutUIDGenerator++;
		if (NGSetTimeoutUIDGenerator == Infinity)
		{
			NGSetTimeoutUIDGenerator = 0;
		}
		this.fptr = fptr;
		this.interval = timeMs;
		this.requestedTime = new Date().getTime() + timeMs;
	};

	NGSingleTimeoutInstance.prototype.shouldExecute = function(curTime) {
		if(curTime < this.requestedTime) {
			return false;
		}
		return true;
	};

	NGSingleTimeoutInstance.prototype.execute = function() {
		delete NGSetTimeoutCallbacks[this.uid];
		this.fptr();
	};
	/**
	*
	*/
	setTimeout = function(fptr,requestedTime) {
		if(requestedTime < 0 || typeof(requestedTime) != "number") {
			requestedTime = 0;
		}

		var inst = new NGSingleTimeoutInstance(fptr,requestedTime);
		NGSetTimeoutCallbacks[inst.uid] = inst;
		return inst.uid;
	};
	/**
	*
	*/
	clearTimeout = function(uid) {
		if(NGSetTimeoutCallbacks.hasOwnProperty(uid)) {
			delete NGSetTimeoutCallbacks[uid];
		}
	};
	/**
	*
	*/
	setInterval = function(fptr,requestedTime) {
		if(requestedTime < 0 || typeof(requestedTime) != "number") {
			requestedTime = 0;
		}

		var inst = new NGSingleTimeoutInstance(fptr,requestedTime);
		/*Special setIntervalMagic */
		inst.execute = function() {
			this.requestedTime = new Date().getTime() + this.interval;
			this.fptr();
		};
		/*End setIntervalMagic */
		NGSetTimeoutCallbacks[inst.uid] = inst;
		return inst.uid;
	};
	clearInterval = clearTimeout;
	
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Class'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Class'] || {}; $MODULE_REGISTRY['NGCore/Shared/Class'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Class.js';

/**
 * @constructor
 * @class <code>Core.Class</code> provides an object-oriented programming (OOP) framework for ngCore
 * apps.
 * @name Core.Class
 */
var Class = function() {};
exports.Class = Class;

/**
 * Create a new class by extending <code>Core.Class</code> or another existing class.
 * <br /><br />
 * The <code>extensions</code> parameter is an object literal whose properties will be added to the
 * new class. See the <a href="https://developer.mobage.com/en/resources/app_development">App
 * Development</a> documentation on the <a href="https://developer.mobage.com/">Mobage Developer
 * Portal</a> for more information about using the <code>extensions</code> parameter.
 * <br /><br />
 * The <code>conditions</code> parameter, which is optional, allows you to create design-by-contract
 * checks for the class. This parameter was added in ngCore 1.8.
 * <br /><br />
 * <strong>Note</strong>: By default, the development server disables design-by-contract checks. You
 * must enable the checks when you start the development server. See the SDK's
 * <code>README-server</code> file for details.
 * <br /><br />
 * Design-by-contract checks can examine any of the following:
 * <ul>
 * <li><strong>Precondition checks</strong> examine characteristics of the method call, such as the
 * presence and type of arguments. The class calls its precondition checks before it executes the
 * method. The parameters from the method call are passed to the precondition check.</li>
 * <li><strong>Postcondition checks</strong> examine the results of the method call. The class calls
 * its postcondition checks after it completes the method call. The method call's return value,
 * followed by the parameters from the method call, is passed to the postcondition check.</li>
 * <li><strong>Invariant checks</strong> examine characteristics of the class that should never
 * change, such as the type of an object property. The class calls its invariant checks after it
 * completes a method call and evaluates the postcondition checks for the method call.</li>
 * </ul>
 * Design-by-contract checks should return either <code>true</code> if the check was successful or
 * <code>false</code> if the check failed.
 * <br /><br />
 * <strong>Note</strong>: If a design-by-contract check fails, the method will throw an error. You
 * can use <code>try</code> and <code>catch</code> blocks to trap the error and handle it
 * appropriately.
 * @example
 * // Create a new class.
 * var MyClass = Class.subclass({
 *    classname: "MyClass",
 *
 *    initialize: function() {
 *        console.log("constructor");
 *    },
 *
 *    foo: function(v) {
 *        console.log("MyClass.foo('" + v + "')");
 *    }
 * });
 * var instance = new MyClass();  // logs "constructor"
 * instance.foo("param");         // logs "MyClass.foo('param')"
 * @example
 * // Create a new class with design-by-contract checks.
 * var checks = {
 *     "setA.pre": function(a) {
 *         return a > 0;
 *     },
 *     invariant: function() {
 *         // If a is defined, ensure that a is a number.
 *         // The assert() function throws an error if a is not a number.
 *         if(typeof this.a !== "undefined") {
 *             assert(typeof this.a === "number", "this.a is not a number!");
 *         }
 *         // If b is defined, ensure that b is a boolean.
 *         // The assert() function throws an error if b is not a boolean.
 *         if(typeof this.b !== "undefined") {
 *             assert(typeof this.b === "boolean", "this.b is not a boolean!");
 *         }
 *         // We will only get here if both of the checks passed.
 *         return true;
 *     }
 * };
 *
 * var MyClass = Class.subclass({
 *     initialize: function() {
 *         this.a = 23;
 *         this.b = true;
 *     },
 *
 *     setA: function(a) {
 *         this.a = a;
 *     },
 *
 *     setB: function(b) {
 *         this.b = b;
 *     }
 * }, checks);
 *
 * var instance = new MyClass();
 * instance.setA(-1);             // Error! The setA.pre check fails.
 * instance.setB({});             // Error! The invariant check fails.
 * @name Core.Class.subclass
 * @function
 * @static
 * @param {Object} extensions Object literal containing new methods for the class.
 * @param {Object} [conditions] Object literal containing design-by-contract checks. Each check
 *		should return <code>true</code> if the check passes or <code>false</code> if the check
 *		fails. Available since ngCore 1.8.
 * @param {Function} [conditions.invariant] The invariant checks for the class. Called after the
 *		method and its postcondition checks have executed.
 * @param {Function} [conditions.methodName.post] The postcondition checks for the method
 *		<code>methodName</code> (replace <code>methodName</code> with the name of your method).
 *		Called after the method has executed.
 * @param {Function} [conditions.methodName.pre] The precondition checks for the method
 *		<code>methodName</code> (replace <code>methodName</code> with the name of your method).
 *		Called before the method has executed.
 * @returns {Function} A function for instantiating the derived class.
 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
 */
Class.subclass = (function()
{
/**#@+ @ignore */
	// Parse a function body and extract the parameter names.
	function argumentNames(body)
	{
	        var names;
		// optimized path for SpiderMonkey
		if (Function.prototype.__arguments) {
			names = body.__arguments();
			if (names) {
			    return names;   
			}
		}
		names = body.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
			.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
			.replace(/\s+/g, '').split(',');
		return names.length == 1 && !names[0] ? [] : names;
	}
	
	// Create a function that calls overrideBody with a closure to ancestorBody.
	function overrideMethod(overrideBody, ancestorBody)
	{
	    var override;
		if(ancestorBody !== undefined)
		{
			// Create a function that calls overrideBody with a closure to ancestorBody as the first param.
			override = function()
			{
				var localThis = this;
				var $super = function() { return ancestorBody.apply(localThis, arguments); };
				Array.prototype.unshift.call(arguments, $super);
				return overrideBody.apply(this, arguments);
			};
		}
		else
		{
			// Create a function that calls overrideBody with undefined as the first param, because ancestorBody is undefined.
			override = function()
			{
				Array.prototype.unshift.call(arguments, undefined);
				return overrideBody.apply(this, arguments);
			};
		}

		// Hide our dirty tricks from the rest of the world.
		override.valueOf = function() { return overrideBody.valueOf(); };
		override.toString = function() { return overrideBody.toString(); };
		return override;
	}


	// Define some empty functions used later. This is a speed optimization.
	function TempClass() {}
	function emptyFunction() {}
	
	return function()
	{
		// Constructor for new class to be created.
		var properties = arguments[0];
	        var conditions = arguments[1];
	        var property;


		var classname = properties.classname || "AnonymousClass";
		if (typeof $_ASSIGNENGINEBINDINGS !== "undefined" && typeof properties._classId !== "undefined")
			$_ASSIGNENGINEBINDINGS(properties, properties._classId);
		var NewClass = eval('(function ' + classname + '(){this.initialize.apply(this, arguments)})');
		
		// Copy statics from this.
		for(property in this)
		{
			if(!this.hasOwnProperty(property)) continue;
			NewClass[property] = this[property];
		}
		
		// Copy prototype from this.
		var ancestorPrototype = this.prototype;
		TempClass.prototype = ancestorPrototype;
		NewClass.prototype = new TempClass();
		NewClass.prototype.superclass = ancestorPrototype;
		NewClass.prototype.constructor = NewClass;
	        var value;		
		// Copy properties into NewClass prototype.
		for(property in properties)
		{
			if(!properties.hasOwnProperty(property)) continue;

			// getters / setters behave differently than normal properties.
			var getter = properties.__lookupGetter__(property);
			var setter = properties.__lookupSetter__(property);

		        if(getter || setter)
			{
				if(getter)
				{
					// Copy getter into klass.
					value = getter;
					if(argumentNames(value)[0] == "$super")
						value = overrideMethod(value, ancestorPrototype.__lookupGetter__(property));
					NewClass.prototype.__defineGetter__(property, value);
				}

				if(setter)
				{
					// Copy setter into klass.
					value = setter;
					if(argumentNames(value)[0] == "$super")
						value = overrideMethod(value, ancestorPrototype.__lookupSetter__(property));
					NewClass.prototype.__defineSetter__(property, value);
				}
			}
			else
			{
				value = properties[property];
				if(typeof value === "function" && property[0] != '$')
				{
					if(argumentNames(value)[0] == "$super")
					{
						// Create override method if first param is $super.
						value = overrideMethod(value, ancestorPrototype[property]);
					}
					else if(property == 'initialize')
					{
						var ancestorInitialize = ancestorPrototype.initialize;
						if(ancestorInitialize)
						{
							// Automatically call inherited constructor.
							var derivedInitialize = value;
							value = function()
							{
								ancestorInitialize.apply(this, arguments);
								derivedInitialize.apply(this, arguments);
							};
						}
					}
					else if(property == 'destroy')
					{
						var ancestorDestroy = ancestorPrototype.destroy;
						if(ancestorDestroy)
						{
							// Automatically call inherited destructor.
							var derivedDestroy = value;
							value = function()
							{
								derivedDestroy.apply(this, arguments);
								ancestorDestroy.apply(this, arguments);
							};
						}
					}

					// Copy function into new class prototype.
					NewClass.prototype[property] = value;
				}
				else
				{
					if(property[0] == '$')
						property = property.slice(1);

					// Copy enum into new class and the prototype.
					NewClass[property] = value;
					NewClass.prototype[property] = value;
				}
			}
		}
		
		// Make sure the is an initialize function.
		if(!NewClass.prototype.initialize)
			NewClass.prototype.initialize = emptyFunction;

		if (typeof $_REGISTERCLASSTOENGINE !== "undefined" && typeof properties._classId !== "undefined")
			$_REGISTERCLASSTOENGINE(properties, properties._classId);

		return NewClass;
	};
/**#@-*/
})();

/**
 * Create a singleton by extending a class.
 * <br /><br />
 * The <code>extensions</code> parameter is an object literal whose properties will be added to the
 * new singleton. See the <a href="https://developer.mobage.com/en/resources/app_development">App
 * Development</a> documentation on the <a href="https://developer.mobage.com/">Mobage Developer
 * Portal</a> for more information about using the <code>extensions</code> parameter.
 * <br /><br />
 * The <code>conditions</code> parameter, which is optional, allows you to create design-by-contract
 * checks for the singleton. See the <code>{@link Core.Class.subclass}</code> documentation for
 * details.
 * @example
 * // Create a new singleton.
 * var MySingleton = Class.singleton({
 *    classname: "MySingleton",
 *
 *    initialize: function() {
 *        console.log("constructor");
 *    },
 *
 *    foo: function(v) {
 *        console.log("MySingleton.foo('" + v + "')");
 *    }
 * });
 * MySingleton.foo("param");   // logs "constructor", then "MySingleton.foo('param')"
 * @function
 * @name Core.Class.singleton
 * @static
 * @param {Object} extensions Object literal containing new methods for the class.
 * @param {Object} [conditions] Object literal containing design-by-contract checks. Each check
 *		should return <code>true</code> if the check passes or <code>false</code> if the check
 *		fails. Accepts the same properties as the <code>conditions</code> parameter to
 *		<code>{@link Core.Class.subclass}</code>.
 * @returns {Object} The singleton instance.
 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
 */
Class.singleton = function()
{
	// Create sublcass as normal.
	var tempClass = this.subclass.apply(this, arguments);
	
	// Hide the initialize.
	var initialize = tempClass.prototype.initialize;
	tempClass.prototype.initialize = function() {};
	
	// Now instantiate.
	var instance = new tempClass();
	
	// Hide every prototype function with an instance function that calls initialize.
	var functions = [];
	/** 
	 * Ensure that the singleton has been created and fully initialized.
	 * @inner
	 * @status iOS, Android, Flash
	 */
	var instantiate = function(real)
	{
		// Delete all of the instance functions we added.
		for(var i in functions)
		{
			var func = functions[i];
			delete instance[func];
		}
		
		// Restore the initialize function and call it.
		instance.initialize = initialize;
		instance.initialize();
		
		// Replace instantiate method with an empty function.
		instance.instantiate = function() {};
		
		// Call the function that caused this instantiation.
		var args = Array.prototype.slice.call(arguments, 1);
		return real.apply(instance, args);
	};
	
	// Iterate over all prototype functions.
	for(var i in instance)
	{
		// Don't do anything for setters or getters.
		if(instance.__lookupGetter__(i)
			|| instance.__lookupSetter__(i))
		{
			//TODO Should put proxies here too.
			continue;
		}
			
		var value = instance[i];
		if(typeof(value) == 'function')
		{
			// Remember the function names that we added so that instantiate() can remove them.
			functions.push(i);
			
			// Add an instance function to hide the prototype function, which will call instantiate.
			instance[i] = instantiate.bind(this, value);
		}
	}
	
	// Add instantiate method.
	instance.instantiate = instantiate.bind(this, function() {});
	
	// Return the isntance.
	return instance;
};

/**
 * @ignore
 */
Class.prototype.bind = function(func)
{
	var context = this;
	if(arguments.length < 2)
	{
		// Fast path if only the 'this' pointer is being bound.
		return function()
		{
			return func.apply(context, arguments);
		};
	}
	else
	{
		// Slower path if additional parameters are being bound.
		var args = Array.prototype.slice.call(arguments, 1);
		return function()
		{
			var finalArgs = args.concat(Array.prototype.slice.call(arguments, 0));
			return func.apply(context, finalArgs);
		};
	}
};

/**
 * @ignore
 */
Class.prototype.toString = function()
{
	return this.constructor.name;
};

// Debug implementation that will replace every method in destroyed objects with a grenade.
/*Class.prototype.destroy = function()
{
	function suicide()
	{
		throw new Error('Function called on destroyed object');
	}
	
	for(var i in this)
	{
		var value = this[i];
		if(typeof(value) == 'function')
		{
			this[i] = suicide;
		}
	}
}*/
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Class'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Class'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Class'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Class.js';

exports.Class = require('NGCore/Shared/Class').Class;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/base64'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/base64'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/base64'] = exports; 
var __dirname = 'NGCore/Shared/Lib';
var __filename = 'NGCore/Shared/Lib/base64.js';

/**
 * @class The <code>Core.Base64</code> class provides methods for converting strings and binary data
 * to and from Base64 format.
 * @name Core.Base64
 */

/*
 * $Id: base64.js,v 1.1 2009/03/01 22:38:45 dankogai Exp dankogai $
 *
 * History:
 *   dankogai's original: character-based
 *   drry's fix: split string to array then join
 *   new version: regexp-based
 */

var Base64 = (function() {
/** @lends Core.Base64.prototype */
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin){
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) {
            t[bin.charAt(i)] = i;
        }
        return t;
    }(b64chars);

    var fromCharCode = String.fromCharCode;

    var sub_toBase64 = function(m){
        var n = (m.charCodeAt(0) << 16)
              | (m.charCodeAt(1) <<  8)
              | (m.charCodeAt(2)      );
        return b64chars.charAt( n >>> 18)
             + b64chars.charAt((n >>> 12) & 63)
             + b64chars.charAt((n >>>  6) & 63)
             + b64chars.charAt( n         & 63);
    };

    var toBase64 = function(bin){
        if (bin.match(/[^\x00-\xFF]/)) {
            throw 'unsupported character found';
        }
        var padlen = 0;
        while(bin.length % 3) {
            bin += '\x00';
            padlen++;
        }
        var b64 = bin.replace(/[\x00-\xFF]{3}/g, sub_toBase64);
        if (!padlen) return b64;
        b64 = b64.substr(0, b64.length - padlen);
        while(padlen--) b64 += '=';
        return b64;
    };

    // use native btoa() if it exists
    var _btoa = typeof(btoa) !== "undefined" ? btoa : toBase64;

    var sub_fromBase64 = function(m){
            var n = (b64tab[ m.charAt(0) ] << 18)
                |   (b64tab[ m.charAt(1) ] << 12)
                |   (b64tab[ m.charAt(2) ] <<  6)
                |   (b64tab[ m.charAt(3) ]);
        return fromCharCode(  n >> 16 )
            +  fromCharCode( (n >>  8) & 0xff )
            +  fromCharCode(  n        & 0xff );
    };

    var fromBase64 = function(b64){
        b64 = b64.replace(/[^A-Za-z0-9\+\/]/g, '');
        var padlen = b64.length % 4;
        while(b64.length % 4){
            b64 += 'A';
        }
        var bin = b64.replace(/[A-Za-z0-9\+\/]{4}/g, sub_fromBase64);
        if (padlen >= 2)
            bin = bin.substring(0, bin.length - [0,0,2,1][padlen]);
        return bin;
    };

    // use native atob() if it exists
    var _atob = typeof(atob) !== "undefined" ? atob : fromBase64;

    var re_char_nonascii = /[^\x00-\x7F]/g;

    var sub_char_nonascii = function(m){
        var n = m.charCodeAt(0);
        return n < 0x800 ? fromCharCode(0xc0 | (n >>>  6))
                         + fromCharCode(0x80 | (n & 0x3f))
            :              fromCharCode(0xe0 | ((n >>> 12) & 0x0f))
                         + fromCharCode(0x80 | ((n >>>  6) & 0x3f))
                         + fromCharCode(0x80 |  (n         & 0x3f))
            ;
    };

    var utob = function(uni){
        return unescape(encodeURIComponent(uni));
    };

    var re_bytes_nonascii
        = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;

    var sub_bytes_nonascii = function(m){
        var c0 = m.charCodeAt(0);
        var c1 = m.charCodeAt(1);
        if(c0 < 0xe0){
            return fromCharCode(((c0 & 0x1f) << 6) | (c1 & 0x3f));
        }else{
            var c2 = m.charCodeAt(2);
            return fromCharCode(
                ((c0 & 0x0f) << 12) | ((c1 & 0x3f) <<  6) | (c2 & 0x3f)
            );
        }
    };

    var btou = function(bin){
        return decodeURIComponent(escape(bin));
    };
    return {
        fromBase64:fromBase64,
        toBase64:toBase64,
        atob:_atob,
        btoa:_btoa,
        utob:utob,
        btou:btou,
        
		/**
		 * Encode a string in Base64 format.
		 * @name encode
		 * @function
		 * @memberOf Core.Base64
		 * @example
		 * var str = "Test string";
		 * var encoded = Core.Base64.encode(str);  // returns "VGVzdCBzdHJpbmc="
		 * @param {String} u The string to encode.
		 * @returns {String} A Base64-encoded version of the string.
		 * @since 1.3.1b
		 */
        encode:function(u){
            if(!u) {
                return "";
            }
            return _btoa(utob(new String(u)));
        },
	
		/**
		 * Encode binary data in Base64 format.
		 * @name encodeBinary
		 * @function
		 * @memberOf Core.Base64
		 * @example
		 * var fileSys = Storage.FileSystem;
		 * fileSys.readFileIn(Storage.FileSystem.Store.Local, "file.bin", { },
		 *   function(err, data) {
		 *     if (err) {
		 *         console.log("An error occurred while reading " + fileName + ": " + err);
		 *     } else {
		 *         var encoded = Core.Base64.encodeBinary(data);
		 *     }
		 * });
		 * @param {String} u The binary data to encode.
		 * @returns {String} A Base64-encoded version of the data.
		 */
		// do not process unicode coversion for binary data.
		encodeBinary: function(u) {
            if(!u) {
                return "";
            }
	    	return _btoa(new String(u));
		},
	
		/**
		 * Decode a Base64-encoded string.
		 * @name decode
		 * @function
		 * @example
		 * var encoded = "VGVzdCBzdHJpbmc=";
		 * var str = Core.Base64.decode(encoded);  // returns "Test string"
		 * @memberOf Core.Base64
		 * @param {String} a A Base64-encoded string.
		 * @returns {String} The decoded string.
		 * @since 1.4.1
		 */
        decode:function(a){
            if(!a) {
                return "";
            }

        	if(a.length % 4 == 1)
			{
				throw new Error("Invalid Base64 string: " + a);
			}

            return btou(_atob(a.replace(/[\-_]/g, function(m0){
                return m0 == '-' ? '+' : '/';
            })));
		},
       
		/**
		 * Decode Base64-encoded binary data.
		 * @name decodeBinary
		 * @function
		 * @example
		 * var fileSys = Storage.FileSystem;
		 * fileSys.readFileIn(Storage.FileSystem.Store.Local, "file.bin.b64", { },
		 *   function(err, data) {
		 *     if (err) {
		 *         console.log("An error occurred while reading " + fileName + ": " + err);
		 *     } else {
		 *         var decoded = Core.Base64.decodeBinary(data);
		 *     }
		 * });
		 * @memberOf Core.Base64
		 * @param {String} a Base64-encoded binary data.
		 * @returns {String} The decoded data.
		 */
		// do not process unicode conversion for binary data.
		decodeBinary: function(a) {
            if(!a) {
                return "";
            }
            return _atob(a.replace(/[\-_]/g, function(m0){
                return m0 == '-' ? '+' : '/';
            }));
       }
    };
})();

exports.Base64 = Base64;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Base64'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Base64'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Base64'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Base64.js';

exports.Base64 = require('NGCore/Shared/Lib/base64').Base64;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/ResultSet'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/ResultSet'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/ResultSet'] = exports; 
var __dirname = 'NGCore/Client/Plus';
var __filename = 'NGCore/Client/Plus/ResultSet.js';

var ClassReq = require("NGCore/Client/Core/Class");
var SystemBindingReq = require('NGCore/Client/UI/SystemBinding');

var ResultSet = ClassReq.Class.subclass({
    classname: "ResultSet",
    initialize: function(continueId) {
        this.items = [];
        this._continueId = continueId;
        this.totalLength = Number.MAX_VALUE;
    },
    /*
	 * Call to getMore adds more items to items list.
	 * Please note that in the callback, it is possible that addedCount == 0
	 * in some cases.  In that case access to items[newIdx] does not yield
	 * any result
	 */
    getMore: function(cb) {
        return SystemBindingReq.SystemBinding._getMoreContacts(this, cb);
    },
    /*
	 * Releases resource used by current ResultSet.
	 *
	 * To avoid resource leakage, please call closeResultSet if getMore
	 * is not called all the way to the end.
	 */
    closeResultSet: function() {
        SystemBindingReq.SystemBinding._closeContactsResultSet(this);
    }
});

exports.ResultSet = ResultSet;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/SystemBinding'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/SystemBinding'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/SystemBinding'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/SystemBinding.js';

var ClassReq = require("NGCore/Client/Core/Class");
var Base64 = require("NGCore/Client/Core/Base64").Base64;
var ResultSetReq = require("NGCore/Client/Plus/ResultSet");

var NGSystemBindingCommands = {
    HandleAction: 0
};

var SystemBinding = ClassReq.Class.subclass({
    classname: "SystemBinding",
    callbacks: {},
    callbacksUidGenerator: 0,
    _contResultSets: {},
    _contResultSetIdxs: {}
});

var ResultSet = ClassReq.Class.subclass({
    classname: "ResultSet",
    initialize: function(continueId) {
        this.items = [];
        this._continueId = continueId;
        this.totalLength = Number.MAX_VALUE;
    },
    /*
	 * Call to getMore adds more items to items list.
	 * Please note that in the callback, it is possible that addedCount == 0
	 * in some cases.  In that case access to items[newIdx] does not yield
	 * any result
	 */
    getMore: function(cb) {
        return SystemBinding._getMoreContacts(this, cb);
    },
    /*
	 * Releases resource used by current ResultSet.
	 *
	 * To avoid resource leakage, please call closeResultSet if getMore
	 * is not called all the way to the end.
	 */
    closeResultSet: function() {
        SystemBinding._closeContactsResultSet(this);
    }
});

SystemBinding._pushContactsCmd = function(cmdname, callbackFunc, continueId) {
    // Generate unused callbackEntry
    var callbackId = SystemBinding.callbacksUidGenerator++;
    if ( !! !callbackFunc) {
        callbackFunc = function() {};
    }
    SystemBinding.callbacks[callbackId] = callbackFunc;
    var message = {
        name: cmdname,
        callbackId: callbackId
    };
    if (typeof continueId != 'undefined') {
        message.continueId = continueId;
    }
    message = JSON.stringify(message);
    NgPushCommand3(NgEntityTypes.NgSystemBinding, NGSystemBindingCommands.HandleAction,
    Base64.encode(message));
};

SystemBinding._closeContactsResultSetfunction = function(rSet) {
    // Passing empty callback as caller does not need to know when the close
    // is complete
    var cb = function() {};
    SystemBinding._pushContactsCmd('closecontacts', cb, rSet._continueId);
};

SystemBinding._getMoreContacts = function(rSet, callbackFunc) {
    if ((typeof rSet._continueId != 'undefined') &&
    (rSet.items.length < rSet.totalLength)) {
        SystemBinding._pushContactsCmd('morecontacts', callbackFunc, rSet._continueId);
        return true;
    }
    return false;
};

SystemBinding.getContacts = function(callbackFunc) {
    SystemBinding._pushContactsCmd('contacts', callbackFunc, undefined);
};

SystemBinding.getDeviceToken = function(callbackFunc) {
    // Generate unused callbackEntry
    var callbackId = SystemBinding.callbacksUidGenerator++;
    if ( !! !callbackFunc) {
        callbackFunc = function() {};
    }
    SystemBinding.callbacks[callbackId] = callbackFunc;
    var message = {
        name: 'devicetoken',
        callbackId: callbackId
    };
    message = JSON.stringify(message);
    NgPushCommand3(NgEntityTypes.NgSystemBinding, NGSystemBindingCommands.HandleAction,
    Base64.encode(message));
};

SystemBinding.handleCommand = function(command) {
    var fields = NgParseCommand2(command, NgParseInt, NgParseBase64);
    var cmd = JSON.parse(fields[1]);
    if (cmd.name == 'callback') {
    	var cb = SystemBinding.callbacks[cmd.callbackId];
		if (typeof cb == "function") {
            if (cmd.callbackname == 'contacts') {
                var obj = SystemBinding._contResultSets[cmd.continueId];
                if (typeof obj == 'undefined') {
                    // First time for this callback
                    obj = new ResultSetReq.ResultSet(cmd.continueId);
                    SystemBinding._contResultSets[cmd.continueId] = obj;
                    SystemBinding._contResultSetIdxs[cmd.continueId] = 0;
                }

                var addedCount = cmd.list.length;
                while (cmd.list.length > 0) {
                    var item = cmd.list.shift();
                    obj.items.push(item);
                }

                var newIdx = SystemBinding._contResultSetIdxs[cmd.continueId];
				if ((typeof newIdx) != 'undefined') {
                	SystemBinding._contResultSetIdxs[cmd.continueId] = newIdx + addedCount;
				}

                // Invalidate the continueId if done - when total is return (no
                // more result) or when result set is explicitly closed (cmd.closed)
                if ((typeof cmd.total != 'undefined') ||
                (typeof cmd.rsclosed != 'undefined')) {
                    if (typeof cmd.total != 'undefined') {
                        obj.totalLength = cmd.total;
                    }
                    delete obj._continueId;
                    delete SystemBinding._contResultSets[cmd.continueId];
                    delete SystemBinding._contResultSetIdxs[cmd.continueId];
                }

                delete SystemBinding.callbacks[cmd.callbackId];
				if (cmd.success) {
                	cb(undefined, obj, newIdx, addedCount);
				} else {
                	cb(cmd.error, obj, newIdx, addedCount);
				}
            } else {
                // other callbacks
                delete SystemBinding.callbacks[cmd.callbackId];
                cb(cmd);
            }
        }
    }
};

exports.SystemBinding = SystemBinding;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/MessageListener'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/MessageListener'] || {}; $MODULE_REGISTRY['NGCore/Shared/MessageListener'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/MessageListener.js';

var Class = require('NGCore/Shared/Class').Class;

exports.MessageListener = Class.subclass(
/** @lends Core.MessageListener.prototype */
{
	classname: 'MessageListener',
	
	/**
	 * @class The <code>MessageListener</code> class is a base class for constructing objects that listen for notifications from emitters 
	 * (see <code>{@link Core.MessageEmitter}</code>). Objects of this type are registered with emitters.
	 * When <code>{@link Core.MessageEmitter#emit}</code> or <code>{@link Core.MessageEmitter#chain}</code> is called on an emitter
	 * all registered listeners will generate a callback function.
	 * <br /><br />
	 * Applications must unregister listener objects when they are no longer required in one of three ways: 
	 * <ul>
	 * <li>Calling <code>{@link Core.MessageEmitter#removeListener}</code> on the <code>MessageEmitter</code>.</li>
	 * <li>Calling <code>{@link Core.MessageEmitter#destroy}</code> on the <code>MessageEmitter</code>.</li>
	 * <li>Calling <code>{@link Core.MessageListener#destroy}</code> on the <code>MessageListener</code></li>
	 * </ul><br />
	 * <p><b>Note:</b> Applications should not attempt to register a listener with an emitter more than once. Registering a listener with an emitter
	 * multiple times results in exceptions.</p>
	 * @example
	 * var MyListener = Core.MessageListener.subclass({
	 *     myCallback: function(verb, value) {
	 *         console.log('MyListener.myCallback(' + verb + ', ' + value + ')');
	 *     }
	 * });
	 * var listener = new MyListener();
	 * emitter.addListener(listener, listener.myCallback);
	 * emitter.emit('fun', 5);
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	initialize: function()
	{
		this._messageEmitters = [];
	},
	
	/**
	 * Unregister this <code>MessageListener</code> from all emitters.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		// Unregister from all emitters.
		var emitters = this._messageEmitters;
		while(emitters.length)
			emitters[0].removeListener(this);
	},
	
	// Called by MessageEmitter when this receiver starts listening.
	_startListeningEmitter: function(emitter)
	{
		var emitters = this._messageEmitters;
		var index = emitters.indexOf(emitter);
		if(index !== -1)
			return false;
		
		emitters.push(emitter);
		return true;
	},
	
	// Called by MessageEmitter when this receiver stops listening.
	_stopListeningEmitter: function(emitter)
	{
		var emitters = this._messageEmitters;
		var index = emitters.indexOf(emitter);
		if(index === -1)
			return false;
		
		emitters.splice(index, 1);
		return true;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/MessageListener'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/MessageListener'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/MessageListener'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/MessageListener.js';

exports.MessageListener = require('NGCore/Shared/MessageListener').MessageListener;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/ObjectRegistry'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/ObjectRegistry'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/ObjectRegistry'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/ObjectRegistry.js';

var Class = require('NGCore/Client/Core/Class').Class;

exports.ObjectRegistry = Class.singleton(
{
	classname: 'ObjectRegistry',
		
	/** 
	  * @private 
	  * @class 
	  * @status 
	  */
	initialize: function()
	{
		this._currentId = 0;
		this._guardId = 0;
		this._objects = {};
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	register: function(obj)
	{
		if(obj.__objectRegistryId)
			throw new Error('ObjectRegistry.register: object already registered');

		var id = ++this._currentId;
		obj.__objectRegistryId = id;
		this._objects[id] = obj;
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	unregister: function(obj)
	{
		if(!obj.__objectRegistryId)
			throw new Error('ObjectRegistry.unregister: object not registered');
			
		var id = obj.__objectRegistryId;
		obj.__objectRegistryId = 0;
		delete this._objects[id];
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	isObjectRegistered: function(obj)
	{
		if(obj.__objectRegistryId)
			return true;
		else
			return false;
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	isIdRegistered: function(id)
	{
		if(this._objects[id])
			return true;
		else
			return false;
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	objectToId: function(obj)
	{
		var id = obj.__objectRegistryId;
		
		if(!id)
			throw new Error('ObjectRegistry.objectToId: object not registered');
		
		return id;
	},
	
	/** 
	  * @status
	  * @since 1.0
	  */
	idToObject: function(id)
	{
		return this._objects[id];
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Proc'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Proc'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Proc'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Proc.js';

////////////////////////////////////////////////////////////////////////////////
// Class Proc
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////

// Command stream.
var $ = "";

var CSAppendMethods = {
	strPreCat: function(mid, obj, args) {
		var objId;
		if (mid << 16 < 0) {
			objId = '';
			// the "obj" arg will be missing here
			args = obj;
		} else {
			objId = ','+obj.__objectRegistryId;
		}
		mid = ":" + (mid >> 16) + "," + (mid << 16 >> 16);
		
		switch (args ? args.length : 0) {
			case  0: $+=mid+objId+',';break;
			case  1: $+=mid+objId+','+args[0];break;
			case  2: $+=mid+objId+','+args[0]+','+args[1];break;
			case  3: $+=mid+objId+','+args[0]+','+args[1]+','+args[2];break;
			case  4: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3];break;
			case  5: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4];break;
			case  6: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5];break;
			case  7: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6];break;
			case  8: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7];break;
			case  9: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8];break;
			case 10: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8]+','+args[9];break;
			case 11: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8]+','+args[9]+','+args[10];break;
			case 12: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8]+','+args[9]+','+args[10]+','+args[11];break;
			case 13: $+=mid+objId+','+args[0]+','+args[1]+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8]+','+args[9]+','+args[10]+','+args[11]+','+args[12];break;
			default:
				$+=mid+objId+','+args[2]+','+args[3]+','+args[4]+','+args[5]+','+args[6]+','+args[7]+','+args[8]+','+args[9]+','+args[10]+','+args[11]+','+args[12];
				for (var x = 13; x < args.length; x++) {
					$+= ','+args[x];
				}
		}
	},
	strMulCat: function(mid, obj, args) {
		var objId;
		if (mid << 16 < 0) {
			objId = '';
			// the "obj" arg will be missing here
			args = obj;
		} else {
			objId = ','+obj.__objectRegistryId;
		}
		mid = ":" + (mid >> 16) + "," + (mid << 16 >> 16);
		
		switch (args ? args.length : 0) {
			case  0: $+=mid;$+=objId;break;
			case  1: $+=mid;$+=objId;$+=args[0];break;
			case  2: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];break;
			case  3: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];break;
			case  4: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];break;
			case  5: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];break;
			case  6: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];break;
			case  7: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];break;
			case  8: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];break;
			case  9: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];break;
			case 10: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];$+=',';$+=args[9];break;
			case 11: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];$+=',';$+=args[9];$+=',';$+=args[10];break;
			case 12: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];$+=',';$+=args[9];$+=',';$+=args[10];$+=',';$+=args[11];break;
			case 13: $+=mid;$+=objId;$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];$+=',';$+=args[9];$+=',';$+=args[10];$+=',';$+=args[11];$+=',';$+=args[12];break;
			default:
				$+=mid;$+=objId;$+=',';$+=args[0];$+=',';$+=args[1];$+=',';$+=args[2];$+=',';$+=args[3];$+=',';$+=args[4];$+=',';$+=args[5];$+=',';$+=args[6];$+=',';$+=args[7];$+=',';$+=args[8];$+=',';$+=args[9];$+=',';$+=args[10];$+=',';$+=args[11];$+=',';$+=args[12];
				for (var x = 13; x < args.length; x++) {
					$+= ','; $+= args[x];
				}
		}
	},
	strLoop: function(mid, obj, args) {
		var objId;
		if (mid << 16 < 0) {
			objId = '';
			// the "obj" arg will be missing here
			args = obj;
		} else {
			objId = ','+obj.__objectRegistryId;
		}
		mid = ":" + (mid >> 16) + "," + (mid << 16 >> 16);
		
		var _ = mid + objId;
		if (args) for (var i = 0, l = args.length; i < l; i++) {
			_ += ',' + args[i];
		}
		$+=_;
	}
};

var Proc = exports.Proc = Class.singleton(
{
	classname: 'Proc',
	
	initialize: function()
	{
		// $_GETENGINEENV is optional and should be added to the global scope before ngCore loads.
		/* $_GETENGINEENV() returns {
			'engine': "JSEngineType",	// eg, "v8", "SpiderMonkey", "JavaScriptCore", etc.
			'boundFunctions': {
				queueCommand: <native function>,
				queueSubcommand: <native function>,
				getCommand: <native function>,
				clearCommand: <native function>,
				
				parseInt: function,
				parseFloat: function,
				parseString: function,
				parseBinary: function,
				parseObject: function,
				
				encodeString: function,
				encodeBinary: function,
				encodeObject: function,
			}
		} */
		var env = typeof $_GETENGINEENV !== "undefined" ? $_GETENGINEENV() : undefined;
		var engine = typeof env == 'object' ? env['engine'] : undefined;
		if ( typeof env == 'object'
				&& typeof env.boundFunctions == 'object')
		{
			var bF = env.boundFunctions;
			if (bF.queueCommand) 
				this.appendToCommandString = bF.queueCommand;
			if (bF.queueSubcommand)
				this.appendSubcommandToCommandString = bF.queueSubcommand;
			if (bF.getCommand)
				this.getCommandString = bF.getCommand;
			if (bF.clearCommand)
				this.clearCommandString = bF.clearCommand;
			
			if (bF.parseInt)
				this.parseInt = bF.parseInt;
			if (bF.parseFloat)
				this.parseFloat = bF.parseFloat;
			if (bF.parseString)
				this.parseString = bF.parseString;
			if (bF.parseObject)
				this.parseObject = bF.parseObject;
			if (bF.parseBinary)
				this.parseBinary = bF.parseBinary;
			
			if (bF.encodeString)
				this.encodeString = bF.encodeString;
			if (bF.encodeObject)
				this.encodeObject = bF.encodeObject;
			if (bF.encodeBinary)
				this.encodeBinary = bF.encodeBinary;
		} else {
			// String.
			switch (engine) {
				case 'v8':
				case 'spiderMonkey':
					this.appendToCommandString = CSAppendMethods.strLoop;
					break;
				case 'webCore':
					this.appendToCommandString = CSAppendMethods.strPreCat;
					break;
				default:
				// Todo: Switch on Core.Capabilities.getPlatformOS(); Not sure it's safe to require_ here
					this.appendToCommandString = CSAppendMethods.strLoop;
			}
			this.appendSubcommandToCommandString = function(args) { $+= ','+args.join() };
		}
		this.clearCommandString();
	},
	
	appendToCommandString: function( str )
	{
		// Let this function initialize the singleton, but ensure pass through to real implementation.
		this.appendToCommandString.apply(this, arguments);
	},
	
	getCommandString: function()
	{
		return $;
	},
	
	clearCommandString: function ()
	{
		$ = "";
	},
	
	encodeString: Base64.encode,
	encodeBinary: Base64.encodeBinary,
	encodeObject: function(v) {
		return this.encodeString( JSON.stringify(v) );
	},
	
	parseBool: function( v )
	{
		return v == 1 ? true : false;
	},

	parseInt: function( v )
	{
		return parseInt( v, 10 );
	},
	
	parseFloat: parseFloat,
	parseString: Base64.decode,
	parseBinary: Base64.decodeBinary,
	parseObject: function( v )
	{
		return JSON.parse( this.parseString( v ) );
	},

	setPrivileged: function()
	{
		this._privileged = true;
	},

	isPrivileged: function()
	{
		return this._privileged ? true : false;
	},

// {{?Wg Generated Code}}
	///////
	// Class constants (for internal use only):
	_classId: 355,
	// Method setCoreJSVersion = -1
	// Method _loadScripts = -2
	// Method _loadScripts_push = -3
	// Method _loadScriptsComplete = -4
	
	_classRecvGen: function( cmd )
	{
		var classId = parseInt( cmd.shift(), 10 );
		
		var handler = PROC_DISPATCH_TABLE[classId];
		if(handler)
		{
			try
			{
				handler(cmd);
			}
			catch (ex)
			{
				NgHandleException(ex);
			}
		}
		else
		{
			NgLogE( "Unknown class id " + classId + " in _classRecvGen" );
		}
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 355
	// Method setCoreJSVersion = -1
	// Method _loadScripts = -2
	// Method _loadScripts_push = -3
	// Method _loadScriptsComplete = -4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Proc._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -4:
					Proc.__loadScriptsCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Proc._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[355] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$__loadScriptsCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Proc._loadScriptsComplete from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Proc._loadScriptsComplete from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in Proc._loadScriptsComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_setCoreJSVersionSendGen: function( packedVersion )
	{
		this.appendToCommandString( 0x163ffff, [ +packedVersion ] );
	},
	
	/** @private */
	$__loadScriptsSendGen: function( callbackId, numFiles )
	{
		this.appendToCommandString( 0x163fffe, [ Proc.encodeString( callbackId ), +numFiles ] );
	},
	
	/** @private */
	$__loadScripts_pushSendGen: function( executableFilePath )
	{
		this.appendSubcommandToCommandString( [ Proc.encodeString( executableFilePath ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $setCoreJSVersion: function( packedVersion ) {}
	
	// $_loadScripts: function( callbackId, numFiles ) {}
	
	// $_loadScripts_push: function( executableFilePath ) {}
	
	// $__loadScriptsCompleteRecv: function( cmd ) {}
	
// {{/Wg Generated Code}}

	/** @private */
	$_loadScripts: function(files, callback ) {
        if(!this._codeAddingCallbacks){
            this._codeAddingCallbacks = {uidGenerator:1};
        }
        this._codeAddingCallbacks[++this._codeAddingCallbacks.uidGenerator] = callback;
        this.__loadScriptsSendGen(this._codeAddingCallbacks.uidGenerator,files.length);
        for(var i = 0; i < files.length; i++ ){
            this.__loadScripts_pushSendGen(files[i]);
        }
    },
    
    /** @private */
	// $_loadScripts_push: function( executableFilePath ) {} -- not needed
	
	/** @private */
	$__loadScriptsCompleteRecv: function( cmd ) {
        var obj = {};
        this.__loadScriptsCompleteRecvGen(cmd,obj);

        if(this._codeAddingCallbacks.hasOwnProperty(obj.callbackId)){
            this._codeAddingCallbacks[obj.callbackId](obj.error);
            delete this._codeAddingCallbacks[obj.callbackId];
        }
    },
    /** @private */
	$load: function(file, callback) {
		if ($ng__COMBINED === true) {
		//	console.log("COMBINE MODE LAZY REQUIRE: " + file);
			setTimeout( callback.bind(null, require(file)), 1 );
			return;
		}
		
		if(this._pendingLoadCalls && arguments.length == 2){
			NgLogD("Proc.load: call already pending. Saving "+file+" for later.");
			if (typeof exception_demangle_require != "undefined") {
				NgLogD(exception_demangle_require(file));
			}
			this._pendingLoadCalls.push(function(){
				NgLogD("Proc.load: resuming saved load call for "+file);
				if (typeof exception_demangle_require != "undefined") {
					NgLogD(exception_demangle_require(file));
				}
				Proc.load(file,callback,true);
});
			return;
		} else if(!this._pendingLoadCalls){
			this._pendingLoadCalls = [];
		}
		
		var file_noext = file.replace(/\.js/,'');
		
//		var entryPointIndex = $APP_VALIDENTRYPOINTS.indexOf(file);
//		if (entryPointIndex == -1){
//			NgLogD("Proc.load: illegal program entry point! Entry must match manifest.loadable! '"+file+"'");
//		}
		
		//Convert Human readable to name-mangled if necessary.
		if(typeof $APP_REQUIREPATHMAP != "undefined" && file in $APP_REQUIREPATHMAP){
			file = $APP_REQUIREPATHMAP[file];
		}
		
		var postLoad = function(){
			NgLogD("Proc.load (postLoad) "+file);
			
			if(this._pendingLoadCalls.length){
				var next = this._pendingLoadCalls.shift();
				next();
			} else {
				this._pendingLoadCalls = null;
			}
			
			// Finally we call the 'previous' Proc.load's callback.
			callback(require(file));
		}.bind(this);
		
		//if (Core.Capabilities.getRequireIsSynchronous()) {
		//	postLoad();
		//} else {
			var array = [];
			// Scan the $APP_REQUIREPATHS array for the requested file.
			// This will be our only linear scan, because dependencies are tracked by ID.
		if (typeof $APP_REQUIREPATHS != "undefined") { //check for reference error
			var rPathIndex = $APP_REQUIREPATHS.indexOf(file);
			if (rPathIndex >= 0) {
				// All this means is that the file has not been included from anywhere else yet.
				delete $APP_REQUIREPATHS[rPathIndex];
				addDependencies(array, rPathIndex);
				/*jsl:ignore*/
				if(!$MODULE_FACTORY_REGISTRY[file]){
				/*jsl:end*/
					array.push(file + ".js");
				}
				
				// Call the system call to actually load the file.
				if(array.length){
					NgLogD("Proc.load: Loading '" + file + "'!");
					NgLogD(JSON.stringify(array));
					Proc._loadScripts(array,postLoad);
				} else {
					NgLogD("Proc.load: no files to load "+file);
					setTimeout(postLoad,1);
				}
			} else {
				NgLogD("Proc.load: Skipping '" + file + "' because it was already included.");
				setTimeout(postLoad,1);
			}
	 	}
	}
});


// Destructive Pre-order traversal of flattened n-ary tree 
var addDependencies = function(array, rPathIndex) {
	if (!$APP_DEPENDENCYTABLE || !$APP_REQUIREPATHS){return;}
	var dependencies = $APP_DEPENDENCYTABLE[rPathIndex];
	if (!(dependencies instanceof Array)) return;
	var depRPIndex;
	while (depRPIndex = dependencies.shift()) {
		// Read the file's name from the $APP_REQUIREPATHS array, if it exists.
		var depRPath = $APP_REQUIREPATHS[depRPIndex];
		// This is our condition to prevent cycles, since we delete it when processing.
		if (depRPath) {
			// Delete this entry from the array before traversing into it.
			delete $APP_REQUIREPATHS[depRPIndex];
			// If there are dependencies for this file, process them first.
			addDependencies(array, depRPIndex);
			// Add the file itself right after the dependencies.
			/*jsl:ignore*/
			if(!$MODULE_FACTORY_REGISTRY[depRPath]){ // Only if it hasn't already been loaded.
			/*jsl:end*/
				array.push(depRPath + ".js");
			}
		}
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Capabilities'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Capabilities'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Capabilities'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Capabilities.js';

	////////////////////////////////////////////////////////////////////////////////
// Class Capabilities
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;


////////////////////////////////////////////////////////////////////////////////

function packVersion(arg1, arg2, arg3, arg4, arg5) {
	if (arg1 instanceof Array) return packVersion.apply(null, arg1);
	return arg1 << 24 | arg2 << 18 | arg3 << 12 | arg4 << 6 | arg5;
}

function unpackVersion(pVers) {
	return [
		pVers >> 24 & 0x03F,
		pVers >> 18 & 0x03F,
		pVers >> 12 & 0x03F,
		pVers >> 6 & 0x03F,
		pVers & 0x03F
	];
}

function packStringVersion(str) {
	return packVersion.apply(null,str.split(/\D/));
}

function stringForVersion(a) {
	if (typeof a == "number") a = unpackVersion(a);
	// Drop trailing zeroes
	while (a.length && (0 | a[a.length - 1]) === 0) {
		a.pop();
	}
	return a.length ? a.join('.') : "Invalid Version";
}

////////////////////////////////////////////////////////////////////////////////

exports.Capabilities = Class.singleton(
/** @lends Core.Capabilities.prototype */
{
	classname: 'Capabilities',
	_configFile: 'configuration.json',
	// The packed integer for the binary version string
	_binaryVersion: 0,
	// The lower of the JS and Binary versions.
	_effectiveVersion: 0,

	/**
	 * @class The <code>Capabilities</code> class provides information about the capabilities of the
	 * device that is running the app. The class also provides details about the app's
	 * configuration and the ngCore binary that is running the app. The information that is provided
	 * by the <code>Capabilities</code> class remains the same throughout the lifetime of the app.
	 * @singleton
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

        // Please keep this on one line, sed won't update otherwise
		this._fields = {version: '1.8.0.3', buildDate: '20120702', buildHash: 'g7da6adf'};
	},

	_getConfigFile:			function() {return this._configFile;},
	_getAccts:				function() {return this._fields._accts;},

	/**
	 * Compare an ngCore version number to the ngCore binary version that is currently running. The
	 * return value indicates whether the current ngCore binary is older than, identical to, or
	 * newer than the specified version.
	 * @example
	 * // Check whether the current ngCore binary version is later than 1.3.2.
	 * var compare = Core.Capabilities.compareBinaryVersion("1.3.2");
	 * if (compare > 0) {
	 *     console.log("The current binary version is more recent than 1.3.2.");
	 * }
	 * @param {String} v The ngCore version number to compare against the current binary.
	 * @returns {Number} A negative number if the specified version is older than the current
	 *		binary; a positive number if the specified version is newer than the current binary;
	 *		or <code>0</code> if the two versions are equal.
	 * @since 1.8
	 */
	compareBinaryVersion: function(v) {
		var version = (arguments.length == 1 && typeof v == "string")
			? packStringVersion(v)
			: packVersion.apply(null, arguments);
		// Compare to version. Will be positive if binary version is newer, zero if equal, negative if binary is older
		return this._binaryVersion - version;
	},

	/**
	 * Check whether the current ngCore binary meets a minimum version number.
	 * @example
	 * // Check whether the current ngCore binary version is 1.8 or greater.
	 * if (Core.Capabilities.meetsBinaryVersion("1.8")) {
	 *     console.log("The current binary version is 1.8 or greater.");
	 * }
	 * @param {String} v The ngCore version number to compare against the current binary.
	 * @returns {Boolean} Set to <code>true</code> if the specified version is equal to or
	 *		greater than the version of the current ngCore binary.
	 * @since 1.8
	 */
	meetsBinaryVersion: function(v)
	{
		return this.compareBinaryVersion(v) >= 0;
	},
	
	/**
	 * Return the object stored in configuration.json for your game.
	 * @returns {Object} The JSON.parsed object represented in your configuration.json file.
	 * @status
	 * @since 1.0
	 */
	getConfigs:			function() {return this._configuration;},

	/**
	 * Return the SDK version number from the <code>Capabilities</code> of this device.
	 * @returns {String} The version of the SDK on the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSDKVersion:           function() { return this._fields.version; },

	/**
	 * Return the build date for the currently installed SDK. The build date is in the format <i>YYYYMMDD</i>.
	 * @returns {String} The build date for the SDK on the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSDKBuildDate:           function() { return this._fields.buildDate; },
	
	/**
	 * Return the build hash of the currently installed SDK.
	 * @returns {String} The build hash for the SDK on the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSDKBuildHash:           function() { return this._fields.buildHash; },

	/**
	 * Return the version of ngCore that is currently running.
	 * @returns {String} The version of ngCore that is running.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.1.5
	 */
	getBinaryVersion:           function() { return this._fields.binaryVersion; },
	
	/**
	 * Return the version of ngCore's host application.
	 * @returns {String} The version of the host application.
	 * @status Android
	 * @since 1.7
	 */
	getApplicationVersion:           function() { return this._fields.applicationVersion; },

	/**
	 * Return the version code of ngCore's host application.
	 * @returns {String} The version code of the host application.
	 * @type String
	 * @status Android
	 * @since 1.8
	 */
	getApplicationVersionCode:       function() { return this._fields.applicationVersionCode; },

	/**
	 * Return the build date for the currently running ngCore binary. The build date is in the format <i>YYYYMMDD</i>.
	 * @returns {String} The build date for the ngCore binary.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.1.5
	 */
	getBinaryBuildDate:           function() { return this._fields.binaryBuildDate; },

	/**
	 * Return the build hash of the currently running ngCore binary.
	 * @returns {String} The build hash for the ngCore binary.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.1.5
	 */
	getBinaryBuildHash:           function() { return this._fields.binaryBuildHash; },
	
	/**
	 * Return the device ID. 
	 * @returns {String} The device ID for the device running the application.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getUniqueId:           function() { return this._fields.uniqueId; },

	/**
	 * Return the lifetime constant value of the device.<br /><br />
	 * <b>Note:</b> Currently only available on Android.
	 * @returns {String} <code>Settings.Secure.ANDROID_ID</code>: A 64-bit number as a hex string randomly generated on first boot of the device if platform is Android. Mac address if platform is iOS.
	 * <b>Note:</b> This value only changes when the device is reset.
	 * @status iOS, Android
	 * @since 1.0
	 */
	getLifetimeName: function() { return this._fields.lifetimeName; },
	
	/**
	 * Return the device name.
	 * @returns {String} The device name for the device running the application.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getDeviceName:         function() { return this._fields.deviceName; },
	
	/**
	 * Return the operating system.
	 * @returns {String} The operating system of the device running the application.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPlatformOS:         function() { return this._fields.platformOs; },
	
	/**
	 * Return the operating system version number.
	 * @returns {String} The version number of the operating system running on the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getPlatformOSVersion:  function() { return this._fields.platformOsVersion; },
	
	/**
	 * Return the device hardware type.
	 * @returns {String} The type of device hardware running the application.
	 * @status iOS, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPlatformHW:         function() { return this._fields.platformHw; },
	
	/**
	 * Return the total amount of installed memory.
	 * @returns {Number} The amount of installed memory on the device running the application.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getPhysicalMem:        function() { return this._fields.physicalMemory; },
	
	/**
	 * Return the total number of installed CPUs.
	 * @returns {Number} The number of CPUs installed on the device running the application.
	 * @status iOS, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPhysicalCpus:       function() { return this._fields.physicalCpus; },
	
	/**
	 * Return the number of active CPUs.
	 * @returns {Number} The number of active CPUs on the device running the application.
	 * @status iOS, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getActiveCpus:         function() { return this._fields.activeCpus; },
	
	/**
	 * Return the installed user language. 
	 * @returns {String} The installed user language on the device running the application.
	 * Expressed as a canonicalized IETF BCP 47 language identifier.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getLanguage:         function() { return this._fields.language; },

	_getBoot: function() { return this._fields.boot; },
	_getBootServer: function() { return this._fields.bootServer; },

	getBootDir: function () { return this._fields.bootDir; },
	getGameDir: function () { return this._fields.gameDir; },
	getProductName: function () { return this._fields.prodName; },
	_getReferrer: function() { return this._fields.referrer; },

	/**
	 * Return the URL for the content of this application.
	 * @returns {String} The URL to content for this application.
	 * @status Flash
	 * @since 1.0
	 */
	getContentUrl:			function() {return this._fields.contentUrl;},

	/**
	 * Return the name of the root application. Root application refers to the application that launches when the user taps the application icon.
	 * @returns {String} The directory name for the root application.
	 * @status Flash
	 * @since 1.0
	 */
	getBootGame:         function() { return this._fields.bootgame; },

	/**
	 * Return the starting server for an application.
	 * @returns {String} The start server.
	 * @status
	 * @since 1.0
	 */
	getStartingServer:         function() { return this._fields.startingServer; },

	/**
	 * Return the name of the application bundled with the binary of this build.
	 * @returns {String} The name of the bundled game.
	 * @status
	 * @since 1.0
	 */
	getBundleGame:         function() { return this._fields.bundleGame; },

	/**
	 * Return the server bundled with the binary of this build.
	 * @returns {String} The bundle server.
	 * @status
	 * @since 1.0
	 */
	getBundleServer:         function() { return this._fields.bundleServer; },

	/**
	 * Return the bundle identifier for the binary of this build.
	 * @returns {String} The bundle identifier.
	 * @status
	 * @since 1.0
	 */
	getBundleIdentifier:         function() { return this._fields.bundleIdentifier; },
	
	/**
	 * Return the directory name of the currently running application.
	 * @returns {String} The current folder name for the application.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	getGame:         function() { return this._fields.game; },

	/**
	 * Return the server from which an application was downloaded.
	 * @returns {String} The download server.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getServer:         function() { return this._fields.server; },

	/**
	 * Return the full URL for the current application.
	 * @returns {String} The URL from which a application is downloaded.
	 * @status Flash
	 * @since 1.0
	 */
	getUrl:         function() { return this._fields.url; },

	/**
	 * Return the logical screen width for this device.
	 * @returns {Number} The current screen width of the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getScreenWidth:        function() { return this._fields.screenWidth; },
	
	/**
	 * Return the logical screen height for this device.
	 * @returns {Number} The current screen height of the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getScreenHeight:       function() { return this._fields.screenHeight; },
	
	/**
	 * Return a reasonable factor for scaling logical coordinates to the current display.
	 * @returns {Number} Logically scaled screen units for the device.
	 * @status
	 * @since 1.0
	 */
	getScreenUnits:        function() { return this._fields.screenUnits; },
	
	/**
	 * Return the number of physical pixels associated with one unit of logical space.
	 * @returns {Number} The total number of pixels that equal one screen unit.
	 * @status
	 * @since 1.0
	 */
	getScreenPixelUnits:       function() { return this._fields.screenPixelUnits; },
	
	/**
	 * Return the maximum number of supported textures.
	 * @returns {Number} The maximum number of supported textures per coordinate (<i>x</i>,<i>y</i>).
	 * @status Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getMaxTextureSize:     function() { return this._fields.maxTextureSize; },
	
	/**
	 * Return the maximum number of supported texture units.
	 * @returns {Number} The maximum number of supported texture units per coordinate (<i>x</i>,<i>y</i>).
	 * @status Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getMaxTextureUnits:    function() { return this._fields.maxTextureUnits; },
	
	/**
	 * Deprecated method for retrieving information about OpenGL extensions.
	 * @deprecated Replaced by {@link UI.GLView#getGLExtensions}.
	 * @returns {String[]} A list of supported extensions.
	 * @since 1.0
	 */
	getOglExtensions:      function()
	{
		if (this._fields.oglExtensions)
			return this._fields.oglExtensions;

		// This table should stay in sync with:
		// https://spreadsheets.google.com/a/ngmoco.com/spreadsheet/ccc?key=0AinqDSqLOjJtdDMwNGk0eDgtRFdvQ2N0eWRUcGlsc0E&hl=en_US&authkey=CMWLyoAC
		switch (this._fields.deviceName)
		{
			case "Droid":                // Motorola Droid
			case "DROID2":               // Motorola Droid 2
			case "DROIDX":               // Motorola Droid X
			case "SGH-T959":             // Samsung Galaxy S 19000 8GB
			case "SGH-T959V":            // Samsung Galaxy S 4G
			case "SAMSUNG-SGH-I997":     // Samsung Galaxy S2
			case "SAMSUNG-SGH-I897":     // Samsung Captivate
			case "Nexus S":              // Google Nexus S
				return ["GL_IMG_texture_compression_pvrtc"];
			case "HTC Desire":           // HTC Desire GSM
			case "PC36100":              // HTC Evo 4G
			case "ADR6300":              // HTC Droid Incredible
			case "001HT":                // HTC Desire HD
			case "Nexus One":            // Google Nexus One
			case "HTC Glacier":          // HTC myTouch 4G
				return ["GL_AMD_compressed_ATC_texture"];
			default:
				return [];
		}
	},

	/**
	 * Return the directory path to the temp directory for this device.
	 * @returns {String} The directory path to the temp directory on the device.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getTmpDir:           function() { return this._fields.tmpDir; },

	/**
	 * Check the <code>Capabilities</code> of this device for an accelerometer.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains an accelerometer.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasAccel:           function() { return this._fields.hasAccel; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a gyroscope.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains an gyroscope.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasGyro:            function() { return this._fields.hasGyro; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for touchscreen input support.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application supports touchscreen input.
	 * @status iOS, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasTouch:           function() { return this._fields.hasTouch; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for multi-touch input support.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application supports multi-touch input.
	 * @status iOS, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasMultiTouch:      function() { return this._fields.hasMultiTouch; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a GPS unit.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a GPS unit.
	 * @status Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasGps:             function() { return this._fields.hasGps; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a magnetic compass.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a magnetic compass.
	 * @status Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasCompass:         function() { return this._fields.hasCompass; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a hardware keyboard.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a hardware keyboard.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasHwKeyboard:      function() { return this._fields.hasHwKeyboard; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a <b>Back</b> button.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a <b>Back</b> button.
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */
	getHasBackButton:      function() { return this._fields.hasBackButton; },

	/**
	 * Check the <code>Capabilities</code> of this device for a camera.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a camera.
	 * @status Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasCamera:          function() { return this._fields.hasCamera; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for access to a wide area network (WAN).
	 * @returns {Boolean} Returns <code>true</code> when the device running the application has access to a WAN.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasWwan:            function() { return this._fields.hasWwan; },

	/**
	 * Check the <code>Capabilities</code> of this device for access to a Wi-Fi network.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application has access to Wi-Fi.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHasWifi:            function() { return this._fields.hasWifi; },

	/**
	 * Return the name of the mobile phone carrier this device was using at program startup.
	 * @returns {String} Returns the name of the mobile phone carrier, or an empty string if no carrier 
	 * was used (for example, if the device is not connected to a carrier or does not include
	 * hardware for mobile phone service).
	 * @status
	 * @since 1.0
	 */
	getCarrier:            function() { return this._fields.carrier; },

	/**
	 * Return the URL used to launch this application.
	 * @returns {String} The URL for launching this application. If the application is not launched from a URL, returns an empty string.
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */
	getIntentUrl:            function() { return this._fields.intentUrl; },
	
	/**
	 * Return the Action used to launch this application.
	 * @returns {String} The action for launching this application. If the application is not launched from an action, returns undefined.
	 * @private
	 * @status
	 * @since 1.6
	 */
	getIntentAction:            function() { return this._fields.intentAction; },
	
	/**
	 * Return the height of the system status bar.
	 * @returns {Number} The status bar height rounded to the nearest integer (in pixels).
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @status Android
	* @since 1.0
	 */
     getStatusBarHeight:            function() { return this._fields.statusBarHeight; },
	
	/**
	 * Return the device locale.
	 * @returns {String} The regional location of a device.
	 * The <code>locale</code> string is a combination of ISO 639-1 and ISO 3166-1. For example, <code>en_US</code>, <code>ja_JP</code>.
	 * @status Flash
	 * @since 1.0
	 */
	getLocale: function() { return this._fields.locale; },

	/**
	 * Return a list of installed fonts on this device.
	 * @returns {String[]} An array of font names installed on the system or addressable by name.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	getAvailableFonts: function()
	{
		return this._deserializedFonts || (this._deserializedFonts = JSON.parse(this._fields.availableFonts));
	},
	
	/** @private */
	getAutorotateDisabled: function()
	{
		return this._fields.autorotateDisabled || false;
	},
	
	/** @private */
	getInstallReferrer: function() { return this._fields.installReferrer; },
	
	/**
	 * Return the social server used for this application.
	 * @returns {String} The social server URL. For example, partner.plusplus.com.
	 * @status
	 * @since 1.0
	 */	
	getSocialServer: function()
	{
		return this.socialServer;
	},

	/**
	 * Return the name of the Mobage distribution first installed on the device.
	 * @returns {String} The name of the distribution.
	 * @private
	 */
	getDistributionName: function() 
	{
		return this._fields.distributionName;
	},

	/**
	 * Return the name of the Mobage distribution currently installed on the device.
	 * @returns {String} The name of the distribution.
	 * @private
	 */
	getBinaryDistributionName: function() 
	{
		return this._fields.binaryDistributionName;
	},

	/**
	 * @private
	 */	
	getSourceAppID: function()
	{
		return this._fields.sourceAppID;
	},

	/**
	 * @private
	 * @status Android
	 */	
	getAppSignatures: function()
	{
		return this._fields.appSignatures;
	},
	
	/**
	 * Return the release version of this application, as specified in the
	 * <code>configuration.json</code> file's <code>releaseVersion</code> property.
	 * @returns {String} The version identifier.
	 * @status
	 * @since 1.7
	 */
	getAppReleaseVersion: function()
	{
		return this._releaseVersion;
	},

	/**
	 * Return the ISO country code of the SIM card that the device is using.
	 * @returns {String} The ISO country code of the SIM card that the device is using.
	 * @since 1.7
	 */
	getSimCountryCode: function()
	{
		return this._fields.simCountryCode;
	},

	/**
	 * Return the ISO country code of the mobile phone network that the device is using.
	 * @returns {String} The ISO country code of the mobile phone network that the device is using.
	 * @since 1.7
	 */
	getNetworkCountryCode: function()
	{
		return this._fields.networkCountryCode;
	},

	/**
	 * Returns true of the app is disaggregated
	 * @returns {bool}
	 * @since 1.6
	 * @private
	 */
	getIsDisaggregated: function() { return this._fields.isDisaggregated; },
	
    /**
     * Returns true of the app should send the log to the timing performance server
     * @returns {bool}
     * @private
     */
    _getLogToFile: function() { return this._fields.logToFile; },

	/**
	 * Check whether a UDP socket can be created using the <code>{@link Network.Socket}</code>
	 * class.
	 * @returns {Boolean} Returns <code>true</code> if UDP sockets are supported on the current
	 *		device and binary.
	 * @since 1.7
	 */
	getUdpAvailable: function()
	{
		if(this.getPlatformOS() == 'Android' || this.getPlatformOS() == 'iPhone OS') {
			if(this.compareBinaryVersion(1, 6, 5) >= 0) {
				return true;
			}
		}
		return false;
	},

	/**
	 * Check whether an unencrypted TCP socket can be created using the 
	 * <code>{@link Network.Socket}</code> class.
	 * @returns {Boolean} Returns <code>true</code> if unencrypted TCP sockets are supported on the
	 *		current device and binary.
	 * @since 1.7
	 */
	getTcpAvailable: function()
	{
		if(this.getPlatformOS() == 'Android' || this.getPlatformOS() == 'iPhone OS') {
			if(this.compareBinaryVersion(1, 6, 5) >= 0) {
				return true;
			}
		}
		return false;
	},

	/**
	 * Check whether a TCP socket with SSL encryption can be created using the
	 * <code>{@link Network.Socket}</code> class.
	 * @returns {Boolean} Returns <code>true</code> if SSL-encrypted TCP sockets are supported on
	 *		the current device and binary.
	 * @since 1.7
	 */
	getSslAvailable: function()
	{
		if(this.getPlatformOS() == 'Android' || this.getPlatformOS() == 'iPhone OS') {
			if(this.compareBinaryVersion(1, 6, 5) >= 0) {
				return true;
			}
		}
		return false;
	},
	
	_getPendingNotification: function () {
		var pending = this._fields.pendingNotification;
		this._fields.pendingNotification = null;
		if (pending) {
			return JSON.parse(pending);
		}
		return null;
	},

	/** @private */
	_init: function(dict)
	{
		// parse the dict
		var ifields = [];
		NgParseCommandDictionary(dict, 2, this._fields, ifields);

		try {
			// Change server based on URL passed in
			var items = /(https?:\/\/.+?)\/(.*)/.exec(this._fields.url);
			this._fields.server = items[1];
			this._fields.game  = items[2];
		}
		catch (e)
		{
			NgLogException(e);
		}

		// KJ this is necessary because an empty string passed becomes undefined
		if (!this._fields.intentUrl)
			this._fields.intentUrl = "";

		if (this._fields.oglExtensions)
		try
		{
			this._fields.oglExtensions = JSON.parse(this._fields.oglExtensions);
		}
		catch (e)
		{
			NgLogE("Unable to parse OGL Extensions! " + this._fields.oglExtensions);
			NgLogException(e);
		}

		if (this._fields._accts)
		try
		{
			this._fields._accts = JSON.parse(this._fields._accts);
		}
		catch (e)
		{
			NgLogE("Unable to parse Accounts! " + this._fields._accts);
			NgLogException(e);
		}

		try
		{
			this._configuration = JSON.parse(this._fields.configJSON);
			this._fields.contentUrl = this._configuration.contentUrl;
			this.socialServer = this._configuration.socialServer;
			this._releaseVersion = this._configuration.releaseVersion;
		}
		catch (e)
		{
			NgLogE("Unable to parse config!! (" + this._fields.configJSON + ")");
			NgLogException(e);
		}

		try {
			var jsVersion = packStringVersion((this.getSDKVersion() || "1.0").match(/[\.\d]+$/)[0]);
			Proc._setCoreJSVersionSendGen(jsVersion);
			this._binaryVersion = packStringVersion((this.getBinaryVersion() || "1.0").match(/[\.\d]+$/)[0]);
			this._effectiveVersion = Math.min(this._binaryVersion, jsVersion);
		}
		catch (e) {
			NgLogE("Unable to parse version strings!");
			NgLogException(e);
		}

		console.log( "dict : JS version : " + this.getSDKVersion() );
		console.log( "dict : JS build date : " + this.getSDKBuildDate() );
		console.log( "dict : JS build hash : " + this.getSDKBuildHash() );

		console.log("dict : contentUrl : " + this._fields.contentUrl);
		console.log("dict : socialServer : " + this.socialServer);
		console.log("dict : releaseVersion : " + this._releaseVersion);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 301,
	// Method create = -1
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Capabilities._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Capabilities._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[301] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x12dffff, [ +__objectRegistryId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/MessageEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/MessageEmitter'] || {}; $MODULE_REGISTRY['NGCore/Shared/MessageEmitter'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/MessageEmitter.js';

var Class = require('NGCore/Shared/Class').Class;
var MessageListener = require('NGCore/Shared/MessageListener').MessageListener;

exports.MessageEmitter = Class.subclass(
/** @lends Core.MessageEmitter.prototype */
{
	classname: 'MessageEmitter',
	
	/**
	 * @class The <code>MessageEmitter</code> class constructs emitter objects that send messages to registered <code>{@link Core.MessageListener}</code> objects. 
	 * When a defined condition triggers an emitter, all registered listener objects are in turn triggered.
	 * <br /><br />
	 * Emitter objects support two communication modes: emit and chain. When emitting, each listener is called in turn.
	 * When chaining, each listener can halt the propagation of a message to 
	 * other listeners by returning <code>true</code> from their callback.
	 * <br /><br />
	 * Each listener can include an optional priority ranking. Priority determines the order
	 * in which an emitter calls each listener. 
	 * If two listener objects are registered with the same priority, the emitter calls them in the order they were registered. 
	 * The default priority is <code>0</code>. 
	 * <br /><br />
	 * The classes in ngCore provide a variety of built-in message emitters. For example, if an
	 * application adds a listener to <code>{@link Device.ShakeEmitter}</code>, the listener will
	 * receive a message when the user shakes the device. You can also use the
	 * <code>MessageEmitter</code> class to create custom message emitters for your application.
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @since 1.0
	 * @status iOS, Android, Flash
	 */
	initialize: function()
	{
		this._messageListenersCount = 0;
		this._messageListenerRecords = [];
		this._messageDeferredWork = [];
		this._messageShouldDefer = false;
	},
	
	/**
	 * Unregister all <code>MessageListener</code> objects from this <code>MessageEmitter</code>.<br /><br />
	 * <b>Note:</b> Do not use the emitter after calling this.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function($super)
	{
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._destroyActual.bind(this, $super));
		}
		else
		{
			this._destroyActual($super);
		}
	},
	
	_destroyActual: function(superDestroy)
	{
		// Unregister all listeners.
		var records = this._messageListenerRecords;
		while(records.length)
		{
			this.removeListener(records[0].l);
		}
		
		if(superDestroy)
			superDestroy();
	},
	
	/**
	 * Retrieve the number of <code>MessageListener</code> objects registered with this <code>MessageEmitter</code>.
	 * @returns {Number} The current number of <code>MessageListener</code> objects.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getListenerCount: function()
	{
		return this._messageListenersCount;
	},
	
	/**
	 * Add a <code>MessageListener</code> to this <code>MessageEmitter</code>. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameters for the callback function are identical to parameters for <code>emit()</code> or
	 * <code>chain()</code>.
	 * <br /><br />
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br /><br />
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 *
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @cb {Function} func The function to call when an application triggers this emitter. The
	 *		callback function can accept any number of parameters. All parameters that are passed to
	 *		<code>emit()</code> or <code>chain()</code> will be passed to the callback function.
	 * @cb-returns {void}
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {Error} The specified listener is already listening to the emitter.
	 * @throws {Error} The specified listener is not an instance of <code>Core.MessageListener</code>.
	 * @see Core.MessageEmitter#removeListener
	 * @see Core.MessageEmitter#emit
	 * @see Core.MessageEmitter#chain
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	addListener: function(listener, func, priority)
	{
		if(!listener instanceof MessageListener)
			throw new Error('MessageEmitter.addListener: listener must be instances of MessageListener');
			
		if(!listener._startListeningEmitter(this))
			throw new Error('MessageEmitter.addListener: listener is already listening');
			
		if(!priority)
		{
			priority = 0;
		}
		
		this._messageListenersCount++;	
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._addListenerActual.bind(this, listener, func, priority));
		}
		else
		{
			this._addListenerActual(listener, func, priority);
		}
	},
	
	_addListenerActual: function(listener, func, priority)
	{
		//  The priority for default value is <code>0</code>
		if ((typeof priority) == 'undefined') {
			priority = 0;
		}
		// TODO Replace with binary search.
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			if(records[i].p <= priority)
				break;
		}
		records.splice(i, 0, {l: listener, f: func, p: priority});
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this <code>MessageEmitter</code>.<br /><br /> 
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @see Core.MessageEmitter#addListener
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	removeListener: function(listener)
	{
		if(!listener._stopListeningEmitter(this))
			//throw new Error('MessageEmitter.removeListner: listener is not listening');
			return false;
		
		this._messageListenersCount--;
		if(this._messageShouldDefer)
		{
			// TODO Replace with binary search.
			var records = this._messageListenerRecords;
			var len = records.length;
			for(var i=0; i < len; ++i)
			{
				var record = records[i];
				if(record.l == listener)
				{
					record.f = null;
					break;
				}
			}
			
			this._messageDeferredWork.push(this._removeListenerActual.bind(this, listener));
		}
		else
		{
			this._removeListenerActual(listener);
		}
		
		return true;
	},
	
	_removeListenerActual: function(listener)
	{
		// TODO Replace with binary search.
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(record.l == listener)
			{
				records.splice(i, 1);
				break;
			}
		}
	},
	
	/**
	 * Send a message to every registered <code>MessageListener</code>. This emitter will trigger all listeners
	 * in descending order based on the listener priority. All listener callback functions are generated
	 * with parameters passed to <code>emit()</code>.
	 * @param {String} params Parameters to pass to the generated callback function. Any
	 *		number and type of parameters may be passed in.
	 * @returns {Boolean} Returns <code>true</code> if the message was sent immediately. Returns
	 * <code>false</code> if the message was deferred.
	 * @see Core.MessageEmitter#chain
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	emit: function(params)
	{
		var handled = false;
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._emitActual.bind(this, arguments, false));
		}
		else
		{
			handled = this._emitActual(arguments, true);
		}
		return handled;
	},
	
	_emitActual: function(params, executeDeferred)
	{
		this._messageShouldDefer = true;
		
		var records = this._messageListenerRecords;
		var len = records.length;
		var handled = false;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(!record.f) continue;
			
			if(record.f.apply(record.l, params))
				handled = true;
		}

		this._messageShouldDefer = false;
		
		if(this._messageDeferredWork.length && executeDeferred)
		{
			this._executeDeferred();
		}

		return handled;
	},
	
	/**
	 * Send a message to every registered <code>MessageListener</code> through a chain of command. 
	 * This emitter will trigger all listeners in descending order based on the listener priority.
	 * All listener callback functions are generated with parameters passed to <code>chain()</code>.	 
	 * <br /><br />
	 * Unlike <code>emit()</code>, <code>chain()</code> allows a <code>MessageListener</code> to halt propagation of a message 
	 * to other listener objects by returning <code>true</code> for the callback function.
	 * This is useful for things like touch event handling. A <code>MessageListener</code> can respond to a touch event
	 * by returning <code>true</code>, masking the touch event from other listener objects.
	 *
	 * @param {String} params Parameters to pass in the generated callback function. Any number and
	 *		type of parameters may be passed in.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener responded. Returns <code>false</code> in all other cases.
	 * <br /><br />
	 * <b>Note:</b> If the application calls <code>chain()</code> recursively from
	 * within a message handler callback, it will always return <code>undefined</code>
	 * regardless of if a <code>MessageListener</code> responds or not.
	 * @see Core.MessageEmitter#emit
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	chain: function(params)
	{
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._chainActual.bind(this, arguments, false));
			return undefined;
		}
		else
		{
			return this._chainActual(arguments, true);
		}
	},
	
	_chainActual: function(params, executeDeferred)
	{
		var result = false;
		this._messageShouldDefer = true;
		
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(!record.f) continue;
			
			if(record.f.apply(record.l, params))
			{
				result = true;
				break;
			}
		}
		
		this._messageShouldDefer = false;
		
		if(this._messageDeferredWork.length && executeDeferred)
		{
			this._executeDeferred();
		}
		
		return result;
	},
	
	_executeDeferred: function()
	{
		// NOTE: Don't factor out deferred.length. Deferred work can add more deferred work.
		var deferred = this._messageDeferredWork;
		for(var i=0; i < deferred.length; ++i)
		{
			deferred[i]();
		}
		this._messageDeferredWork = [];
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/MessageEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/MessageEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/MessageEmitter'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/MessageEmitter.js';

exports.MessageEmitter = require('NGCore/Shared/MessageEmitter').MessageEmitter;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/DownloadFile'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/DownloadFile'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/DownloadFile'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/DownloadFile.js';

////////////////////////////////////////////////////////////////////////////////
// Class DownloadFile
// Downloads a file to the sandbox
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.DownloadFile = Class.subclass(
/** @lends Network.DownloadFile.prototype */
{
	classname: 'DownloadFile',
	/**
	 * @class The `DownloadFile` class constructs objects that conduct a file download through an
	 * HTTP request.
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function() {},

	/**
	 * Initiate a file download.
	 * @example
	 * var url = "http://example.com/sample-file.png";
	 * var filename = "./Content/sample-file.png";
	 * var downloader = new Network.DownloadFile();
	 * downloader.start(filename, "GET", url, [{item: "From", content: "user@example.com"}],
	 *   function(status, md5, responseHeaders) {
	 *     console.log("Downloaded " + filename + ". Status code: " + status + 
	 *       ", MD5: " + md5);
	 *     console.log("Response headers: " + JSON.stringify(responseHeaders));
	 * });
	 * @param {String} filename A local and relative path for storing the downloaded data.
	 * @param {String} method The HTTP method to use.  Specify either `GET` or
	 *		`POST`.
	 * @param {String} url The URL of the downloaded file.
	 * @param {Object[]|String[]} headers An array providing custom headers for the HTTP request.
	 *		The array can contain either strings that contain raw text for the headers (for example,
	 *		`["From: user@example.com"]`) or objects with an `item` property representing a key and
	 *		a `content` property representing a value (for example, `[{item: "From", content:
	 *		"user@example.com"}]`). If you do not need to provide custom headers, pass in an empty
	 *		array.
	 * @cb {Function} [callback] The function to call after the download is complete.
	 * @cb-param {String} statusCode The status code that was received when downloading the file.
	 * @cb-param {String} fileSignature An MD5 checksum of the downloaded file.
	 * @cb-param {Object[]} responseHeaders An array of headers from the HTTP response. The array
	 *		contains objects with an `item` property representing a key and a `content` property
	 *		representing a value (for example, `[{item: "Location", content:
	 *		"http://example.com/sample-file.png"}]`).
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	start: function(filename, method, url, headers, callback)
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		url = url.split(' ').join('%20');
		// Check headers
		if (!(headers instanceof Array))
		{
			if(headers){
				NgLogE('Improper headers sent('+headers+'). Need an array, ex: [{item:"Content-Easter", content:"egg"}]');
			}
			headers = [];
		}

		// Send the goods
		this.__sendSendGen( filename, method, url, headers.length );

		// Send headers
		for (var i in headers)
		{
			this.__headerSendGen(headers[i].item, headers[i].content);
		}

		// Save the callback
		this.mCB = callback;
	},

    /**
      * Stop a file download.
      * @returns {void}
      * @status Flash, Test, FlashTested
      * @since 1.4.1
      */
	abort: function()
	{
		this._destroySendGen();
		ObjectRegistry.unregister(this);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 341,
	// Method create = -1
	// Method destroy = 2
	// Method _send = 3
	// Method _header = 4
	// Method finish = 5
	// Method finishWithHeaders = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._finishRecv( cmd );
					break;
				case 6:
					instance._finishWithHeadersRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in DownloadFile._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in DownloadFile._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[341] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_finishRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		obj[ "status" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "status" ] === undefined )
		{
			NgLogE("Could not parse status in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		obj[ "signature" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "signature" ] === undefined )
		{
			NgLogE("Could not parse signature in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_finishWithHeadersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in DownloadFile.finishWithHeaders from command: " + cmd );
			return false;
		}
		
		obj[ "status" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "status" ] === undefined )
		{
			NgLogE("Could not parse status in DownloadFile.finishWithHeaders from command: " + cmd );
			return false;
		}
		
		obj[ "signature" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "signature" ] === undefined )
		{
			NgLogE("Could not parse signature in DownloadFile.finishWithHeaders from command: " + cmd );
			return false;
		}
		
		obj[ "headers" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "headers" ] === undefined )
		{
			NgLogE("Could not parse headers in DownloadFile.finishWithHeaders from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x155ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1550002, this );
	},
	
	/** @private */
	__sendSendGen: function( fileName, method, url, headers )
	{
		Core.Proc.appendToCommandString( 0x1550003, this, [ Core.Proc.encodeString( fileName ), Core.Proc.encodeString( method ), Core.Proc.encodeString( url ), +headers ] );
	},
	
	/** @private */
	__headerSendGen: function( item, content )
	{
		Core.Proc.appendSubcommandToCommandString( [ Core.Proc.encodeString( item ), Core.Proc.encodeString( content ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// _send: function( fileName, method, url, headers ) {}
	
	// _header: function( item, content ) {}
	
	// _finishRecv: function( cmd ) {}
	// _finishWithHeadersRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,
	_finishRecv: function( cmd )
	{
		this._destroySendGen();
		
		var obj = {};
		this._finishRecvGen(cmd, obj);

		if (this.mCB)
			this.mCB(obj.status, obj.signature, {});

		ObjectRegistry.unregister(this);
	},

	_finishWithHeadersRecv: function( cmd )
	{
		this._destroySendGen();
		
		var obj = {};
		this._finishWithHeadersRecvGen(cmd, obj);


		if (this.mCB)
		{
			var headerEx = /^([\w-]+):\s*([^\n]+?)\s*$/;

			var headers = [];
			var lines = obj.headers.split('\n');

			for(var i = 0; i < lines.length; i++)
			{
				var match = headerEx.exec(lines[i]);
				if(match)
					headers.push({"item": match[1], "content": match[2]});
			}

			this.mCB(obj.status, obj.signature, headers);
		}
	
		ObjectRegistry.unregister(this);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/_int_Util'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/_int_Util'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/_int_Util'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/_int_Util.js';

///////////////////////////////////////////////////////////////////////////////
// Class _int_Util
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;
////////////////////////////////////////////////////////////////////////////////

var _int_Util = exports._int_Util = Class.singleton(
/** @lends Network._int_Util.prototype */
{
	classname: '_int_Util',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this._callbackID = 0;
		this._callbacks = [];

		// Only set this to false if we do not meet this version. Otherwise we have to say true;
		this.valid = !Core.Capabilities.meetsBinaryVersion("1.3.5.10");
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	ProcID:
	{ 
		Persist: -1,
		Game: -2
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 350,
	// Method create = -1
	// Method destroy = 2
	// Method sign = 3
	// Method signCallback = 4
	// Method adTapjoySendActionComplete = -5
	// Method verified = -6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._signCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _int_Util._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -6:
					_int_Util._verifiedRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in _int_Util._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[350] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_signCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		obj[ "signature" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "signature" ] === undefined )
		{
			NgLogE("Could not parse signature in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	$_verifiedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _int_Util.verified from command: " + cmd );
			return false;
		}
		
		obj[ "b" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "b" ] === undefined )
		{
			NgLogE("Could not parse b in _int_Util.verified from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x15effff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x15e0002, this );
	},
	
	/** @private */
	_signSendGen: function( baseString, callbackID, environment )
	{
		Core.Proc.appendToCommandString( 0x15e0003, this, [ Core.Proc.encodeString( baseString ), +callbackID, Core.Proc.encodeString( environment ) ] );
	},
	
	/** @private */
	$_adTapjoySendActionCompleteSendGen: function( actionId )
	{
		Core.Proc.appendToCommandString( 0x15efffb, [ Core.Proc.encodeString( actionId ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// sign: function( baseString, callbackID, environment ) {}
	
	// _signCallbackRecv: function( cmd ) {}
	// $adTapjoySendActionComplete: function( actionId ) {}
	
	// $_verifiedRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,
	$_verifiedRecv: function( cmd )
	{
		this.valid = true;
		if (this._verifiedCallback)
		{
			this._verifiedCallback();
		}
	},

	sign: function( baseString, environment, callback) {
		// Save requests
		if (this.valid)
		{
			this._callbacks[this._callbackID] = callback;
			this._signSendGen(baseString,this._callbackID++, environment);
		}
		else
		{
			callback(false);
		}
	},
	_signCallbackRecv: function( cmd ) {
		var msg = {};
		if (! this._signCallbackRecvGen(cmd, msg)) {
			return;
		}
		var func = this._callbacks[parseInt(msg.callbackID)];
		if (func) {
			func(msg.signature);
		}
	},

	signable: function()
	{
		return this.valid;
	},

	registerVerifiedCB: function(cb)
	{
		if (this.valid)
		{
			cb();
		}
		else
		{
			this._verifiedCallback = cb;
		}
	},

	$adTapjoySendActionComplete: function(actionId) {
		console.log('_int_Util.adTapjoysendActionComplete: ' + actionId);
		this._adTapjoySendActionCompleteSendGen(actionId);
	}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/Socket'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/Socket'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/Socket'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/Socket.js';

////////////////////////////////////////////////////////////////////////////////
// Class Socket
//   Low-level (BSD-like) network API
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Caps = require('NGCore/Client/Core/Capabilities').Capabilities;

////////////////////////////////////////////////////////////////////////////////


exports.Socket = Class.subclass(
/** @lends Network.Socket.prototype */
{
	classname: 'Socket',
	
	/**
	 * @class The `Network.Socket` class enables applications to connect to a server using
	 * Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) sockets, without the 
	 * additional overhead of an HTTP or HTTPS request. The current implementation is based on
	 * Internet Protocol version 4 (IPv4).
	 * 
	 * TCP is designed to ensure reliable, accurate delivery of messages, at the cost of increased
	 * latency when there is a problem sending or receiving data. Use TCP for network operations
	 * that depend on this increased accuracy. In contrast, UDP delivers messages as quickly as
	 * possible, with no error checking; messages may be dropped, arrive out of order, or contain
	 * errors. Use UDP for network operations that are more error-tolerant and depend upon low
	 * latency.
	 *
	 * Secure Sockets Layer (SSL) encryption is supported for TCP sockets. An encrypted TCP socket
	 * can connect to servers that use SSLv3 or Transport Layer Security (TLS) v1. SSLv2, which has
	 * been deprecated due to security issues, is not supported.
	 * 
	 * **Note**: `Network.Socket` is designed to support low-level network operations. Use the
	 * `{@link Network.DownloadFile}` and `{@link Network.XHR}` classes for HTTP/HTTPS requests.
	 *
	 * After creating the socket, your application should use the following methods to specify
	 * callback functions for the socket:
	 *
	 * + `{@link Network.Socket#setOnReadable}`: The function to call when there is data available
	 * to be read from the socket.
	 * + `{@link Network.Socket#setOnWritable}`: The function to call when the socket is ready to
	 * transmit data.
	 * + `{@link Network.Socket#setOnError}`: The function to call when an error occurs while
	 * transmitting data.
	 * 
	 * **Important**: Before your application creates a socket connection, it should verify that
	 * socket support is available by calling `{@link Core.Capabilities#getTcpAvailable}` (for TCP)
	 * or `{@link Core.Capabilities#getUdpAvailable}` (for UDP).
	 * @name Network.Socket
	 * @constructs Create a network socket.
	 * @augments Core.Class
	 * @example
	 * // Create a TCP socket without security (the default).
	 * var socket;
	 *
	 * if (Core.Capabilities.getTcpAvailable()) {
	 *     socket = new Network.Socket();
	 * } else {
	 *     // Use another network connection method, or report that the
	 *     // application is not supported on the current platform.
	 * }
	 * @example
	 * // If SSL is available, create a TCP socket with SSL security. Otherwise,
	 * // create a TCP socket without security.
	 * var security;
	 * var socket;
	 *
	 * if (Core.Capabilities.getTcpAvailable()) {
	 *     if (Core.Capabilities.getSslAvailable()) {
	 *         security = Network.Socket.Security.SecSSL;
	 *     } else {
	 *         security = Network.Socket.Security.SecNone;  
	 *     }
	 *     socket = new Network.Socket(Network.Socket.Protocol.TCP4, security);
	 * } else {
	 *     // Use another network connection method, or report that the
	 *     // application is not supported on the current platform.
	 * }
	 * @example
	 * // 1. Create a TCP socket, bind it to a local port selected by the device, 
	 * //    and connect it to a remote host at 10.16.10.200:9876.
	 * // 2. Write "Hello World!" to the socket.
	 * // 3. Log the remote host's response to the console, then close the socket.
	 * var tcpSocket;
	 * var readBuffer;
	 * var writeBuffer;
	 * var connected = false;
	 * var bytesRead;
	 * var server;
	 *
	 * if (Core.Capabilities.getTcpAvailable()) {
	 *     tcpSocket = new Network.Socket();
	 *     readBuffer = new Core.Buffer();
	 *     writeBuffer = new Core.Buffer();
	 *
	 *     tcpSocket.setOnWritable(function(socket) {
	 *         // Make sure we only send the message once.
	 *         if (!connected) {
	 *             connected = true;
	 *             writeBuffer.writeBytes("Hello World!");
	 *             socket.send(writeBuffer);
	 *         }
	 *     });
	 *
	 *     tcpSocket.setOnReadable(function(socket) {
	 *         bytesRead = socket.recv(readBuffer);
	 *         if (bytesRead !== 0) {
	 *             // We received data from the remote host.
	 *             // Read the data, then close the socket.
	 *             console.log("Received the following data from the socket: " + 
	 *               readBuffer.readBytes(readBuffer.getSize()));
	 *             socket.close();
	 *         }
	 *     });
	 *
	 *     tcpSocket.setOnError(function(err, socket) {
	 *         console.log("A socket error occurred: " + err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.NotConnected:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             case Network.Socket.Error.ConnectionTimeout:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     });
	 *
	 *     tcpSocket.bind(0, function(err, socket, port) {
	 *         if (err) {
	 *             console.log("Unable to bind the socket to a local port: " + 
	 *               err.description);
	 *             // Take action based on the type of error.
	 *             switch(err.code) {
	 *                 case Network.Socket.Error.AddrInUse:
	 *                     // Add code to handle the error.
	 *                     break;
	 *                 // Add code to handle other errors as needed.
	 *                 default:
	 *                     // Add code to handle the error.
	 *                     break;
	 *             }
	 *         } else {
	 *             server = {
	 *                 host: "10.16.10.200",
	 *                 port: 9876
	 *             };
	 *             socket.connect(server);
	 *         }
	 *     });
	 * } else {
	 *     // Use another network connection method, or report that the
	 *     // application is not supported on the current platform.
	 * }
	 * @param {Network.Socket.Protocol} [protocol=Network.Socket.Protocol.TCP4] The transport
	 *		protocol to use for the socket. **Note**: Call
	 *		`{@link Core.Capabilities#getTcpAvailable}` or
	 *		`{@link Core.Capabilities#getUdpAvailable}` to verify that the requested transport
	 *		protocol is supported.
	 * @param {Network.Socket.Security} [security=Network.Socket.Security.SecNone] The type of
	 *		security to use for the socket. **Note**: When using SSL, call
	 *		`{@link Core.Capabilities#getSslAvailable}` to verify that SSL is supported.
	 * @see Core.Buffer
	 * @see Core.Capabilities#getSslAvailable
	 * @see Core.Capabilities#getTcpAvailable
	 * @see Core.Capabilities#getUdpAvailable
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.6.5
	 */
	initialize: function(protocol, security)
	{
		this._protocol = (protocol === undefined)?this.Protocol.TCP4:protocol;
		this._security = (security === undefined)?this.Security.SecNone:security;
		this._isStream = (this._protocol != this.Protocol.UDP4);
		this._isServer = false;
		this._state = this.State.CLOSED;
		this._maxSndBufSize = 64*1024;
		this._curSndBufSize = this._maxSndBufSize;
		this._rcvBuf = '';
		this._rcvBufInfo = []; // each item has a form of { size:64, host:'10.1.1.2', port:5678 }
		this._EOS = false;
		this._localAddr = null;
		this._peerAddr = null;
		this._nextCbId = 0;
		this._pendingChildren = [];
		this._cb = {};
		this._onReadable = null;
		this._onWritable = null;
		this._onError = null;
		this._storeCb = function(cb) {
			var cbId = -1;
			if(cb) {
				cbId = this._nextCbId++;
				this._cb[cbId] = cb?cb:function(){};
			}
			return cbId;
		};
		this._restoreCb = function(cbId) {
			var cb = this._cb[cbId];
			delete this._cb[cbId];
			return cb;
		};
		if(this._parentId === undefined || this._childId === undefined) {
			this._parentId = -1;
			this._childId = -1;
		} else {
			this._state = this.State.READY;
			this._isServer = true;
		}

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId, this._protocol, this._security, this._parentId, this._childId);
	},

// API

	/**
	 * Specify a value for one of the socket's configuration options. See
	 * `{@link Network.Socket#Option}` for details about the options that are supported.
	 * @example
	 * // Set the connection timeout to 10 seconds for the existing socket
	 * // 'tcpSocket'.
	 * tcpSocket.setOption(Network.Socket.Option.OpConnectionTimeout, 10000, 
	 *   function(err, soc) {
	 *     if (err) {
	 *         console.log("Unable to set the socket's connection timeout: " +
	 *           err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.Invalid:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     } else {
	 *         // Continue using the socket object ('soc').
	 *     }
	 * });
	 * @param {Network.Socket#Option} op The configuration option to set.
	 * @param {Number} val The value to use for the configuration option.
	 * @cb {Function} cb The function to call after setting the configuration option.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.Socket#Error} [err.code] A code identifying the type of error.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {Network.Socket} [soc] The socket whose configuration option was set.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see Network.Socket#getOption
	 * @see Network.Socket#Option
	 * @since 1.6.5
	 */
	setOption: function(op, val, cb)
	{
		var cbId = this._storeCb(cb);
		this._setOptionSendGen(op, val, '', cbId);
	},

	/**
	 * Retrieve the current value of one of the socket's configuration options. See
	 * `{@link Network.Socket#Option}` for details about the options that are supported.
	 * @example
	 * // Retrieve the connection timeout for the existing socket 'tcpSocket'.
	 * tcpSocket.getOption(Network.Socket.Option.OpConnectionTimeout,
	 *   function(err, soc, val) {
	 *     if (err) {
	 *         console.log("Unable to retrieve the socket's connection timeout: " +
	 *           err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.Invalid:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     } else {
	 *         console.log("The current connection timeout is " + val);
	 *         // Continue using the socket object ('soc').
	 *     }
	 * });
	 * @param {Network.Socket#Option} op The configuration option to retrieve.
	 * @cb {Function} cb The function to call after retrieving the configuration option.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.Socket#Error} [err.code] A code identifying the type of error.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {Network.Socket} [soc] The socket whose configuration option was retrieved.
	 * @cb-param {Number} val The value of the configuration option.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see Network.Socket#Option
	 * @see Network.Socket#setOption
	 * @since 1.6.5
	 */
	getOption: function(op, cb)
	{
		var cbId = this._storeCb(cb);
		this._getOptionSendGen(op, cbId);
	},

	/**
	 * Set the function to call when there is data available to be read from the socket.
	 * @example
	 * // For the existing socket 'tcpSocket', read data from the socket,
	 * // then write the data to the console.
	 * var readBuffer = new Core.Buffer();
	 *
	 * tcpSocket.setOnReadable(function(socket) {
	 *     var bytesRead = socket.recv(readBuffer);
	 *     if (bytesRead !== 0) {
	 *         // We received data from the remote host.
	 *         console.log("Received the following data from the socket: " + 
	 *           readBuffer.readBytes(readBuffer.getSize()));
	 *     }
	 * });
	 * @cb {Function} callback The function to call when there is data available to be read from the
	 *		socket.
	 * @cb-param {Network.Socket} [soc] The socket for which data is available.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see Core.Buffer
	 * @since 1.6.5
	 */
	setOnReadable: function(callback)
	{
		this._onReadable = callback;
	},

	/**
	 * Set the function to call when the socket is ready to transmit data. For TCP sockets, when
	 * this function is called for the first time, it indicates that the connection has been
	 * established.
	 * @example
	 * // If there is data available in the write buffer, write it to the 
	 * // existing socket 'tcpSocket'.
	 * var writeBuffer = new Core.Buffer();
	 * writeBuffer.writeBytes("Hello World!");
	 *
	 * tcpSocket.setOnWritable(function(socket) {
	 *     if (writeBuffer.getSize() > 0) {
	 *         tcpSocket.send(writeBuffer);
	 *     }
	 * });
	 * @cb {Function} callback The function to call when the socket is ready to transmit data.
	 * @cb-param {Network.Socket} [soc] The socket that is ready to transmit data.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see Core.Buffer
	 * @since 1.6.5
	 */
	setOnWritable: function(callback)
	{
		this._onWritable = callback;
	},

	/**
	 * Set the function to call when an error occurs while transmitting data.
	 * @example
	 * // If the existing socket 'tcpSocket' experiences an error, log a message
	 * // to the console, then handle the error.
	 * tcpSocket.setOnError(function(err, socket) {
	 *     console.log("A socket error occurred: " + err.description);
	 *     // Take action based on the type of error.
	 *     switch(err.code) {
	 *         case Network.Socket.Error.NotConnected:
	 *             // Add code to handle the error.
	 *             break;
	 *         case Network.Socket.Error.ConnectionTimeout:
	 *             // Add code to handle the error.
	 *             break;
	 *         // Add code to handle other errors as needed.
	 *         default:
	 *             // Add code to handle the error.
	 *             break;
	 *     }
	 * });
	 * @cb {Function} callback The function to call when an error occurs while transmitting data.
	 * @cb-param {Object} err Information about the error.
	 * @cb-param {Network.Socket#Error} err.code A code identifying the type of error.
	 * @cb-param {String} err.description A description of the error.
	 * @cb-param {Network.Socket} [soc] The socket for which an error occurred.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.6.5
	 */
	setOnError: function(callback)
	{
		this._onError = callback;
	},

	/**
	 * Bind the socket to a local port.
	 * @example
	 * // Bind the existing socket 'tcpSocket' to a port number assigned by
	 * // the device. If an error occurs, log a message and handle the error.
	 * var port;
	 * tcpSocket.bind(0, function(err, soc, port) {
	 *     if (err) {
	 *         console.log("Unable to bind the socket to a local port: " + 
	 *           err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.AddrInUse:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     } else {
	 *         // Connect the socket object ('soc') to a remote host.
	 *     }
	 * });
	 * @param {Number} port The local port number to bind to this socket. Use the value `0` to allow
	 *		the device to assign a port number.
	 * @cb {Function} [callback] The function to call after binding the socket to a port number.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.Socket#Error} [err.code] A code identifying the type of error.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {Network.Socket} [soc] The socket that was bound to a local port.
	 * @cb-param {Number} [port] The local port number to which the socket was bound.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.6.5
	 */
	bind: function(port, callback)
	{
		if(this._state == this.State.CLOSED) {
			var cbId = this._storeCb(callback);
			this._bindSendGen(port, 0/*future-use*/, cbId);
		}
	},

	/**
	 * Add the socket as a member of a specified multicast group. Used only for UDP sockets.
	 * @example
	 * // Add the existing UDP socket 'udpSocket' to a multicast group, setting
	 * // the time-to-live for outgoing packets to 2. If an error occurs, log a
	 * // message and handle the error.
	 * var options = {
	 *     ttl: 2
	 * };
	 * udpSocket.addMembership("10.16.1.105", options, function(err, soc) {
	 *     if (err) {
	 *         console.log("Unable to add the socket to a multicast group: " + 
	 *           err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.NotConnected:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     } else {
	 *         // Continue using the socket object ('soc').
	 *     }
	 * });
	 * @param {String} mcgrp The IP address of the multicast group.
	 * @param {Object} [options] Options for multicasting.
	 * @param {Boolean} [options.loop=false] Set to `true` to receive packets sent to the multicast
	 *		group.
	 * @param {Number} [options.ttl=1] The time-to-live (TTL) for outgoing packets, which controls
	 *		how many times the packet will be forwarded.
	 * @cb {Function} [callback] The function to call after adding the socket to the multicast
	 *		group.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.Socket#Error} [err.code] A code identifying the type of error.
	 * @cb-param {Number} [err.description] A description of the error.
	 * @cb-param {Network.Socket} [soc] The socket that was added to the multicast group.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.6.5
	 */
	addMembership: function(mcgrp, options, callback)
	{
		if(!this._isStream) {
			var flags = 0;
			var ttl = 1;
			if(typeof(options) == 'object') {
				if(options) {
					if(options['loop']) {
						flags |= this.MulticastFlag['loop'];
					}
					if(options['ttl']) {
						ttl = options['ttl'];
					}
				}
			} else {
				callback = options;
			}
			var cbId = this._storeCb(callback);
			this._addMembershipSendGen( mcgrp, flags, ttl, cbId );
		}
	},

	/**
	 * Remove the socket from a specified multicast group. Used only for UDP sockets.
	 * @example
	 * // Remove the existing UDP socket 'udpSocket' from a multicast group.
	 * // If an error occurs, log a message and handle the error.
	 * udpSocket.dropMembership("10.16.1.105", function(err, soc) {
	 *     if (err) {
	 *         console.log("Unable to remove the socket from a multicast group: " +
	 *           err.description);
	 *         // Take action based on the type of error.
	 *         switch(err.code) {
	 *             case Network.Socket.Error.NotConnected:
	 *                 // Add code to handle the error.
	 *                 break;
	 *             // Add code to handle other errors as needed.
	 *             default:
	 *                 // Add code to handle the error.
	 *                 break;
	 *         }
	 *     } else {
	 *         // Continue using the socket object ('soc').
	 *     }
	 * });
	 * @param {String} mcgrp The IP address of the multicast group.
	 * @cb {Function} [callback] The function to call after removing the socket from the multicast
	 *		group.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.Socket#Error} [err.code] A code identifying the type of error.
	 * @cb-param {Number} [err.description] A description of the error.
	 * @cb-param {Socket} [soc] The socket that was removed from the multicast group.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.6.5
	 */
	dropMembership: function(mcgrp, callback)
	{
		if(!this._isStream) {
			var cbId = this._storeCb(callback);
			this._dropMembershipSendGen( mcgrp, cbId );
		}
	},

	/**
	 * Connect the socket to a remote host. For TCP sockets, you must call this method before you
	 * transmit data through the socket. For UDP sockets, you can call this method to connect the
	 * socket to a remote host, or you can specify a remote host when you call
	 * `{@link Network.Socket#send}` or `{@link Network.Socket#recv}`.
	 * @example
	 * // Connect the existing socket 'tcpSocket' to a remote host at
	 * // 10.16.10.200:9876.
	 * var server = {
	 *     host: "10.16.10.200",
	 *     port: 9876
	 * };
	 * tcpSocket.connect(server);
	 * @param {Object} to Information about the remote host.
	 * @param {String} [to.cn] The remote host's fully qualified domain name (FQDN). If this 
	 *		parameter is included, and the socket is using SSL security, the FQDN will be used to
	 *		verify the common name (CN) used to generate the remote host's SSL certificate. If this
	 *		parameter is omitted, or if the socket is not using SSL, verification will be skipped.
	 *		Available since ngCore 1.7.
	 * @param {String} to.host The IP address of the remote host.
	 * @param {Number} to.port The port number of the remote host.
	 * @returns {void}
	 * @since 1.6.5
	 */
	connect: function(to)
	{
		if(this._isStream) {
			if(this._state == this.State.CLOSED) {
				this._state = this.State.CONNECTING;
				if(!to.cn) to.cn = '';
				this._connectSendGen(to.host, to.port, to.cn);
			}
		} else {
			if(this._state == this.State.CLOSED || this._state == this.State.READY) {
				if(!this._peerAddr) {
					this._state = this.State.CONNECTING;
				}
				this._connectSendGen(to.host, to.port, '');
			}
		}
	},

	/**
	 * @private
	 * Listen on a socket. (TCP only)
	 */
	listen: function()
	{
		if(this._state == this.State.CLOSED) {
			if(this._isStream) {
				var backlog = 8;
				this._state = this.State.LISTENING;
				this._listenSendGen(backlog);
			}
		}
	},

	/**
	 * @private
	 * Accept a new socket. (TCP listener only)
	 * @return Non-null Socket object is returned on success, or null on failure.
	 */
	accept: function()
	{
		var newSoc = null;
		if(this._isStream && this._state == this.State.LISTENING) {
			var child = this._pendingChildren.shift();
			if(child) {
				newSoc = new TcpServerSocket(this._protocol, this._security, child['parentId'], child['childId']);
				newSoc._peerAddr = { host:child['host'], port:child['port'] };
				newSoc._localAddr = this._localAddr;
			}
		}
		return newSoc;
	},

	/** @private */
	/*
	_dumpDigits: function(s) {
		var str = '';
		for(var i = 0; i < s.length; ++i) {
			var val = s.charCodeAt(i);
			var digit = val.toString(16);
			if(digit.length < 2) {
				digit = '0' + digit;
			}

			str += (digit + ' ');

			if((i % 8) == 7) {
				if((i % 32) == 31) {
					str += '\n';
				} else {
					str += ' ';
				}
			}
		}

		return str;
	},
	*/

	/**
	 * Send data from a buffer to a socket, removing the data from the buffer. Returns the number of
	 * characters that were written to the socket.
	 * @example
	 * // Create a new buffer that contains the string "Hello World", and send the
	 * // entire contents of the buffer using the existing TCP socket 'tcpSocket'.
	 * var writeBuffer = new Core.Buffer();
	 * writeBuffer.writeBytes("Hello World");
	 * var charsWritten = tcpSocket.send(writeBuffer);
	 * @example
	 * // Create a new buffer that contains 2,500 characters. Send the buffer's
	 * // contents in several messages that contain up to 1,000 characters each,
	 * // using the existing UDP socket 'udpSocket' and the remote host
	 * // 10.16.10.200:9876.
	 * var writeBuffer = new Core.Buffer(),
	 *     string = "";
	 * for (var i = 0; i < 2500; i++) {
	 *     string += "a";
	 * }
	 * writeBuffer.writeBytes(string);
	 *
	 * var server = {
	 *     host: "10.16.10.200",
	 *     port: 9876
	 * };
	 * var charsWritten;
	 *
	 * while (writeBuffer.getSize() > 0) {
	 *     charsWritten = udpSocket.send(writeBuffer, 1000, server);
	 *     console.log("Wrote " + charsWritten + " characters to the socket. " +
	 *       writeBuffer.getSize() + " characters left to write.");
	 * }
	 * @param {Core.Buffer} buf The buffer that contains data to be sent. The data that was written
	 *		to the socket will be removed from the buffer.
	 * @param {Number} [len=-1] The number of characters to send, or a negative number to send all 
	 *		data in the buffer. For UDP sockets, use a value less than `1400` to reduce
	 *		fragmentation at the IP layer; UDP packets larger than 2 KB will be discarded by the
	 *      receiver.
	 * @param {Object} [to] Information about the remote host. Required for UDP sockets; after the
	 *		UDP socket has connected to a remote host, the value of this parameter will be ignored.
	 *		Not used for TCP sockets.
	 * @param {String} [to.host] The IP address of the remote host.
	 * @param {Number} [to.port] The port number of the remote host.
	 * @returns {Number} The number of characters that were written to the socket.
	 * @see Core.Buffer
	 * @since 1.6.5
	 */
	send: function(buf, len, to) {
		if(this._isStream) {
			if(this._state != this.State.READY) {
				return this.Error.Invalid;
			}
		} else {
			if(this._state == this.State.CLOSED) {
				this._state = this.State.READY;
			} else {
				if(this._state != this.State.CONNECTING && this._state != this.State.READY) {
					return this.Error.Invalid;
				}
			}
		}
		if(len === undefined) {
			len = -1;
		} else {
			if(typeof(len) == 'object') {
				to = len;
				len = -1;
			}
		}
    if(len < 0 || len > buf.getSize()) {
			len = buf.getSize();
		}
		if(len > this._curSndBufSize) {
			if(!this._isStream) {
				return exports.Socket.Error.TryAgain;
			}
			len = this._curSndBufSize;
			if(!len) {
				return 0;
			}
		}
		var data = buf.readBytes(len);
		if(!to)
			to = {host:'',port:0};
		this._curSndBufSize -= data.length;
		this._sendSendGen(data, to.host, to.port);
		return data.length;
	},

	/**
	 * Read data from a socket and write it to a buffer. Returns the number of characters that were
	 * written to the buffer.
	 *
	 * If the method's return value is `0`, the remote server has closed the connection. Your
	 * application can call `{@link Network.Socket#close}` to close the socket.
	 * @example
	 * // Read all of the data from the existing TCP socket 'tcpSocket', and store 
	 * // the data in a new buffer.
	 * var readBuffer = new Core.Buffer();
	 * tcpSocket.recv(readBuffer);
	 * @example
	 * // Read all of the data from the existing UDP socket 'udpSocket', using 
	 * // the remote host 10.16.10.200:9876, and store the data in a new buffer.
	 * var readBuffer = new Core.Buffer();
	 * var server = {
	 *     host: "10.16.10.200",
	 *     port: 9876;
	 * };
	 * udpSocket.recv(readBuffer, server);
	 * @param {Core.Buffer} buf The buffer in which to write data. If the buffer already contains
	 *		data, the new data will be appended to the existing data.
	 * @param {Number} [len=-1] The number of bytes to read, or a negative number to read all
	 *		available data. Used only for TCP sockets.
	 * @param {Object} [from] Information about the remote host. Required for UDP sockets; after the
	 *		UDP socket has connected to a remote host, the value of this parameter will be ignored.
	 *		Not used for TCP sockets.
	 * @param {String} [from.host] The IP address of the remote host.
	 * @param {Number} [from.port] The port number of the remote host.
	 * @returns {Number} The number of characters that were written to the buffer.
	 * @see Core.Buffer
	 * @since 1.6.5
	 */
	recv: function(buf, len, from) {
		if(this._state != this.State.READY && this._state != this.State.CLOSING) {
			return this.Error.Invalid;
		}
		if(len === undefined) {
			len = -1;
		} else {
			if(typeof(len) == 'object') {
				from = len;
				len = -1;
			}
		}
		var orgSize = buf.getSize();
		if(this._isStream) {
			if(!this._rcvBuf.length) {
				return this._EOS? 0:exports.Socket.Error.TryAgain;
			}
			if(len < 0 || len >= this._rcvBuf.length) {
				buf.writeBytes(this._rcvBuf);
				this._rcvBuf = '';
			} else {
				buf.writeBytes(this._rcvBuf.slice(0, len));
				this._rcvBuf = this._rcvBuf.slice(len);
			}
			if(from) {
				from['host'] = this._peerAddr['host'];
				from['port'] = this._peerAddr['port'];
			}
		} else {
			if(!this._rcvBufInfo.length)
			{
				this._rcvBuf = ''; // for just in case.
				return exports.Socket.Error.TryAgain;
			}
			var info = this._rcvBufInfo.shift();
			len = info['size'];
			if(len > 0) {
				buf.writeBytes(this._rcvBuf.slice(0, len));
				this._rcvBuf = this._rcvBuf.slice(len);
			}
			if(from) {
				from['host'] = info['host'];
				from['port'] = info['port'];
			}
		}
		if(buf.getSize() > 0) {
			this._updateSendGen( this.UpdateId.U_SizeRcvd, buf.getSize(), '' );
		}
		return buf.getSize() - orgSize;
	},

	/**
	 * Initiate a graceful shutdown process for the socket. For TCP sockets, call this method prior
	 * to calling `{@link Network.Socket#close}`. Do not call this method on UDP sockets.
	 *
	 * If the shutdown process is successful, the following steps occur:
	 *
	 * 1. The remote server notifies the socket that it has closed the connection.
	 * 2. The socket executes the callback function defined by calling
	 * `{@link Network.Socket#setOnReadable}`. This callback function will normally include a call
	 * to the method `{@link Network.Socket#recv}`.
	 * 3. The `{@link Network.Socket#recv}` method returns the value `0`, indicating that the
	 * application can close the socket by calling `{@link Network.Socket#close}`.
	 * @deprecated Since ngCore 1.8. Because of device limitations, it is not possible to complete a
	 *		graceful shutdown on many devices. This method may be removed in a future version of
	 *		ngCore.
	 * @returns {void}
	 * @since 1.6.5
	 */
	shutdown: function() {
		if(this._state == this.State.READY) {
			this._state = this.State.CLOSING;
			this._shutdownSendGen(0/*not used*/);
		}
	},

	/**
	 * Close the socket. Do not reuse the `Network.Socket` object after calling this method.
	 *
	 * **Note**: Calling this method closes the socket immediately. If you need to close the
	 * connection more gracefully, add code to your app that notifies the remote server that the
	 * connection is closing, and add code to your server that acknowledges the notification. The
	 * app can then close the connection after it receives the acknowledgement.
	 * @returns {void}
	 * @since 1.6.5
	 */
	close: function() {
		this._closeSendGen();
		this._state = this.State.CLOSED;
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Retrieve the socket's current state.
	 * @example
	 * // Retrieve the state of the existing TCP socket 'tcpSocket', and
	 * // take an action based on the current state.
	 * var state = tcpSocket.getState();
	 * switch (state) {
	 *     case Network.Socket.State.READY:
	 *         // Your code here.
	 *         break;
	 *     case Network.Socket.State.CLOSED:
	 *         // Your code here.
	 *         break;
	 *     // Continue through each enumerated value that you want to test.
	 *     default:
	 *         // Your code here.
	 *         break;
	 * }
	 * @returns {Network.Socket#State} The socket's current state.
	 * @since 1.6.5
	 */
	getState: function() {
		return this._state;
	},

	/**
	 * Retrieve the number of bytes that can be written to the socket's send buffer before it 
	 * reaches its maximum size.
	 * @returns {Number} The send buffer's writable size, in bytes.
	 * @since 1.6.5
	 */
	getSizeWritable: function() {
		return this._curSndBufSize;
	},

	/**
	 * Retrieve the number of bytes that are available to be read from the socket.
	 * @returns {Number} The size of the socket's available data, in bytes.
	 * @since 1.6.5
	 */
	getSizeReadable: function() {
		return this._rcvBuf.length;
	},

	/**
	 * Retrieve the address of the remote server for a TCP socket. The value `null` will be returned
	 * if the connection has not been established.
	 * @returns {Object} The remote server's address, or null if the socket is not yet active. The
	 *		"host" property contains the IP address, and the "port" property contains the port
	 *		number.
	 * @since 1.6.5
	 */
	getPeerAddr: function() {
		return this._peerAddr;
	},

	/**
	 * Retrieve the local address for the socket. For TCP sockets, the value `null` will be returned
	 * if the connection has not been established. For UDP sockets, the value `null` will be
	 * returned if no data has been received.
	 * @returns {Object} The local address, or null if the socket is not yet active. The "host"
	 *		property contains the IP address, and the "port" property contains the port number.
	 * @since 1.6.5
	 */
	getLocalAddr: function() {
		return this._localAddr;
	},

// Receivers

	_onSetOptionCbRecv: function( cmd )
	{
		var obj = {};
		if(this._onSetOptionCbRecvGen(cmd, obj)) {
			if(obj['cbId'] >= 0) {
				var cb = this._restoreCb(obj['cbId']);
				var err = obj['errCode']? { code:obj['errCode'], description:obj['errStr'] }:null;
				cb(err, this);
			}
		}
	},

	_onGetOptionCbRecv: function( cmd )
	{
		var obj = {};
		if(this._onGetOptionCbRecvGen(cmd, obj)) {
			if(obj['cbId'] >= 0) {
				var cb = this._restoreCb(obj['cbId']);
				var err = obj['errCode']? { code:obj['errCode'], description:obj['errStr'] }:null;
				cb(err, this, obj['numVal']);
			}
		}
	},

	_onBindCbRecv: function( cmd )
	{
		var obj = {};
		if(this._onBindCbRecvGen(cmd, obj)) {
			var notifyUdpWritable = false;
			if(!obj['errCode']) {
				this._localAddr = { host: obj['lhost'], port: obj['lport'] };
				if(!this._isStream && this._state == this.State.CLOSED) {
					this._state = this.State.READY;
					notifyUdpWritable = true;
				}
			}
			if(obj['cbId'] >= 0) {
				var cb = this._restoreCb(obj['cbId']);
				var err = obj['errCode']? { code:obj['errCode'], description:obj['errStr'] }:null;
				cb(err, this, obj['lport']);
			}
			if(notifyUdpWritable && this._state == this.State.READY /* checking if still in ready state */) {
				if(this._onWritable && this._curSndBufSize == this._maxSndBufSize ) {
						this._onWritable(this);
				}
			}
		}
	},

	/*
	 * @status Not tested yet
	 */
	_onConnectRecv: function( cmd )
	{
		if(this._state == this.State.CONNECTING) {
			this._state = this.State.READY;
			var obj = {};
			if(this._onConnectRecvGen(cmd, obj)) {
				// {String} obj['rhost'] Dotted-decimal IP address of peer's.
				// {Number} obj['rport'] Peer's port number.
				this._peerAddr = { host: obj['rhost'], port: obj['rport'] };
				if(this._onWritable && this._curSndBufSize == this._maxSndBufSize) {
					this._onWritable(this);
				}
			}
		}
	},

	/*
	 * @status Not tested yet
	 */
	_onAcceptRecv: function( cmd )
	{
		var obj = {};
		if(this._onAcceptRecvGen(cmd, obj)) {
			// {String} obj['rhost'] Dotted-decimal IP address of peer's.
			// {Number} obj['rport'] Peer's port number.
			// {Number} obj['parentId'] Parent socket ID.
			// {Number} obj['childId'] Child socket ID.
			this._pendingChildren.push({
				host: obj['rhost'],
				port: obj['rport'],
				parentId: obj['parentId'],
				childId: obj['childId']
			});
			if(this._onReadable) {
				this._onReadable(this);
			}
		}
	},

	/*
	 * @status Not tested yet
	 */
	_onReceiveRecv: function( cmd )
	{
		var obj = {};
		if(this._onReceiveRecvGen(cmd, obj)) {
			// {String} obj['buf'] Received data.
			// {String} obj['rhost'] Dotted-decimal IP address of peer's.
			// {Number} obj['rport'] Peer's port number.
			var rlen = obj['buf'].length;
			if(rlen > 0) {
				this._rcvBuf += obj['buf'];
			}
			if(this._isStream) {
				if(!rlen) {
					this._EOS = true;
				}
			} else {
				this._rcvBufInfo.push({ size:rlen, host:obj['rhost'], port:obj['rport'] });
			}
			if(this._onReadable) {
				this._onReadable(this);
			}
		}
	},

	/*
	 * @status Not tested yet
	 */
	_onErrorRecv: function( cmd )
	{
		var obj = {};
		if(this._onErrorRecvGen(cmd, obj)) {
			var err = obj['errCode']? { code:obj['errCode'], description:obj['errStr'] }:null;
			if(this._onError && err) {
				this._onError(err, this);
			}
		}
	},

	_onUpdateRecv: function( cmd )
	{
		var obj = {};
		if(this._onUpdateRecvGen(cmd, obj)) {
			// {Number} obj[ "updateId" ]
			// {Number} obj[ "val" ]
			// {String} obj[ "optional" ]
			switch(obj['updateId']) {
				case this.UpdateId.U_SizeSent:
					this._curSndBufSize += obj['val'];
					if(this._onWritable && this._curSndBufSize == this._maxSndBufSize) {
						if(this._state == this.State.READY) {
							this._onWritable(this);
						}
					}
					break;
				default:
					NgLogE('Unknown OnUpdate ID ' + obj['updateId']);
					break;
			}
		}
	},
	

	_onMembershipCbRecv: function( cmd )
	{
		var obj = {};
		if(this._onMembershipCbRecvGen(cmd, obj)) {
			if(obj['cbId'] >= 0) {
				var cb = this._restoreCb(obj['cbId']);
				var err = obj['errCode']? { code:obj['errCode'], description:obj['errStr'] }:null;
				cb(err, this);
			}
		}
	},


	/**
	 * Enumeration for transport protocols that a socket can use.
	 * @name Protocol
	 * @fieldOf Network.Socket#
	 */
	/**
	 * User Datagram Protocol (UDP) over Internet Protocol version 4 (IPv4).
	 * @name Protocol.UDP4
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * Transmission Control Protocol (TCP) over Internet Protocol version 4 (IPv4).
	 * @name Protocol.TCP4
	 * @fieldOf Network.Socket#
	 * @constant
	 */

	/**
	 * Enumeration for types of security that a socket can use.
	 * @name Security
	 * @fieldOf Network.Socket#
	 */
	/**
	 * No security.
	 * @name Security.SecNone
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * Secure Sockets Layer (SSL) security, using SSLv3 or TLSv1. Available only for TCP sockets.
	 * @name Security.SecSSL
	 * @fieldOf Network.Socket#
	 * @constant
	 */

	/**
	 * Enumeration for socket states.
	 * @name State
	 * @fieldOf Network.Socket#
	 */
	/**
	 * The socket is closed.
	 * @name State.CLOSED
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The socket is connecting to a remote host.
	 * @name State.CONNECTING
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The socket is listening for connections. Used only for TCP sockets.
	 * @name State.LISTENING
	 * @fieldOf Network.Socket#
	 * @private
	 * @constant
	 */
	/**
	 * The socket is connected and is ready for reading and writing.
	 * @name State.READY
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The socket is closing. Used only for TCP sockets.
	 * @name State.CLOSING
	 * @fieldOf Network.Socket#
	 * @constant
	 */

	/**
	 * Enumeration for the names of configuration options for the socket.
	 *
	 * **Note**: Do not change the enumerated values themselves. To change an option's value, call
	 * `{@link Network.Socket#setOption}`, and use the `op` parameter to specify which option to
	 * change. To retrieve an option's value, call `{@link Network.Socket#getOption}`, and use the
	 * `op` parameter to specify which option to retrieve.
	 * @name Option
	 * @fieldOf Network.Socket#
	 */
	/**
	 * The size of the socket's send buffer. The default size is 65,536 bytes.
	 * @name Option.OpSendBufSize
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The size of the socket's receive buffer. The default size is 65,536 bytes.
	 * @name Option.OpRecvBufSize
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * Indicates whether to send outgoing messages immediately rather than combining small messages
	 * into a single packet. Accepts the values `0`, to disable the option, or `1`, to enable the
	 * option. This option is enabled by default.
	 * @name Option.OpNoDelay
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The timeout value, in milliseconds, for establishing a connection. The default timeout is
	 * 30,000 milliseconds (30 seconds).
	 * @name Option.OpConnectionTimeout
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The timeout value, in milliseconds, for shutting down a connection. Used only for TCP
	 * sockets. The default timeout is 10,000 milliseconds (10 seconds).
	 * @name Option.OpShutdownTimeout
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * Indicates whether other sockets will be allowed to bind to the same port as this socket,
	 * provided that this socket is not active. Accepts the values `0`, to disable the option, or
	 * `1`, to enable the option. This option is disabled by default.
	 * @name Option.OpReuseAddr
	 * @fieldOf Network.Socket#
	 * @constant
	 */

	/**
	 * Enumeration for types of socket errors.
	 * @name Error
	 * @fieldOf Network.Socket#
	 */
	/**
	 * An unknown error occurred.
	 * @name Error.Unknown
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The requested operation is invalid, or an invalid parameter was specified.
	 * @name Error.Invalid
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The requested operation is not supported.
	 * @name Error.NotSupported
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The socket is not currently available for the requested operation.
	 * @name Error.TryAgain
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The requested address for the socket is already in use.
	 * @name Error.AddrInUse
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The device does not have enough memory available for the requested operation.
	 * @name Error.NoMemory
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The socket is not connected.
	 * @name Error.NotConnected
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The connection timed out.
	 * @name Error.ConnectionTimeout
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The attempt to shut down the socket timed out. Used only for TCP sockets.
	 * @name Error.ShutdownTimeout
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The SSL handshake failed.
	 * @name Error.SSLError
	 * @fieldOf Network.Socket#
	 * @constant
	 */
	/**
	 * The remote host is unreachable.
	 * @name Error.Unreachable
	 * @fieldOf Network.Socket#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Protocol:
	{ 
		UDP4: 0,
		TCP4: 1
	},
	
	Security:
	{ 
		SecNone: 0,
		SecSSL: 1
	},
	
	State:
	{ 
		CLOSED: 0,
		CONNECTING: 1,
		LISTENING: 2,
		READY: 3,
		CLOSING: 4
	},
	
	Option:
	{ 
		OpSendBufSize: 0,
		OpRecvBufSize: 1,
		OpNoDelay: 2,
		OpConnectionTimeout: 3,
		OpShutdownTimeout: 4,
		OpReuseAddr: 5
	},
	
	Error:
	{ 
		Unknown: -1,
		Invalid: -2,
		NotSupported: -3,
		TryAgain: -4,
		AddrInUse: -5,
		NoMemory: -6,
		NotConnected: -7,
		ConnectionTimeout: -8,
		ShutdownTimeout: -9,
		SSLError: -10,
		Unreachable: -11,
		ConnectionRefused: -12
	},
	
	/** @private Enumeration for multicast flags. */
	MulticastFlag:
	{ 
		McLoop: 0x00000001
	},
	
	/** @private Enumeration for update ID. */
	UpdateId:
	{ 
		U_NOP: 0,
		U_SizeSent: 1,
		U_SizeRcvd: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 360,
	// Method create = -1
	// Method setOption = 2
	// Method getOption = 3
	// Method bind = 4
	// Method connect = 5
	// Method listen = 6
	// Method send = 7
	// Method shutdown = 8
	// Method close = 9
	// Method addMembership = 10
	// Method dropMembership = 11
	// Method update = 12
	// Method onSetOptionCb = 13
	// Method onGetOptionCb = 14
	// Method onBindCb = 15
	// Method onConnect = 16
	// Method onAccept = 17
	// Method onReceive = 18
	// Method onError = 19
	// Method onUpdate = 20
	// Method onMembershipCb = 21
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 13:
					instance._onSetOptionCbRecv( cmd );
					break;
				case 14:
					instance._onGetOptionCbRecv( cmd );
					break;
				case 15:
					instance._onBindCbRecv( cmd );
					break;
				case 16:
					instance._onConnectRecv( cmd );
					break;
				case 17:
					instance._onAcceptRecv( cmd );
					break;
				case 18:
					instance._onReceiveRecv( cmd );
					break;
				case 19:
					instance._onErrorRecv( cmd );
					break;
				case 20:
					instance._onUpdateRecv( cmd );
					break;
				case 21:
					instance._onMembershipCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Socket._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Socket._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[360] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onSetOptionCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onSetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "opId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "opId" ] === undefined )
		{
			NgLogE("Could not parse opId in Socket.onSetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in Socket.onSetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Socket.onSetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Socket.onSetOptionCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onGetOptionCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 6 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "opId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "opId" ] === undefined )
		{
			NgLogE("Could not parse opId in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "numVal" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "numVal" ] === undefined )
		{
			NgLogE("Could not parse numVal in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "strVal" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "strVal" ] === undefined )
		{
			NgLogE("Could not parse strVal in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 5 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Socket.onGetOptionCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onBindCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 5 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		obj[ "lhost" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "lhost" ] === undefined )
		{
			NgLogE("Could not parse lhost in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		obj[ "lport" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "lport" ] === undefined )
		{
			NgLogE("Could not parse lport in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Socket.onBindCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onConnectRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onConnect from command: " + cmd );
			return false;
		}
		
		obj[ "rhost" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "rhost" ] === undefined )
		{
			NgLogE("Could not parse rhost in Socket.onConnect from command: " + cmd );
			return false;
		}
		
		obj[ "rport" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "rport" ] === undefined )
		{
			NgLogE("Could not parse rport in Socket.onConnect from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onAcceptRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onAccept from command: " + cmd );
			return false;
		}
		
		obj[ "rhost" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "rhost" ] === undefined )
		{
			NgLogE("Could not parse rhost in Socket.onAccept from command: " + cmd );
			return false;
		}
		
		obj[ "rport" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "rport" ] === undefined )
		{
			NgLogE("Could not parse rport in Socket.onAccept from command: " + cmd );
			return false;
		}
		
		obj[ "parentId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "parentId" ] === undefined )
		{
			NgLogE("Could not parse parentId in Socket.onAccept from command: " + cmd );
			return false;
		}
		
		obj[ "childId" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "childId" ] === undefined )
		{
			NgLogE("Could not parse childId in Socket.onAccept from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onReceiveRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onReceive from command: " + cmd );
			return false;
		}
		
		obj[ "buf" ] = Core.Proc.parseBinary( cmd[ 0 ] );
		if( obj[ "buf" ] === undefined )
		{
			NgLogE("Could not parse buf in Socket.onReceive from command: " + cmd );
			return false;
		}
		
		obj[ "rhost" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "rhost" ] === undefined )
		{
			NgLogE("Could not parse rhost in Socket.onReceive from command: " + cmd );
			return false;
		}
		
		obj[ "rport" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "rport" ] === undefined )
		{
			NgLogE("Could not parse rport in Socket.onReceive from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onErrorRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onError from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Socket.onError from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Socket.onError from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "updateId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "updateId" ] === undefined )
		{
			NgLogE("Could not parse updateId in Socket.onUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "val" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "val" ] === undefined )
		{
			NgLogE("Could not parse val in Socket.onUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "optional" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "optional" ] === undefined )
		{
			NgLogE("Could not parse optional in Socket.onUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onMembershipCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Socket.onMembershipCb from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in Socket.onMembershipCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Socket.onMembershipCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Socket.onMembershipCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId, proto, sec, parentId, childId )
	{
		Core.Proc.appendToCommandString( 0x168ffff, [ +__objectRegistryId, +proto, +sec, +parentId, +childId ] );
	},
	
	/** @private */
	_setOptionSendGen: function( opId, numVal, strVal, cbId )
	{
		Core.Proc.appendToCommandString( 0x1680002, this, [ +opId, +numVal, Core.Proc.encodeString( strVal ), +cbId ] );
	},
	
	/** @private */
	_getOptionSendGen: function( opId, cbId )
	{
		Core.Proc.appendToCommandString( 0x1680003, this, [ +opId, +cbId ] );
	},
	
	/** @private */
	_bindSendGen: function( lport, flags, cbId )
	{
		Core.Proc.appendToCommandString( 0x1680004, this, [ +lport, +flags, +cbId ] );
	},
	
	/** @private */
	_connectSendGen: function( rhost, rport, cn )
	{
		Core.Proc.appendToCommandString( 0x1680005, this, [ Core.Proc.encodeString( rhost ), +rport, Core.Proc.encodeString( cn ) ] );
	},
	
	/** @private */
	_listenSendGen: function( backlog )
	{
		Core.Proc.appendToCommandString( 0x1680006, this, [ +backlog ] );
	},
	
	/** @private */
	_sendSendGen: function( buf, rhost, rport )
	{
		Core.Proc.appendToCommandString( 0x1680007, this, [ Core.Proc.encodeBinary( buf ), Core.Proc.encodeString( rhost ), +rport ] );
	},
	
	/** @private */
	_shutdownSendGen: function( how )
	{
		Core.Proc.appendToCommandString( 0x1680008, this, [ +how ] );
	},
	
	/** @private */
	_closeSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1680009, this );
	},
	
	/** @private */
	_addMembershipSendGen: function( mcgrp, flags, ttl, cbId )
	{
		Core.Proc.appendToCommandString( 0x168000a, this, [ Core.Proc.encodeString( mcgrp ), +flags, +ttl, +cbId ] );
	},
	
	/** @private */
	_dropMembershipSendGen: function( mcgrp, cbId )
	{
		Core.Proc.appendToCommandString( 0x168000b, this, [ Core.Proc.encodeString( mcgrp ), +cbId ] );
	},
	
	/** @private */
	_updateSendGen: function( updateId, val, optional )
	{
		Core.Proc.appendToCommandString( 0x168000c, this, [ +updateId, +val, Core.Proc.encodeString( optional ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId, proto, sec, parentId, childId ) {}
	
	// setOption: function( opId, numVal, strVal, cbId ) {}
	
	// getOption: function( opId, cbId ) {}
	
	// bind: function( lport, flags, cbId ) {}
	
	// connect: function( rhost, rport, cn ) {}
	
	// listen: function( backlog ) {}
	
	// send: function( buf, rhost, rport ) {}
	
	// shutdown: function( how ) {}
	
	// close: function(  ) {}
	
	// addMembership: function( mcgrp, flags, ttl, cbId ) {}
	
	// dropMembership: function( mcgrp, cbId ) {}
	
	// update: function( updateId, val, optional ) {}
	
	// _onSetOptionCbRecv: function( cmd ) {}
	// _onGetOptionCbRecv: function( cmd ) {}
	// _onBindCbRecv: function( cmd ) {}
	// _onConnectRecv: function( cmd ) {}
	// _onAcceptRecv: function( cmd ) {}
	// _onReceiveRecv: function( cmd ) {}
	// _onErrorRecv: function( cmd ) {}
	// _onUpdateRecv: function( cmd ) {}
	// _onMembershipCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});

TcpServerSocket = exports.Socket.subclass(
{
	classname: 'TcpServerSocket',
	initialize: function($super, protocol, security, parentId, childId)
	{
		this._parentId = parentId;
		this._childId = parentId;
		$super(protocol, security);
	}
});

// vim: ts=2:sw=2:noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/DNS'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/DNS'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/DNS'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/DNS.js';

////////////////////////////////////////////////////////////////////////////////
// Class DNS
// DNS resolver
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.DNS = Class.singleton(
/** @lends Network.DNS.prototype */
{
	classname: 'DNS',
	
	/**
	 * @class The `Network.DNS` class enables applications to obtain the IP addresses that are 
	 * associated with a domain name.
	 * @singleton
	 * @constructs
	 * @augments Core.Class
	 * @since 1.6.5
	 */
	initialize: function()
	{
		this._nextCbId = 0;
		this._cb = {};
		this._storeCb = function(cb) {
			var cbId = -1;
			if(cb) {
				cbId = this._nextCbId++;
				this._cb[cbId] = cb?cb:function(){};
			}
			return cbId;
		};
		this._restoreCb = function(cbId) {
			var cb = this._cb[cbId];
			delete this._cb[cbId];
			return cb;
		};

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	/**
	 * Retrieve a list of IP addresses that are associated with a domain name.
	 * @example
	 * // Obtain the IP addresses that are associated with the domain name mobage.com.
	 * var ip = [];
	 * Network.DNS.resolve("mobage.com", function(err, addrs) {
	 *     if (err) {
	 *         console.log("An error occurred while resolving the domain name: " +
	 *           err.code + ": " + err.description);
	 *     } else {
	 *         ip = addrs;
	 *     }
	 * });
	 * @param {String} host The domain name to resolve.
	 * @cb {Function} cb The function to call after resolving the domain name.
	 * @cb-param {Object} err Information about the error, if any.
	 * @cb-param {Network.DNS#Error} [err.code] A code identifying the error.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {String[]} addrs The IP addresses associated with the domain name.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.6.5
	 */
	resolve: function(host, cb)
	{
		var cbId = this._storeCb(cb);
		this._resolveSendGen(host, 0,  cbId);
	},

	_onResolveCbRecv: function( cmd )
	{
		var obj = {};
		if(this._onResolveCbRecvGen(cmd, obj)) {
			if(obj['cbId'] >= 0) {
				var cb = this._restoreCb(obj['cbId']);
				if(obj['errCode']) {
					cb({ code:obj['errCode'], description:obj['errStr'] }, []);
				} else {
					cb(null, obj['addrs']?JSON.parse(obj['addrs']):[]);
				}
			}
		}
	},
	
	/**
	 * Enumeration for types of DNS errors.
	 * @name Error
	 * @fieldOf Network.DNS#
	 */
	
	/**
	 * An unknown error occurred.
	 * @name Error.Unknown
	 * @fieldOf Network.DNS#
	 * @constant
	 */
	
	/**
	 * The domain name is invalid.
	 * @name Error.Invalid
	 * @fieldOf Network.DNS#
	 * @constant
	 */
	
	/**
	 * The requested operation is not supported.
	 * @name Error.NotSupported
	 * @fieldOf Network.DNS#
	 * @constant
	 */
	
	/**
	 * The domain name could not be found.
	 * @name Error.NotFound
	 * @fieldOf Network.DNS#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Error:
	{ 
		Unknown: -100,
		Invalid: -101,
		NotSupported: -102,
		NotFound: -103
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 361,
	// Method create = -1
	// Method resolve = 2
	// Method onResolveCb = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._onResolveCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in DNS._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in DNS._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[361] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onResolveCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in DNS.onResolveCb from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in DNS.onResolveCb from command: " + cmd );
			return false;
		}
		
		obj[ "addrs" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "addrs" ] === undefined )
		{
			NgLogE("Could not parse addrs in DNS.onResolveCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in DNS.onResolveCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in DNS.onResolveCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x169ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_resolveSendGen: function( host, flags, cbId )
	{
		Core.Proc.appendToCommandString( 0x1690002, this, [ Core.Proc.encodeString( host ), +flags, +cbId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// resolve: function( host, flags, cbId ) {}
	
	// _onResolveCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Color'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Color'] || {}; $MODULE_REGISTRY['NGCore/Shared/Color'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Color.js';

var Class = require('NGCore/Shared/Class').Class;

exports.Color = Class.subclass(
/** @lends Core.Color.prototype */
{
	classname: 'Color',
	
	/**
	 * @class The <code>Color</code> class constructs objects that control the RGB components of a device. 
	 * RGB is a color model used for rendering objects on-screen and is derived 
	 * from the three primary colors used in the model: red, green, and blue.
	 * Each value ranges from <code>(0-1)</code> and determines the color saturation level.	 
	 * @constructs The default constructor.
	 * @example
	 * // Create a new color with all components set to one (1 = white).
	 * var style1 = new Core.Color();
	 * @example
	 * // Copy an existing color.
	 * var style2 = new Core.Color(style1);
	 * @example
	 * // Specify all three components.
	 * var style3 = new Core.Color(1.0, 1.0, 1.0);
	 * @example
	 * // Specify the color as solid blue.
	 * var style4 = new Core.Color([0, 0, 1.0]);
	 * @example
	 * // Specify the color as solid red.
	 * var style5 = new Core.Color([1.0, 0, 0]);
	 * @example
	 * // Specify the color as a dark shade of red.
	 * var style6 = new Core.Color([.5, 0, 0]);
	 * @augments Core.Class
	 * @param {Number} [red=1] The red component.
	 * @param {Number} [green=1] The green component.
	 * @param {Number} [blue=1] The blue component.
	 * @throws {Wrong number of arguments for a Color} Number of parameters passed by this call is invalid.
	 * @since 1.0
	 */
	initialize: function(red, green, blue)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._red = 1.0;
				this._green = 1.0;
				this._blue = 1.0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._red = 1.0;
					this._green = 1.0;
					this._blue = 1.0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (color)
					this._red = rhs.getRed();
					this._green = rhs.getGreen();
					this._blue = rhs.getBlue();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._red = 1.0;
							this._green = 1.0;
							this._blue = 1.0;
							break;
						case 1:
							// ([color])
							rhs = rhs[0];
							this._red = rhs.getRed();
							this._green = rhs.getGreen();
							this._blue = rhs.getBlue();
							break;
						case 3:
							// ([red, green, blue])
							this._red = rhs[0];
							this._green = rhs[1];
							this._blue = rhs[2];
							break;
						default:
							throw new Error('Wrong number of arguments for a Color');
					}
				}
				break;
			case 3:
				// (red, gree, blue)
				this._red = arguments[0];
				this._green = arguments[1];
				this._blue = arguments[2];
				break;
			default:
				throw new Error('Wrong number of arguments for a Color');
		}
		return this;
	},
	
	/**
	 * Set the saturation level for all three color components.
	 * @example Core.Color.setAll(0.5, 0.5, 1.0);
	 * @param {Number} [red=1] The red component.
	 * @param {Number} [green=1] The green component.
	 * @param {Number} [blue=1] The blue component.
	 * @returns {this}
	 * @see Core.Color for a full list of supported calling styles.
	 * @since 1.0
	 */
	setAll: function(red, green, blue)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Retrieve the saturation level for the red component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the red component.
	 * @since 1.0
	 */
	getRed: function()
	{
		return this._red;
	},
	
	/**
	 * Retrieve the saturation level for the green component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the green component.
	 * @since 1.0
	 */
	getGreen: function()
	{
		return this._green;
	},
	
	/**
	 * Retrieve the saturation level for the blue component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the blue component.
	 * @since 1.0
	 */
	getBlue: function()
	{
		return this._blue;
	},
	
	/**
	 * Set the saturation level for the red component of this <code>Color</code>.
	 * @example Core.Color.setRed(0.7);
	 * @param {Number} red The new saturation level for the red component.
	 * @returns {this}
	 * @see Core.Color#getRed
	 * @since 1.0
	 */
	setRed: function(red)
	{
		this._red = red;
		return this;
	},
	
	/**
	 * Set the saturation level for the green component of this <code>Color</code>.
	 * @example Core.Color.setGreen(0.3);
	 * @param {Number} green The new saturation level for the green component.
	 * @returns {this}
	 * @see Core.Color#getGreen
	 * @since 1.0
	 */
	setGreen: function(green)
	{
		this._green = green;
		return this;
	},
	
	/**
	 * Set the saturation level for the blue component of this <code>Color</code>.
	 * @example Core.Color.setBlue(1.0);
	 * @param {Number} blue The new saturation level for the blue component.
	 * @returns {this}
	 * @see Core.Color#getBlue
	 * @since 1.0
	 */
	setBlue: function(blue)
	{
		this._blue = blue;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Color'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Color'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Color'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Color.js';

exports.Color = require('NGCore/Shared/Color').Color;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Vector'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Vector'] || {}; $MODULE_REGISTRY['NGCore/Shared/Vector'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Vector.js';

var Class = require('NGCore/Shared/Class').Class;

exports.Vector = Class.subclass(
/** @lends Core.Vector.prototype */
{
	classname: 'Vector',
	
	/**
	 * @class The <code>Vector</code> class constructs objects that define vector point values for the <i>x</i> and <i>y</i> components. 
	 * @constructs The default constructor.
	 * @example
	 * // All components are set to zero.
	 * var style1 = new Core.Vector();
	 * @example
	 * // Copy an existing vector.
	 * var style2 = new Core.Vector(style1);
	 * @example
	 * // Specify a value for both components.
	 * var style3 = new Core.Vector(1.0, 1.0);
	 * @example
	 * // Specify a value for both components.
	 * var style4 = new Core.Vector([1.0, 1.0]);
	 * @augments Core.Class
	 * @param {Number} [x=0] The <i>x</i> component.
	 * @param {Number} [y=0] The <i>y</i> component.
	 * @throws {Error} The number of parameters is invalid.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	initialize: function()
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._x = 0;
				this._y = 0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._x = 0;
					this._y = 0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (vector)
					this._x = rhs.getX();
					this._y = rhs.getY();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._x = 0;
							this._y = 0;
							break;
						case 1:
							// ([vector])
							rhs = rhs[0];
							this._x = rhs.getX();
							this._y = rhs.getY();
							break;
						case 2:
							// ([x, y])
							this._x = rhs[0];
							this._y = rhs[1];
							break;
						default:
							throw new Error('Wrong number of arguments for a Vector');
					}
				}
				break;
			case 2:
				// (x, y)
				this._x = arguments[0];
				this._y = arguments[1];
				break;
			default:
				throw new Error('Wrong number of arguments for a Vector');
		}
	},
	
	/**
	 * Set the value of both components for this <code>Vector</code>. 
	 * @param {Number} [x=0] The new <i>x</i> coordinate.
	 * @param {Number} [y=0] The new <i>y</i> coordinate.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAll: function()
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate this <code>Vector</code>.
	 * @returns {Core.Vector} A new vector with identical coordinates to the duplicated vector.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>x</i> component for this <code>Vector</code>.
	 * @returns {Number} The current <i>x</i> coordinate.
	 * @see Core.Vector#setX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getX: function()
	{
		return this._x;
	},
	
	/**
	 * Set the value of the <i>x</i> component for this <code>Vector</code>.
	 * @param {Number} <i>x</i> The new <i>x</i> coordinate.
	 * @returns {this}
	 * @see Core.Vector#getX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setX: function(x)
	{
		this._x = x;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>y</i> component for this <code>Vector</code>.
	 * @returns {Number} The current <i>y</i> coordinate.
	 * @see Core.Vector#setY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getY: function()
	{
		return this._y;
	},
	
	/**
	 * Set the value of the <i>y</i> component for this <code>Vector</code>.
	 * @param {Number} <i>y</i> The new <i>y</i> coordinate.
	 * @returns {this}
	 * @see Core.Vector#getY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setY: function(y)
	{
		this._y = y;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Vector'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Vector'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Vector'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Vector.js';

exports.Vector = require('NGCore/Shared/Vector').Vector;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Point'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Point'] || {}; $MODULE_REGISTRY['NGCore/Shared/Point'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Point.js';

var Class = require('NGCore/Shared/Class').Class;

var setAll = function(x, y)
{
	switch(arguments.length)
	{
		case 0:
			// ()
			this._x = 0;
			this._y = 0;
			break;
		case 1:
			var rhs = arguments[0];
			if(rhs === undefined)
			{
				// (undefined)
				this._x = 0;
				this._y = 0;
			}
			else if(!rhs.hasOwnProperty('length'))
			{
				// (point)
				this._x = rhs.getX();
				this._y = rhs.getY();
			}
			else
			{
				switch(rhs.length)
				{
					case 0:
						// ([])
						this._x = 0;
						this._y = 0;
						break;
					case 1:
						// ([point])
						rhs = rhs[0];
						this._x = rhs.getX();
						this._y = rhs.getY();
						break;
					case 2:
						// ([x, y])
						this._x = rhs[0];
						this._y = rhs[1];
						break;
					default:
						throw new Error('Wrong number of arguments for a Point');
				}
			}
			break;
		case 2:
			// (x, y)
			this._x = arguments[0];
			this._y = arguments[1];
			break;
		default:
			throw new Error('Wrong number of arguments for a Point');
	}
	return this;
};

exports.Point = Class.subclass(
/** @lends Core.Point.prototype */
{
	classname: 'Point',
	
	/**
	 * @class The <code>Point</code> class defines a 2D point coordinate (<i>x</i> and <i>y</i>). 
	 * @status iOS, Android, Flash, Test
	 * @constructs The default constructor.
	 * @example
	 * // All components are set to zero.
	 * var style1 = new Core.Point();
	 * @example
	 * // Copy an existing point.
	 * var style2 = new Core.Point(style1);
	 * @example
	 * // Specify a value for both components.
	 * var style3 = new Core.Point(1.0, 1.0);
	 * @example
	 * // Specify a value for both components.
	 * var style4 = new Core.Point([1.0, 1.0]);
	 * @name Core.Point
	 * @augments Core.Class
	 * @param {Number} [x=0] The <i>x</i> coordinate.
	 * @param {Number} [y=0] The <i>y</i> coordinate.
	 * @throws {Wrong number of arguments for a Point} Number of parameters passed by this call is invalid.
	 * @since 1.0
	 */
	initialize: setAll,
	
	/**
	 * Set the value of both the <i>x</i> and <i>y</i> components. 
	 * @param {Number} [<i>x</i>=0] The new <i>x</i> coordinate.
	 * @param {Number} [<i>y</i>=0] The new <i>y</i> coordinate.
	 * @returns {this}
	 * @see Core.Point for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAll: setAll,
	
	/**
	 * Duplicate this <code>Point</code>.
	 * @returns {Core.Point} A new point with identical <i>x</i> and <i>y</i> coordinates to the cloned point.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>x</i> component of this <code>Point</code>.
	 * @returns {Number} The current <i>x</i> coordinate.
	 * @see Core.Point#setX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getX: function()
	{
		return this._x;
	},
	
	/**
	 * Set the value of the <i>x</i> component for this <code>Point</code>.
	 * @param {Number} <i>x</i> The new <i>x</i> coordinate.
	 * @returns {this}
	 * @see Core.Point#getX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setX: function(x)
	{
		this._x = x;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>y</i> component of this <code>Point</code>.
	 * @returns {Number} The current <i>y</i> coordinate.
	 * @see Core.Point#setY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getY: function()
	{
		return this._y;
	},
	
	/**
	 * Set the value of the <i>y</i> component for this <code>Point</code>.
	 * @param {Number} <i>y</i> The new <i>y</i> coordinate.
	 * @returns {this}
	 * @see Core.Point#getY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setY: function(y)
	{
		this._y = y;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Point'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Point'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Point'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Point.js';

exports.Point = require('NGCore/Shared/Point').Point;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Size'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Size'] || {}; $MODULE_REGISTRY['NGCore/Shared/Size'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Size.js';

var Class = require('NGCore/Shared/Class').Class;

exports.Size = Class.subclass(
/** @lends Core.Size.prototype */
{
	classname: 'Size',
	
	/**
	 * @class The <code>Size</code> class constructs objects that define size values for the <i>height</i> and <i>width</i> components. 
	 * @status iOS, Android, Flash
	 * Supported values range between <code>(0-1)</code>.
	 * @constructs The default constructor.
	 * @example
	 * // Set both component values to 0.
	 * var style1 = new Core.Size();
	 * @example
	 * // Copy an existing size.
	 * var style2 = new Core.Size(style1);
	 * @example
	 * // Specify a value for both components.
	 * var style3 = new Core.Size(1.0, 1.0);
	 * @example
	 * // Specify a value for both components.
	 * var style4 = new Core.Size([1.0, 1.0]);
	 * @augments Core.Class
	 * @param {Number} [width=0] The <i>width</i> component.
	 * @param {Number} [height=0] The <i>height</i> component.
	 * @since 1.0
	 */
	initialize: function(width, height)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._width = 0;
				this._height = 0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._width = 0;
					this._height = 0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (size)
					this._width = rhs.getWidth();
					this._height = rhs.getHeight();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._width = 0;
							this._height = 0;
							break;
						case 1:
							// ([size])
							rhs = rhs[0];
							this._width = rhs.getWidth();
							this._height = rhs.getHeight();
							break;
						case 2:
							// ([x, y])
							this._width = rhs[0];
							this._height = rhs[1];
							break;
						default:
							throw new Error('Wrong number of arguments for a Size');
					}
				}
				break;
			case 2:
				// (x, y)
				this._width = arguments[0];
				this._height = arguments[1];
				break;
			default:
				throw new Error('Wrong number of arguments for a Size');
		}
	},
	
	/**
	 * Set the value of all components for this <code>Size</code>. 
	 * @param {Number} [width=0] The new <i>width</i>.
	 * @param {Number} [height=0] The new <i>height</i>.
	 * @throws {Wrong number of arguments for a Size} Number of parameters passed by this call is invalid.
	 * @returns {this}
	 * @see Core.Size for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAll: function(width, height)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate this <code>Size</code>.
	 * @returns {Core.Size} A new size with identical <i>height</i> and <i>width</i> components.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>width</i> component for this <code>Size</code>.
	 * @returns {Number} The current <i>width</i>.
	 * @see Core.Size#setWidth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getWidth: function()
	{
		return this._width;
	},
	
	/**
	 * Set the value of the <i>width</i> component for this <code>Size</code>.
	 * @param {Number} width The new <i>width</i>.
	 * @returns {this}
	 * @see Core.Size#getWidth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setWidth: function(width)
	{
		this._width = width;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>height</i> component for this <code>Size</code>.
	 * @returns {Number} The current <i>height</i>.
	 * @see Core.Size#setHeight
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHeight: function()
	{
		return this._height;
	},
	
	/**
	 * Set the value of the <i>height</i> component for this <code>Size</code>.
	 * @param {Number} height The new <i>height</i>.
	 * @returns {this}
	 * @see Core.Size#getHeight
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setHeight: function(height)
	{
		this._height = height;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Size'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Size'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Size'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Size.js';

exports.Size = require('NGCore/Shared/Size').Size;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Rect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Rect'] || {}; $MODULE_REGISTRY['NGCore/Shared/Rect'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Rect.js';

var Class = require('NGCore/Shared/Class').Class;
var Point = require('NGCore/Shared/Point').Point;
var Size = require('NGCore/Shared/Size').Size;

exports.Rect = Class.subclass(
/** @lends Core.Rect.prototype */
{
	classname: 'Rect',
	
	/**
	 * @class The <code>Rect</code> class constructs a rectangle object that is derived from two values: a point of origin  
	 * and a size.	 
	 * @status iOS, Android, Flash
	 * @constructs The default constructor.
	 * @example
	 * // All components set to zero.
	 * var style1 = new Core.Rect();
	 * @example
	 * // Copy an existing rect.
	 * var style2 = new Core.Rect(style1);
	 * @example
	 * // Specify a point and size.
	 * var style3 = new Core.Rect(new Core.Point(), new Core.Size());
	 * @example
	 * // Specify four components.
	 * var style4 = new Core.Rect(0, 0, 100, 100);
	 * @augments Core.Class
	 * @param {Core.Point} [origin=0] The rectangle point of origin.
	 * @param {Core.Size} [size=0] The rectangle size.
	 * @throws {Wrong number of arguments for a Rect} Number of parameters passed by this call is invalid.
	 * @since 1.0
	 */
	initialize: function(origin, size)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._origin = new Point();
				this._size = new Size();
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._origin = new Point();
					this._size = new Size();
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (rect)
					this._origin = new Point(rhs.getOrigin());
					this._size = new Size(rhs.getSize());
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._origin = new Point();
							this._size = new Size();
							break;
						case 1:
							// ([rect])
							rhs = rhs[0];
							this._origin = new Point(rhs.getOrigin());
							this._size = new Size(rhs.getSize());
							break;
						case 2:
							// ([point, size])
							// ([[x, y], [width, height]])
							this._origin = new Point(rhs[0]);
							this._size = new Size(rhs[1]);
							break;
						case 4:
							// ([x, y, width, height])
							this._origin = new Point(rhs[0], rhs[1]);
							this._size = new Size(rhs[2], rhs[3]);
							break;
						default:
							throw new Error('Wrong number of arguments for a Rect');
					}
				}
				break;
			case 2:
				// (point, size)
				this._origin = new Point(arguments[0]);
				this._size = new Size(arguments[1]);
				break;
			case 4:
				// (x, y, width, height)
				this._origin = new Point(arguments[0], arguments[1]);
				this._size = new Size(arguments[2], arguments[3]);
				break;
			default:
				throw new Error('Wrong number of arguments for a Rect');
		}
	},
	
	/**
	 * Set the value of all components for this <code>rect</code>. 
	 * @param {Core.Point} [origin=0] The new point of origin.
	 * @param {Core.Size} [size=0] The new rectangle size.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAll: function(origin, size)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate the point of origin of this <code>rect</code>.
	 * @returns {Core.Point} A new rectangle with an identical origin and size.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the point of origin for this <code>rect</code>.
	 * @returns {Core.Point} The current point of origin.
	 * @see Core.Rect#setOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getOrigin: function()
	{
		return this._origin;
	},
	
	/**
	 * Set the point of origin for this <code>rect</code>.
	 * @param {Core.Point} origin The new point of origin.
	 * @returns {this}
	 * @see Core.Rect#getOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setOrigin: function(origin)
	{
		this._origin.setAll(origin);
		return this;
	},
	
	/**
	 * Change the point of origin so that the center of this <code>rect</code> is at the specified location.
	 * @param {Core.Point} origin The new point of origin that results in a rectangle with a center position at the specified location.
	 * @returns {this}
	 * @see Core.Rect#setSizeCentered
	 * @see Core.Rect#setOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setOriginCentered: function(origin)
	{
		origin = new Core.Point(origin);
		this._origin.setX(origin.getX() - this._size.getWidth()/2);
		this._origin.setY(origin.getY() - this._size.getHeight()/2);
		return this;
	},
	
	/**
	 * Retrieve the size of this <code>rect</code>.
	 * @returns {Core.Size} The current rectangle size.
	 * @see Core.Rect#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSize: function()
	{
		return this._size;
	},
	
	/**
	 * Set the size of this <code>rect</code>.
	 * @param {Core.Size} size The new rectangle size.
	 * @returns {this}
	 * @see Core.Rect#getSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setSize: function(size)
	{
		this._size.setAll(size);
		return this;
	},
	
	/**
	 * Set the size of this <code>rect</code> and preserve the current center position.
	 * @param {Core.Size} size The new rectangle size that retains the current center position.
	 * @returns {this}
	 * @see Core.Rect#setOriginCentered
	 * @see Core.Rect#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setSizeCentered: function(size)
	{
		var oldWidth = this._size.getWidth();
		var oldHeight = this._size.getHeight();
		
		this._size.setAll(size);

		this._origin.setX(this._origin.getX() + oldWidth/2 - this._size.getWidth()/2);
		this._origin.setY(this._origin.getY() + oldHeight/2 - this._size.getHeight()/2);
		return this;
	},
	
	/**
	 * Retrieve the minimum value for <i>x</i>. This is represented by the left coordinate.
	 * @returns {Number} The current minimum value of  the <i>x</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMinX: function()
	{
		return this._origin.getX();
	},
	
	/**
	 * Retrieve the average of the minimum and maximum <i>x</i> values. This is the middle coordinate.
	 * @returns {Number} The current average of the minimum and maximum <i>x</i> coordinate values. 
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMidX: function()
	{
		return this._origin.getX() +  this._size.getWidth()/2;
	},
	
	/**
	 * Retrieve the maximum value for <i>x</i>. This is the right coordinate.
	 * @returns {Number} The current maximum value of the <i>x</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMaxX: function()
	{
		return this._origin.getX() + this._size.getWidth();
	},
	
	/**
	 * Retrieve the minimum value for <i>y</i>. This is the top coordinate.
	 * @returns {Number} The current minimum value of the <i>y</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMinY: function()
	{
		return this._origin.getY();
	},
	
	/**
	 * Retrieve the average of the minimum and maximum <i>y</i> values. This is the middle coordinate.
	 * @returns {Number} The current average of the minimum and maximum <i>y</i> coordinate values.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMidY: function()
	{
		return this._origin.getY() + this._size.getHeight()/2;
	},
	
	/**
	 * Retrieve the maximum value for <i>y</i>. This is the bottom coordinate.
	 * @returns {Number} The current maximum value of the <i>y</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getMaxY: function()
	{
		return this._origin.getY() + this._size.getHeight();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Rect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Rect'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Rect'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Rect.js';

exports.Rect = require('NGCore/Shared/Rect').Rect;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/md5'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/md5'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/md5'] = exports; 
var __dirname = 'NGCore/Shared/Lib';
var __filename = 'NGCore/Shared/Lib/md5.js';

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  var hex_tab = "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/**
 * Find the MD5 hash of a string.
 * @name toMD5
 * @function
 * @memberOf Core
 * @example
 * var md5 = Core.toMD5("Test string");  // returns 0fd3dbec9730101bff92acc820befc34
 * @param {String} s The string that will be hashed.
 * @returns {String} An MD5 hash of the string.
 */
var toMD5 = function(s) { return rstr2hex(rstr_md5(str2rstr_utf8(s))); };

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return toMD5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

exports.toMD5 = toMD5;
exports.testMD5 = md5_vm_test;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/toMD5'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/toMD5'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/toMD5'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/toMD5.js';

exports.toMD5 = require('NGCore/Shared/Lib/md5').toMD5;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/sha1'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/sha1'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/sha1'] = exports; 
var __dirname = 'NGCore/Shared/Lib';
var __filename = 'NGCore/Shared/Lib/sha1.js';

/**
 * @class The <code>Core.SHA1</code> class provides a JavaScript implementation of the Secure Hash
 * Algorithm (SHA-1), as defined in
 * <a href="http://www.itl.nist.gov/fipspubs/fip180-1.htm">FIPS PUB 180-1</a>.
 * @name Core.SHA1
 */

/*
	Version 2.1a Copyright Paul Johnston 2000 - 2002.
	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet.
	Distributed under the BSD License.
	See http://pajhome.org.uk/crypt/md5 for details.
*/

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) { return (b & c) | ((~b) & d); }
  if(t < 40) { return b ^ c ^ d; }
  if(t < 60) { return (b & c) | (b & d) | (c & d); }
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */

function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) { w[j] = x[i + j]; }
      else {
		w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
	  }
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = [];
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz) {
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  }
  return bin;
}

function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) {
	bkey = core_sha1(bkey, key.length * chrsz);
  }

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz) {
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                  (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                   ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32){
		str += b64pad;
	  } else {
		str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
	  }
    }
  }
  return str;
}

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */

/**
 * Encode a string in hexidecimal SHA-1 format.
 * @memberOf Core.SHA1
 * @example
 * var str = "Test string";
 * var hexSHA1 = Core.SHA1.hex_sha1(str);  // returns 18af819125b70879d36378431c4e8d9bfa6a2599
 * @param {String} s The string to encode.
 * @returns {String} A hexidecimal SHA-1 encoded version of the string.
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}

/**
 * Encode a string in Base64 SHA-1 format.
 * @memberOf Core.SHA1
 * @example
 * var str = "Test string";
 * var base64SHA1 = Core.SHA1.b64_sha1(str);  // returns GK+BkSW3CHnTY3hDHE6Nm/pqJZk
 * @param {String} s The string to encode.
 * @returns {String} A Base64 SHA-1 encoded version of the string.
 */
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}

function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}

function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}

/**
 * Encode a string in Base64 SHA-1 format using a specified key.
 * @memberOf Core.SHA1
 * @example
 * var key = "testkey";
 * var str = "Test string";
 * var pad = "=";
 * var base64SHA1 = Core.SHA1.b64_hmac_sha1(key, str, pad);  // returns d/KEmi5KvmH91Pv8eu3UPcTSXBw=
 * @param {String} key The key to use when encoding the string.
 * @param {String} data The string to encode.
 * @param {String} [padChar] A single character that is used to pad the encoded string. Use
 *                           <code>=</code> to comply with
 *                           <a href="http://tools.ietf.org/html/rfc4648">RFC 4648</a>, which
 *                           specifies the Base64 format. By default, the encoded string is not
 *                           padded.
 * @returns {String} A Base64 SHA-1 encoded version of the string. If a value is passed in the
 *                   <code>padChar</code> parameter, it is used to pad the end of the string.
 */
function b64_hmac_sha1(key, data, padChar){
	if ((typeof padChar != "undefined") && padChar) {
        b64pad = padChar;
	}
	return binb2b64(core_hmac_sha1(key, data));
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

// Exports for node.js
if((typeof exports != "undefined") && exports)
{
	exports.b64_hmac_sha1 = b64_hmac_sha1;
	exports.hex_sha1 = hex_sha1;
	exports.b64_sha1 = b64_sha1;
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/SHA1'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/SHA1'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/SHA1'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/SHA1.js';

var sha1 = require('NGCore/Shared/Lib/sha1');

exports.SHA1 = {
	b64_hmac_sha1: sha1.b64_hmac_sha1,
	hex_sha1: sha1.hex_sha1,
	b64_sha1: sha1.b64_sha1
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/UpdateEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/UpdateEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/UpdateEmitter'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/UpdateEmitter.js';

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var Time = require('NGCore/Client/Core/Time').Time;

exports.UpdateEmitter = MessageEmitter.singleton(
/** @lends Core.UpdateEmitter.prototype */
{
	classname: 'UpdateEmitter',
		
	/**
	 * @class The <code>UpdateEmitter</code> class constructs a singleton object that emits every
	 * frame and sends its listeners the delta, in milliseconds, since the last frame.<br /><br />
	 * <b>Note:</b> <code>{@link Core.UpdateEmitter#setTickRate}</code> is also used to define the framerate of any animation reproduced by a sprite 
	 * (see <code>{@link GL2.Sprite#setAnimation}</code>).<br /><br />
	 * <strong>Note<strong>: If your app uses the <code>{@link UI.WebView}</code> class to display a
	 * web-based game, avoid adding listeners to <code>UpdateEmitter</code> when possible. Attaching
	 * a listener to <code>UpdateEmitter</code> can limit the performance of web-based games.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		
		this.__clubObject = new NgEngineEntity();
		this.__clubObject.mIsUpdatable = true;
		this.__clubObject.onUpdate = this._emitTime.bind(this);
		this.__clubObject.register();
		
		this._createSendGen(this.__objectRegistryId);
		
		if (!Core.Capabilities.meetsBinaryVersion("1.8")) {
			this._setListenerCountSendGen = function() {};
		}
		this._setListenerCountSendGen(0);
	},
	
	_emitTime: function()
	{
		this.emit(Time.getFrameDelta());
	},
	/**
	 * Set the number of seconds between updates from this <code>UpdateEmitter</code>.<br /><br />
	 * <b>Note</b>: The new value will take effect after the current update completes. The actual
	 * tick rate will be less than or equal to the requested tick rate.
	 * @example
	 * // Send updates every 0.1 seconds, or 100 milliseconds, to any MessageListener objects
	 * // that are listening to this UpdateEmitter
	 * Core.UpdateEmitter.setTickRate(0.1);
	 * @param {Number} r The number of seconds between updates from this <code>UpdateEmitter</code>.
	 * @see GL2.Sprite
	 * @returns {void}
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	setTickRate: function( r ) 
	{
		this._setTickRateSendGen(r);
	},
	
	addListener: function($super, listener, func, priority) {
		$super(listener, func, priority);
		this._setListenerCountSendGen(this.getListenerCount());
	},
	
	removeListener: function($super, listener) {
		$super(listener);
		this._setListenerCountSendGen(this.getListenerCount());
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 304,
	// Method create = -1
	// Method setTickRate = 2
	// Method setListenerCount = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in UpdateEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in UpdateEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[304] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x130ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_setTickRateSendGen: function( rate )
	{
		Proc.appendToCommandString( 0x1300002, this, [ +rate ] );
	},
	
	/** @private */
	_setListenerCountSendGen: function( count )
	{
		Proc.appendToCommandString( 0x1300003, this, [ +count ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setTickRate: function( rate ) {}
	
	// setListenerCount: function( count ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/sprintf'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/sprintf'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/sprintf'] = exports; 
var __dirname = 'NGCore/Shared/Lib';
var __filename = 'NGCore/Shared/Lib/sprintf.js';

/**
sprintf() for JavaScript 0.6

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2007.04.03 - 0.1:
 - initial release
2007.09.11 - 0.2:
 - feature: added argument swapping
2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)
2007.10.21 - 0.4:
 - unit test and patch (David Baird)
2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license
2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.
**/



exports.sprintf = function() {
	var str_repeat = function(i, m) {
		for (var o = []; m > 0; o[--m] = i) {}
		return o.join('');
	};

	var params = [];
	var outputArray = false;
	var paramsConsumed = 1;
        var i;
	if (typeof(arguments[0]) == 'object' && arguments[0].length) {
		outputArray = true;
		for (i = 0; i < arguments[0].length; ++i) {
			params[i] = arguments[0][i];
		}
	} else {
		for (i = 0; i < arguments.length; ++i) {
			params[i] = arguments[i];
		}
	}
        i=0;
	var a, f = params[i++], o = [], m, p, c, x, s = '';
	while (f) {
		if (m = /^[^\x25]+/.exec(f)) {
			o.push(m[0]);
		}
		else if (m = /^\x25{2}/.exec(f)) {
			o.push('%');
		}
		else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
			if (((a = params[m[1] || i++]) === null) || (a === undefined)) {
				throw('Too few arguments.');
			}
			if (/[^s]/.test(m[7]) && (typeof(a) != 'number')) {
				throw('Expecting number but found ' + typeof(a));
			}
			switch (m[7]) {
				case 'b': a = a.toString(2); break;
				case 'c': a = String.fromCharCode(a); break;
				case 'd': a = parseInt(a, 10); break;
				case 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;
				case 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;
				case 'o': a = a.toString(8); break;
				case 's': a = ((a = String(a)) && m[6] ? a.substring(0, m[6]) : a); break;
				case 'u': a = Math.abs(a); break;
				case 'x': a = a.toString(16); break;
				case 'X': a = a.toString(16).toUpperCase(); break;
			}
			a = (/[def]/.test(m[7]) && m[2] && a >= 0 ? '+'+ a : a);
			c = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';
			x = m[5] - String(a).length - s.length;
			p = m[5] ? str_repeat(c, x) : '';
			o.push(s + (m[4] ? a + p : p + a));
			if (outputArray) ++paramsConsumed;
		}
		else {
			throw('Huh ?!');
		}
		f = f.substring(m[0].length);
	}
	if (outputArray && paramsConsumed > 0) {
		arguments[0].splice(0, paramsConsumed);
	}
	return o.join('');
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Logger'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Logger'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Logger'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Logger.js';

var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var sprintf = require('NGCore/Shared/Lib/sprintf').sprintf;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

var Logger = Class.singleton(
/** @lends Core.Logger.prototype */
{
	classname: 'Logger',

	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
        timingLog = function(message, argv) {};
	},

	/** @private */
	_disable: function()
	{
		console.log("Logger : javascript logging disabled");
        console.log = Logger.log = function(message, argv) {};
        timingLog = function(message, argv) {};
	},

	_enable: function(timingOnly)
	{

        timingLog = function(message, argv)
        {
	    var i;
            if (arguments.length > 1) {
                try {
                    var params = [];
                    for (i = 0; i < arguments.length; ++i) {
                        params[i] = arguments[i];
                    }
                    var result = sprintf(params);
                    params.unshift(result);
                    message = params.join(" ");
                } catch (err) {
                    var concat = [];
                    for (i = 0; i < arguments.length; ++i) {
                        concat[i] = arguments[i];
                    }
                    message = concat.join(" ");
                }
            }
            __underscore_SysLog(message);
        };

        if (timingOnly) {
            return;
        }

        console.log = Logger.log = function(message, argv)
        {
            if (arguments.length > 1) {
		var i;
                try {
                    var params = [];
                    for (i = 0; i < arguments.length; ++i) {
                        params[i] = arguments[i];
                    }
                    var result = sprintf(params);
                    params.unshift(result);
                    message = params.join(" ");
                } catch (err) {
                    var concat = [];
                    for (i = 0; i < arguments.length; ++i) {
                        concat[i] = arguments[i];
                    }
                    message = concat.join(" ");
                }
            }
            __underscore_SysLog(message);
        };
        console.log("Logger : javascript logging enabled");
	},

	/**
	 * Log a message to the development console.
	 * @param {string} message
	 * @param {Array} argv Additional arguments to log.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	log: function(message, argv)
	{
		
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 305,
	// Method create = -1
	// Method log = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Logger._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Logger._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[305] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x131ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_logSendGen: function( msg )
	{
		Proc.appendToCommandString( 0x1310002, this, [ Proc.encodeString( msg ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// log: function( msg ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});

Logger.instantiate();

__underscore_SysLog = function(_massage)
{
	Logger._logSendGen( _massage );
};

// JMarr Don't override console.log when on flash.
if(typeof(_NG_TARGET_FLASH) == 'undefined')
	console.log = Logger.log;

exports.Logger = Logger;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/OrientationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/OrientationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/OrientationEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/OrientationEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class OrientationEmitter
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.OrientationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.OrientationEmitter.prototype */
{
	classname: 'OrientationEmitter',
		
	/**
	 * @class <code>OrientationEmitter</code> constructs a singleton object that tracks the physical
	 * orientation of the device, as well as the orientation of the device's interface. When the
	 * physical or interface orientation changes, the listener receives an object that has the
	 * following properties:
	 * <ul>
	 *		<li><code>orientation</code>: The new orientation. Corresponds to an enumerated value of
	 *		<code>{@link Device.OrientationEmitter#Orientation}</code>.</li>
	 *		<li><code>type</code>: Indicates whether the physical or interface orientation changed.
	 *		Corresponds to an enumerated value of
	 *		<code>{@link Device.OrientationEmitter#OrientationType}</code>.</li>
	 * </ul>
	 * Rotating the device does not automatically rotate the interface presented to the user.
	 * Applications must explicitly call
	 * <code>{@link Device.OrientationEmitter#setInterfaceOrientation}</code> to rotate the
	 * interface. This allows an application to selectively choose which device orientations will
	 * result in a change to the interface orientation.<br /><br />
	 * @constructs The default constructor.
	 * @singleton
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._lastDeviceOrientation    = this.Orientation.Portrait;
		this._lastInterfaceOrientation = this.Orientation.Portrait;
	},
	
	/**
	 * Retrieve the device orientation.
	 * @returns {Device.OrientationEmitter#Orientation} The current device orienation.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getDeviceOrientation: function()
	{
		return this._lastDeviceOrientation;
	},
	
	/**
	 * Retrieve the interface orientation. Initially, this is the same as the device orientation.
	 * @returns {Device.OrientationEmitter#Orientation} The current interface orientation.
	 * @see Device.OrientationEmitter#setInterfaceOrientation
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getInterfaceOrientation: function()
	{
		return this._lastInterfaceOrientation;
	},
	
	/**
	 * Set the interface orientation. The <code>LandscapeRight</code> and <code>PortraitUpsideDown</code>
	 * orientations are supported on iOS and on Android 2.3 and later.
	 * @example
	 * Device.OrientationEmitter.setInterfaceOrientation(Device.OrientationEmitter.Orientation.Portrait);
	 * @param {Device.OrientationEmitter#Orientation} orientation The new device orientation.
	 * @param {Boolean} [animated] Set to <code>true</code> to render the orientation change with an animated effect.
	 * @returns {void}
	 * @see Device.OrientationEmitter#getInterfaceOrientation
	 * @see Device.OrientationEmitter#isInterfaceOrientation
	 * @status iOS, Test
	 * @since 1.0
	 */
	setInterfaceOrientation: function(orientation, animated)
	{
		if( !this.isInterfaceOrientation( orientation ) )
		{
			NgLogE("Unknown orientation specified: " + orientation);
			return;
		}

		if (orientation != this._lastInterfaceOrientation)
		{
			NgLogD("setInterfaceOrientation to " + orientation);
			this._setInterfaceOrientationSendGen(orientation,animated);
			this._lastInterfaceOrientation = orientation;
		}
	},
	
	/**
	 * Check whether a specified orientation can be used as a parameter to
	 * <code>{@link Device.OrientationEmitter#setInterfaceOrientation}</code>.
	 * @param {Device.OrientationEmitter#Orientation} orientation The orientation to check.
	 * @returns {Boolean} Set to <code>true</code> if the specified orientation can be used to set
	 *		the interface orientation.
	 * @see Device.OrientationEmitter#getInterfaceOrientation
	 * @since 1.6
	 */
	isInterfaceOrientation: function(orientation)
	{
		return orientation == this.Orientation.Portrait
			|| orientation == this.Orientation.PortraitUpsideDown
			|| orientation == this.Orientation.LandscapeLeft
			|| orientation == this.Orientation.LandscapeRight;
	},
	
	/**
	 * Enumeration for device orientation.
	 * @fieldOf Device.OrientationEmitter#
	 */
	Orientation:
	{ 
		/** 
		* Portrait orientation. 
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		Portrait: 0,
		/** 
		* Portrait orientation, but rotated 180 degrees. Used only on iOS and on Android 2.3 and later.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		PortraitUpsideDown: 1,
		/** 
		* Landscape orientation with the top of the device to the left. 
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		LandscapeLeft: 2,
		/** 
		* Landscape orientation with the top of the device to the right. Used only on iOS and on Android 2.3 and later.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		LandscapeRight: 3,
		/** 
		* Oriented with the face of the device up. Used only on iOS.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		FaceUp: 4,
		/** 
		* Oriented with the face of the device down. Used only on iOS.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		FaceDown: 5
	},

	/**
	 * Enumeration for the type of orientation change that occurred.
	 * @fieldOf Device.OrientationEmitter#
	 */
	OrientationType:
	{
		/**
		* Device orientation has changed.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		Device: 0,
		/**
		* Interface orientation has changed.
		* @fieldOf Device.OrientationEmitter#
		* @constant
		*/
		Interface: 1
	},

	_orientationChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._orientationChangedRecvGen(cmd, msg))
			return;
 
 		this._lastDeviceOrientation = msg['orientation'];
		this.emit({type: this.OrientationType.Device, orientation:msg['orientation']});
		
		//Cascade the original message back out to native for forwarding
		this._orientationChangedSendGen(msg.orientation);
	},
	
	_interfaceOrientationChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._interfaceOrientationChangedRecvGen(cmd, msg))
			return;
 
 		this._lastInterfaceOrientation = msg['orientation'];
		this.emit({type: this.OrientationType.Interface, orientation:msg['orientation']});
		
		//Cascade the original message back out to native for forwarding
		this._interfaceOrientationChangedSendGen(msg.orientation);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 335,
	// Method create = -1
	// Method orientationChanged = 2
	// Method setInterfaceOrientation = 3
	// Method interfaceOrientationChanged = 4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._orientationChangedRecv( cmd );
					break;
				case 4:
					instance._interfaceOrientationChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in OrientationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in OrientationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[335] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_orientationChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in OrientationEmitter.orientationChanged from command: " + cmd );
			return false;
		}
		
		obj[ "orientation" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "orientation" ] === undefined )
		{
			NgLogE("Could not parse orientation in OrientationEmitter.orientationChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_interfaceOrientationChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in OrientationEmitter.interfaceOrientationChanged from command: " + cmd );
			return false;
		}
		
		obj[ "orientation" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "orientation" ] === undefined )
		{
			NgLogE("Could not parse orientation in OrientationEmitter.interfaceOrientationChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14fffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_orientationChangedSendGen: function( orientation )
	{
		Core.Proc.appendToCommandString( 0x14f0002, this, [ +orientation ] );
	},
	
	/** @private */
	_setInterfaceOrientationSendGen: function( orientation, animated )
	{
		Core.Proc.appendToCommandString( 0x14f0003, this, [ +orientation, ( animated ? 1 : 0 ) ] );
	},
	
	/** @private */
	_interfaceOrientationChangedSendGen: function( orientation )
	{
		Core.Proc.appendToCommandString( 0x14f0004, this, [ +orientation ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _orientationChangedRecv: function( cmd ) {}
	// orientationChanged: function( orientation ) {}
	
	// setInterfaceOrientation: function( orientation, animated ) {}
	
	// _interfaceOrientationChangedRecv: function( cmd ) {}
	// interfaceOrientationChanged: function( orientation ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/Storage';
var __filename = 'NGCore/Client/Storage/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// Storage diagnostic emitter; collects info from Storage subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////
    
//
// Create and export a DiagnosticEmitter for Storage.
//

exports.Diagnostics = Core.DiagnosticEmitter.singleton(
{
    classname: 'Storage_Diagnostics',

	/**
	 * @class The `Storage.Diagnostics` class provides detailed diagnostic information about classes
	 * in the `Storage` module. You can use this information to debug your app's use of the
	 * `Storage` module and learn more about the app's performance.
	 *
	 * The emitter emits an object of the form:
	 *
	 *     {
	 *         name: "Storage",                         // The emitter's name
	 *         getItem: {
	 *             count: {Number}                      // The number of calls to Storage.KeyValue.getItem()
	 *         },
	 *         setItem: {
	 *             count: {Number}                      // The number of calls to Storage.KeyValue.setItem()
	 *         },
	 *         removeItem: {
	 *             count: {Number}                      // The number of calls to Storage.KeyValue.removeItem()
	 *         },
	 *         readFile: {
	 *             count: {Number}                      // The number of calls to read a file
	 *         },
	 *         writeFile: {
	 *             count: {Number}                      // The number of calls to write a file
	 *         },
	 *         deleteFile: {
	 *             count: {Number}                      // The number of calls to delete a file
	 *         },
	 *         renameFile: {
	 *             count: {Number}                      // The number of calls to rename a file
	 *         },
	 *         decompressFile: {
	 *             count: {Number}                      // The number of calls to decompress a file
	 *         },
	 *         readFile: {
	 *             count: {Number}                      // The number of calls to read a file
	 *         },
	 *         stat: {
	 *             count: {Number}                      // The number of calls to get information about a file
	 *         },
	 *         KeyValue: {                              // Detailed information for Storage.KeyValue
	 *             bytesSetItem: {KeyValueBytes},       // Amount of data written through setItem()
	 *             bytesGetItem: {KeyValueBytes}        // Amount of data read through getItem()
	 *         },
	 *         FileSystem: {                            // Detailed information for Storage.FileSystem
	 *             bytesRead: {FileSystemBytes},        // Number of bytes read from file system
	 *             bytesWritten: {FileSystemBytes}      // Number of bytes written to file system
	 *         }
	 *     }
	 *
	 * The `KeyValueBytes` type is an object of the form:
	 *
	 *     {
	 *         perSecondGlobal: {Number},   // Transfer rate, in bytes per second, for the global store
	 *         perSecondLocal: {Number},    // Transfer rate, in bytes per second, for the local store
	 *         accumGlobal: {Number},       // Total bytes transferred for the global store
	 *         accumLocal: {Number}         // Total bytes transferred for the local store
	 *     }
	 *
	 * The `FileSystemBytes` type is an object of the form:
	 *
	 *     {
	 *         perSecondLocal: {Number},    // Transfer rate, in bytes per second, for the
	 *                                      // persistent file store
	 *         perSecondTemp: {Number},     // Transfer rate, in bytes per second, for the
	 *                                      // temporary file store
	 *         accumLocal: {Number},        // Total bytes transferred for the persistent file store
	 *         accumTemp: {Number}          // Total bytes transferred for the temporary file store
	 *     }
	 * @name Storage.Diagnostics
	 * @constructs
	 * @augments Core.DiagnosticEmitter
	 * @singleton
	 * @since 1.8
	 */
	
	initialize: function($super)
	{
	$super('Storage');
	}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage/KeyValue'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage/KeyValue'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage/KeyValue'] = exports; 
var __dirname = 'NGCore/Client/Storage';
var __filename = 'NGCore/Client/Storage/KeyValue.js';

////////////////////////////////////////////////////////////////////////////////
// Class KeyValue
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;
var Diagnostics = require('NGCore/Client/Storage/Diagnostics').Diagnostics;

////////////////////////////////////////////////////////////////////////////////

function KeyValueCache() {

}

exports.KeyValueCache = KeyValueCache;
/** @lends Storage.KeyValueCache.prototype 
*/

/** @private */
KeyValueCache.lruMeanCacheSize = 100;
/** @private */
KeyValueCache.instanceMap = {};
//TODO: rename this later
var StorageGlobalScopes = [];

KeyValueCache.optimizeCaches = function() 
{
	for (var storeKey in KeyValueCache.instanceMap) {
		if(KeyValueCache.instanceMap.hasOwnProperty(storeKey)) {
			KeyValueCache.instanceMap[storeKey].optimize();
		}
	}
};

KeyValueCache.lowMemoryWarning = function() 
{
	for (var storeKey in KeyValueCache.instanceMap) {
		if(KeyValueCache.instanceMap.hasOwnProperty(storeKey)) {
			var instance = KeyValueCache.instanceMap[storeKey];
			instance.data = {};

			//Purge entries in callbacks
			var newCallbacks = {};
			newCallbacks.uidGenerator = instance.callbacks.uidGenerator;
			for(var cbId in instance.callbacks)
			{
				if(instance.callbacks.hasOwnProperty(cbId)) {
					if(instance.callbacks[cbId]) {
						newCallbacks = instance.callbacks[cbId];
					}
				}
			}
			instance.callbacks = newCallbacks;
		}
	}
};

/**
* @class Provides access to the local key-value data store.
*
* The data you store with `Storage.KeyValueCache` is not tied to a specific Mobage user.
* Access the local `Storage.KeyValueCache` by using {@link Storage.KeyValueCache#local}. 
*
* If you need to store user-specific data, do one of the following:
*
* 1. Verify that your application is storing and retrieving data for the correct Mobage user. 
* Keep in mind that several different Mobage users could all use the same application on the
* same device.
* 2. As an alternative to `Storage.KeyValueCache`, consider using the
* `{@link Social.Common.Appdata}` class, which stores application data that is tied to a specific
* Mobage user.
*
* @name Storage.KeyValueCache
* @singleton
* @constructs
*/
KeyValueCache.init = function()
{
	KeyValueCache.local = new Storage.KeyValue();
	KeyValueCache.local.registerForKey("local");
};

/**
* Returns a `Storage.KeyValue` object for the local data store of the device.
*
* @name local
* @fieldOf Storage.KeyValueCache#
* @example
* var keys = Storage.KeyValueCache.local;
* 
* keys.getItem("nextQuest", {}, function(err, val, name) {
*     if (err) {
*         console.log("An error occurred while retrieving the value of " +
*           name + ": " + err);
*         return;
*     } else {
*         console.log("The value of " + name + " is " + val);
*     }
* });
*
*/

/**
 * @static Scopes this `KeyValueCache` object as global. A globally scoped KeyValueCache object can
 * be used by multiple applications for the same data. 
 * @param {String} globalKey The store key for the `KeyValueCache` object.
 * @ignore
 * @private
 */
KeyValueCache.global = function(globalKey)
{
	if(StorageGlobalScopes[globalKey])
	{
		return StorageGlobalScopes[globalKey];
	}

	//Miss Global Table Cache.
	var scope = new exports.KeyValue();
	scope.registerForKey(globalKey);
	StorageGlobalScopes[globalKey] = scope;
	return scope;
};

exports.KeyValue = Core.Class.subclass(
/** @lends Storage.KeyValue.prototype */
{
	classname: "KeyValue",

  /** @private */
  _options: {
    blocking    : 0x0001  /* legacy blocking(main thread) mode operation for backward compatibility */
  },
	
	/**
	 * @class The `KeyValue` class constructs objects that allow you to manage application key/value
	 * pairs in a datastore.
	 * 
	 * + Use `KeyValueCache.local` to access the `local` datastore for your application.
	 *
	 * The data you store with `Storage.KeyValue` is not tied to a specific Mobage user. If you need
	 * to store user-specific data, do one of the following:
	 *
	 * 1. Verify that your application is storing and retrieving data for the correct Mobage user. 
	 * Keep in mind that several different Mobage users could all use the same application on the
	 * same device.
	 * 2. As an alternative to `Storage.KeyValue`, consider using the
	 * `{@link Social.Common.Appdata}` class, which stores application data that is tied to a specific
	 * Mobage user.
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		/** @private */
		this.initialized = false;
		/** @private */
		this.origin = null;
		/** @private */
		this.callbacks = {};
		/** @private */
		this.callbacks.uidGenerator = 0;
		/** @private */
		this.local = false;
		/** @private */
		this.lruCacheShrinkCounter = 0;
	
		/** @private */
		this.data = {};
		/** @private */
		this.usage = {};
		
		this.oldBinary = !Core.Capabilities.meetsBinaryVersion("1.4");

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._getItemCount = 0;
		this._setItemCount = 0;
		this._removeItemCount = 0;

		Diagnostics.pushCollector(this.collectDiagnostics.bind(this));
	},
	
	/**
	 * Destroy this instance and release resources on the backend.
	 * @returns {void}
	 * @since 1.0
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
    /*
	 * @private
	 * Call `registerForKey()` to access a datastore identified by the value of the `storeKey`
	 * parameter.
	 * @param {String} storeKey The unique identifier of the datastore.
	 * @returns {this}
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */	
	registerForKey: function(storeKey) 
	{
		this.origin = storeKey;
		KeyValueCache.instanceMap[storeKey] = this;

		//Push this instance across the native bridge
		this._registerCommandSendGen(this.origin,KeyValueCache.lruMeanCacheSize);
		
		return this;
	},
	/**
	 * Retrieve the value of a key.
	 * @param {String} key The key that is associated with the value.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to retrieve the value synchronously
	 *		(i.e, the application pauses until the value is retrieved). This option can cause  
	 *		significant delays on some devices and should be used only if your application cannot
	 *		function without synchronous retrieval of a key's value.
	 * @param {Boolean} [options.ignoreCache=false] Set to `true` to retrieve the value from the 
	 *		device's storage, ignoring the cache.
	 * @cb {Function} callbackFunc The function to call after retrieving the value.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} val The value associated with the key.
	 * @cb-param {String} name The name of the key.
	 * @cb-returns {void}
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.getItem("nextQuest", {}, function(err, val, name) {
	 *     if (err) {
	 *         console.log("An error occurred while retrieving the value of " +
	 *           name + ": " + err);
	 *         return;
	 *     } else {
	 *         console.log("The value of " + name + " is " + val);
	 *     }
	 * });
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getItem: function(key, options, callbackFunc) {
		this._getItemCount++;

		if (this.oldBinary && typeof options == 'object') {
			var ignCache = options['ignoreCache'];
			options = callbackFunc;
			callbackFunc = ignCache;
		}
		
    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      if (!this.oldBinary) NgLogW("KeyValue.getItem(): using deprecated function signature");
      var ignoreCache = callbackFunc;
      callbackFunc = options;
      var callbackId;

      if(!ignoreCache)
      {
        if(this.data[key]) {
          callbackFunc(null,this.data[key],key);
          this.usage[key]++;
          return;
        }
        else
        {
          NgLogD("Value not found in cache for..falling back to native");
        }
      }

      //Generate unused callbackEntry
      callbackId = this.callbacks.uidGenerator++;

      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._getItemSendGen(this.origin,callbackId,key);
    }
    else
    {
      if(!options['ignoreCache'])
      {
        if(this.data[key]) {
          callbackFunc(null,this.data[key],key);
          this.usage[key]++;
          return;
        }

        //NgLogD("Value not found in cache for..falling back to native");
      }
      else
      {
        //NgLogD("KeyValue: ignoring cache...");
      }

      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;

      //Generate unused callbackEntry
      callbackId = this.callbacks.uidGenerator++;

      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._getItemAsyncSendGen(this.origin,callbackId,key,op);
    }
	},

	/**
	 * Deprecated signature to retrieve the value of a key.
	 * @name getItem^2
	 * @function
	 * @memberOf Storage.KeyValue#
	 * @deprecated Since version 1.4.1. Use the signature getItem(key, options, callbackFunc)
	 * rather than this signature.
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.getItem("key_name", false, function(err, val, name) {
	 *     // Add callback code.
	 * });
	 * @param {String} key The key that is associated with the value.
	 * @param {Boolean} [ignoreCache=false] Set to `true` to retrieve the value from the device's
	 *		storage, ignoring the cache.
	 * @cb {Function} callbackFunc The function to call after retrieving the value.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} val The value associated with the key.
	 * @cb-param {String} name The name of the key.
	 * @cb-returns {void}
	 * @returns {void}
	 */

	/**
	 * Associate a value with a key.
	 * @param {String} key The key to associate with the value.
	 * @param {String} value The value to associate with the key.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to set the key-value pair 
	 *		synchronously (i.e., the application pauses until the key-value pair is set). This
	 *		option can cause significant delays on some devices and should be used only if your
	 *		application cannot function without synchronous storage of key-value pairs.
	 * @cb {Function} [callbackFunc] The function to call after storing the key-value pair.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} name The name of the key.
	 * @cb-returns {void}
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.setItem("nextQuest", "monster_attack", {}, function(err, name) {
	 *     if (err) {
	 *         console.log("Unable to store key-value pair: " + err);
	 *     } else {
	 *         console.log("Updated the value of the key " + name);
	 *     }
	 * });
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setItem: function(key, value, options, callbackFunc)
	{
		this._setItemCount++;

		if (this.oldBinary && typeof options == 'object') {
			options = callbackFunc;
		}

	        var callbackId;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      if (!this.oldBinary) NgLogW("KeyValue.setItem(): using deprecated function signature");
      callbackFunc = options;

      this.data[key] = value;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._setItemSendGen(this.origin,callbackId,key,value);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;

      this.data[key] = value;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._setItemAsyncSendGen(this.origin,callbackId,key,value,op);
    }
	},

	/**
	 * Deprecated signature for associating a value with a key.
	 * @name setItem^2
	 * @function
	 * @memberOf Storage.KeyValue#
	 * @deprecated Since version 1.4.1. Use the signature setItem(key, value, options, callbackFunc)
	 * rather than this signature.
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.setItem("key_name", "value", function(err, name) {
	 *     // Add callback code.
	 * });
	 * @param {String} key The key to associate with the value.
	 * @param {String} value The value to associate with the key.
	 * @cb {Function} [callbackFunc] The function to call after storing the key-value pair.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} name The name of the key.
	 * @cb-returns {void}
	 * @returns {void}
	 */
	
	/**
	 * Remove the value that is associated with a key.
	 * @param {String} key The key that is associated with the value to remove.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to remove the key-value pair
	 *		synchronously (i.e., the application pauses until the key-value pair is removed). This 
	 *		option can cause significant delays on some devices and should be used only if your
	 *		application cannot function without synchronous storage of key-value pairs.
	 * @cb {Function} [callbackFunc] The function to call after removing the key's value.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} name The name of the key that was removed.
	 * @cb-returns {void}
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.removeItem("nextQuest", {}, function(err, name) {
	 *     if (err) {
	 *         console.log("Unable to remove a key's value: " + err);
	 *     } else {
	 *         console.log("The key " + name + " was removed.");
	 *     }
	 * });
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	removeItem: function(key, options, callbackFunc)
	{
		this._removeItemCount++;

		if (this.oldBinary && typeof options == 'object') {
			options = callbackFunc;
		}
	    var callbackId;
    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
     if (!this.oldBinary) NgLogW("KeyValue.removeItem(): using deprecated function signature");
      callbackFunc = options;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._removeItemSendGen(this.origin,callbackId,key);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._removeItemAsyncSendGen(this.origin,callbackId,key,op);
    }
	},

	/**
	 * Deprecated signature for removing the value that is associated with a key.
	 * @name removeItem^2
	 * @function
	 * @memberOf Storage.KeyValue#
	 * @deprecated Since version 1.4.1. Use the signature removeItem(key, options, callbackFunc)
	 * rather than this signature.
	 * @example
	 * var keys = new Storage.KeyValue();
	 * keys.removeItem("key_name", function(err, name) {
	 *     // Add callback code.
	 * });
	 * @param {String} key The key that is associated with the value to remove.
	 * @cb {Function} [callbackFunc] The function to call after removing the key's value.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String} name The name of the key that was removed.
	 * @cb-returns {void}
	 * @returns {void}
	 */


	/**
	 * @private
	 * Clear all key/value pairs stored within this store
	 * NOTE: Legacy function signature, clear([{Function}cb]) is still supported but deprecated.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to make the operation block the main
	 *		thread (not recommended).
	 * @param {Function} [callbackFunc] The callback function to be called
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	clear: function(options, callbackFunc)
	{
		if (this.oldBinary && typeof options == 'object') {
			options = callbackFunc;
		}
	    var callbackId;
    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      if (!this.oldBinary) NgLogW("KeyValue.clear(): using deprecated function signature");
      callbackFunc = options;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._clearSendGen(this.origin,callbackId);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;

      callbackId = this.callbacks.uidGenerator++;
      if(!!!callbackFunc) {
      	/** @inner */
        callbackFunc = function(){};
      }
      this.callbacks[callbackId] = callbackFunc;

      this._clearAsyncSendGen(this.origin,callbackId,op);
    }
	},
	/**
	 * @ignore
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	enforceLRUCacheSize: function()
	{
		NgLogD("Enforcing KeyValue Cache Size");
		var tmp = [];
		for (var k in this.data) {
			if (this.data.hasOwnProperty(k)) {
				tmp.push(k);
			}
		}
		var usage = this.usage;
		tmp.sort(function(a,b) {
			var p1 = usage[a];
			if (!p1) {
				p1 = 0;
			}

			var p2 = usage[b];
			if (!p2) {
				p2 = 0;
			}

			if (p1 == p2) { return 0; }
			return p1 < p2 ? 1 : -1;
		});

		var oldData = this.data;
		this.data = {};
		//Copy over the lruMeanCache(number) most used entries
		var stopPoint = KeyValueCache.lruMeanCacheSize;
		for (var i = 0; i < stopPoint && i < tmp.length; i++)
		{
			if(!oldData[tmp[i]]) {
				//Case cache didn't contain that key at this point in time
				stopPoint++;
			}
			else {
				this.data[tmp[i]] = oldData[tmp[i]];
			}
		}
	},
	
	_getInstanceRecv : function(cmd)
	{
		var msg = {};
		if(!this._getInstanceRecvGen(cmd, msg))
			return;
			
		var storeKey = msg["storeKey"];

		var instance = KeyValueCache.instanceMap[storeKey];
		//NgLogD("Storage.getInstanceForCommand Found instance for key [" + storeKey + "]: " + instance + " (" + command + ")");
		return instance;
	},
	
	_registerCommandCbRecv : function(cmd)
	{		
		var msg = {};
		if(!this._registerCommandCbRecvGen(cmd, msg))
			return;
		
		//NgLogD("Storage registerCallback: "+command+"\n");
		if(msg["error"]){
			console.log("Storage: Error registering for KeyValue location '"+msg["error"]+"'");
			if(!this.initialized) {
				delete StorageGlobalScopes[msg["originalStoreKey"]];
			}
			return;
		}

		if(this.origin == "local") {
			this.local = true;
			StorageGlobalScopes[this.origin] = this;
		}

		this.origin = msg["storeKey"];
		this.initialized = true;
		
		for(var i=0; i < msg.preloadDataCount; ++i)
		{
			var preload = {};
			if(!this._preloadDataRecvGen(cmd, preload))
				return;
			
			this.data[preload.key] = preload.value;
		}
	},
	
	_getItemCommandCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._getItemCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];
		var value = msg["value"];
		if (error) {
			value = null;
		}

		this.data[key] = value;
		if(!this.usage[key]) {
			this.usage[key] = 1;
		} else {
			this.usage[key]++;
		}

		var cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,value,key);
			this.callbacks[cbId] = null;
		}

		if(((this.lruCacheShrinkCounter++) % KeyValueCache.lruMeanCacheSize) === 0) {
			this.enforceLRUCacheSize();
		}
		return this;
	},
	
	_setItemCommandCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._setItemCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];

		if(!this.usage[key]) {
			this.usage[key] = 1;
		} else {
			this.usage[key]++;
		}
		
		//NgLogD("Storage.setItemCommand Found instance for key [" + key + "]: " + " (" + cbId + ")");

		var cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			//NgLogD("Storage.setItemCommand Found callback");
			cb(error,key);
			this.callbacks[cbId] = null;
		}
		if(((this.lruCacheShrinkCounter++) % KeyValueCache.lruMeanCacheSize) === 0) {
			this.enforceLRUCacheSize();
		}
	},
	
	_removeItemCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._removeItemCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];
		delete this.usage[key];
		delete this.data[key];

		var cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,key);
			this.callbacks[cbId] = null;
		}
	},
	
	_clearCommandCbRecv : function(cmd)
	{
		var msg ={};
		if(!this._clearCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];

		this.data = {};
		this.usage = {};

		var cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,this.origin);
			this.callbacks[cbId] = null;
		}

	},
	
	/**
	 * Enumeration for response types.
	 * @name Responses
	 * @fieldOf Storage.KeyValue#
	 * @ignore
	 */
	
	/**
	 * Register storage.
	 * @name Responses.Register
	 * @fieldOf Storage.KeyValue#
	 * @constant
	 * @ignore
	 */
	
	/**
	 * Get item.
	 * @name Responses.GetItem
	 * @fieldOf Storage.KeyValue#
	 * @constant
	 * @ignore
	 */
	
	/**
	 * Set item.
	 * @name Responses.SetItem
	 * @fieldOf Storage.KeyValue#
	 * @constant
	 * @ignore
	 */
	
	/**
	 * Remove item.
	 * @name Responses.RemoveItem
	 * @fieldOf Storage.KeyValue#
	 * @constant
	 * @ignore
	 */
	
	/**
	 * Clear all items.
	 * @name Responses.Clear
	 * @fieldOf Storage.KeyValue#
	 * @constant
	 * @ignore
	 */
	
// {{?Wg Generated Code}}
	
	// Enums.
	Responses:
	{ 
		Register: 0,
		GetItem: 1,
		SetItem: 2,
		RemoveItem: 3,
		Clear: 4
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 339,
	// Method create = -1
	// Method destroy = 2
	// Method registerCommand = 3
	// Method getItem = 4
	// Method setItem = 5
	// Method removeItem = 6
	// Method clear = 7
	// Method getInstance = 8
	// Method registerCommandCb = 9
	// Method preloadData = 10
	// Method getItemCommandCb = 11
	// Method setItemCommandCb = 12
	// Method removeItemCb = 13
	// Method clearCommandCb = 14
	// Method getItemAsync = 15
	// Method setItemAsync = 16
	// Method removeItemAsync = 17
	// Method clearAsync = 18
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 8:
					instance._getInstanceRecv( cmd );
					break;
				case 9:
					instance._registerCommandCbRecv( cmd );
					break;
				case 10:
					instance._preloadDataRecv( cmd );
					break;
				case 11:
					instance._getItemCommandCbRecv( cmd );
					break;
				case 12:
					instance._setItemCommandCbRecv( cmd );
					break;
				case 13:
					instance._removeItemCbRecv( cmd );
					break;
				case 14:
					instance._clearCommandCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in KeyValue._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in KeyValue._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[339] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_getInstanceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_registerCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 5 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "originalStoreKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "originalStoreKey" ] === undefined )
		{
			NgLogE("Could not parse originalStoreKey in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "preloadDataCount" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "preloadDataCount" ] === undefined )
		{
			NgLogE("Could not parse preloadDataCount in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 5);
		return true;
	},
	
	/** @private */
	_preloadDataRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 2 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 2);
		return true;
	},
	
	/** @private */
	_getItemCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 6 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 5 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_setItemCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 6 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 5 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_removeItemCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 5 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_clearCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x153ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1530002, this );
	},
	
	/** @private */
	_registerCommandSendGen: function( storeKey, lruMeanCacheSize )
	{
		Core.Proc.appendToCommandString( 0x1530003, this, [ Core.Proc.encodeString( storeKey ), +lruMeanCacheSize ] );
	},
	
	/** @private */
	_getItemSendGen: function( storeKey, callbackId, key )
	{
		Core.Proc.appendToCommandString( 0x1530004, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ) ] );
	},
	
	/** @private */
	_setItemSendGen: function( storeKey, callbackId, key, value )
	{
		Core.Proc.appendToCommandString( 0x1530005, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ), Core.Proc.encodeString( value ) ] );
	},
	
	/** @private */
	_removeItemSendGen: function( storeKey, callbackId, key )
	{
		Core.Proc.appendToCommandString( 0x1530006, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ) ] );
	},
	
	/** @private */
	_clearSendGen: function( storeKey, callbackId )
	{
		Core.Proc.appendToCommandString( 0x1530007, this, [ Core.Proc.encodeString( storeKey ), +callbackId ] );
	},
	
	/** @private */
	_getItemAsyncSendGen: function( storeKey, callbackId, key, options )
	{
		Core.Proc.appendToCommandString( 0x153000f, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ), +options ] );
	},
	
	/** @private */
	_setItemAsyncSendGen: function( storeKey, callbackId, key, value, options )
	{
		Core.Proc.appendToCommandString( 0x1530010, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ), Core.Proc.encodeString( value ), +options ] );
	},
	
	/** @private */
	_removeItemAsyncSendGen: function( storeKey, callbackId, key, options )
	{
		Core.Proc.appendToCommandString( 0x1530011, this, [ Core.Proc.encodeString( storeKey ), +callbackId, Core.Proc.encodeString( key ), +options ] );
	},
	
	/** @private */
	_clearAsyncSendGen: function( storeKey, callbackId, options )
	{
		Core.Proc.appendToCommandString( 0x1530012, this, [ Core.Proc.encodeString( storeKey ), +callbackId, +options ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// registerCommand: function( storeKey, lruMeanCacheSize ) {}
	
	// getItem: function( storeKey, callbackId, key ) {}
	
	// setItem: function( storeKey, callbackId, key, value ) {}
	
	// removeItem: function( storeKey, callbackId, key ) {}
	
	// clear: function( storeKey, callbackId ) {}
	
	// _getInstanceRecv: function( cmd ) {}
	// _registerCommandCbRecv: function( cmd ) {}
	// _preloadDataRecv: function( cmd ) {}
	// _getItemCommandCbRecv: function( cmd ) {}
	// _setItemCommandCbRecv: function( cmd ) {}
	// _removeItemCbRecv: function( cmd ) {}
	// _clearCommandCbRecv: function( cmd ) {}
	// getItemAsync: function( storeKey, callbackId, key, options ) {}
	
	// setItemAsync: function( storeKey, callbackId, key, value, options ) {}
	
	// removeItemAsync: function( storeKey, callbackId, key, options ) {}
	
	// clearAsync: function( storeKey, callbackId, options ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,

//Diagnostics collector
	collectDiagnostics: function(type, interval)
	{
		var collectedInfo = {
			getItem: {
				count: this._getItemCount
			},
			setItem: {
				count: this._setItemCount
			},
			removeItem: {
				count: this._removeItemCount
			}
         };

		 return collectedInfo;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/_int_LGL'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/_int_LGL'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/_int_LGL'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/_int_LGL.js';

////////////////////////////////////////////////////////////////////////////////
// Class _int_LGL
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////
function getCorrectedPlatformOS() {
	var os = Capabilities.getPlatformOS();
	switch (os) {
		case 'Android': return 'android';
		case 'iPhone OS': return 'ios';
	}
	return os;
}

function expandTexName(name)
{
	var list =
	{
		"pvr": "GL_IMG_texture_compression_pvrtc",
		"atc": "GL_AMD_compressed_ATC_texture",
		"etc1": "GL_OES_compressed_ETC1_RGB8_texture",
		"3dc": "GL_AMD_compressed_3DC_texture"
	};

	return list[name] || name;
}

var overridePropertyEvaluators = {
	isMatch: function(condition, value) {
		// Return true if the condition holds for the provided value
		// condition may be prefixed with an operator, so we extract it.
		var symbol;
		switch (condition.charAt(0)) {
		case '>':
			symbol = (condition.charAt(1) == '=') ? '>=' : '>';
			break;
		case '<':
			symbol = (condition.charAt(1) == '=') ? '<=' : '<';
			break;
		}
		// Consume any characters we detected, then set the default operation (equals)
		if (symbol) {
			condition = condition.slice(symbol.length);
		} else symbol = '=';

		if (condition == value) {
			return (symbol == '=' || symbol == '<=' || symbol == '>=');
		} else if (condition < value) {
			return (symbol == '<' || symbol == '<=');
		} else {
			return (symbol == '>' || symbol == '>=');
		}
	},

	isVersionMatch: function(condition, value) {
		// Return true if the condition holds for the provided value
		// condition may be prefixed with an operator, so we extract it.
		var symbol;
		if (condition.length > 0) switch (condition.charAt(0)) {
		case '>':
			symbol = (condition.charAt(1) == '=') ? '>=' : '>';
			break;
		case '<':
			symbol = (condition.charAt(1) == '=') ? '<=' : '<';
			break;
		case '=':
			symbol = (condition.charAt(1) == '=') ? '==' : '=';
			break;
		}
		// Consume any characters we detected, or set the default operation (equals)
		if (symbol) {
			condition = condition.slice(symbol.length);
		} else symbol = '=';

		var con = condition.split('.');
		var val = value.split('.');

		var l = Math.max(con.length, val.length);

		for (var i = 0; i < l; i++) {
			var ci = '0.' + (con[i] || 0);
			var vi = '0.' + (val[i] || 0);
			if (ci == vi) continue;
			if (ci < vi) {
				return (symbol == '<' || symbol == '<=');
			} else {
				return (symbol == '>' || symbol == '>=');
			}
		}
		return true;
	},

	'sdkVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getSDKVersion());
	},

	'binaryVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getBinaryVersion());
	},

	'platformOS': function(v) {
		return v == getCorrectedPlatformOS();
	},

	'platformOSVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getPlatformOSVersion());
	},

	'platformHW': function(v) {
		return v == Capabilities.getPlatformHW();
	},

	'physicalMem': function(v) {
		return this.isMatch(v, Capabilities.getPhysicalMem());
	},

	'physicalCpus': function(v) {
		return this.isMatch(v, Capabilities.getPhysicalCpus());
	},

	'activeCpus': function(v) {
		return this.isMatch(v, Capabilities.getActiveCpus());
	},

	'language': function(v) {
		return v == Capabilities.getLanguage();
	},

	'textureMatch': "none",
	'textureCompression': function(v) {
		var matched = Capabilities.getOglExtensions().indexOf(expandTexName(v)) > -1;
		if (matched) this.textureMatch = v;
		return matched;
	},

	'screenWidth': function(v) {
		return this.isMatch(v, Capabilities.getScreenWidth());
	},

	'screenHeight': function(v) {
		return this.isMatch(v, Capabilities.getScreenHeight());
	},

	'screenResolution': function(v) {
		return v == (Capabilities.getScreenWidth() + 'x' + Capabilities.getScreenHeight());
	},

	'screenUnits': function(v) {
		return this.isMatch(v, Capabilities.getScreenUnits());
	},

	'screenPixelUnits': function(v) {
		return this.isMatch(v, Capabilities.getScreenPixelUnits());
	},

	'maxTextureSize': function(v) {
		return this.isMatch(v, Capabilities.getMaxTextureSize());
	},
	
	'reset': function(v) {
		this.textureMatch = "none";
	}
};

var _int_LGL = Class.singleton(
/** @lends Core._int_LGL.prototype */
{
	classname: '_int_LGL',

	initialize: function()
	{
		this._loadCallbacks = {};
	},

	launch: function(url, proc)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		// Default to game proc. Games should actually not be aware of the third option,
		//	as they cannot use it anyway.
		if (!proc)
			proc = _int_LGL.ProcID.Game;

		url = Util.NormalizeUrl(url);

		var run = (function()
		{
			gNgShutdownPending = true;
			this._launchSendGen(url,proc);
		}).bind(this);

		if (proc == _int_LGL.ProcID.Game)
		{
			this.updateGameUse(url, run);
		}
		else
		{
			run();
		}
	},

	loadGame: function(url, callback)
	{
		var Util = require('NGCore/Client/Network/Util').Util;

		url = Util.NormalizeUrl(url);

		this._loadCallbacks[url] = callback;
		this._loadGameSendGen(url);
	},

	_gameLoadedRecv: function( cmd ) {
		var msg = {};
		this._gameLoadedRecvGen(cmd, msg);

		var url = msg.url;

		if(this._loadCallbacks[url])
		{
			var cb = this._loadCallbacks[url];
			delete this._loadCallbacks[url];
			cb();
		}
	},

	launchLoadedGame: function()
	{
		this._launchLoadedGameSendGen();
	},
	
	updateAvailable: function(game, doneCB, errorCB)
	{
		// Normalize URL
		var url = game;
		if (! url.match(/^\//) && !url.match(/https?:\/\//))
			url = '/' + url;

		var caps = require("NGCore/Client/Core/Capabilities").Capabilities;

		// If we are testing ourselves, we don't to md5 our url
		var name = "";
		if (caps.getUrl() != game)
		{
			var Util = require('NGCore/Client/Network/Util').Util;
			url = Util.NormalizeUrl(url);
			name = Util.GetMD5HashDirectoryFromUrl(url);
		}

		// Get device-specific manifest directory
		var buildPath = {"Android" : "android", "iPhone OS" : "ios", "flash" : ""};
		// Get Device capabilities platformOs
		var build = "/" + buildPath[caps.getPlatformOS()];

		var DownloadManifest = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
		var dm = new DownloadManifest();

		dm.isUpdated(url + build, name, false, doneCB, errorCB);
	},

// Utility (non-generated) functionality
	updateGameUse: function(game, doneCB)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		var url = Util.NormalizeUrl(game);
		var name = Util.GetMD5HashDirectoryFromUrl(url);
		var self = this;
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		this.mGameStore = KeyValueCache.global("Core.GameList");
		this.mActiveGameKey = "activeGames";

		// Get our list of games
		this.mGameStore.getItem(this.mActiveGameKey, {},
			function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				var item;
				for (var i in list)
				{
					if (list[i].name == name)
					{
						item = list[i];
						break;
					}
				}

				if (!item)
				{
					item = {"name": name};
					list.push(item);
				}

				item.lastRun = (new Date()).getTime();
				item.url = game;

				self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(list), {});

                LocalGameList.updateGameList(list);
 				doneCB();
			}, true
		);
	},
	
	getManifestName: function(config) {
		var manifestName = 'webgame.ngmanifest';

		if (config && config.manifestOverrides) {
			try {
				var overrides = config.manifestOverrides;

				for (var i = 0; i < overrides.length; i++) {
					var override = overrides[i];
					if (override && override.criteria) {
						// Clear any matched values...
						overridePropertyEvaluators.reset();

						var criteria = override.criteria;
						var key, overrideMatched = true;
						for (key in criteria) {
							if (!criteria.hasOwnProperty(key)) continue;
							var value = criteria[key];

							var evaluator = overridePropertyEvaluators[key];
							if (typeof evaluator != 'function') {
								console.log("ERROR! Undefined criterion " + key + " in configuration.json");
								overrideMatched = false;
								break;
							}

							var criterionMatched = false;
							if (value instanceof Array) {
								for (var vi = 0; vi < value.length; vi++) {
									criterionMatched |= evaluator.call(overridePropertyEvaluators, value[vi]);
									if (criterionMatched) break;
								}
							} else {
								criterionMatched = evaluator(value);
							}

							if (!criterionMatched) {
								overrideMatched = false;
								break;
							}
						}

						// At this point, the override has matched. Figure out its name and return the value.
						if (overrideMatched) {
							console.log("MATCHED Override: " + JSON.stringify(override));

							// Format the override manifest name:
							var format = override.manifest.slice(0);
							for (var fi = 1; fi < format.length; fi++) {
								key = format[fi];
								switch (key) {
								case 'textureCompression':
									format[fi] = overridePropertyEvaluators.textureMatch;
									break;
								case 'platformOS':
									format[fi] = getCorrectedPlatformOS();
									break;
								default:
									// Look up the named property on Capabilities.
									var cap = Capabilities['get' + key.charAt(0).toUpperCase() + key.slice(1)]();
									format[fi] = cap.replace(' ', '_');
								}
							}

							return require('NGCore/Shared/Lib/sprintf').sprintf(format);
						} else {
							console.log("DID NOT MATCH Override: " + JSON.stringify(override));
						}
					}
				}
			} catch (e) {
				console.log("ERROR! Exception occurred in manifest overrides: " + e);
			}
		}

		return manifestName;
	},

// {{?Wg Generated Code}}
	
	// Enums.
	ProcID:
	{ 
		Persist: -1,
		Game: -2
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 342,
	// Method launch = -1
	// Method loadGame = -2
	// Method gameLoaded = -3
	// Method launchLoadedGame = -4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _int_LGL._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -3:
					_int_LGL._gameLoadedRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in _int_LGL._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[342] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$_gameLoadedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _int_LGL.gameLoaded from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _int_LGL.gameLoaded from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_launchSendGen: function( url, proc )
	{
		Proc.appendToCommandString( 0x156ffff, [ Proc.encodeString( url ), +proc ] );
	},
	
	/** @private */
	$_loadGameSendGen: function( url )
	{
		Proc.appendToCommandString( 0x156fffe, [ Proc.encodeString( url ) ] );
	},
	
	/** @private */
	$_launchLoadedGameSendGen: function(  )
	{
		Proc.appendToCommandString( 0x156fffc );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $launch: function( url, proc ) {}
	
	// $loadGame: function( url ) {}
	
	// $_gameLoadedRecv: function( cmd ) {}
	// $launchLoadedGame: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});

exports._int_LGL = _int_LGL;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/LocalGameList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/LocalGameList'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/LocalGameList'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/LocalGameList.js';

////////////////////////////////////////////////////////////////////////////////
// Class LocalGameList
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Proc = require('NGCore/Client/Core/Proc').Proc;
var Class = require('NGCore/Client/Core/Class').Class;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Base64 = require('NGCore/Client/Core/Base64').Base64;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var Util = require('NGCore/Client/Network/Util').Util;
var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;

////////////////////////////////////////////////////////////////////////////////

var LifeListener = MessageListener.subclass(
{
	initialize: function(listen)
	{
		LifecycleEmitter.addListener(this, this.onLifecycleUpdate);
		this._listener = listen;
	},

	destroy: function()
	{
		LifecycleEmitter.removeListener(this);
	},

	onLifecycleUpdate: function(event)
	{
		switch (event)
		{
			case Device.LifecycleEmitter.Event.Resume:
				this._listener.onResume();
				break;
		}
	}
});

exports.LocalGameList = Class.singleton (
/** @lends Core.LocalGameList.prototype */
{
	classname: 'LocalGameList',

	/**
	 * @class The <code>LocalGameList</code> class constructs objects that handle the loading and updating of a user's application list.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @constructs The default constructor.
	 * @singleton
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		new LifeListener(this);
		this.mRefCount = 0;
		this.mRefTable = [];
		this.mSpaceAvailable = 0;
		this.mRequiredAvailableSpace = 0;
		
		this.mSpaceCB = [];

		this._getRepoSpaceSendGen();

		var self = this;
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		this.mGameStore = KeyValueCache.global("Core.GameList");
		this.mActiveGameKey = "activeGames";
		this.onResume();
	},


	/** @private */
	onResume: function()
	{
		this._reloadGameList();
	},

	_reloadGameList: function()
	{
		this.mGameStore.getItem(this.mActiveGameKey, {},
			(function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				this.mGameList = list;
				if (typeof this.mListListen == 'function')
					this.mListListen();
			}).bind(this),
			true
		);
	},

	/** @private */
	setListListener: function(funk)
	{
		this.mListListen = funk;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 302,
	// Method create = -1
	// Method updateGame = 2
	// Method updateDone = 3
	// Method getRepoSpace = 4
	// Method repoSpace = 5
	// Method deleteGame = 6
	// Method _setUpdateProgressVisible = 7
	// Method _setUpdateProgressBounds = 8
	// Method pauseUpdate = 9
	// Method resumeUpdate = 10
	// Method cancelUpdate = 11
	// Method updateProgress = 12
	// Method runGame = 13
	// Method finishGame = 14
	// Method _forwardException = 15
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._updateDoneRecv( cmd );
					break;
				case 5:
					instance._repoSpaceRecv( cmd );
					break;
				case 12:
					instance._updateProgressRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[302] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_updateDoneRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		obj[ "id" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "id" ] === undefined )
		{
			NgLogE("Could not parse id in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_repoSpaceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		obj[ "space" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "space" ] === undefined )
		{
			NgLogE("Could not parse space in LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_updateProgressRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "cur" ] = Proc.parseInt( cmd[ 1 ] );
		if( obj[ "cur" ] === undefined )
		{
			NgLogE("Could not parse cur in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "total" ] = Proc.parseInt( cmd[ 2 ] );
		if( obj[ "total" ] === undefined )
		{
			NgLogE("Could not parse total in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Proc.parseBool( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x12effff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_updateGameSendGen: function( url, id )
	{
		Proc.appendToCommandString( 0x12e0002, this, [ Proc.encodeString( url ), +id ] );
	},
	
	/** @private */
	_getRepoSpaceSendGen: function(  )
	{
		Proc.appendToCommandString( 0x12e0004, this );
	},
	
	/** @private */
	_deleteGameSendGen: function( mdFive )
	{
		Proc.appendToCommandString( 0x12e0006, this, [ Proc.encodeString( mdFive ) ] );
	},
	
	/** @private */
	__setUpdateProgressVisibleSendGen: function( visible )
	{
		Proc.appendToCommandString( 0x12e0007, this, [ ( visible ? 1 : 0 ) ] );
	},
	
	/** @private */
	__setUpdateProgressBoundsSendGen: function( x, y, w, h )
	{
		Proc.appendToCommandString( 0x12e0008, this, [ +x, +y, +w, +h ] );
	},
	
	/** @private */
	_pauseUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( 0x12e0009, this, [ Proc.encodeString( url ) ] );
	},
	
	/** @private */
	_resumeUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( 0x12e000a, this, [ Proc.encodeString( url ) ] );
	},
	
	/** @private */
	_cancelUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( 0x12e000b, this, [ Proc.encodeString( url ) ] );
	},
	
	/** @private */
	_runGameSendGen: function( url )
	{
		Proc.appendToCommandString( 0x12e000d, this, [ Proc.encodeString( url ) ] );
	},
	
	/** @private */
	_finishGameSendGen: function(  )
	{
		Proc.appendToCommandString( 0x12e000e, this );
	},
	
	/** @private */
	__forwardExceptionSendGen: function( exceptionString )
	{
		Proc.appendToCommandString( 0x12e000f, this, [ Proc.encodeString( exceptionString ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// updateGame: function( url, id ) {}
	
	// _updateDoneRecv: function( cmd ) {}
	// getRepoSpace: function(  ) {}
	
	// _repoSpaceRecv: function( cmd ) {}
	// deleteGame: function( mdFive ) {}
	
	// _setUpdateProgressVisible: function( visible ) {}
	
	// _setUpdateProgressBounds: function( x, y, w, h ) {}
	
	// pauseUpdate: function( url ) {}
	
	// resumeUpdate: function( url ) {}
	
	// cancelUpdate: function( url ) {}
	
	// _updateProgressRecv: function( cmd ) {}
	// runGame: function( url ) {}
	
	// finishGame: function(  ) {}
	
	// _forwardException: function( exceptionString ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


	,
	_setProgressVisible: function (progressVisible) {
		this.progressVisible = progressVisible;
		this.__setUpdateProgressVisibleSendGen(progressVisible);
	},
	
	_setProgressBounds: function(bounds) {
		this.__setUpdateProgressBoundsSendGen(bounds[0],bounds[1],bounds[2],bounds[3]);
	},

	/**
	 * Restart the current application.
	 * @returns {void}
	 * @since 1.0.6
	 */
	restartGame: function()
	{
		this.runGame(Capabilities.getServer() + "/" + Capabilities.getGame());
	},

	/**
	 * Launch an application from the specified URL.
	 * @param {String} url The URL of an application. On the Japan platform, use the value
	 *		<code>null</code> to exit the application.
	 * @returns {void}
	 * @since 1.0
	 */
	runGame: function( url )
	{
		console.log("Calling runGame with " + url);
		if (!url)
		{
			console.log("Finishing");
			this._finishGame();
		}
		else
		{
			this._runGameSendGen(Util.NormalizeUrl(url));
		}
	},

	/** 
	 * @private 
	 */
	_finishGame: function()
	{
		this._finishGameSendGen();
	},

	// Next 5 functions are for mobage, not developers.

	// callback = function(gameUrl, dl'd, total, error)
	// mobage responsibility to intercept when dl'd == total, update is finished
	//	or know if there was an error by checking that param

    /**
     * @private
     */
	listenUpdates: function(callback)
	{
		this.mUpdateListener = callback;
	},

    /**
     * @private
     */
	stopUpdateListening: function()
	{
		delete this.mUpdateListener;
	},

    /**
     * @private
     */
	pauseUpdate: function(url)
	{
		this._pauseUpdateSendGen(Util.NormalizeUrl(url));
	},

    /**
     * @private
     */
	resumeUpdate: function(url)
	{
		this._resumeUpdateSendGen(Util.NormalizeUrl(url));
	},

    /**
     * @private
     */
	cancelUpdate: function(url)
	{
		this._cancelUpdateSendGen(Util.NormalizeUrl(url));
	},

	/**
	* Update an application at the specified URL.
	* @example Core.LocalGameList.updateGame(url, (function(err)
	*	{
	*		if (err)
	*		{
	*			NgLogE("GameHub error updating game! " + err);
	*			Network.Util.showSimpleNetworkError();
	*			this._loadingGame = false;
	*		}
	*		else
	*		{
	*			Core.LocalGameList.runGame(url);
	*		}
	*	});
	* @param {String} url The specified URL.
	* @cb {Function} cb The function to call after updating the application.
	* @cb-param {String} err The error message, if any.
	* @cb-returns {void}
	* @returns {Number} The number of additional applications being updated.
	* @status Flash, Test, FlashTested
	* @since 1.0
	*/
	updateGame: function( url , cb )
	{
		var reqId = this.mRefCount;
		this.mRefTable[this.mRefCount++] = cb;

		this._updateGameSendGen( Util.NormalizeUrl(url), reqId );
		return reqId;
	},

	/**
	 * Update and restart the current application without restarting the ngCore binary. Calling this
	 * method is equivalent to calling <code>{@link Core.LocalGameList#runUpdatedGame}</code> and
	 * specifying the current application in the <code>url</code> parameter.
	 * @example
	 * Core.LocalGameList.updateAndRestartCurrentGame();
	 * @returns {void}
	 * @since 1.7
	 */
	updateAndRestartCurrentGame : function()
	{
		this.runUpdatedGame(Capabilities.getUrl());
		OrientationEmitter.setInterfaceOrientation(OrientationEmitter.Orientation.Portrait, false);
	},

	/**
	* Launch an updated application from the specified URL.
	* @example Core.LocalGameList.runUpdatedGame('/games/MyGames');
	* @param {String} url The specified URL of an updated application.
	* @returns {void}
	* @status Flash, Test, FlashTested
	* @since 1.0
	*/
	runUpdatedGame: function (url)
	{
		if (!url)
		{
			this._finishGame();
			return;
		}

		this.updateGame(url,
			(function(err)
			{
				if (err)
				{
					NgLogE("LGL Error updating game! " + err);
					Util.showFatalErrorDialog();
				}
				else
				{
					this.runGame(url);
				}
			}).bind(this)
		);
	},

	_updateProgressRecv: function( cmd )
	{
		var obj = {};
		this._updateProgressRecvGen(cmd, obj);
		if (this.mUpdateListener)
			this.mUpdateListener(obj.url, obj.cur, obj.total, obj.error);
	},

	_updateDoneRecv: function( cmd )
	{
		var obj = {};
		this._updateDoneRecvGen(cmd, obj);

		this._reloadGameList();

		var cb = this.mRefTable[obj.id];
		if (cb)
		{
			cb(obj.error);
		}

		delete this.mRefTable[obj.id];
		this._getRepoSpaceSendGen();
	},

	_repoSpaceRecv: function( cmd )
	{
		var obj = {};
		this._repoSpaceRecvGen(cmd, obj);
		this.mSpaceAvailable = obj.space - 7340032; // KJ report 7mb less
		console.log('LocalGameList.got response:', this.mSpaceAvailable, 'and need:', this.mRequiredAvailableSpace);
		
		if(this.mRequiredAvailableSpace > this.mSpaceAvailable)
		{
			var errorAlert = new UI.AlertDialog();
			errorAlert.setText(Core.Localization.getString("SD card is full"));
			errorAlert.setChoices([Core.Localization.getString("Exit")]);
			errorAlert.game = this.game;
			errorAlert.onchoice = function(ret)
			{
				errorAlert.hide();
				LifecycleEmitter.exitProcess();
			};
			errorAlert.show();
		}
		else
		{
			for(var i=0; i < this.mSpaceCB.length; ++i)
			{
				this.mSpaceCB[i]();
			}
			this.mSpaceCB = [];
			this.mRequiredAvailableSpace = 0;
		}
	},

	/**
	 * @private
	 */
	getGameList: function()
	{
		// Caveat! This will return an empty list if it is the first call. Must initialize beforehand.-KJ
		return this.mGameList;
	},

	/**
	 * @private
	 */
	updateGameList: function(list)
	{
		this.mGameList = list;
	},

	/**
	 * @private
	 */
	freeSpace: function(space, cb)
	{
		this.mRequiredAvailableSpace += space;
		
		this.mSpaceCB.push(cb);
		console.log('LocalGameList.freeSpace space=', this.mRequiredAvailableSpace);
		if(this.mSpaceCB.length == 1)
		{
			console.log('LocalGameList.sending request to native');
			// Send request to native if this is the first requester.
			this._getRepoSpaceSendGen();
		}
	},

	/**
	 * @private
	 */
	deleteGame: function(url)
	{
		url = Util.NormalizeUrl(url);
		var hash = toMD5(url);
		this._deleteGameSendGen(hash);

		var self = this;
		var doneCB = function ()
		{
			NgLogD("LocalGameList finished deleting game from " + self.mActiveGameKey + " for " + hash );
		};

		// Update cached game list to match what's going to happen outside of game proc.
		// Matches logic in _LocalGameList._deleteGameFromStorage, but doesn't
		// write to Storage key.
		if( this.mGameList )
		{
			var list = this.mGameList;
			var good = false;
			var ind;
			var out = [];
			for(ind = 0; ind < list.length; ++ind)
			{
				if(list[ind].name == hash)
					good = true;
				else
					out.push(list[ind]);
			}

			if( good )
			{
				NgLogD("LocalGameList found and removed " + hash);
				this.mGameList = out;
			}
			else
				NgLogD("LocalGameList failed to find and remove " + hash);
		}
		else
			NgLogD("LocalGameList cache not warm, can't remove " + hash);
	},

	/**
	 * Check if an update is available for the specified application.<br /><br />
	 * The following code illustrates how to retrieve an application name to pass in for this call.
	 * @param {String} game The specified game. Use <code>{@link Core.Capabilities#getGame}</code> to return the game name.
	 * @cb {Function} doneCB The function to call after checking for an update.
	 * @cb-param {Boolean} updated Set to <code>true</code> if an update is available for the
	 *		application.
	 * @cb-param {Number} spaceNeeded The amount of space, in bytes, that is required to download
	 *		the update.
	 * @cb-returns {void}
	 * @cb {Function} errorCB The function to call if an error occurs.
	 * @cb-param {String} err The error message, if any.
	 * @cb-returns {void}
	 * @example
	 *
	 * updateButton.onclick = function() {
	 *     LocalGameList.updateAvailable(Core.Capabilities.getUrl(), function(updated, spaceNeeded) {
	 *         if (updated)
	 *             LGL.runUpdatedGame(Core.Capabilities.getUrl());
	 *     },
     *     function (error) {
     *         console.log("An error occurred while checking for an application update: " + error);
	 *     });
	 * };
	 * @returns {void}
	 * @status
	 * @since 1.0
	 */
	updateAvailable: function(game, doneCB, errorCB)
	{
		var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
		_int_LGL.updateAvailable(game, doneCB, errorCB);
	},

	_forwardException: function( exceptionString )
	{
		this.__forwardExceptionSendGen(exceptionString);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage/FileSystem'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage/FileSystem'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage/FileSystem'] = exports; 
var __dirname = 'NGCore/Client/Storage';
var __filename = 'NGCore/Client/Storage/FileSystem.js';

////////////////////////////////////////////////////////////////////////////////
// Class FileSystem
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;
var Diagnostics = require('NGCore/Client/Storage/Diagnostics').Diagnostics;

////////////////////////////////////////////////////////////////////////////////

var FSError = function(code, description) {
	this.code = code;
	this.description = description;
	return this;
};

FSError.prototype = {
	classname:"FileSystemError",
	toString: function() {
		return this.className + " " + this.code + ": " + this.description;
	}
};

exports.FileSystem = Core.Class.singleton(
/** @lends Storage.FileSystem.prototype */
{
	classname: 'FileSystem',

  /** @private */
  _options: {
    blocking    : 0x0001, /* legacy blocking(main thread) mode operation for backward compatibility */
    binary      : 0x0002,
    useBinaryCb : 0x0004, /* if _NOT_ set, uses readFileCb for returning binary (legacy) */
    returnFiles : 0x0100,
    returnMd5   : 0x0200
  },
	
	/**
	 * @class The `Storage.FileSystem` class constructs a singleton object that enables an 
	 * application to work with files stored on a device. Use this class to read, write, rename, 
	 * delete, decompress, and retrieve information about files.
	 *
	 * The files you store with `Storage.FileSystem` are not tied to a specific Mobage user. If you 
	 * need to store user-specific files, verify that your application is storing and retrieving 
	 * files for the correct Mobage user. Keep in mind that several different Mobage users could all
	 * use the same application on the same device.
	 * @singleton
	 * @constructs
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		/** @private */
		this.readRequests = {};
		/** @private */
		this.writeRequests = {};
        /** @private */
		this.statRequests = {};
		/** @private */
		this.cbIdCounter = 1;

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._readCount = 0;
		this._writeCount = 0;
		this._deleteCount = 0;
		this._renameCount = 0;
		this._decompressCount = 0;
		this._statCount = 0;

		Diagnostics.pushCollector(this.collectDiagnostics.bind(this));
	},

	/**
	 * Read a file into memory from local storage. Calling this method is equivalent to calling
	 * `{@link Storage.FileSystem#readFileIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * // Read a binary-format game level into memory.
	 * var levelName = "level.bin";
	 *
	 * // Call readFile(), and use the options parameter to indicate that the file is in
	 * // binary format.
	 * Storage.FileSystem.readFile(levelName, { binary: true }, function(err, data) {
	 *     if (err) {
	 *         console.log("An error occurred while reading " + fileName + ": " + err);
	 *     } else {
	 *         // parse the game level file
	 *     }	
	 * });
	 * @param {String} fname The name of the file to read into memory.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to read the file synchronously
	 *		(i.e., the application pauses until the entire file is read). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot
	 *		function without synchronous file access.
	 * @param {Boolean} [options.binary=false] Set to `true` to assume that the file is in binary
	 *		format.
	 * @cb {Function} cb The function to call after reading the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {String} [data] The file data, if the file loaded successfully.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	readFile: function( fname, options, cb )
	{
		this.readFileIn(this.Store.Local, fname, options, cb);
	},
	
	/**
	 * Deprecated signature for reading a file into memory from local storage.
	 * @name readFile^2
	 * @function
	 * @memberOf Storage.FileSystem#
	 * @deprecated Since version 1.4.1. Use the signature readFile(fname, options, cb) rather than
	 * this signature.
	 * @example
	 * Storage.FileSystem.readFile("filename", true, function(err, data) {
	 *     // Add callback code.
	 * });
	 * @param {String} fname The name of the file to read into memory.
	 * @param {Boolean} [binary=false] Set to `true` if `readFile()` should assume that the file is
	 *		in binary format.
	 * @cb {Function} cb The function to call after reading the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {String} [data] The file data, if the file loaded successfully.
	 * @cb-returns {void}
	 * @returns {void}
	 */

	/**
	 * Read a file into memory from a specified local file store. There are separate stores for
	 * persistent files, which are intended to be saved between application sessions, and temporary
	 * files, which can be deleted at any time.
	 * @example
	 * // Cache a user's first name.
	 * var firstName = "Danielle";
	 * Storage.FileSystem.writeFileIn(Storage.FileSystem.Store.Temp, "first-name.txt", 
	 *   firstName, {}, function (err) {
	 *     if (err) {
	 *         console.log("An error occurred while writing " + fileName + ": " + err);
	 *     } else {
	 *         // Read the user's first name.
	 *         Storage.FileSystem.readFileIn(Storage.FileSystem.Store.Temp,
	 *           "first-name.txt", {}, function(err, data) {
	 *             if (err) {
	 *                 console.log("An error occurred while reading " + fileName + 
	 *                   ": " + err);
	 *             } else {
	 *                 console.log("The user's first name is " + data);
	 *             }
	 *         });
	 *     }	
	 * });
	 * @param {Storage.FileSystem#Store} store The local file store to read from. Use
	 *		`Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} fname The name of the file to read into memory.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to read the file synchronously
	 *		(i.e., the application pauses until the entire file is read). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot
	 *		function without synchronous file access.
	 * @param {Boolean} [options.binary=false] Set to `true` to assume that the file is in binary
	 *		format.
	 * @cb {Function} cb The function to call after reading the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {String} [data] The file data, if the file loaded successfully.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	readFileIn: function( store, fname, options, cb )
	{
		var op, cbId = 0;

		this._readCount++;

		if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.readFile/readFileIn(): using deprecated function signature");
      var binary = options;

      if(typeof(binary) == 'function')
      {
        cb = binary;
        binary = false;
      }
      binary = binary || false;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.readRequests[ cbId ] = cb;
      }

      op = this._options.blocking;
      if (binary)
          op |= this._options.binary | this._options.useBinaryCb;
      this._readFileAsyncSendGen(cbId,store,fname,op);
    }
    else
    {
      op = 0;
      if(options['blocking'])
        op |= this._options.blocking;
      if(options['binary'])
        op |= this._options.binary | this._options.useBinaryCb;

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.readRequests[ cbId ] = cb;
      }

      this._readFileAsyncSendGen(cbId,store,fname,op);
    }
	},

	/**
	 * Write a file to local storage. Calling this method is equivalent to calling
	 * `{@link Storage.FileSystem#writeFileIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * var fileName = "write_test";
	 * var data = "test data";
	 * 
	 * Storage.FileSystem.writeFile(fileName, data, {}, function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while reading " + fileName + ": " + err);
	 *     }	
	 * });
	 * @param {String} fname The name of the file to write into storage.
	 * @param {Binary, String} data The data to write to the file.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to write the file synchronously
	 *		(i.e., the application pauses until the entire file is written). This option can
	 *		cause significant delays on some devices and should be used only if your application
	 *		cannot function without synchronous file access.
	 * @param {Boolean} [options.binary=false] Set to `true` to assume that the data is in binary
	 *		format.
	 * @cb {Function} cb The function to call after writing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	writeFile: function( fname, data, options, cb )
	{
		this.writeFileIn(this.Store.Local, fname, data, options, cb);
	},

	/**
	 * Deprecated signature for writing a file to local storage.
	 * @name writeFile^2
	 * @function
	 * @memberOf Storage.FileSystem#
	 * @deprecated Since version 1.4.1. Use the signature writeFile(fname, data, options, cb)
	 * rather than this signature.
	 * @example
	 * Storage.FileSystem.writeFile("filename", true, function(err) {
	 *     // Add callback code.
	 * });
	 * @param {String} fname The name of the file to write into storage.
	 * @param {Boolean} [binary=false] Set to `true` if `writeFile()` should assume that the file is
	 *		in binary format.
	 * @cb {Function} cb The function to call after writing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 */

	/**
	 * Write a file to a specified local file store. There are separate stores for persistent files,
	 * which are intended to be saved between application sessions, and temporary files, which can
	 * be deleted at any time.
	 * @example
	 * var fileName = "write_test";
	 * var data = "test data";
	 * 
	 * Storage.FileSystem.writeFileIn(Storage.FileSystem.Store.Temp, fileName, 
	 *   data, {}, function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while reading " + fileName + ": " + err);
	 *     }
	 * });
	 * @param {Storage.FileSystem#Store} store The local file store to write to. Use
	 *		`Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} fname The name of the file to write into storage.
	 * @param {Binary, String} data The data to write to the file.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to write the file synchronously
	 *		(i.e., the application pauses until the entire file is written). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot 
	 *		function without synchronous file access.
	 * @param {Boolean} [options.binary=false] Set to `true` to assume that the data is in binary 
	 *		format.
	 * @cb {Function} cb The function to call after writing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	writeFileIn: function( store, fname, data, options, cb )
	{
		var cbId = 0;

		this._writeCount++;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.writeFile/writeFileIn(): using deprecated function signature");
      var binary = options;

      if(typeof(binary) == 'function')
      {
        cb = binary;
        binary = false;
      }
      binary = binary || false;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }

      this._writeFileSendGen(cbId,store,fname,data,binary);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;
      if(options['binary'])
        op |= this._options.binary;

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }

      if((op & this._options.binary) !== 0 && Core.Capabilities.compareBinaryVersion(1, 4) >= 0)
        this._writeFileAsyncBinarySendGen(cbId,store,fname,data,op);
      else
        this._writeFileAsyncSendGen(cbId,store,fname,data,op);
    }
	},

	/**
	 * Delete a file from local storage. Calling this method is equivalent to calling
	 * `{@link Storage.FileSystem#deleteFileIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * var fileName = "delete_test";
	 * 
	 * Storage.FileSystem.deleteFile(fileName, {}, function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while deleting " + fileName + ": " + err);
	 *     }	
	 * });
	 * @param {String} fname The name of the file to delete.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to delete the file synchronously
	 *		(i.e., the application pauses until the entire file is deleted). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot 
	 *		function without synchronous file access.
	 * @cb {Function} cb The function to call after deleting the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	deleteFile: function ( fname, options, cb )
	{
		this.deleteFileIn(this.Store.Local, fname, options, cb);
	},

	/**
	 * Deprecated signature for deleting a file from local storage.
	 * @name deleteFile^2
	 * @function
	 * @memberOf Storage.FileSystem#
	 * @deprecated Since version 1.4.1. Use the signature deleteFile(fname, options, cb) rather
	 * than this signature.
	 * @example
	 * Storage.FileSystem.deleteFile("filename", function(err) {
	 *     // Add callback code.
	 * });
	 * @param {String} fname The name of the file to delete.
	 * @cb {Function} cb The function to call after deleting the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 */

	/**
	 * Delete a file from a specified local file store. There are separate stores for persistent 
	 * files, which are intended to be saved between application sessions, and temporary files, 
	 * which can be deleted at any time.
	 * @example
	 * var fileName = "delete_test";
	 * 
	 * Storage.FileSystem.deleteFile(Storage.FileSystem.Store.Temp, fileName, {},
	 *   function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while deleting " + fileName + ": " + err);
	 *     }	
	 * });
	 * @param {Storage.FileSystem#Store} store The local file store to delete from. Use
	 *		`Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} fname The name of the file to delete.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to delete the file synchronously
	 *		(i.e., the application pauses until the entire file is deleted). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot 
	 *		function without synchronous file access.
	 * @cb {Function} cb The function to call after deleting the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	deleteFileIn: function ( store, fname, options, cb )
	{
		var cbId = 0;

		this._deleteCount++;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.deleteFile/deleteFileIn(): using deprecated function signature");
      cb = options;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._deleteFileSendGen(cbId,store,fname);
    }
    else
    {
      var op = 0;

      if(options['blocking'])
      {
        op |= this._options.blocking;
      }

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._deleteFileAsyncSendGen(cbId, store, fname, op);
    }
	},
	
	/**
	 * Decompress a .zip file from local storage. Calling this method is equivalent to calling
	 * `{@link Storage.FileSystem#decompressFileIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * var fileName = "unzip_test";
	 * var fileDir = "dir_test";
	 * 
	 * Storage.FileSystem.decompressFile(fileName, fileDir, {}, function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while decompressing " + fileName +
	 *           ": " + err);
	 *     }	
	 * });
	 * @example
	 * var fileName = "unzip_test";
	 * var fileDir = "dir_test";
	 * 
	 * Storage.FileSystem.decompressFile(fileName, fileDir, { returnFiles: true },
	 *   function(err, files) {
	 *     if (err) {
	 *         console.log("An error occurred while decompressing " + fileName +
	 *           ": " + err);
	 *     } else {
	 *         for (var i = 0; files[i]; i++) {
	 *             console.log("The file " + files[i].name + " has the MD5 hash " +
	 *               files[i].hash + " and is " + files[i].size + " bytes");
	 *         }
	 *     }
	 * });
	 * @param {String} fname The name of the .zip file to decompress.
	 * @param {String} destination The directory where the contents of the decompressed file are
	 *		stored.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to decompress the file synchronously
	 *		(i.e., the application pauses until the entire file is decompressed). This option can
	 *		cause significant delays on some devices and should be used only if your application
	 *		cannot function without synchronous file access.
	 * @param {Boolean} [options.returnFiles=false] If this is set to `true`, an array will be
	 *		passed to the callback function containing a list of the files that were decompressed,
	 *		each file's MD5 hash, and each file's size in bytes.
	 * @cb {Function} cb The function to call after decompressing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {Object[]} [files] Information about the files that were decompressed.
	 * @cb-param {String} [files[].name] The relative path of the file that was decompressed.
	 * @cb-param {String} [files[].hash] The MD5 hash of the file.
	 * @cb-param {Number} [files[].size] The file's size in bytes.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.0
	 */
	decompressFile: function( fname, destination, options, cb )
	{
		this.decompressFileIn(this.Store.Local, fname, destination, options, cb);
	},
	
	/**
	 * Deprecated signature for decompressing a .zip file.
	 * @name decompressFile^2
	 * @function
	 * @memberOf Storage.FileSystem#
	 * @deprecated Since version 1.4.1. Use the signature decompressFile(fname, destination,
	 * options, cb) rather than this signature.
	 * @example
	 * Storage.FileSystem.decompressFile("filename", "dir_test", true,
	 *   function(err, files) {
	 *     // Add callback code.
	 * });
	 * @param {String} fname The name of the .zip file to decompress.
	 * @param {String} destination The directory path where the contents of the decompressed file
	 *		are written.
	 * @param {Boolean} [returnFiles=false] If this is set to `true`, an array will be passed to the
	 *		callback function containing a list of the files that were decompressed, each file's MD5
	 *		hash, and each file's size in bytes.
	 * @cb {Function} cb The function to call after decompressing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {Object[]} [files] Information about the files that were decompressed.
	 * @cb-param {String} [files[].name] The relative path of the file that was decompressed.
	 * @cb-param {String} [files[].hash] The MD5 hash of the file.
	 * @cb-param {Number} [files[].size] The file's size in bytes.
	 * @cb-returns {void}
	 * @returns {void}
	 */

	/**
	 * Decompress a .zip file in a specified local file store. There are separate stores for
	 * persistent files, which are intended to be saved between application sessions, and temporary 
	 * files, which can be deleted at any time.
	 * @example
	 * var fileName = "unzip_test";
	 * var fileDir = "dir_test";
	 * 
	 * Storage.FileSystem.decompressFileIn(Storage.FileSystem.Store.Temp, fileName,
	 *   fileDir, {}, function(err) {
	 *     if (err) {
	 *         console.log("An error occurred while decompressing " + fileName + 
	 *           ": " + err);
	 *     }	
	 * });
	 * @example
	 * var fileName = "unzip_test";
	 * var fileDir = "dir_test";
	 * 
	 * Storage.FileSystem.decompressFileIn(Storage.FileSystem.Store.Temp, fileName,
	 *   fileDir, { returnFiles: true }, function(err, files) {
	 *     if (err) {
	 *         console.log("An error occurred while decompressing " + fileName + 
	 *           ": " + err);
	 *     } else {
	 *         for (var i = 0; files[i]; i++) {
	 *             console.log("The file " + files[i].name + " has the MD5 hash " + 
	 *               files[i].hash + " and is " + files[i].size + " bytes");
	 *         }
	 *     }
	 * });
	 * @param {Storage.FileSystem#Store} store The local file store for the .zip file to decompress. 
	 *		Use `Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} fname The name of the .zip file to decompress.
	 * @param {String} destination The directory where the contents of the decompressed file are
	 *		stored.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to decompress the file synchronously
	 *		(i.e., the application pauses until the entire file is decompressed). This option can
	 *		cause significant delays on some devices and should be used only if your application 
	 *		cannot function without synchronous file access.
	 * @param {Boolean} [options.returnFiles=false] If this is set to `true`, an array will be
	 *		passed to the callback function containing a list of the files that were decompressed,
	 *		each file's MD5 hash, and each file's size in bytes.
	 * @cb {Function} cb The function to call after decompressing the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-param {Object[]} [files] Information about the files that were decompressed.
	 * @cb-param {String} [files[].name] The relative path of the file that was decompressed.
	 * @cb-param {String} [files[].hash] The MD5 hash of the file.
	 * @cb-param {Number} [files[].size] The file's size in bytes.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android    
	 * @since 1.0
	 */
	decompressFileIn: function( store, fname, destination, options, cb )
	{
		var cbId = 0;

		this._decompressCount++;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.decompressFile/decompressFileIn(): using deprecated function signature");
      var returnFiles = options;
      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._decompressFileSendGen(cbId,store,fname,destination,returnFiles);
    }
    else
    {
      var op = 0;

      if(options['blocking'])
      {
        op |= this._options.blocking;
      }
      if(options['returnFiles'])
      {
        op |= this._options.returnFiles;
      }

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._decompressFileAsyncSendGen(cbId, store, fname, destination, op);
    }
	},
	
	/**
	 * Rename a file on local storage. Calling this method is equivalent to calling
	 * `{@link Storage.FileSystem#renameFileIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * var filenameOld = "important_file.txt";
	 * var filenameNew = "important_file.xml";
	 *
	 * Storage.FileSystem.writeFile(filenameOld, "test", {}, function (err) {
	 *     if (err) {
	 *         log("An error occurred while writing " + filenameOld + ": " + err);
	 *     } else {
	 *         Storage.FileSystem.renameFile(filenameOld, filenameNew, {},
	 *           function(err) {
	 *             if (err) {
	 *                 log("An error occurred while renaming the file: " + err);
	 *             }
	 *         });
	 *     }
	 * });
	 * @param {String} oldPath The full path of the file to rename.
	 * @param {String} newPath The full path of the file's new name.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to rename the file synchronously
	 *		(i.e., the application pauses until the file is renamed). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot
	 *		function without synchronous file access.
	 * @cb {Function} cb The function to call after renaming the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.4.1
	 */
	renameFile: function ( oldPath, newPath, options, cb )
	{
		this.renameFileIn(this.Store.Local, oldPath, newPath, options, cb);
	},
	/**
	 * Rename a file in a specified local file store. There are separate stores for persistent
	 * files, which are intended to be saved between application sessions, and temporary files, 
	 * which can be deleted at any time.
	 * @example
	 * var filenameOld = "temp_file.txt";
	 * var filenameNew = "temp_file.xml";
	 *
	 * Storage.FileSystem.writeFileIn(Storage.FileSystem.Store.Temp, filenameOld,
	 *   "test", {}, function (err) {
	 *     if (err) {
	 *         log("An error occurred while writing " + filenameOld + ": " + err);
	 *     } else {
	 *         fileSys.renameFileIn(Storage.FileSystem.Store.Temp, filenameOld,
	 *           filenameNew, {}, function(err) {
	 *             if (err) {
	 *                 log("An error occurred while renaming the file: " + err);
	 *             }
	 *         });
	 *     }
	 * });
	 * @param {Storage.FileSystem#Store} store The local file store for the file to rename. Use
	 *		`Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} oldPath The full path of the file to rename.
	 * @param {String} newPath The full path of the file's new name.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to rename the file synchronously
	 *		(i.e., the application pauses until the file is renamed). This option can cause
	 *		significant delays on some devices and should be used only if your application cannot
	 *		function without synchronous file access.
	 * @cb {Function} cb The function to call after renaming the file.
	 * @cb-param {String} [err] The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.4.1
	 */
	renameFileIn: function ( store, oldPath, newPath, options, cb )
	{
		var cbId = 0;
		var op = 0;

		this._renameCount++;

		if(Core.Capabilities.compareBinaryVersion(1, 4) < 0)
		{
			if(typeof(options) == 'function')
			{
				cb = options;
			}
		
			if(cb)
			{
				cb('Not supported');
			}

			return;
		}

		if(typeof(options) !== 'object')
		{
			// assume 'options' arg is not supplied.
			// default behavior is non-blocking.
			cb = options;
		}
		else
		{
			if(options['blocking'])
			{
				op |= this._options.blocking;
			}
		}

		if(cb)
		{
			cbId = this.cbIdCounter++;
			this.writeRequests[ cbId ] = cb;
		}
		this._renameFileAsyncSendGen(cbId, store, oldPath, newPath, op);
	},
	/**
	 * Retrieve information about a file on local storage. Calling this method is equivalent to 
	 * calling `{@link Storage.FileSystem#statIn}` with the `store` parameter set to
	 * `Storage.FileSystem.Store.Local`.
	 * @example
	 * var newFileName = "important_file.txt";
	 *
	 * Storage.FileSystem.writeFile(newFileName, "test", {}, function (err) {
	 *     if (err) {
	 *         log("An error occurred while writing " + newFileName + ": " + err);
	 *     } else {
	 *         Storage.FileSystem.stat(newFileName, {}, function(err, stats) {
	 *             if (err) {
	 *                 log("An error occurred while retrieving file information: " + 
	 *                   JSON.stringify(err));
	 *             }
	 *             else {
	 *                 log("Retrieved file information: " + JSON.stringify(stats));
	 *             }
	 *         });
	 *     }
	 * });
	 * @param {String} filePath The full path of the file for which to retrieve information.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to retrieve information about the
	 *		file synchronously (i.e., the application pauses until the information is obtained).
	 *		This option can cause significant delays on some devices and should be used only if your
	 *		application cannot function without synchronous file access.
	 * @param {Boolean} [options.returnMd5=false] Set to `true` to retrieve the MD5 hash of the
	 *		file's contents. Available since ngCore 1.7.
	 * @cb {Function} cb The function that is called after retrieving information about the file.
	 * @cb-param {Object} [err] Information about the error, if any.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {Storage.FileSystem#ErrorCode} [err.code] A code identifying the type of
	 *		error.
	 * @cb-param {Object} [stats] Information about the file.
	 * @cb-param {Number} [stats.atime] The time when the file was last accessed. Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {Number} [stats.ctime] The time when the file's status was last changed (for 
	 *		example, the file was modified, or its owner or permissions changed). Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {String} [stats.hash] The MD5 hash of the file's contents. Returned only if the
	 *		parameter `options.returnMd5` is set to `true`. Available since ngCore 1.7.
	 * @cb-param {Number} [stats.mtime] The time when the file was last modified. Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {Number} [stats.size] The size of the file, in bytes.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.6
	 */
	stat: function ( filePath, options, cb )
	{
		this.statIn(this.Store.Local, filePath, options, cb);
	},
	/**
	 * Retrieve information about a file in a specified local file store. There are separate stores 
	 * for persistent files, which are intended to be saved between application sessions, and 
	 * temporary files, which can be deleted at any time.
	 * @example
	 * var newFileName = "temp_file.txt";
	 *
	 * Storage.FileSystem.writeFileIn(Storage.FileSystem.Store.Temp, newFileName,
	 *   "test", {}, function (err) {
	 *     if (err) {
	 *         log("An error occurred while writing " + newFileName + ": " + err);
	 *     } else {
	 *         Storage.FileSystem.statIn(Storage.FileSystem.Store.Temp, newFileName, 
	 *           {}, function(err, stats) {
	 *             if (err) {
	 *                 log("An error occurred while retrieving file information: " + 
	 *                   JSON.stringify(err));
	 *             }
	 *             else {
	 *                 log("Retrieved file information: " + JSON.stringify(stats));
	 *             }
	 *         });
	 *     }
	 * });
	 * @param {Object} store The local file store for the file for which to retrieve information.
	 *		Use `Storage.FileSystem.Store.Local` for persistent files and
	 *		`Storage.FileSystem.Store.Temp` for temporary files.
	 * @param {String} filePath The full path of the file for which to retrieve information.
	 * @param {Object} options Options for the method call.
	 * @param {Boolean} [options.blocking=false] Set to `true` to retrieve information about the
	 *		file synchronously (i.e., the application pauses until the information is obtained).
	 *		This option can cause significant delays on some devices and should be used only if your
	 *		application cannot function without synchronous file access.
	 * @param {Boolean} [options.returnMd5=false] Set to `true` to retrieve the MD5 hash of the
	 *		file's contents. Available since ngCore 1.7.
	 * @cb {Function} cb The function that is called after retrieving information about the file.
	 * @cb-param {Object} [err] Information about the error, if any.
	 * @cb-param {String} [err.description] A description of the error.
	 * @cb-param {Storage.FileSystem#ErrorCode} [err.code] A code identifying the type of
	 *		error.
	 * @cb-param {Object} [stats] Information about the file.
	 * @cb-param {Number} [stats.atime] The time when the file was last accessed. Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {Number} [stats.ctime] The time when the file's status was last changed (for 
	 *		example, the file was modified, or its owner or permissions changed). Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {String} [stats.hash] The MD5 hash of the file's contents. Returned only if the
	 *		parameter `options.returnMd5` is set to `true`. Available since ngCore 1.7.
	 * @cb-param {Number} [stats.mtime] The time when the file was last modified. Expressed in
	 *		Unix time (milliseconds since 00:00:00 UTC on January 1, 1970).
	 * @cb-param {Number} [stats.size] The size of the file, in bytes.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.6
	 */
	statIn: function ( store, filePath, options, cb )
	{
		var cbId = 0;
		var op = 0;

		this._statCount++;

		if(Core.Capabilities.compareBinaryVersion(1, 6) < 0)
		{
			if(typeof(options) == 'function')
			{
				cb = options;
			}

			if(cb)
			{
				cb(new FSError(this.ErrorCode.Unsupported, "Not Supported"));
			}

			return;
		}

		if(typeof(options) !== 'object')
		{
			// assume 'options' arg is not supplied.
			// default behavior is non-blocking.
			cb = options;
		}
		else
		{
			if(options['blocking'])
			{
				op = this._options.blocking;
			}
			if(options['returnMd5'])
			{
				op |= this._options.returnMd5;
			}
		}

		if(cb)
		{
			cbId = this.cbIdCounter++;
			this.statRequests[ cbId ] = cb;
		}

		this._statAsyncSendGen(cbId, store, filePath, op);
	},

	/**
	 * Enumeration for local file stores.
	 * @name Store
	 * @fieldOf Storage.FileSystem#
	 */
	
	/**
	 * Temporary file store. Used for files that can be deleted at any time.
	 * @name Store.Temp
	 * @fieldOf Storage.FileSystem#
	 * @constant
	 */
	
	/**
	 * Persistent file store. Used for files that are intended to be saved between application
	 * sessions.
	 * @name Store.Local
	 * @fieldOf Storage.FileSystem#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for errors that occurred during a request.
	 * @name ErrorCode
	 * @fieldOf Storage.FileSystem#
	 */
	
	/**
	 * The file was not found.
	 * @name ErrorCode.NotFound
	 * @fieldOf Storage.FileSystem#
	 * @constant
	 */
	
	/**
	 * An unknown error occurred.
	 * @name ErrorCode.Unknown
	 * @fieldOf Storage.FileSystem#
	 * @constant
	 */
	
	/**
	 * The requested operation is not available.
	 * @name ErrorCode.Unsupported
	 * @fieldOf Storage.FileSystem#
	 * @constant
	 */

	

	/**
	  * @private
	  */
	registerManifest: function ( manifest, cb )
	{
		// left for source code-level compatibility from < 1.6
		if ( cb )
		{
			cb( "" );
		}
	},
	
	/**
	 * @private
	 */
        _readFileCbRecv: function(cmd)
        {
		var msg = {};
		if(!this._readFileCbRecvGen(cmd, msg))
			return;
                this._readFileCbRecvCore(msg["callbackId"], msg["data"], msg["error"]);
        },

	/**
	 * @private
	 */
        _readFileBinaryCbRecv: function(cmd)
        {
		var msg = {};
		if(!this._readFileBinaryCbRecvGen(cmd, msg))
			return;
                this._readFileCbRecvCore(msg["callbackId"], msg["data"], msg["error"]);
        },

	_readFileCbRecvCore: function(cbId, data, err)
	{
		if ( !cbId )
		{
			NgLogE ( "FileSystem.onReadFile: No cbId" );
			return;
		}
		
		var cb = this.readRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem.onReadFile: No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.readRequests[ cbId ];
		cb ( err, data );
	},
	
	/**
	 * @private
	 */
	_writeFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._writeFileCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
			
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}

		delete this.writeRequests[ cbId ];
		cb ( err );
	},
	
	/**
	 * @private
	 */
	_deleteFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._deleteFileCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.writeRequests[ cbId ];
		cb ( err );
	},
	
	/**
	 * @private
	 */
	_decompressFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._decompressFileCbRecvGen(cmd, msg))
			return;
			
		var cbId = msg[ "callbackId" ];
		var files = msg[ "files" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		try
		{
			files = JSON.parse(files);
		}
		catch(e)
		{
			NgLogE ( "FileSystem command : Could not parse response :" + files );
			err = "Could not parse files";
		}
		
		delete this.writeRequests[ cbId ];
		cb ( err, files );
	},
	
	/**
	 * @private
	 */
	_renameFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._renameFileCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.writeRequests[ cbId ];
		cb ( err );
	},

	/**
	 * @private
	 */
	_statCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._statCbRecvGen(cmd, msg))
			return;

		var cbId = msg[ "callbackId" ];
		var data = msg[ "data" ];
		var err = msg[ "error" ];

		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}

		var cb = this.statRequests[ cbId ];

		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.statRequests[ cbId ];

		var errObject = null;
		if(err !== '')
		{
			errObject = JSON.parse(err);
		}

		var dataObject = null;
		if(data !== '')
		{
			dataObject = JSON.parse(data);
		}

		cb ( errObject, dataObject );
	},

	/**
	 * @private
	 */
	_registerManifestCbRecv: function ( cmd )
	{
		var msg = {};
		if ( !this._registerManifestCbRecvGen( cmd, msg ) )
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLocE (" FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.registerManifestRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE (" FileSystem command : No register cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.registerManifestRequests[ cbId ];
		cb( err );
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	Store:
	{ 
		Temp: 0,
		Local: 1
	},
	
	ErrorCode:
	{ 
		Unknown: -1,
		NotFound: -2,
		Unsupported: -3
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 338,
	// Method create = -1
	// Method readFile = 2
	// Method writeFile = 3
	// Method deleteFile = 4
	// Method decompressFile = 5
	// Method readFileCb = 6
	// Method writeFileCb = 7
	// Method deleteFileCb = 8
	// Method decompressFileCb = 9
	// Method readFileAsync = 10
	// Method writeFileAsync = 11
	// Method deleteFileAsync = 12
	// Method decompressFileAsync = 13
	// Method readFileBinaryCb = 14
	// Method writeFileAsyncBinary = 15
	// Method renameFileAsync = 16
	// Method renameFileCb = 17
	// Method registerManifest = 18
	// Method registerManifestCb = 19
	// Method statAsync = 20
	// Method statCb = 21
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._readFileCbRecv( cmd );
					break;
				case 7:
					instance._writeFileCbRecv( cmd );
					break;
				case 8:
					instance._deleteFileCbRecv( cmd );
					break;
				case 9:
					instance._decompressFileCbRecv( cmd );
					break;
				case 14:
					instance._readFileBinaryCbRecv( cmd );
					break;
				case 17:
					instance._renameFileCbRecv( cmd );
					break;
				case 19:
					instance._registerManifestCbRecv( cmd );
					break;
				case 21:
					instance._statCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in FileSystem._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in FileSystem._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[338] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_readFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_writeFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_deleteFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_decompressFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "files" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "files" ] === undefined )
		{
			NgLogE("Could not parse files in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_readFileBinaryCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.readFileBinaryCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.readFileBinaryCb from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseBinary( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in FileSystem.readFileBinaryCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.readFileBinaryCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_renameFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.renameFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.renameFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.renameFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_registerManifestCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.registerManifestCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.registerManifestCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.registerManifestCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_statCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.statCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.statCb from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in FileSystem.statCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.statCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x152ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_readFileSendGen: function( callbackId, storeId, filename, binary )
	{
		Core.Proc.appendToCommandString( 0x1520002, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), ( binary ? 1 : 0 ) ] );
	},
	
	/** @private */
	_writeFileSendGen: function( callbackId, storeId, filename, data, binary )
	{
		Core.Proc.appendToCommandString( 0x1520003, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), Core.Proc.encodeString( data ), ( binary ? 1 : 0 ) ] );
	},
	
	/** @private */
	_deleteFileSendGen: function( callbackId, storeId, filename )
	{
		Core.Proc.appendToCommandString( 0x1520004, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ) ] );
	},
	
	/** @private */
	_decompressFileSendGen: function( callbackId, storeId, filename, destination, returnFiles )
	{
		Core.Proc.appendToCommandString( 0x1520005, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), Core.Proc.encodeString( destination ), ( returnFiles ? 1 : 0 ) ] );
	},
	
	/** @private */
	_readFileAsyncSendGen: function( callbackId, storeId, filename, options )
	{
		Core.Proc.appendToCommandString( 0x152000a, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), +options ] );
	},
	
	/** @private */
	_writeFileAsyncSendGen: function( callbackId, storeId, filename, data, options )
	{
		Core.Proc.appendToCommandString( 0x152000b, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), Core.Proc.encodeString( data ), +options ] );
	},
	
	/** @private */
	_deleteFileAsyncSendGen: function( callbackId, storeId, filename, options )
	{
		Core.Proc.appendToCommandString( 0x152000c, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), +options ] );
	},
	
	/** @private */
	_decompressFileAsyncSendGen: function( callbackId, storeId, filename, destination, options )
	{
		Core.Proc.appendToCommandString( 0x152000d, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), Core.Proc.encodeString( destination ), +options ] );
	},
	
	/** @private */
	_writeFileAsyncBinarySendGen: function( callbackId, storeId, filename, data, options )
	{
		Core.Proc.appendToCommandString( 0x152000f, this, [ +callbackId, +storeId, Core.Proc.encodeString( filename ), Core.Proc.encodeBinary( data ), +options ] );
	},
	
	/** @private */
	_renameFileAsyncSendGen: function( callbackId, storeId, oldPath, newPath, options )
	{
		Core.Proc.appendToCommandString( 0x1520010, this, [ +callbackId, +storeId, Core.Proc.encodeString( oldPath ), Core.Proc.encodeString( newPath ), +options ] );
	},
	
	/** @private */
	_registerManifestSendGen: function( callbackId, filename )
	{
		Core.Proc.appendToCommandString( 0x1520012, this, [ +callbackId, Core.Proc.encodeString( filename ) ] );
	},
	
	/** @private */
	_statAsyncSendGen: function( callbackId, storeId, filePath, options )
	{
		Core.Proc.appendToCommandString( 0x1520014, this, [ +callbackId, +storeId, Core.Proc.encodeString( filePath ), +options ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// readFile: function( callbackId, storeId, filename, binary ) {}
	
	// writeFile: function( callbackId, storeId, filename, data, binary ) {}
	
	// deleteFile: function( callbackId, storeId, filename ) {}
	
	// decompressFile: function( callbackId, storeId, filename, destination, returnFiles ) {}
	
	// _readFileCbRecv: function( cmd ) {}
	// _writeFileCbRecv: function( cmd ) {}
	// _deleteFileCbRecv: function( cmd ) {}
	// _decompressFileCbRecv: function( cmd ) {}
	// readFileAsync: function( callbackId, storeId, filename, options ) {}
	
	// writeFileAsync: function( callbackId, storeId, filename, data, options ) {}
	
	// deleteFileAsync: function( callbackId, storeId, filename, options ) {}
	
	// decompressFileAsync: function( callbackId, storeId, filename, destination, options ) {}
	
	// _readFileBinaryCbRecv: function( cmd ) {}
	// writeFileAsyncBinary: function( callbackId, storeId, filename, data, options ) {}
	
	// renameFileAsync: function( callbackId, storeId, oldPath, newPath, options ) {}
	
	// _renameFileCbRecv: function( cmd ) {}
	// registerManifest: function( callbackId, filename ) {}
	
	// _registerManifestCbRecv: function( cmd ) {}
	// statAsync: function( callbackId, storeId, filePath, options ) {}
	
	// _statCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,

	//Diagnostics collector
	collectDiagnostics: function(type, interval)
	{
		var collectedInfo = {
			readFile: {
				count: this._readCount
			},
			writeFile: {
				count: this._writeCount
			},
			deleteFile: {
				count: this._deleteCount
			},
			renameFile: {
				count: this._renameCount
			},
			decompressFile: {
				count: this._decompressCount
			},
			stat: {
				count: this._statCount
			}
         };

		 return collectedInfo;
	}
});

// vim: ts=2:sw=2:noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Localization'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Localization'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Localization'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Localization.js';

var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;

var LocalizationEngine = exports.LocalizationEngine = MessageEmitter.subclass(
/** @lends Core.Localization.prototype */
{
	classname: 'Localization',
    
    /**
     * Specifies the directory path to language files this object will load.
     */
    directoryPath:null,
    
    /**
     * Specifies the directory path to a language file for a specific language.
     */
	languageFilePath:null,
    
	/**
	 * @class The <code>Localization</code> class provides applications with access to localized strings.
	 * Applications supply a language code corresponding to a file in <code>Content/Localization/</code> or a JSON object.<br /><br /> 
     * Loading of dictionary files is an anynchronous process. Applications need to listen for emitted notifications from <code>Localization</code> objects that signal when the language dictionary
     * is modified. When a <code>Localization</code> object emits a notification, localized strings are available to the application (see <code>{@link Core.MessageEmitter#emit}</code>).
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	initialize: function(directoryPath)
	{
		if(!directoryPath){directoryPath = "./Content/Localization/";}
	    NgLogD("Localization : init ("+directoryPath+")");
	    this.directoryPath = directoryPath;
	    
        this.setLanguage(Capabilities.getLanguage());
	},
    
	/**
	 * Aynchronously load the localization dictionary for the specified language.
     * <br /><br />
	 * <b>Notes:</b> 
	 * <ul>
	 * <li>This function looks for the corresponding JSON dictionary file in the <code>Content/Localization</code> directory.
     * For example, <code>Content/Localization/fr.json</code>. If the application cannot load a dictionary, this call has no effect.</li>
     * <li><code>Localization</code> objects emit a notification with the new language string if this call succeeds.</li>
     *</ul>
	 *
	 * @example
	 * Core.Localization.addListener(listener, function()
     * {
     *     listener.label.setText(Core.Localization.getString("Hello World"));
     * });
	 * Core.Localization.setLanguage('es');
	 *
	 * @param {String} language The base name of a JSON dictionary file in <code>./Content/Language</code>.
	 * @see Core.Localization#setDictionary
	 * @see Core.MessageListener
	 * @returns {void}
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */    
    setLanguage: function(language)
    {
        var dictionaryPath = this.languageFilePath = this.directoryPath + language + '.json';
        var self = this;
        NgLogD("Localization : reading json file "+ dictionaryPath);
        
        NgLogT("@@@ Localization.setLanguage readFile " + dictionaryPath + " +");
		FileSystem.readFile(dictionaryPath, {}, function(error, data)
        {
            NgLogT("@@@ Localization.setLanguage readFile " + dictionaryPath + " -");
            if(error === '')
            {
                NgLogD("Localization : successfully read json file "+ dictionaryPath);  
                self.setDictionary(language, JSON.parse(data));
            }
            else
            {
                NgLogD("Localization: unable to read json file "+ dictionaryPath + ", use default english setting instead");                
                self.setDictionary(language, null);
            }
        });
    },

	/**
	 * Directly set the language code and localization dictionary.
     * <code>Localization</code> objects emit a message with the new language string during this call.
	 * 
	 * @example
     * var chDictionary =    
     * {
     *     "Hello World": "&#20320;&#22909;&#19990;&#30028;"
     * };
	 * Core.Localization.setDictionary('ch', chDictionary);
	 * label.setText(Core.Localization.getString("Hello World"));
	 *
	 * @param {String} language A string identifying the specified language or localization.
	 * @param {Object} dictionary An object containing key/value pairs for the specified language.
	 * @see Core.Localization#setLanguage
	 * @see Core.MessageEmitter#emit
	 * @returns {void}
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */    
    setDictionary: function(lang, dictionary)
    {
        this._lang = lang;
        this._dictionary = dictionary;
        this.emit(this._lang);
    },    
    
    /**
	 * Retrieve a localized string.
     * @param {String} str A localization key.
	 * @returns {String} The localized string or the provided key if the application is unable to lcoate the specified string.
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */
	getString: function(str)
	{        
        if(this._dictionary && typeof this._dictionary === 'object')
        {
            var value = this._dictionary[str];
            if(value && typeof value !== 'undefined')
            {
                return value;
            }
        }
        
        return this.unknownString(str);
	},
	
	/** 
	  * @private
	  */
	unknownString:function(str){
		NgLogD("Localization: ... No localization for "+str+" in "+this._lang);
		return str;
	}
});

/**
 * Global Localization Singleton, gets initialized when the device locale is known.
 * @ignore
 */
exports.Localization = LocalizationEngine.singleton({});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Storage.js';

/**
 * @name Storage
 * @namespace Access files and key/value pairs.
 * @description The `Storage` module is a collection of classes that support data manipulation
 * operations. Each class handles a specific aspect of the module implementation and contains APIs
 * that support the class:
 *
 * + `{@link Storage.Diagnostics}`: Provide diagnostic information about the app's use of the
 * `Storage` module.
 * + `{@link Storage.FileSystem}`: Construct objects for reading a file, writing to a file, deleting
 * a file, decompressing a file, or retrieving information about a file.
 * + `{@link Storage.KeyValue}`: Construct objects that store key/value pairs on the device.
 * + `{@link Storage.KeyValueCache}`: Obtain access to the local key/value store.
 *
 * When you use these classes, the data you store is not tied to a specific Mobage user. If you need
 * to store user-specific data, do one of the following:
 *
 * 1. Verify that your application is storing and retrieving data for the correct Mobage user. Keep
 * in mind that several different Mobage users could all use the same application on the same
 * device.
 * 2. As an alternative to `{@link Storage.KeyValue}`, consider using the
 * `{@link Social.Common.Appdata}` class, which stores application data that is tied to a specific
 * Mobage user.
 */
function StorageLoader(map) {
	this.add = function(key, toEval) {
		this.__defineGetter__(key, function() {
			delete this[key];
			return this[key] = toEval();
		});
	};
	for (var k in map) {
		if (map.hasOwnProperty(k)) this.add(k, map[k]);
	}
}

exports.Storage = new StorageLoader({
	'KeyValue': function() { return require('NGCore/Client/Storage/KeyValue').KeyValue; },
	'KeyValueCache': function() { return require('NGCore/Client/Storage/KeyValue').KeyValueCache; },
	'FileSystem': function() { return require('NGCore/Client/Storage/FileSystem').FileSystem; },
	'Diagnostics': function() { return require('NGCore/Client/Storage/Diagnostics').Diagnostics; }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/_LocalGameList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/_LocalGameList'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/_LocalGameList'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/_LocalGameList.js';

////////////////////////////////////////////////////////////////////////////////
// Class _LocalGameList
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Time = require('NGCore/Client/Core/Time').Time;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var Util = require('NGCore/Client/Network/Util').Util;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////

var _LocalGameList = exports._LocalGameList = Class.singleton (
/** @lends Core._LocalGameList.prototype */
{
	classname: '_LocalGameList',

	/**
	 * The <code>_LocalGameList</code> class constructs a singleton object that identifies all of the
	 * applications that a client can download. It also manages downloading of updated applications and
	 * ensures that adequate space is available to save updated files on the device.
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this.mGameList = [];
		var Storage = require('NGCore/Client/Storage').Storage;
		this.mFile = Storage.FileSystem;
		this.mGameStore = Storage.KeyValueCache.global("Core.GameList");

		this.mLoadingGames = {};
		this.mActiveGameKey = "activeGames";
		this.mRequiredAvailableSpace = 0;
		this.mSpaceAvailable = 0;
		this.mSpaceFreeCallbacks = [];
		this._firstBootGameLaunch = true;

		this._getRepoSpaceSendGen();

		this._setStage(this.ProgressStage.BootFirst);
		this._reloadGameList();
		this._allowDeterminateProgress = true;
	},
	
	ProgressStage:
	{
		BootFirst: {boot:[-1,0], progressBar:[0,0.25]},
		CheckConfiguration: {boot:[-1,0], progressBar:[0.25,0.25]},
		CheckManifest: {boot:[-1,0], progressBar:[0.25,0.25]},
		DownloadFiles: {boot:[0.1,0.9], progressBar:[0.25,0.75]},
		Launching: {boot:[-1,0], progressBar:[0.75,1]}
	},
	
	_setStage: function(stage)
	{
		this._progressStage = stage;
		if (typeof stage == 'object') {
			this._progressMin = this._progressStage[ this._hasProgressBar ? "progressBar" : "boot"][0];
			this._progressRange = this._progressStage[ this._hasProgressBar ? "progressBar" : "boot"][1];
		} else {
			this._progressMin = -1;
			this._progressRange = 0;
		}
		console.log('min:', this._progressMin, 'range:', this._progressRange);
		this._setProgress(0);
	},
	
	_nextStage: function()
	{
		switch(this._progressStage)
		{
			case this.ProgressStage.BootFirst:
				this._setStage(this.ProgressStage.CheckConfiguration);
				break;
			case this.ProgressStage.CheckConfiguration:
				this._setStage(this.ProgressStage.CheckManifest);
				break;
			case this.ProgressStage.CheckManifest:
				this._setStage(this.ProgressStage.DownloadFiles);
				break;
			case this.ProgressStage.DownloadFiles:
				this._setStage(this.ProgressStage.Launching);
				break;
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 303,
	// Method create = -1
	// Method updateGame = 2
	// Method updateDone = 3
	// Method getRepoSpace = 4
	// Method repoSpace = 5
	// Method deleteGame = 6
	// Method setUpdateProgress = 7
	// Method pauseUpdate = 8
	// Method resumeUpdate = 9
	// Method cancelUpdate = 10
	// Method updateProgress = 11
	// Method allowBGUpdates = 12
	// Method runGame = 13
	// Method finishGame = 14
	// Method setProgressText = 15
	// Method setSplashVisible = 16
	// Method exceptionForwarded = 17
	// Method setHasCustomProgressBar = 18
	// Method gameUnbundled = -19
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._updateGameRecv( cmd );
					break;
				case 5:
					instance._repoSpaceRecv( cmd );
					break;
				case 6:
					instance._deleteGameRecv( cmd );
					break;
				case 8:
					instance._pauseUpdateRecv( cmd );
					break;
				case 9:
					instance._resumeUpdateRecv( cmd );
					break;
				case 10:
					instance._cancelUpdateRecv( cmd );
					break;
				case 12:
					instance._allowBGUpdatesRecv( cmd );
					break;
				case 13:
					instance._runGameRecv( cmd );
					break;
				case 14:
					instance._finishGameRecv( cmd );
					break;
				case 17:
					instance._exceptionForwardedRecv( cmd );
					break;
				case 18:
					instance._setHasCustomProgressBarRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -19:
					_LocalGameList._gameUnbundledRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in _LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[303] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_updateGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		obj[ "id" ] = Proc.parseInt( cmd[ 1 ] );
		if( obj[ "id" ] === undefined )
		{
			NgLogE("Could not parse id in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_repoSpaceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		obj[ "space" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "space" ] === undefined )
		{
			NgLogE("Could not parse space in _LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_deleteGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		obj[ "mdFive" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "mdFive" ] === undefined )
		{
			NgLogE("Could not parse mdFive in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		obj[ "game" ] = Proc.parseString( cmd[ 1 ] );
		if( obj[ "game" ] === undefined )
		{
			NgLogE("Could not parse game in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_pauseUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.pauseUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.pauseUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_resumeUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.resumeUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.resumeUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_cancelUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.cancelUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.cancelUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_allowBGUpdatesRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.allowBGUpdates from command: " + cmd );
			return false;
		}
		
		obj[ "allow" ] = Proc.parseBool( cmd[ 0 ] );
		if( obj[ "allow" ] === undefined )
		{
			NgLogE("Could not parse allow in _LocalGameList.allowBGUpdates from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_runGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.runGame from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.runGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_finishGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.finishGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_exceptionForwardedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.exceptionForwarded from command: " + cmd );
			return false;
		}
		
		obj[ "exceptionString" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "exceptionString" ] === undefined )
		{
			NgLogE("Could not parse exceptionString in _LocalGameList.exceptionForwarded from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_setHasCustomProgressBarRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.setHasCustomProgressBar from command: " + cmd );
			return false;
		}
		
		obj[ "hasProgressBar" ] = Proc.parseBool( cmd[ 0 ] );
		if( obj[ "hasProgressBar" ] === undefined )
		{
			NgLogE("Could not parse hasProgressBar in _LocalGameList.setHasCustomProgressBar from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	$_gameUnbundledRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.gameUnbundled from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x12fffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_updateDoneSendGen: function( id, error )
	{
		Proc.appendToCommandString( 0x12f0003, this, [ +id, Proc.encodeString( error ) ] );
	},
	
	/** @private */
	_getRepoSpaceSendGen: function(  )
	{
		Proc.appendToCommandString( 0x12f0004, this );
	},
	
	/** @private */
	_setUpdateProgressSendGen: function( progress )
	{
		Proc.appendToCommandString( 0x12f0007, this, [ +progress ] );
	},
	
	/** @private */
	_updateProgressSendGen: function( url, cur, total, error )
	{
		Proc.appendToCommandString( 0x12f000b, this, [ Proc.encodeString( url ), +cur, +total, ( error ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setProgressTextSendGen: function( text )
	{
		Proc.appendToCommandString( 0x12f000f, this, [ Proc.encodeString( text ) ] );
	},
	
	/** @private */
	_setSplashVisibleSendGen: function( visible )
	{
		Proc.appendToCommandString( 0x12f0010, this, [ ( visible ? 1 : 0 ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _updateGameRecv: function( cmd ) {}
	// updateDone: function( id, error ) {}
	
	// getRepoSpace: function(  ) {}
	
	// _repoSpaceRecv: function( cmd ) {}
	// _deleteGameRecv: function( cmd ) {}
	// setUpdateProgress: function( progress ) {}
	
	// _pauseUpdateRecv: function( cmd ) {}
	// _resumeUpdateRecv: function( cmd ) {}
	// _cancelUpdateRecv: function( cmd ) {}
	// updateProgress: function( url, cur, total, error ) {}
	
	// _allowBGUpdatesRecv: function( cmd ) {}
	// _runGameRecv: function( cmd ) {}
	// _finishGameRecv: function( cmd ) {}
	// setProgressText: function( text ) {}
	
	// setSplashVisible: function( visible ) {}
	
	// _exceptionForwardedRecv: function( cmd ) {}
	// _setHasCustomProgressBarRecv: function( cmd ) {}
	// $_gameUnbundledRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


	,
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_updateGameRecv: function( cmd )
	{
		this._getRepoSpaceSendGen();

		var o = {};
		this._updateGameRecvGen(cmd, o);

		if (o.url in this.mLoadingGames)
		{
			this.mLoadingGames[o.url].id = o.id;
			this.mLoadingGames[o.url].dlman.resume();
		}
		else
		{
			this.updateGame(o.url, o.id,
				(function (url, newFiles, err)
				{
					o.id = this.mLoadingGames[url].id;
					this._updateDoneSendGen(o.id, err || ""); // err should be a string.
				}).bind(this, o.url)
			);
		}
	},
	mobageRunGame: function (funk)
	{
		this._gameRunner = funk;
	},
	_runGameRecv: function( cmd )
	{
		var o = {};
		this._runGameRecvGen(cmd, o);
		if (this._gameRunner)
		{
			console.log("_LGL running gameRunner " + o.url);
			this._gameRunner(o.url);
		}
		else
		{
			console.log("_LGL running game " + o.url);
			var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
			_int_LGL.launch(o.url, _int_LGL.ProcID.Game);
		}
	},
	/**
	 * set the function that kills the current game app
	 */
	setFinishGameHandler: function(funk)
	{
		this._finishGameHandler = funk;
	},
	_finishGameRecv: function()
	{
		if (this._finishGameHandler)
		{
			this._finishGameHandler();
		} else {
			console.log("_LocalGameList: finishGameHandler is not set");
		}
	},
	_repoSpaceRecv: function( cmd )
	{
		var obj = {};
		this._repoSpaceRecvGen(cmd, obj);
		this.mSpaceAvailable = obj.space;
		console.log("SD card space available(b): " + this.mSpaceAvailable);

		var length = this.mSpaceFreeCallbacks.length;
		while (length--)
		{
			(this.mSpaceFreeCallbacks.pop())();
		}
	},

	_deleteGameRecv: function( cmd )
	{
		// site to calc md5: http://pajhome.org.uk/crypt/md5/
		var allowedGames =
		[
			"http://10.15.", // Allow partial ones, for testing
			'http://10.16.',
			'http://gamehub.mobage.com/app/1.0s/gamehub',
			'url of allowed game'
		];

		var obj = {};
		this._deleteGameRecvGen(cmd, obj);
		var i;
		for(i in allowedGames)
		{
			var match = obj.game.match(allowedGames[i]);
			if(match && !match.index)
			{
				NgLogD("Deleting " + obj.mdFive);
				this.deleteGameFiles(obj.mdFive);

				var doneCB = (function ()
				{
					NgLogD("Finished deleting game from " + this.mActiveGameKey + " for " + obj.mdFive );
				}).bind(this);
				this._deleteGameFromStorage(obj.mdFive,doneCB);

				return;
			}
			else
			{
				// for testing, allow any local server starting with 10.15
			}
		}
		NgLogE("_LocalGameList unauthorized call to deleteGame from "+obj.game+"!");
	},

// _deleteGameFromStorage is for deleting the games info from LGL storage, not the game's storage

	_deleteGameFromStorage: function(mdFive,doneCB)
	{
		var self = this;
		this.mGameStore.getItem(this.mActiveGameKey, {},
			function(error, value)
			{
				var list = JSON.parse(value);
				
				var good = false;
				var ind;
				var out = [];
				for(ind = 0; ind < list.length; ++ind)
				{
					if(list[ind].name == mdFive)
						good = true;
					else
						out.push(list[ind]);
				}
				
				if( good )
				{
					NgLogD("_LocalGameList found and removed " + mdFive);
					self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(out), { blocking: true }, doneCB);
				}
				else
				{
					NgLogD("_LocalGameList failed to find and remove " + mdFive);
					doneCB("Could not remove item: " + error);
				}
				
			}, true
		);
	},

	getGameConfig: function(identifier, isMDFive, callBack)
	{
		if (typeof isMDFive == 'function')
		{
			callBack = isMDFive;
			isMDFive = false;
		}

		var folder;
		if (isMDFive)
		{
			folder = identifier;
		}
		else
		{
			var Util = require('NGCore/Client/Network/Util').Util;
			var norm = Util.NormalizeUrl(identifier);
			folder = toMD5(norm);
		}

		NgLogT("@@@ _LocalGameList.getGameConfig readFile +");

		this.mFile.readFile(folder + "/" + Capabilities._getConfigFile(), {},
			function (err, contents)
			{
				NgLogT("@@@ _LocalGameList.getGameConfig readFile -");
				
				var ret = {};
				if (err || !contents)
				{
					console.log("Could not get config from %s! err: %s", identifier, err);
				}
				else
				{
					ret = JSON.parse(contents);
				}
				callBack(ret);
			}
		);
	},

	getRepoSpace: function()
	{
		return this.mSpaceAvailable;
	},

	getConfig: function(gameOrigin, name, callback, failEarly)
	{// callback = function (config, err)
		// XHR
		var XHR = require('NGCore/Client/Network/XHR').XHR;
		var Util = require('NGCore/Client/Network/Util').Util;
		
		var httpStatus = 0;
		
		Util.OperationWithRetries(function(failCb)
		{
			var req = new XHR();
			req.onreadystatechange = function()
			{
				if(req.readyState == 4)
				{
					httpStatus = req.status;
					if(httpStatus == 200)
					{
						// Succes.
						callback(req.responseText);
					}
					else if(httpStatus == 404)
					{
						// File not on server, so load from the regular location
						console.log("no configuration file found at %s, using root server", gameOrigin + name);
						callback( "{}" );
					}
					else
					{
						//Error! Retry
						failCb();
					}
				}
			};
			req.setRequestHeader("X-Distribution", Capabilities.getDistributionName());
			req.open('GET', gameOrigin + name + Util.getCacheBustingString(), true);
			req.send();
		}, function()
		{
			callback(null, true, httpStatus);
		}, failEarly);
	},

	// gameOrigin: url to folder holding webgame.ngmanifest
	// doneCB = function(totalBytes, error)
	updateGame: function(gameOrigin, id, doneCB, failEarly, failAllowed)
	{
		// console.log ( "LGL.updateGame url = " + gameOrigin );
		// console.log ( "LGL.updateGame boot game = " + Capabilities.getBootGame() );
		
		var re = new RegExp(".*" + Capabilities.getBootGame());
		var match = gameOrigin.match(re);
		
		if (match) 
			this._firstBootGameLaunch = false;
			
		// console.log ( "_LocalGameList.updateGame updating game." );

		// Normalize URL
		var Util = require('NGCore/Client/Network/Util').Util;
		gameOrigin = Util.NormalizeUrl(gameOrigin);

		var name = Util.GetMD5HashDirectoryFromUrl(gameOrigin);
		this.mLoadingGames[gameOrigin] = {id: id};

		NgLogI("_LocalGameList.updateGame(): url = " + gameOrigin + " name = " + name);

		// Get device-specific manifest directory
		var buildPath = {"Android" : "android", "iPhone OS" : "ios", "flash" : ""};
		// Get Device capabilities platformOs
		var caps = require("NGCore/Client/Core/Capabilities").Capabilities;
		var build = "/" + buildPath[caps.getPlatformOS()];

		this._setStage(this.ProgressStage.CheckConfiguration);

		var curContUrl = "";
		var configFile = name + "/" + caps._getConfigFile();
		
		// This is guaranteed to be synchronous, so will always occur before the callback for subsequent operations.
		this.mFile.readFile(configFile, {},
			function(err, data)
			{
				if (data)
				{
					var obj = JSON.parse(data);
					curContUrl = obj.contentUrl;
				}
			}
		);

		var url = gameOrigin + build + "/" + caps._getConfigFile();
		NgLogI("_LocalGameList.updateGame(): downloading configuration.json, url = " + url);
		this.getConfig(gameOrigin + build, "/" + caps._getConfigFile(),
        (function(config, error, status)
		{
			if (error)
			{
				NgLogI("_LocalGameList.updateGame(): ERROR downloading configuration.json, url = " + url);
				this._setStage(-1); // ERROR
				doneCB(0, error);
				delete this.mLoadingGames[gameOrigin];
			}
			else
			{
				// Read config
				var parsedConfig = JSON.parse(config);
				if(!parsedConfig.contentUrl)
				{
					parsedConfig.contentUrl = gameOrigin + build;
				}
				else if (parsedConfig.contentUrl == curContUrl)
				{
					NgLogI("_LocalGameList.updateGame(): Game is up to date! url = " + url);

					// no need to update.
					this._setStage(this.ProgressStage.Launching);
					this.mFile.writeFile(configFile, JSON.stringify(parsedConfig), {}, (function(err)
					{
						if(err) {
							NgLogE("gameUpdate failed to write config:" + err);
						}
						doneCB(0, err);
						delete this.mLoadingGames[gameOrigin];
					}).bind(this));
					return;
				}

				NgLogI("_LocalGameList.updateGame(): Downloading game! url = " + url);
				this._setStage(this.ProgressStage.CheckManifest);
				this._callDownloadManifest(parsedConfig, gameOrigin, name, failEarly, failAllowed, (function(bytes, error)
				{
					NgLogI("_LocalGameList.updateGame(): Finished Downloading game! url = " + url);

					if (! error) {
						var that = this;
						this._reloadGameList({name:name, url:gameOrigin}, function()
						{
							if (doneCB && (typeof doneCB == 'function')) {
								doneCB(bytes, error);
								delete that.mLoadingGames[gameOrigin];
							}
						});
					} else {
						doneCB(bytes, error);
						delete this.mLoadingGames[gameOrigin];
					}
				}).bind(this));
			}
		}).bind(this), failEarly);
	},

	_allowBGUpdatesRecv: function( cmd )
	{
		var o = {};
		this._allowBGUpdatesRecvGen(cmd, o);
		this._pauseOrResumeAll(o.allow);
	},

	_pauseOrResumeAll: function(resume)
	{
		for (var i in this.mLoadingGames)
		{
			if (resume)
			{
				console.log("Resuming download of " + i);
				this.resumeUpdate(i);
			}
			else
			{
				console.log("Pausing download of " + i);
				this.pauseUpdate(i);
			}
		}
	},

	pauseUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if(this.mLoadingGames[url].dlman)
			{
				this.mLoadingGames[url].dlman.pause();
				this.mLoadingGames[url].userPause = true;
			}
		}
	},

	_pauseUpdateRecv: function(cmd)
	{
		var o = {};
		this._pauseUpdateRecvGen(cmd, o);
		this.pauseUpdate(o.url);
	},

	resumeUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if(this.mLoadingGames[url].dlman)
			{
				this.mLoadingGames[url].dlman.resume();
				this.mLoadingGames[url].userPause = false;
			}
		}
	},

	_resumeUpdateRecv: function(cmd)
	{
		var o = {};
		this._resumeUpdateRecvGen(cmd, o);
		this.resumeUpdate(o.url);
	},

	cancelUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if (this.mLoadingGames[url].dlman) {
                this.mLoadingGames[url].dlman.abort();
            }
			delete this.mLoadingGames[url];

			//Cancel the keep alive request as well
			var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;

			LifecycleEmitter.cancelEngineKeepAlive(_LocalGameList.classname);
		}
	},

	_cancelUpdateRecv: function(cmd)
	{
		var o = {};
		this._cancelUpdateRecvGen(cmd, o);
		this.cancelUpdate(o.url);
	},

	_setProgress: function (progress) {
		if(progress > 1) progress = 1;
		// Indeterminate
		if(progress < 0) progress = -1;
		this._progress = progress;
		if (progress >= 0 && this._allowDeterminateProgress) {
			this._setUpdateProgressSendGen( this._progressMin + progress * this._progressRange );
		} else {
			this._setUpdateProgressSendGen(-1);
		}
	},
	
	_setAllowDeterminateProgress: function (allow) {
		this._allowDeterminateProgress = allow;
		this._setProgress(this._progress);
	},

	listenToProgress: function (listener)
	{
		this._privListener = listener;
	},

	_updateProgress: function(url, prog, total, err)
	{
		//console.log("Updating progress for: %s, %d, %d " + err, url, prog, total);
		if (this._privListener)
			this._privListener(url, prog, total, err);

		if (this.mLoadingGames[url] && this.mLoadingGames[url].id >=0)
			this._updateProgressSendGen(url,prog,total,err);
	},

	// doneCB = function(totalBytes, error)
	_callDownloadManifest: function (config, gameOrigin, name, failEarly, failAllowed, doneCB)
	{
		var contentUrl = config.contentUrl;
		var reportTotalBytes = 0;
		var self = this;
		var Downloader = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
		
		var manifestName = require('NGCore/Client/Core/_int_LGL')._int_LGL.getManifestName(config);

		// Do download
		(function doDownload()
		{
			var dler = new Downloader();
			dler.mLocalGameList = self;
			var firstProgress = true;
			var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
			LifecycleEmitter.requestEngineKeepAlive(_LocalGameList.classname);

			// Only allow this on iOS
			config.omitJsUpdate = config.omitJsUpdate && (Capabilities.getPlatformOS() == "iPhone OS");
			dler._setConfig(config);
			dler.start(contentUrl, name, {'webgame.ngmanifest':manifestName}, function(bytesDownloaded, bytesTotal)
			{
				if(firstProgress)
				{
					// First progress callback is made when manifest is downloaded.
					firstProgress = false;
					self._setStage(bytesDownloaded < bytesTotal ? self.ProgressStage.DownloadFiles : self.ProgressStage.Launching);
					reportTotalBytes = bytesTotal;
				}
				else
				{
					self._setProgress( bytesDownloaded / bytesTotal );
				}

				// update LGL
				self._updateProgress(gameOrigin, bytesDownloaded, bytesTotal);
			}, function(error, manifest, wasCached)
			{
				LifecycleEmitter.cancelEngineKeepAlive(_LocalGameList.classname);

				if (failAllowed)
				{
					if (doneCB)
					{
						doneCB(reportTotalBytes, error);
					}
				}
				else if(error)
				{
					NgLogE("Error: " + error);
					// update LGL
					self._updateProgress(gameOrigin, 0, 0, error);
					doneCB(0, error);
				}
				else
				{
					if (doneCB)
					{
						doneCB(reportTotalBytes);
					}
				}
			}, false, failEarly);
			self.mLoadingGames[gameOrigin].dlman = dler;
		})();
	},

	freeSpace: function(space, cb)
	{
		this.mRequiredAvailableSpace = space;
		this.mSpaceFreeCallbacks.push(
			(function()
			{
				if (this.mRequiredAvailableSpace > this.mSpaceAvailable)
				{
					if (this._privListener)
					{
						this._privListener("", 0, 0, "SD card is full");
					}
					else
					{
						console.log("Warning!! Mobage is not handling SD card full error!");
						// This is Preservation of ancient code which has and will likely never execute
						var checkAgain = function()
						{
							if (this.mRequiredAvailableSpace > this.mSpaceAvailable)
							{
								this.pruneGames(1);
								this.mSpaceFreeCallbacks.push(checkAgain);
							}
							else
							{
								cb();
							}
						};
						// Is a redundant check on space, but looks better/is simpler/won't ever be used anyhow
						checkAgain();
					}
				}
				else
				{
					cb();
				}
			}).bind(this)
		);

		this._getRepoSpaceSendGen();
	},

	pruneGames: function(number)
	{
		var self = this;

		// Function to put oldest games on top of the stack
		var sort = function (l, r)
		{
			return r.lastRun - l.lastRun;
		};

		this.mGameStore.getItem(this.mActiveGameKey, {},
			function(error, value)
			{
				var list = JSON.parse(value);
				list.sort(sort);
				while (number-- && (list.length - 1))
				{
					var game = list.pop();

					// Do not delete the currently loading game
					if (!(game.name in self.mLoadingGames))
					{
						// delete game
						self.deleteGameFiles(game.name);
					}
					else
					{
						list.push(game);
					}
				}

				// Save the data
				self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(list), {});
			}, true
		);
	},

	deleteGame: function (url, callBack)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		var norm = Util.NormalizeUrl(url);
		var mdFive = toMD5(norm);

		this.deleteGameFiles(mdFive);
		this._deleteGameFromStorage(mdFive, callBack);
	},

	// Delete the KeyValueCache.local of the given game
	deleteGameKeyValue: function(mdFive)
	{
		var kvm = require('NGCore/Client/Storage').KeyValueCache;
		kvm.global(mdFive).clear({});
	},

	deleteGameFiles: function(game)
	{
		var self = this;
		self.mFile.deleteFile( game, {},
			function(err)
				{
					if(err === "" )
						NgLogI('Deleted');
					else
						NgLogD("Could not delete game");

					self._getRepoSpaceSendGen();
				});
	},

	getGameList: function()
	{
		return this.mGameList;
	},

	clearWatch: function()
	{
		var fs = require('NGCore/Client/Storage/FileSystem').FileSystem;
		fs.deleteFile(".watch", {});
	},

	/**
	 * @private
	 */
	_reloadGameList: function(newItem, cb)
	{
		this.mGameStore.getItem(this.mActiveGameKey, {},
			(function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				if (newItem)
				{
					var bNew = true;
					for (var i in list)
					{
						if (list[i].name == newItem.name)
						{
							bNew = false;
							newItem.lastRun = list[i].lastRun;
							list[i] = newItem;
							break;
						}
					}

					if (bNew)
					{
						list.push(newItem);
					}
					this.mGameStore.setItem(this.mActiveGameKey, JSON.stringify(list), {});
				}

				this.mGameList = list;

				if (typeof cb == 'function')
					cb();
			}).bind(this),
			true
		);
	},

	_getRunningGame: function(callBack)
	{
		// Function to put oldest games on top of the stack
		var sort = function (l, r)
		{
			return r.lastRun - l.lastRun;
		};

		this._reloadGameList(false, (function(cb)
		{
			var list = this.mGameList;
			list.sort(sort);
			var current = null;
			var len = list.length;
			for (var i = 0; i < len; ++i)
			{
				if (list[i].lastRun)
				{
					current = list[i];
					break;
				}
			}
			if (current && current.url)
				cb(current.url);
		}).bind(this, callBack));
	},

	/** @private */
	_pausingGame: function()
	{
		// true to resume download when pausing a game
		this._pauseOrResumeAll(true);
	},

	/** @private */
	_resumingGame: function()
	{
		// Check if the current game allows downloading
		this._getRunningGame((function(game)
		{
			this.getGameConfig(game, (function(config)
			{
				if (config.noBackgroundUpdates)
				{
					// false to pause download when resuming a game
					this._pauseOrResumeAll(false);
				}
			}).bind(this));
		}).bind(this));
	},

	setSplashVisible: function( visible )
	{
		this._setSplashVisibleSendGen(visible);
	},

	setProgressText: function( text )
	{
		this._progressText = text;
		this._setProgressTextSendGen(text);
	},

	updateAvailable: function(game, doneCB, errorCB)
	{
		var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
		_int_LGL.updateAvailable(game, doneCB, errorCB);
	},

	/*
	 * Set the exception handler. Default is undefined.
	 * @param {Function} the function that handles the exception occurred in the Game proc. signature: function(exceptionString)
	 */
	setExceptionHandler: function(func)
	{
		this._exceptionHandler = func;
	},

	_exceptionForwardedRecv: function( cmd )
	{
		var obj = {};
	        var exception = {};
		this._exceptionForwardedRecvGen(cmd, obj);
		try {
			exception = JSON.parse(obj.exceptionString);
		} catch (e) {
			console.log("ERROR: Unparseable exception: " + obj.exceptionString);
		}
		if (this._exceptionHandler) this._exceptionHandler(exception);
	},
	
	_setHasCustomProgressBarRecv: function( cmd ) {
		var obj = {};
		this._setHasCustomProgressBarRecvGen(cmd, obj);
		this._hasProgressBar = obj.hasProgressBar;
	},

	registerUnbundleListener: function(cb)
	{
		if (this.unbundled)
		{
			cb();
		}
		else
		{
			this.unbundleListener = cb;
		}
	},
	$_gameUnbundledRecv: function( cmd )
	{
		this.unbundled = true;
		if (this.unbundleListener)
		{
			this.unbundleListener();
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/NativeAppLaunch.js';

// @deprecated
var NativeAppLaunch;

exports.NativeAppLaunch = NativeAppLaunch;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ViewGeometry'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ViewGeometry'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ViewGeometry'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ViewGeometry.js';

var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

/**
 * The `UI.ViewGeometry` namespace includes a collection of classes and objects that control spatial
 * components for UI views. Classes that belong to `UI.ViewGeometry` include:
 * 
 * + `{@link UI.ViewGeometry.Rect}`
 * + `{@link UI.ViewGeometry.Scale}`
 * 
 * `UI.ViewGeometry` also includes the following enumerated constants:
 * 
 * + `{@link UI.ViewGeometry#FitMode}`
 * + `{@link UI.ViewGeometry#Gravity}`
 * @name UI.ViewGeometry
 * @namespace
 * @description
 */

var ViewGeometry = exports.ViewGeometry = {};

var Scale = ViewGeometry.Scale = exports.Scale = Class.singleton(
/** @lends UI.ViewGeometry.Scale.prototype */
{
	/**
	 * @name UI.ViewGeometry.Scale
	 * @class The `UI.ViewGeometry.Scale` class is a singleton that provides scaling factors for
	 * modifying the size of a view rectangle.
	 * @singleton
	 * @augments Core.Class
	 */
	initialize: function() {
		var screenUnits = Capabilities.getScreenUnits();
		this.iOSConversion = screenUnits;
		this.pointConversion = this.iOSConversion * 160 / 72; 
	},

	// Use the values of generated constants... Mostly for if we need to send these to native in the future.
	Pixels: Commands.Scaling.Pixels,
	Points: Commands.Scaling.Points,
	Unit: Commands.Scaling.Unit,
	Percent: Commands.Scaling.Percent,
	iPhone: Commands.Scaling.iPhone,
	
	// Internals.
    
	pointConversion: 1.0,
    
	iOSConversion: 1.0,

    /** 
     * Retrieve a scaling factor that can be used when modifying the size of a view rectangle.
     * @param {UI.Commands#Scaling} units The unit of measure.
     * @param {Number} size The width or height, in pixels, of the device's screen. Use the width
	 *		when modifying a view rectangle's width and the height when modifying a view rectangle's
	 *		height.
     * @returns {Number} The scaling factor.
     * @since 1.0
     */
	getScale: function(units, size) {
		switch (+units) {
			case this.Points:
				return this.pointConversion;
			case this.Unit:
				return size;
			case this.Percent:
				return size / 100;
			case this.iPhone:
				return this.iOSConversion;
		}
		return 1.0;
	}
});

/** 
 * Enumeration for image or text gravity in a view. The values in this enumeration can be assigned 
 * to the `imageGravity`, `textGravity`, or `titleGravity` property for any `UI` class that accepts
 * these properties.
 * @name Gravity
 * @fieldOf UI.ViewGeometry#
 */
var Gravity = ViewGeometry.Gravity = exports.Gravity = 

{
	/**
	 * Center of gravity is the top-left corner of the view.
	 * @name Gravity.TopLeft
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	TopLeft: [0.0,0.0],
	
	/** 
	 * Center of gravity is the top-center portion of the view. 
	 * @name Gravity.TopCenter
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	TopCenter: [0.5,0.0],
	
	/** 
	 * Center of gravity is the top-right corner of the view. 
	 * @name Gravity.TopRight
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	TopRight: [1.0, 0.0],
	
	/** 
	 * Center of gravity is the left side of the view. 
	 * @name Gravity.Left
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	Left: [0.0,0.5],
	
	/** 
	 * Center of gravity is the center of the view. 
	 * @name Gravity.Center
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	Center: [0.5,0.5],
	
	/** 
	 * Center of gravity is the right side of the view. 
	 * @name Gravity.Right
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	Right: [1.0,0.5],
	
	/** 
	 * Center of gravity is the bottom-left corner of the view. 
	 * @name Gravity.BottomLeft
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	BottomLeft: [0.0,1.0],
	
	/** 
	 * Center of gravity is the bottom-center portion of the view. 
	 * @name Gravity.BottomCenter
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	BottomCenter: [0.5,1.0],
	
	/** 
	 * Center of gravity is the bottom-right corner of the view. 
	 * @name Gravity.BottomRight
	 * @fieldOf UI.ViewGeometry#
	 * @constant
	 */
	BottomRight: [1.0,1.0]
};

 
var FitModes = ViewGeometry.FitModes = exports.FitModes = Commands.FitMode;
 
/** 
 * Enumeration for different ways to fit an image within a view. The image is resized relative to 
 * the size of the view, minus any insets that have been applied to the view.
 * @name FitMode
 * @fieldOf UI.ViewGeometry#
 */

/**
 * The image is not scaled.
 * @name FitMode.None
 * @fieldOf UI.ViewGeometry#
 * @constant
 */

/**
 * The image is proportionally scaled to fit completely within the view. If the image is smaller
 * than the size of the view, it is upscaled to fill either the width or height of the view.
 * @name FitMode.Inside
 * @fieldOf UI.ViewGeometry#
 * @constant
 */
 
/**
 * The image is proportionally scaled to fill the entire view, clipping any part of the image that
 * does not fit within the view.
 * @name FitMode.Fill
 * @fieldOf UI.ViewGeometry#
 * @constant
 */
 
/**
 * The image is non-proportionally scaled to fill the entire view.
 * @name FitMode.Stretch
 * @fieldOf UI.ViewGeometry#
 * @constant
 */

/**
 * The image is proportionally scaled to fill the entire width of the view, clipping any part of the
 * image that does not fit within the view.
 * @name FitMode.AspectWidth
 * @fieldOf UI.ViewGeometry#
 * @constant
 */

/**
 * The image is proportionally scaled to fill the entire height of the view, clipping any part of 
 * the image that does not fit within the view.
 * @name FitMode.AspectHeight
 * @fieldOf UI.ViewGeometry#
 * @constant
 */

/**
 * The image is scaled down proportionally to fit within the view. If the image is smaller than
 * the size of the view, the image is displayed at its actual size, with no upscaling.
 * @name FitMode.InsideNoUpscaling
 * @fieldOf UI.ViewGeometry#
 * @constant
 */

	
var Rect = ViewGeometry.Rect = exports.Rect = Class.subclass(
/** @lends UI.ViewGeometry.Rect.prototype */
{
	/**
	 * @name UI.ViewGeometry.Rect
	 * @class The `UI.ViewGeometry.Rect` class constructs objects that represent a rectangular
	 * portion of the device's screen. Use these objects to position a user interface's components.
	 *
	 * The constructor must specify the view rectangle's point of origin, width, and height. Your
	 * application can pass these parameters to the constructor in any of the following formats:
	 *
	 * 1. Four individual integers that represent the following, measured in pixels:
	 *     1. The location of the rectangle's upper left corner along the X axis.
	 *     2. The location of the rectangle's upper left corner along the Y axis.
	 *     3. The width of the rectangle.
	 *     4. The height of the rectangle.
	 * 2. An array that contains the four integers described above.
	 * 3. Two arrays of integers. The first array contains the first and second integers described
	 * above. The second array contains the third and fourth integers described above.
	 * 4. A `UI.ViewGeometry.Rect` object.
	 * @constructs Create a view rectangle.
	 * @augments Core.Class
	 * @example
	 * // Create a view rectangle by passing in an array of four integers.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * @example
	 * // Create a view rectangle by passing in two arrays.
	 * var rect = new UI.ViewGeometry.Rect([0, 0], [100, 50]);
	 * @example
	 * // Create a view rectangle by passing in another view rectangle.
	 * var rect1 = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * var rect2 = new UI.ViewGeometry.Rect(rect1);
	 * @param {Number|Number[]|UI.ViewGeometry.Rect} arg0 The rectangle's point of origin, width,
	 *		and height in one of the formats specified above.
	 * @since 1.0
	 */
    initialize: function(arg0)
    {
    	if (arg0 instanceof this.constructor){
    		// Another Rect
    		this.x = arg0.x;
    		this.y = arg0.y;
    		this.w = arg0.w;
    		this.h = arg0.h;
    	} else if (arg0 instanceof Array) {
    		if (arguments.length == 2 
    			&& arguments[0].length >= 2 
    			&& arguments[1] instanceof Array 
    			&& arguments[1].length >= 2) {
				
				// Arguments can be two arrays, one of which is a point and one of which is a size,
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.w = arguments[1][0];
				this.h = arguments[1][1];
			}
			else if (arguments.length == 1 && arg0.length >= 4) {
				// Single Array
				this.x = arg0[0];
				this.y = arg0[1];
				this.w = arg0[2];
				this.h = arg0[3];
			}
			else {
				NgLogD("UI.ViewGeometry.Rect initialized with unparseable Array(s)");
			}
		} else if (arguments.length == 4) {
			// Four numbers
			this.x = arguments[0];
			this.y = arguments[1];
			this.w = arguments[2];
			this.h = arguments[3];
		}
		return this;
    },
	/**
	 * Determine whether the view rectangle is missing one of its component values or has an area of
	 * 0.
	 * @example
	 * // Create a view rectangle with a height of 0.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 100, 0]);
	 * // Verify that the view rectangle is empty.
	 * if (rect.isEmpty()) {
	 *     console.log("Empty view rectangle");
	 * }
	 * @returns {Boolean} Set to `true` if any component value is missing or if the view rectangle
	 *		has an area of 0.
	 * @since 1.0
	 */
	isEmpty: function(){
		return (this.w * this.h <= 0) || isNaN(this.x) || isNaN(this.y) || isNaN(this.w) || isNaN(this.h);
	},
	/**
	 * Create a new view rectangle with the same point of origin, width, and height as the existing
	 * view rectangle.
	 * @example
	 * // Create a new view rectangle based on an existing view rectangle.
	 * var rect1 = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * var rect2 = rect1.copy();
	 * @returns {UI.ViewGeometry.Rect} A new view rectangle with the same point of origin, width,
	 *		and height.
	 * @since 1.0
	 */	
	copy: function() {
		return new (this).constructor(this);
	},
    /**
	 * Retrieve the view rectangle's point of origin, width, and height.
	 * @returns {Number[]} An array of integers specifying the view rectangle's X origin, Y origin,
	 *		width, and height.
	 * @since 1.0
	 */	
	array: function() {
		return [this.x, this.y, this.w, this.h];
	},
	
	/**
	 * Replace the view rectangle with an inset of the existing rectangle. The inset will be created
	 * only on the top and right sides of the view rectangle.
	 * @function
	 * @example
	 * // Create a view rectangle, then add a top and right inset of 10 pixels.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * rect.inset(10);
	 * @param {Number} tr The inset, in pixels, for the top and right sides of the view rectangle.
	 * @returns {this}
	 * @since 1.0
	 */
	inset: function(t, r, b, l, units) {
		if (arguments.length > 4) {
			var xScale = Scale.getScale(units, this.w);
			var yScale = Scale.getScale(units, this.h);
			t = Math.floor(t * yScale);
			r = Math.floor(r * xScale);
			b = Math.floor(b * yScale);
			l = Math.floor(l * xScale);
		}
		
		if (arguments.length < 2) {
			r = t;
		}
		if (arguments.length < 4) {
			b = t;
			l = r;
		}
		this.y += t;
		this.h -= t + b;
		this.x += l;
		this.w -= l + r;
		return this;
	},
	/**
	 * Replace the view rectangle with an inset of the existing rectangle. The first parameter
	 * represents the top and bottom inset, and the second parameter represents the left and right
	 * inset.
	 * @name inset^2
	 * @function
	 * @memberOf UI.ViewGeometry.Rect#
	 * @example
	 * // Create a view rectangle, then add a top and bottom inset of 10 pixels
	 * // and a left and right inset of 15 pixels.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * rect.inset(10, 15);
	 * @param {Number} tb The inset, in pixels, for the top and bottom of the view rectangle.
	 * @param {Number} lr The inset, in pixels, for the left and right sides of the view rectangle.
	 * @returns {this}
	 * @since 1.0
	 */
	/**
	 * Replace the view rectangle with an inset of the existing rectangle, specifying the inset for
	 * each side of the rectangle. If you include the `units` parameter, the inset will be scaled
	 * based on the value you specify.
	 * @name inset^3
	 * @function
	 * @memberOf UI.ViewGeometry.Rect#
	 * @example
	 * // Create a view rectangle, then add a top inset of 10 pixels, a right
	 * // inset of 5 pixels, a bottom inset of 20 pixels, and a left inset of
	 * // 15 pixels.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * rect.inset(10, 5, 20, 15);
	 * @param {Number} t The inset, in pixels, for the top of the view rectangle.
	 * @param {Number} r The inset, in pixels, for the right side of the view rectangle.
	 * @param {Number} b The inset, in pixels, for the bottom of the view rectangle.
	 * @param {Number} l The inset, in pixels, for the left side of the view rectangle.
	 * @param {UI.Commands#Scaling} [units] The scaling factor that will be used to adjust the
	 *		specified insets. By default, the inset is not scaled.
	 * @returns {this}
	 * @see UI.Commands#Scaling
	 * @since 1.0
	 */   
	
   /**
	 * Create a new view rectangle by removing a horizontal slice from the top or bottom of an
	 * existing view rectangle. If you include the `units` parameter, the slice's height will be 
	 * scaled based on the value you specify.
	 *
	 * **Note**: This method is called `sliceVertical()` because it modifies the rectangle's height
	 * along the vertical (Y) axis.
	 * @example
	 * // Create a view rectangle that is 50 pixels tall, and remove a 20-pixel-tall
	 * // horizontal slice from the top of the rectangle.
	 * var mainRect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * var sliceRect = mainRect.sliceVertical(20);
	 * var mainRectInfo = mainRect.array();  // mainRectInfo == [0, 20, 100, 30]
	 * var sliceRectInfo = sliceRect.array();  // sliceRectInfo == [0, 0, 100, 20]
	 * @param {Number} height The height, in pixels, of the slice to remove from the existing view
	 *		rectangle. Use a positive value to remove the top of the existing rectangle and a
	 *		negative value to remove the bottom of the existing rectangle.
	 * @param {UI.Commands#Scaling} [units] The scaling factor that will be used to adjust the 
	 *		specified height. By default, the height is not scaled.
	 * @returns {UI.ViewGeometry.Rect} The new view rectangle that was sliced from the existing
	 *		view rectangle.
	 * @see UI.ViewGeometry.Rect#sliceHorizontal
	 * @since 1.0
	 */	
	sliceVertical: function(height, units) {
		if (arguments.length > 1) height = Math.floor(height * Scale.getScale(units, this.h));
		
		var newRect = this.copy();
		if (height < 0) {
			// Return the bottom area...
			newRect.h = -height;
			this.h += height;
			newRect.y += this.h;
		} else {
			newRect.h = height;
			this.y += height;
			this.h -= height;
		}
		return newRect;
	},
    /**
	 * Create a new view rectangle by removing a vertical slice from the left or right side of an
	 * existing view rectangle. If you include the `units` parameter, the slice's width will be 
	 * scaled based on the value you specify.
	 *
	 * **Note**: This method is called `sliceHorizontal()` because it modifies the rectangle's width
	 * along the horizontal (X) axis.
	 * @example
	 * // Create a view rectangle that is 100 pixels wide, and remove a 10-pixel-wide
	 * // vertical slice from the left side of the rectangle.
	 * var mainRect = new UI.ViewGeometry.Rect([0, 0, 100, 50]);
	 * var sliceRect = mainRect.sliceHorizontal(10);
	 * var mainRectInfo = mainRect.array();  // mainRectInfo is [10, 0, 90, 50]
	 * var sliceRectInfo = sliceRect.array();  // sliceRectInfo is [0, 0, 10, 50]
	 * @param {Number} width The width, in pixels, of the slice to remove from the existing view
	 *		rectangle. Use a positive value to remove the left side of the existing rectangle and a
	 *		negative value to remove the right side of the existing rectangle.
	 * @param {UI.Commands#Scaling} [units] The scaling factor that will be used to adjust the 
	 *		specified width. By default, the width is not scaled.
	 * @returns {UI.ViewGeometry.Rect} The new view rectangle that was sliced from the existing
	 *		view rectangle.
	 * @see UI.ViewGeometry.Rect#sliceVertical
	 * @since 1.0
	 */	
	sliceHorizontal: function(width, units) {
		if (arguments.length > 1) width = Math.floor(width * Scale.getScale(units, this.w));

		var newRect = this.copy();
		if (width < 0) {
			newRect.w = -width;
			this.w += width;
			newRect.x += this.w;
		} else {
			newRect.w = width;
			this.x += width;
			this.w -= width;
		}
		return newRect;
	},

	toString: function() {
		return "Rect: {" + this.array().join(',') + "}";
	},

	/**
	 * Divide an existing view rectangle into a grid, with evenly spaced columns and rows, and
	 * retrieve an array of new view rectangles that represent each cell in the grid. The existing
	 * view rectangle is not modified.
	 *
	 * **Note**: The width and height of each grid cell are rounded to an integer. As a result, the
	 * grid cells may cover a slightly smaller area than the existing view rectangle.
	 * @example
	 * // Create a view rectangle that is 60 pixels wide and 20 pixels high.
	 * var rect = new UI.ViewGeometry.Rect([0, 0, 60, 20]);
	 * // Divide the rectangle into two rows and three columns. Retrieve the grid
	 * // cells in the following format:
	 * // [ [ {row1col1}, {row1col2}, {row1col3} ], [ {row2col1}, {row2col2}, {row2col3} ] ]
	 * var cells = rect.getGrid(2, 3, false);
	 * // Divide the rectangle into two rows and three columns. Retrieve the grid
	 * // cells in the following format:
	 * // [ {row1col1}, {row1col2}, {row1col3}, {row2col1}, {row2col2}, {row2col3} ]
	 * var flatCells = rect.getGrid(2, 3, true);
	 * @param {Number} rows The number of rows in the grid.
	 * @param {Number} columns The number of columns in the grid.
	 * @param {Boolean} flat Set to `true` to retrieve a flat array of grid cells, ordered from left
	 *		to right along each row, starting with the top row and ending with the bottom row. Set
	 *		to `false` to retrieve an array that contains multiple child arrays; the child arrays
	 *		start with the top row and end with the bottom row, and each child array contains the
	 *		grid cells from a single row, ordered from left to right.
	 * @returns {Array[]|UI.ViewGeometry.Rect[]} An array of grid cells, in the format specified by
	 *		the `flat` parameter.
	 * @since 1.0
	 */
	getGrid: function(rows, columns, flat) {
		// Return an array of this rect divided equally into columns and rows.
		flat = (flat === true);
		var cellW = Math.floor(this.w / columns);
		var cellH = Math.floor(this.h / rows);
		
		var rowSet = [];
		for (var i = 0; i < rows; i++) {
			var colSet = [];
			for (var j = 0; j < columns; j++) {
				var r = new this.constructor(this.x + j * cellW, this.y + i * cellH, cellW, cellH);
				(flat ? rowSet : colSet).push(r);
			}
			if (!flat) rowSet.push(colSet);
		}
		return rowSet;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Style'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Style'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Style'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Style.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var stateMap = {
	'normal': Commands.State.Normal,
	'focused': Commands.State.Focused,
	'selected': Commands.State.Selected,
	'pressed': Commands.State.Pressed,
	'disabled': Commands.State.Disabled
};

var Style = exports.Style = Element.subclass({
/** @lends UI.Style.prototype */
	"type":"style",
	"classname":"UI_Style",
	
	/**
	 * @class The `UI.Style` class creates objects that contain style properties for UI components,
	 * such as the component's fill color and outline; the component's text color; and the text to
	 * display in the component. Use this class wherever your application will display multiple UI
	 * components that use the same style.
	 * 
	 * By creating a single `UI.Style` object and applying it to multiple UI components, you reduce
	 * the amount of communication between ngCore's JavaScript API and the device's native code. As
	 * a result, using `UI.Style` objects can significantly improve your application's performance.
	 *
	 * `UI.Style` objects can be applied to any UI component that extends `{@link UI.AbstractView}`.
	 * To apply a `UI.Style` object to a UI component, call the component's `setStyle()` method,
	 * which is inherited from `{@link UI.AbstractView}`.
	 *
	 * **Note**: If you assign a `UI.Style` object to a UI component, then set one of the
	 * component's style properties, the style property you set will override the value that is
	 * provided by the `UI.Style` object. Keep in mind that many style properties are tied to 
	 * specific view states; for example, if a `UI.Style` object provides a style property for the
	 * `disabled` view state, you must also specify the `disabled` view state when you override the
	 * property. See below for more information about style properties and view states.
	 *
	 * ### Supported Properties ###
	 * A `UI.Style` object can contain any of the style properties that are available through the
	 * class' getter and setter methods, which are described below. Most UI components use only a
	 * subset of these properties. For example, because `{@link UI.Image}` objects cannot contain
	 * text, they do not use the `text` property. See the documentation for each class in the
	 * `{@link UI}` module to determine which properties are used by each UI component.
	 * 
	 * If a UI component does not use a property that is specified in a `UI.Style` object, that 
	 * property will be ignored.
	 *
	 * ### Style Properties and View States ###
	 * A `UI.Style` object can use different properties for different view states. For example, it
	 * can specify that a UI component's text should use a different color when the component is
	 * disabled. To implement this feature, your application can call a `UI.Style` setter method
	 * more than once, passing a different view state in the `flags` parameter for each method call.
	 *
	 * When you pass style properties in the class' constructor method, the properties will apply in
	 * the `normal`, or default, view state. To specify a style property for a different view state, 
	 * add the name of the view state to the beginning of the property name, and capitalize the
	 * property name. For example, to specify an image border for a UI component that has focus,
	 * pass the `focusedImageBorder` property in the constructor. This approach is supported only
	 * for the `normal`, `focused`, `selected`, `pressed`, and `disabled` view states. To specify a
	 * style property for a custom view state, or for a component that is in multiple states, you
	 * must use `UI.Style`'s setter methods.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Style#setImageGravity}` to control an
	 * image's position within its view, the image gravity you specify will apply in all view
	 * states.
	 * @name UI.Style
	 * @constructs Create a new set of style properties.
	 * @augments UI.Element
	 * @example
	 * // Create a new UI.Style object without setting any of its properties.
	 * var style = new UI.Style();
	 * @example
	 * // Create a UI.Style object, setting several of its style properties, 
	 * // and apply the style properties to three buttons.
	 * var style = new UI.Style({
	 *     gradient: {
	 *         corners: "5.0 5.0 5.0 5.0",
	 *         gradient: ["FF9999FF 0.0", "FF5665FF 0.4", "FF0000FF 1.0"],
	 *         innerShadow: "FFFFFFFF 15.0 {0.0, 0.0}",
	 *         outerLine: "FF5F5F5F 1.0",
	 *         outerShadow: "00000000 0.0 {0.0, 0.0}"
	 *     },
	 *     textColor: "FFFFFF",
	 *     textShadow: "FF666666 2.0 {0.0, -1.0}"
	 * });
	 * var button1 = new UI.Button(),
	 *     button2 = new UI.Button(),
	 *     button3 = new UI.Button();
	 * button1.setStyle(style);
	 * button2.setStyle(style);
	 * button3.setStyle(style);
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.Style`
	 *		object.
	 * @see UI.Commands#State
	 * @since 1.6
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (Style._init) Style._init();
		$super(properties);
	},
	
	/** @private */
	$synthesizePropertyWithState: function(propName, commandsFn) {
		function doSynthesis(caseAdjusted, stateName, stateFlags) {
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}
		Element.synthesizePropertyWithState.call(this, propName, commandsFn);
		// Synthesize stateful accessors.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		for (var stateName in stateMap) {
			doSynthesis.call(this, caseAdjusted, stateName, stateMap[stateName]);
		}
	}
});

Style._init = function() {
	delete Style._init;
	if (Element._init) Element._init();

		/**
		 * Set the `gradient` property for a specified view state. You can use this property to add
		 * outlines, shadows, rounded corners, and gradient fills to a view. The `gradient` property
		 * can contain any or all of the following properties:
		 * 
		 * + **`corners`**: The radius, in pixels, for the view's corners. Specified as a string that
		 * contains a list of four floats separated by spaces. The floats start with the top left 
		 * corner of the view and go clockwise around the view. For example, to specify a radius of 
		 * 6 pixels for the top right and bottom left corners: `"0.0 6.0 0.0 6.0"`
		 * + **`gradient`**: The gradient fill for the view, drawn from top to bottom. Specified as 
		 * an array of strings (for example, `["FF0028FF 0.00", "FF6A84FF 0.25"]`). Each string 
		 * contains two values separated by spaces:
		 *     1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
		 *     2. A float, ranging from `0.0` (the top of the button) to `1.0` (the bottom of the
		 *     button), indicating a point at which the color should begin to fade into the prior
		 *     color.
		 * + **`innerLine`**: The line drawn inside the view's edges. Specified as a string (for 
		 * example, `"FFC0EA82 2.0"`) that contains two values separated by a space:
		 *     1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
		 *     2. A float indicating the width, in pixels, of the line.
		 * + **`innerShadow`**: The shadow drawn inside the view's edges, which can be used to 
		 * create a "glowing" effect. Specified as a string (for example, `"FFFFFFFF 5.0 {0.0, 
		 * 0.0}"`) that contains three values separated by spaces:
		 *     1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
		 *     2. The width, in pixels, to blur the edges of the shadow.
		 *     3. Two comma-separated floats enclosed in brackets:
		 *         1. The shadow's X offset from the left, in pixels.
		 *         2. The shadow's Y offset from the top, in pixels.
		 * + **`insets`**: The view's insets, in pixels, from its edges. Specified as a string 
		 * containing four comma-separated floats enclosed in brackets. The floats start at the top 
		 * of the view and go counter-clockwise around the view. For example, to specify a top inset 
		 * of 5 pixels and a right inset of 10 pixels: `{0, 5, 0, 10}`
		 * + **`outerLine`**: The line drawn outside the view's edges. Uses the same format as the
		 * `innerLine` property.
		 * + **`outerShadow`**: The shadow drawn outside the view's edges, which can be used to 
		 * create a "drop shadow" effect. Uses the same format as the `innerShadow` property.
		 * **Note**: The outer shadow is drawn within the view's bounds. This means you must specify
		 * insets in order for the drop shadow to be visible.
		 * @name UI.Style#setGradient
		 * @function
		 * @example
		 * // Create a style for an opaque white inner shadow that has a 
		 * // 10-pixel blur and no offset.
		 * var style = UI.Style();
		 * var gradient = {
		 *     innerShadow: "FFFFFFFF 5.0 {0.0, 0.0}"
		 * };
		 * style.setGradient(gradient);
		 * @example
		 * // Create an opaque gradient that is light blue in the middle and
		 * // dark blue on the top and bottom edges.
		 * var style = UI.Style();
		 * var gradient = {
		 *     gradient: ["FF0028FF 0.00", "FF6A84FF 0.25", "FF6A84FF 0.75",
		 *         "FF0028FF 1.00"]
		 * };
		 * style.setGradient(gradient);
		 * @example
		 * // Create an opaque gradient that is dark blue at the top, bottom,
		 * // and middle and light blue in between.
		 * var style = UI.Style();
		 * var gradient = {
		 *     gradient: ["FF0028FF 0.000", "FF6A84FF 0.250", "FF0028FF 0.500",
		 *         "FF6A84FF 0.750", "FF0028FF 1.000"]
		 * };
		 * style.setGradient(gradient);
		 * @example
		 * // Create a style for a gradient that fades from light blue to dark
		 * // blue, with a white inner shadow and a dark gray border.
		 * var style = UI.Style();
		 * var gradient = {
		 *     corners: "5.0 5.0 5.0 5.0",
		 *     gradient: ["FF9999FF 0.0", "FF5665FF 0.4", "FF0000FF 1.0"],
		 *     innerShadow: "FFFFFFFF 15.0 {0.0, 0.0}",
		 *     outerLine: "FF5F5F5F 1.0",
		 *     outerShadow: "00000000 0.0 {0.0, 0.0}"
		 * };
		 * style.setGradient(gradient);
		 * @param {Object} gradient The new `gradient` property, using the format described above.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this gradient. To specify a gradient for a view that is in multiple states, you 
		 * 		can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getGradient
		 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `gradient` property for a specified view state.
		 * @name UI.Style#getGradient
		 * @function	
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {Object} The current gradient, in the format described in
		 *		`{@link UI.Style#setGradient}`.
		 * @see UI.Style#setGradient
		 * @since 1.6
		 */
		Style.synthesizePropertyWithState('gradient', Commands.setGradient);
		
		/**
		 * Set the `image` property, which contains the path to an image that will be displayed for 
		 * a specified view state.
		 * @name UI.Style#setImage
		 * @function 
		 * @example
		 * var style = new UI.Style();
		 * style.setImage("./Content/splash.png", UI.Commands.State.Selected |
		 *     UI.Commands.State.Focused);
		 * @param {String} imageURL The new image URL.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this image. To specify an image for a view that is in multiple states, you can 
		 * 		use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getImage
		 * @since 1.6
		 */
		/**
		 * Retrieve a path to the image for a specified view state.
		 * @name UI.Style#getImage
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The path to the image for the specified view state.
		 * @see UI.Style#setImage
		 * @since 1.6
		 */
		Style.synthesizePropertyWithState('image', Commands.setImage);
		/**
		 * Set the `imageBorder` property, which defines a border for images in a specified view 
		 * state. See `{@link UI.Style#setGradient}` for information about the format of this
		 * property.
		 * @name UI.Style#setImageBorder
		 * @function
		 * @example
		 * // Create a style for a dark gray image border.
		 * var style = new UI.Style();
		 * var border = {
		 *     outerLine: "FF5F5F5F 1.0"
		 * }; 
		 * style.setImageBorder(border);
		 * @param {Object} imageBorder The new image border.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this border. To specify a border for a view that is in multiple states, you can
		 * 		use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getImageBorder
		 * @see UI.Style#setGradient
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the `imageBorder` property, which defines a border for images in a specified
		 * view state.
		 * @name UI.Style#getImageBorder
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {Object} The current image border.
		 * @see UI.Style#setImageBorder
		 * @since 1.6
		 */
		Style.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
		/**
		 * Set the `imageFit` property, which defines how images will be scaled relative to the
		 * view.
		 * @name UI.Style#setImageFit
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setImageFit(UI.Commands.FitMode.None);
		 * @param {UI.Commands#FitMode} imageFit The scaling option that will be used to scale 
		 * 		images relative to the button.
		 * @returns {void}
		 * @see UI.Commands#FitMode
		 * @see UI.Style#getImageFit
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `imageFit` property, which defines how images will be scaled
		 * relative to the view.
		 * @name UI.Style#getImageFit
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setImageFit(UI.Commands.FitMode.AspectWidth);
		 * var image = new UI.Image();
		 * image.setStyle(style);
		 * // More code here.
		 * // Later, the application takes an action based on the image's
		 * // fit mode:
		 * var imageStyle = image.getStyle();
		 * var imageFitMode = imageStyle.getImageFit();
		 * switch (imageFitMode) {
		 *     case UI.Commands.FitMode.AspectHeight:
		 *         // Your code here
		 *         break;
		 *     case UI.Commands.FitMode.AspectWidth:
		 *         // Your code here
		 *         break;
		 *     // Continue through each enumerated value that you want to test
		 *     default:
		 *         // Your code here
		 *         break;
		 * }
		 * @returns {Number} The current scaling option that will be used to scale images relative
		 * 		to the view. The returned value corresponds to an enumerated value of
		 *		`{@link UI.Commands#FitMode}`.
		 * @see UI.Commands#FitMode
		 * @see UI.Style#setImageFit
	 	 * @since 1.6
		 */
		Style.synthesizeProperty('imageFit', Commands.setImageFitMode);
		/**
		 * Set the `imageInsets` property, which contains insets that are used to clip the edges of
		 * an image. The inset is specified as an array of floats, starting with the top inset and
		 * going clockwise around the image.
		 * @name UI.Style#setImageInsets
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
		 * // a left inset of 5.
		 * style.setImageInsets([10, 20, 15, 5]);
		 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
		 *		starting with the top inset and going clockwise around the image.
		 * @returns {void}
		 * @see UI.Style#getImageInsets
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `imageInsets` property, which contains insets that are used to
		 * clip the edges of an image.
		 * @name UI.Style#getImageInsets
		 * @function
		 * @returns {Number[]} The current image insets. Specified as an array of four floats, 
		 *		starting with the top inset and going clockwise around the image.
		 * @see UI.Style#setImageInsets
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
		/**
		 * Set the `imageGravity` property, which defines how an image is positioned within the
		 * viewable area. The image gravity is defined as two floats, one for the X (horizontal)
		 * axis and one for the Y (vertical) axis. Each float represents a percentage of the
		 * whitespace surrounding the image.
		 * 
		 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
		 * image, with the remainder placed to the right of the image. For the Y axis, the specified 
		 * percentage of whitespace will be placed above the image, with the remainder placed below
		 * the image.
		 * 
		 * Each UI component uses a different default value for its image gravity. See the UI
		 * component's documentation for details.
		 * @name UI.Style#setImageGravity
		 * @function
		 * @example
		 * // Set the image gravity so that images are vertically centered
		 * // and horizontally placed near the left edge.
		 * var style = new UI.Style();
		 * style.setImageGravity([0.25, 0.5]);
		 * @param {Number[]|UI.ViewGeometry#Gravity} imageGravity The new image gravity. Specified
		 *		as an array of two floats, where the first represents the X axis and the second
		 *		represents the Y axis. You can also specify an enumerated value of
		 *		`{@link UI.ViewGeometry#Gravity}` in place of the array.
		 * @returns {void}
		 * @see UI.Style#getImageGravity
		 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `imageGravity` property, which defines how an image is
		 * positioned within the viewable area.
		 * @name UI.Style#getImageGravity
		 * @function
		 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where
		 *		the first represents the X axis and the second represents the Y axis.
		 * @see UI.Style#setImageGravity
		 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
		/**
		 * Set the `imageTransform` property, which defines an affine transformation of an image. An
		 * affine transformation makes it possible to move, scale, or skew an image while ensuring 
		 * that straight lines remain straight and parallel lines remain parallel. You can also use 
		 * an affine transformation to rotate an image.
		 * 
		 * The parameters to this method represent a 2 x 3 matrix that contains the following
		 * values:
		 * 
		 *     --      --    a = X scale    tx = X reposition
		 *     | a    b |    b = Y skew     ty = Y reposition
		 *     | c    d |    c = X skew
		 *     | tx  ty |    d = Y scale
		 *     --      --
		 * @name UI.Style#setImageTransform
		 * @function
		 * @example
		 * // Increase an image's size by 20 units along the X axis, and move it
		 * // down 5 units along the Y axis.
		 * var style = new UI.Style();
		 * var scaleX = 20;
		 * var moveY = 5;
		 * style.setImageTransform([scaleX, 0, 0, 0, 0, moveY]);
		 * @example
		 * // Rotate an image 30 degrees to the left.
		 * function degreesToRadians(degrees) {
		 *     return degrees * (Math.PI / 180);
		 * }
		 *
		 * var style = new UI.Style();
		 * var angle = degreesToRadians(30);
		 * style.setImageTransform([Math.cos(angle), Math.sin(angle),
		 *     -Math.sin(angle), Math.cos(angle), 0, 0]);
		 * @example
		 * // Skew the bottom of an image to the right by 10 units along the
		 * // X axis.
		 * var style = new UI.Style();
		 * var skewX = 10;
		 * style.setImageTransform([0, 0, skewX, 0, 0, 0]);
		 * @param {Number[]} imageTransform The new affine transformation to use. Specified as an
		 *		array of six floats: `[a, b, c, d, tx, ty]`.
		 * @returns {void}
		 * @see UI.Style#getImageTransform
		 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `imageTransform` property, which defines an affine transformation
		 * of the image.
		 * @name UI.Style#getImageTransform
		 * @function
		 * @returns {Number[]} The current affine transformation. Specified as an array of six 
		 *		 floats: `[a, b, c, d, tx, ty]`.
		 * @see UI.Style#setImageTransform
		 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
		
		/**
		 * Set the `text` property, which defines text for the view in a specified view state.
		 * @name UI.Style#setText
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setText("More information");
		 * @param {String} text The new text for the view.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this text. To specify text for a view that is in multiple states, you can use 
		 * 		the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getText
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `text` property, which defines text for the view in a specified
		 * view state.
		 * @name UI.Style#getText
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current text for the specified view state.
		 * @see UI.Style#setText
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('text', Commands.setText);
		/**
		 * Set the `textColor` property, which defines the text color for the view in a specified 
		 * view state.
		 * @name UI.Style#setTextColor
		 * @function 
		 * @example
		 * var style = new UI.Style();
		 * style.setTextColor("FFFFFF");
		 * @param {String} textColor The new text color, in hexidecimal RGB format.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this text color. To specify a text color for a view that is in multiple states, 
		 * 		you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTextColor
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textColor` property, which defines the text color for the view
		 * in a specified view state.
		 * @name UI.Style#getTextColor
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
		 *		format.
		 * @see UI.Style#setTextColor
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('textColor', Commands.setTextColor);
		/**
		 * Set the `textFont` property, which defines the font that is used for the view's text in a
		 * specified view state.
		 * @name UI.Style#setTextFont
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setTextFont("DroidSans");
		 * @param {String} textFont The name of the new font.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this font. To specify a font for a view that is in multiple states, you can use 
		 * 		the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTextFont
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textFont` property, which defines the font that is used for 
		 * the view's text in a specified view state.
		 * @name UI.Style#getTextFont
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The name of the current font for the specified view state.
		 * @see UI.Style#setTextFont
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('textFont', Commands.setTextFont);
		/**
		 * Set the `textShadow` property, which defines the color and size of shadows on the view's 
		 * text in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0,
		 * -1.0}"`) that contains three values separated by spaces:
		 * 
		 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
		 * 2. The width, in pixels, to blur the edges of the shadow.
		 * 3. Two comma-separated floats enclosed in brackets:
		 *     1. The shadow's X offset from the left, in pixels.
		 *     2. The shadow's Y offset from the top, in pixels.
		 * @name UI.Style#setTextShadow
		 * @function
		 * @example
		 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
		 * var style = new UI.Style();
		 * style.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
		 * @param {String} textShadow The new text shadow, in the format specified above.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this text shadow. To specify a text shadow for a view that is in multiple 
		 * 		states, you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTextShadow
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textShadow` property, which defines the color and size of 
		 * shadows on the view's text in a specified view state.
		 * @name UI.Style#getTextShadow
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current text shadow.
		 * @see UI.Style#setTextShadow
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
		/**
		 * Set the `textGravity` property, which defines how a view's text is positioned within the
		 * viewable area. The text gravity is defined as two floats, one for the X (horizontal) 
		 * axis and one for the Y (vertical) axis. Each float represents a percentage of the 
		 * whitespace surrounding the text.
		 * 
		 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
		 * text, with the remainder placed to the right of the text. For the Y axis, the specified 
		 * percentage of whitespace will be placed above the text, with the remainder placed below 
		 * the text.
		 * 
		 * Each UI component uses a different default value for its text gravity. See the UI
		 * component's documentation for details.
		 * @name UI.Style#setTextGravity
		 * @function
		 * @example
		 * // Set the text gravity so that text is vertically centered and
		 * // horizontally placed near the left edge.
		 * var style = new UI.Style();
		 * style.setTextGravity([0.1, 0.5]);
		 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as
		 *		an array of two floats, where the first represents the X axis and the second
		 *		represents the Y axis. You can also specify an enumerated value of
		 *		`{@link UI.ViewGeometry#Gravity}` in place of the array.
		 * @returns {void}
		 * @see UI.Style#getTextGravity
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textGravity` property, which defines how a view's text is
		 * positioned within the viewable area.
		 * @name UI.Style#getTextGravity
		 * @function
		 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where 
		 *		the first represents the X axis and the second represents the Y axis.
		 * @see UI.Style#setTextGravity
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
		/**
		 * Set the `textSize` property, which specifies the size, in pixels, of a view's text.
		 * @name UI.Style#setTextSize
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * var textSize = 24;
		 * style.setTextSize(textSize);
		 * @param {Number} textSize The new size, in pixels, of a view's text.
		 * @returns {void}
		 * @see UI.Style#getTextSize
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of a
		 * view's text.
		 * @name UI.Style#getTextSize
		 * @function
		 * @returns {Number} The current size, in pixels, of a view's text.
		 * @see UI.Style#setTextSize
	 	 * @since 1.6
		 */
		Style.synthesizeProperty('textSize', Commands.setTextSize);
		/**
		 * Set the `textInsets` property, which contains insets that are used to clip the edges of
		 * text. The inset is specified as an array of floats, starting with the top inset and going
		 * clockwise around the text.
		 * @name UI.Style#setTextInsets
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * var insetLeft = 10;
		 * style.setTextInsets([0, 0, 0, insetLeft]);
		 * @param {Number[]} textInsets The new text insets. Specified as an array of four floats, 
		 *		starting with the top inset and going clockwise around the text.
		 * @returns {void}
		 * @see UI.Style#getTextInsets
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `textInsets` property, which contains insets that are used to 
		 * clip the edges of text.
		 * @name UI.Style#getTextInsets
		 * @function
		 * @returns {Number[]} The current text insets. Specified as an array of four floats, 
		 *		starting with the top inset and going clockwise around the text.
		 * @see UI.Style#setTextInsets
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
		Style.synthesizeProperty('lineHeight', Commands.setLineHeight);

		/**
		 * Set the `rightImage` property, which defines a path to an image to display on the right 
		 * side of a view for a specified view state.
		 * @name UI.Style#setRightImage
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setRightImage("./Content/right-arrow.png",
		 *     UI.Commands.State.Focused);
		 * @param {String} rightImage The path to the new image.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this right image. To specify a right image for a view that is in multiple 
		 * 		states, you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getRightImage
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `rightImage` property, which defines a path to an image to 
		 * display on the right side of a view for a specified view state.
		 * @name UI.Style#getRightImage
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current path to the image that will be displayed on the right side 
		 *		of the view.
		 * @see UI.Style#setRightImage
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('rightImage', Commands.setRightImage);
		/**
		 * Set the `rightImageBorder` property, which defines a border for the image that is
		 * specified by the `rightImage` property for a specified view state. See 
		 * `{@link UI.Style#setGradient}` for information about the format of the `rightImageBorder`
		 * property.
		 * @name UI.Style#setRightImageBorder
		 * @function
		 * @example
		 * // Specify a one-pixel dark gray border.
		 * var style = new UI.Style();
		 * style.setRightImageBorder({
		 *     outerLine: "FF5F5F5F 1.0"
		 * });
		 * @param {Object} rightImageBorder The new image border for the right image.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this right image border. To specify a right image border for a view that is in 
		 * 		multiple states, you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getRightImageBorder
		 * @see UI.Style#setGradient
		 * @see UI.Style#setRightImage
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `rightImageBorder` property, which defines a border for the 
		 * image that is specified by the `rightImage` property for a specified view state.
		 * @name UI.Style#getRightImageBorder
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {Object} The current image border for the right image.
		 * @see UI.Style#setRightImage
		 * @see UI.Style#setRightImageBorder
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('rightImageBorder', Commands.setRightImageBorder);
		/**
		 * Set the `rightImageFit` property, which defines how the right image will be scaled 
		 * relative to a view.
		 * @name UI.Style#setRightImageFit
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setRightImageFit(UI.Commands.FitMode.None);
		 * @param {UI.Commands#FitMode} rightImageFit The scaling option that will be used to scale 
		 * 		the right image relative to a view.
		 * @returns {void}
		 * @see UI.Style#getRightImageFit
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `rightImageFit` property, which defines how the right image 
		 * will be scaled relative to a  view.
		 * @name UI.Style#getRightImageFit
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setImageFit(UI.Commands.FitMode.AspectWidth);
		 * var cell = new UI.CellView();
		 * cell.setStyle(style);
		 * // More code here.
		 * // Later, the application takes an action based on the image's fit mode:
		 * var imageStyle = cell.getStyle();
		 * var imageFitMode = imageStyle.getImageFit();
		 * switch (imageFitMode) {
		 *     case UI.Commands.FitMode.AspectHeight:
		 *         // Your code here
		 *         break;
		 *     case UI.Commands.FitMode.AspectWidth:
		 *         // Your code here
		 *         break;
		 *     // Continue through each enumerated value that you want to test
		 *     default:
		 *         // Your code here
		 *         break;
		 * }
		 * @returns {Number} The current scaling option that will be used to scale the right image 
		 * 		relative to the view. The returned value corresponds to an enumerated value of
		 *		`{@link UI.Commands#FitMode}`.
		 * @see UI.Style#setRightImageFit
	 	 * @since 1.6
		 */
		Style.synthesizeProperty('rightImageFit', Commands.setRightImageFitMode);
		/**
		 * Set the `rightImageInsets` property, which contains insets that are used to clip the 
		 * edges of the right image. The inset is specified as an array of floats, starting with the
		 * top inset and going clockwise around the image.
		 * @name UI.Style#setRightImageInsets
		 * @function
		 * @example
		 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
		 * // a left inset of 5.
		 * var style = new UI.Style();
		 * style.setRightImageInsets([10, 20, 15, 5]);
		 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
		 *		starting with the top inset and going clockwise around the image.
		 * @returns {void}
		 * @see UI.Style#getRightImageInsets
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `rightImageInsets` property, which contains insets that are 
		 * used to clip the edges of the right image.
		 * @name UI.Style#getRightImageInsets
		 * @function
		 * @returns {Number[]} imageInsets The current image insets. Specified as an array of four 
		 *		floats, starting with the top inset and going clockwise around the image.
		 * @see UI.Style#setRightImageInsets
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('rightImageInsets', Commands.setRightImageInsets);
		/**
		 * Set the `rightImageGravity` property, which defines how the right image is positioned 
		 * within a viewable area. See `{@link UI.Style#setImageGravity}` for information about this
		 * property.
		 * @name UI.Style#setRightImageGravity
		 * @function
		 * @example
		 * // Set the image gravity so that the right image is horizontally
		 * // centered and vertically adjacent to the top side of the view.
		 * var style = new UI.Style();
		 * style.setRightImageGravity([0.5, 0.0]);
		 * @param {Number[]} rightImageGravity The image gravity to use. Specified as an array of 
		 *		two floats, where the first represents the X axis and the second represents the Y
		 *		axis.
		 * @returns {void}
		 * @see UI.Style#getRightImageGravity
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `rightImageGravity` property, which defines how the right image
		 * is positioned within a viewable area.
		 * @name UI.Style#getRightImageGravity
		 * @function
		 * @returns {Number[]} rightImageGravity The current image gravity. Specified as an array of
		 *		two floats, where the first represents the X axis and the second represents the Y
		 *		axis.
		 * @see UI.Style#setRightImageGravity
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('rightImageGravity', Commands.setRightImageGravity);
		/**
		 * Set the `rightImageTransform` property, which defines an affine transformation of the
		 * right image. See `{@link UI.Style#setImageTransform}` for information about this
		 * property.
		 * @name UI.Style#setRightImageTransform
		 * @function
		 * @example 
		 * // Increase an image's size by 20 units along the X axis, and move it
		 * // down 5 units along the Y axis.
		 * var style = new UI.Style();
		 * var scaleX = 20;
		 * var moveY = 5;
		 * style.setRightImageTransform([scaleX, 0, 0, 0, 0, moveY]);
		 * @param {Number[]} rightImageTransform The new affine transformation. Specified as an 
		 *		array of six floats: `[a, b, c, d, tx, ty]`.
		 * @returns {void}
		 * @see UI.Style#getRightImageTransform
		 * @see UI.Style#setImageTransform
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the current value of the `rightImageTransform` property, which defines an affine
		 * transformation of the right image.
		 * @name UI.Style#getRightImageTransform
		 * @function
		 * @returns {Number[]} rightImageTransform The current affine transformation. Specified as
		 *		an array of six floats: `[a, b, c, d, tx, ty]`.
		 * @see UI.Style#setRightImageTransform
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('rightImageTransform', Commands.setRightImageTransform);
		
		/**
		 * Set the `title` property, which defines a title for a view in a specified view state.
		 * @name UI.Style#setTitle
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * var title = "Configure Application";
		 * style.setTitle(title);
		 * @param {String} title The new view title.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this title. To specify a title for a view that is in multiple states, you can 
		 * 		use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTitle
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the current value of the `title` property, which defines a title for a view in a
		 * specified view state.
		 * @name UI.Style#getTitle
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current view title.
		 * @see UI.Style#setTitle
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('title', Commands.setTitle);
		/**
		 * Set the `titleColor` property, which defines the text color for a view's title in a 
		 * specified view state.
		 * @name UI.Style#setTitleColor
		 * @function 
		 * @example
		 * var style = new UI.Style();
		 * style.setTitleColor("FFFFFF");
		 * @param {String} titleColor The new title text color, in hexidecimal RGB format.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this text color. To specify a text color for a view that is in multiple states, 
		 * 		you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTitleColor
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleColor` property, which defines the text color for a
		 * view's title in a specified view state.
		 * @name UI.Style#getTitleColor
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current title text color, in hexidecimal RGB format.
		 * @see UI.Style#setTitleColor
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('titleColor', Commands.setTitleColor);
		/**
		 * Set the `titleFont` property, which defines the font that is used for a view's title text
		 * in a specified view state.
		 * @name UI.Style#setTitleFont
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setTitleFont("DroidSans");
		 * @param {String} textFont The name of the new font.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this font. To specify a font for a view that is in multiple states, you can use 
		 * 		the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#getTitleFont
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleFont` property, which defines the font that is used for 
		 * a view's title text in a specified view state.
		 * @name UI.Style#getTitleFont	 
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current title text font.
		 * @see UI.Style#setTitleFont
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('titleFont', Commands.setTitleFont);
		/**
		 * Set the `titleShadow` property, which defines the color and size of shadows on a view's 
		 * title text in a specified view state. See `{@link UI.Style#setTextShadow}` for 
		 * information about this property.
		 * @name UI.Style#setTitleShadow
		 * @function
		 * @example
		 * // Use a white title text shadow with a two-pixel blur, shifted up
		 * // one pixel.
		 * var style = new UI.Style();
		 * style.setTitleShadow("FFCCCCFF 2.0 {0.0, -1.0}");
		 * @param {String} titleShadow The new title text shadow, in the format specified by 
		 *		`{@link UI.Style#setTextShadow}`.
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to 
		 *		use this title text shadow. To specify a text shadow for a view that is in multiple 
		 * 		states, you can use the `|` operator to combine multiple flags.
		 * @returns {void}
		 * @see UI.Style#setTextShadow
		 * @see UI.Style#getTitleShadow
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleShadow` property, which defines the color and size of 
		 * shadows on a view's title text in a specified view state.
		 * @name UI.Style#getTitleShadow
		 * @function
		 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
		 * @returns {String} The current title text shadow.
		 * @see UI.Style#setTitleShadow
	 	 * @since 1.6
		 */
		Style.synthesizePropertyWithState('titleShadow', Commands.setTitleShadow);
		/**
		 * Set the `titleGravity` property, which defines how a view's title text is positioned 
		 * within the viewable area. See `{@link UI.Style#setTextGravity}` for information about 
		 * this property.
		 * @name UI.Style#setTitleGravity
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * style.setTitleGravity([0.5, 0.0]);	 
		 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new title text gravity. 
		 *		Specified as an array of two floats, where the first represents the X axis and the 
		 *		second represents the Y axis. You can also specify an enumerated value of
		 *		`{@link UI.ViewGeometry#Gravity}` in place of the array.
		 * @returns {void}
		 * @see UI.Style#getTitleGravity
		 * @see UI.Style#setTextGravity
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleGravity` property, which defines how a view's title text
		 * is positioned within the viewable area.
		 * @name UI.Style#getTitleGravity
		 * @function
		 * @returns {Number[]} The current title text gravity. Specified as an array of two floats,
		 *		where the first represents the X axis and the second represents the Y axis.
		 * @see UI.Style#setTitleGravity
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('titleGravity', Commands.setTitleGravity);
		/**
		 * Set the `titleSize` property, which specifies the size, in pixels, of a view's title
		 * text.
		 * @name UI.Style#setTitleSize
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * var textSize = 24;
		 * style.setTitleSize(textSize);
		 * @param {Number} titleSize The new size, in pixels, of the title text.
		 * @returns {void}
		 * @see UI.Style#getTitleSize
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleSize` property, which specifies the size, in pixels, of
		 * a view's title text.
		 * @name UI.Style#getTitleSize
		 * @function
		 * @returns {Number} The current size, in pixels, of the title text.
		 * @see UI.Style#setTitleSize
	 	 * @since 1.6
		 */
		Style.synthesizeProperty('titleSize', Commands.setTitleSize);
		/**
		 * Set the `titleInsets` property, which contains insets that are used to clip the edges of 
		 * a view's title text. The inset is specified as an array of floats, starting with the top 
		 * inset and going clockwise around the text.
		 * @name UI.Style#setTitleInsets
		 * @function
		 * @example
		 * var style = new UI.Style();
		 * var insetLeft = 10;
		 * style.setTitleInsets([0, 0, 0, insetLeft]);
		 * @param {Number[]} titleInsets The new title text insets. Specified as an array of four 
		 *		floats, starting with the top inset and going clockwise around the text.
		 * @returns {void}
		 * @see UI.Style#getTitleInsets
	 	 * @since 1.6
		 */
		/**
		 * Retrieve the value of the `titleInsets` property, which contains insets that are used to 
		 * clip the edges of a view's title text.
		 * @name UI.Style#getTitleInsets
		 * @function
		 * @returns {Number[]} titleInsets The current title text insets. Specified as an array of 
		 *		four floats, starting with the top inset and going clockwise around the text.
		 * @see UI.Style#setTitleInsets
	 	 * @since 1.6
		 */
		Style.synthesizeCompoundProperty('titleInsets', Commands.setTitleInsets);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AbstractView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AbstractView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AbstractView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/AbstractView.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Rect = require('NGCore/Client/UI/ViewGeometry').Rect;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Style = require('NGCore/Client/UI/Style').Style;

var stateMap = {
	'normal': Commands.State.Normal,
	'focused': Commands.State.Focused,
	'pressed': Commands.State.Pressed,
	'disabled': Commands.State.Disabled,
	//** extra-deprecated */
	'selected': Commands.State.Focused,
	'highlighted': Commands.State.Pressed
};

var AbstractView = exports.AbstractView = Element.subclass(
/** @lends UI.AbstractView.prototype */
{
	'type':'<com.ngmoco.view.abstract>',
	/**
	 * @class The `UI.AbstractView` class is a base class for derived classes that manage
	 * application views.
	 * 
	 * **Important**: This base class is not exported in the `UI` module. Do not access it directly
	 * or create subclasses of `UI.AbstractView`.
	 * 
	 * Classes that are derived from `UI.AbstractView` include:
	 * 
	 * + `{@link UI.Button}`
	 * + `{@link UI.CellView}`
	 * + `{@link UI.CheckBox}`
	 * + `{@link UI.EditText}`
	 * + `{@link UI.GLView}`
	 * + `{@link UI.Image}`
	 * + `{@link UI.Label}`
	 * + `{@link UI.Spinner}`
	 * + `{@link UI.View}`
	 * + `{@link UI.WebView}`
	 *
	 * The appearance of an object that is derived from `UI.AbstractView` can change automatically
	 * when the object's view state changes. For example, the view's fill color can change
	 * automatically when the view gains focus or is selected. To implement this feature, your
	 * application can call a `UI.AbstractView` setter method more than once, passing a different
	 * value in the `flags` parameter each time. In addition, your application can include
	 * properties for multiple view states in the constructor. See the `{@link UI}` module overview
	 * for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.AbstractView#setBackgroundColor}` to specify
	 * the view's background color, the color you specify will apply in all view states.
	 * @name UI.AbstractView
	 * @constructs Create a new view.
	 * @augments UI.Element
	 * @example
	 * // Create a new UI.Button object (derived from UI.AbstractView) without
	 * // setting any of its properties.
	 * var button = new UI.Button();
	 * @example
	 * // Create a new UI.Button object (derived from UI.AbstractView), setting
	 * // its text and text size.
	 * var button = new UI.Button({
	 *     text: "Back",
	 *     textSize: 32
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.AbstractView` object.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (AbstractView._init) AbstractView._init();
		
		this._assignedVisible = true;
		$super(properties);
	},
	
	/** @private */
	destroy: function($super){
		this.removeFromParent();
		$super();
	},
	
	/**
	 * Retrieve the view's parent.
	 * @function
	 * @returns {Object} The view's parent, or `undefined` if the view does not have a parent.
	 * @see UI.AbstractView#addToParent
	 * @see UI.AbstractView#removeFromParent
	 * @since 1.0
	 */    
	getParent: function(){
		return this._parent;
	},
    
	/**
	 * Add a node as a child of the specified parent node. If an index is specified, the node will
	 * be added to the parent node at the specified index. Otherwise, the node will be added as the 
	 * last child of the parent node.
	 * @function
	 * @example
	 * var myParent = new UI.View();
	 * var childNode = new UI.View();
	 * childNode.addToParent(myParent); 
	 * @param {Object} parentNode The parent node.
	 * @param {Number} [index] The index at which to add the child node.
	 * @returns {void}
	 * @see UI.AbstractView#getParent
	 * @see UI.AbstractView#removeFromParent
	 * @since 1.0
	 */
	addToParent: function(parentNode, index){
		parentNode.addChild(this, index);
	},
    
	/**
	 * Remove a child node from the parent node.
	 * @function
	 * @example
	 * var myParent = new UI.View();
	 * var childNode = new UI.View();
	 * childNode.addToParent(myParent);
	 * // more code here
	 * childNode.removeFromParent(myParent);
	 * @returns {this}
	 * @see UI.AbstractView#getParent
	 * @see UI.AbstractView#addToParent
	 * @since 1.0
	 */    
	removeFromParent: function(){
		if (this._parent && !this._parent._destroyed) {
			this._parent.removeChild(this);
			this._parent = null;
		}
		return this;
	},
	
	
	/**
	 * Add a view state to the view.
	 * @function
	 * @example
	 * var image = new UI.Image();
	 * image.addState(UI.Commands.State.Focused);
	 * @param {Number} flags The view state for this view.
	 * @returns {void}
	 * @see UI.AbstractView#clearState
	 * @see UI.AbstractView#getState
	 * @see UI.AbstractView#setState
	 * @see UI.Commands#State
	 * @since 1.0
	 */
	addState: function(flags) {
		this.setState(this._state | flags);
	},
	
	/**
	 * Clear the specified state from the view.
	 * @function 
	 * @example
	 * var image.new UI.Image();
	 * image.addState(UI.Commands.State.Focused);
	 * // More code here
	 * image.clearState(UI.Commands.State.Focused);
	 * @param {Number} flags The view state to clear from the view.
	 * @returns {void}
	 * @see UI.AbstractView#addState
	 * @see UI.AbstractView#getState
	 * @see UI.AbstractView#setState
	 * @see UI.Commands#State
	 * @since 1.0
	 */  
	clearState: function(flags) {
		this.setState(this._state & ~flags);
	},
    
	/**
	 * Retrieve the root node for this view.
	 * @function 
	 * @returns {Object} The root node if this is a child node, or `undefined` if it is not a child
	 *		node.
	 * @since 1.0
	 */
	getRoot: function() {
		return this._parent ? this._parent.getRoot() : undefined;
	},

	/**
	 * Retrieve the view's position and size relative to a second view. The second view must share
	 * an ancestor with the view.
	 *
	 * This method returns `undefined` in the following cases:
	 *
	 * + A frame has not been defined for the view.
	 * + The second view is `null` or `undefined`.
	 * + The second view does not share an ancestor with the view.
	 * @example
	 * // 1. Create a 500-pixel by 500-pixel parent view at the screen's 
	 * //    origin, and add it as a child of UI.Window.document.
	 * // 2. Create a 10-pixel by 10-pixel child view, with a 10-pixel X and Y
	 * //    offset from the origin, and add it as a child of the parent view.
	 * // 3. Create a 500-pixel by 500-pixel child view, with a 10-pixel X and Y
	 * //    offset from the origin, and add it as a child of UI.Window.document.
	 * // 4. Retrieve the frame for the second child view relative to the
	 * //    first child view. Because the two views have the same X and Y 
	 * //    offset, the origin is [0, 0]. The width and height are [10, 10],
	 * //    the dimensions of the smaller of the two views.
	 * var myParent = new UI.View();
	 * myParent.setFrame([0, 0, 500, 500]);
	 * UI.Window.document.addChild(myParent);
	 * var childView1 = new UI.View();
	 * childView1.setFrame([10, 10, 10, 10]);
	 * childView1.addToParent(myParent);
	 * var childView2 = new UI.View();
	 * childView2.setFrame([10, 10, 500, 500]);
	 * UI.Window.document.addChild(childView2);
	 * // frameInChildView2 is set to [0, 0, 10, 10]:
	 * var frameInChildView2 = childView1.getFrameIn(childView2);
	 * @param {UI.AbstractView} other The second view that will be used to calculate the view's
	 *		relative position.
	 * @returns {Number[]} An array of four floats identifying the view's width, height, X origin,
	 *		and Y origin relative to the second view, in that order.
	 * @see UI.AbstractView#setFrame
	 * @since 1.7
	 */
	getFrameIn: function(other) {
		if (!other) return undefined;
		if (UI.Window === other) {
			other = UI.Window.document;
		}
		var frame = this.getFrame();
		if (!frame) return undefined;
		frame = [0, 0, frame[2], frame[3]];
		if (this === other) return frame;

		// Create stack for this branch
		var thisBranch = [];
		var visited = {};
		var curView = this;
		do {
			visited[curView] = true;
			thisBranch.push(curView);
			if (curView === other) break;
			curView = curView.getParent();
		} while (curView);

		// Create stack for other branch, stop when common ancestor is found
		var otherBranch = [];
		curView = other;
		while (curView && !visited[curView]) {
			otherBranch.push(curView);
			curView = curView.getParent();
		}
		if (!curView) {
			// If both nodes have roots (WindowLayer as the first layer), then they are comparable since WindowLayers are all the same dimensions
			var thisRoot = this.getRoot();
			if (thisRoot && other.getRoot()) {
				curView = thisRoot;
				otherBranch.pop();
			} else {
				return undefined; // No common ancestor
			}
		}

		// Create array marking path from this to other
		// The common ancestor needs to be excluded since it provides a frame to its parent which isn't included in the path
		var commonAncestorIndex = thisBranch.indexOf(curView);
		for (var endIndex=commonAncestorIndex, l=commonAncestorIndex + otherBranch.length; endIndex<l; ++endIndex) {
			thisBranch[endIndex] = otherBranch.pop();
		}

		// Calculate the frame relative to other by following path
		for (var i=0; i<endIndex; ++i) {
			var curFrame = thisBranch[i].getFrame();
			if (curFrame) {
				if (typeof thisBranch[i].getFrameOffset === 'function') {
					var offset = thisBranch[i].getFrameOffset();
					curFrame[0] += offset[0];
					curFrame[1] += offset[1];
				}
				frame[0] += (i < commonAncestorIndex ? curFrame[0] : -curFrame[0]);
				frame[1] += (i < commonAncestorIndex ? curFrame[1] : -curFrame[1]);
			} else {
				return undefined; // undefined frame for a view between this and other
			}
		}

		return frame;
	},

	/** 
	  * @private
	  */
	_setVisible: function(makeVisible) {
		var willBeVisible = makeVisible && this._assignedVisible && this._parent && this._parent._visible;
		if (this._visible != willBeVisible) {
			this._visible = willBeVisible;
			var fn = (makeVisible ? this.getOnAppear() : this.getOnDisappear());
			if (typeof fn == 'function') fn.call(this);
		}
	},
	
	/**
	 * Cancel any running animations that apply to the object.
	 * @function
	 * @returns {void}
	 */
	clearAnimations: Commands.clearAnimations,
	
	/** 
	  * @private
	  */
	$synthesizePropertyWithState: function(propName, commandsFn) {
		function doSynthesis(caseAdjusted, stateName, stateFlags) {
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}
		Element.synthesizePropertyWithState.call(this, propName, commandsFn);
		// Synthesize stateful accessors.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		for (var stateName in stateMap) {
			doSynthesis.call(this, caseAdjusted, stateName, stateMap[stateName]);
		}
	}
});

// Properties
AbstractView._init = function() {
	delete AbstractView._init;
	if (Element._init) Element._init();
	
	var getVisible = function() {
		return this._visible;
	};
	var setVisible = function(makeVisible) {
		this._assignedVisible = makeVisible;
		Commands.setIsVisible.call(this, makeVisible);
		this._setVisible(makeVisible);
	};
	/**
	 * Set the `visible` property for this view, which defines whether the view is visible.
	 * @name UI.AbstractView#setVisible
	 * @example
	 * var myView = new UI.View();
	 * myView.setVisible(false);
	 * @function 
	 * @param {boolean} makeVisible Set to `true` to make this view visible.
	 * @returns {void}
	 * @see UI.AbstractView#getVisible
	 */
	/**
	 * Determine whether this view is visible.
	 * @name UI.AbstractView#getVisible
	 * @function
	 * @returns {Boolean} Set to `true` if this object is visible.
	 * @see UI.AbstractView#setVisible
	 */
	AbstractView.registerAccessors('visible', getVisible, setVisible);
	
	/**
	 * Set the `backgroundColor` property, which defines the background color for a view.
	 * @name UI.AbstractView#setBackgroundColor
	 * @function
	 * @example
	 * var myView = new UI.View();
	 * myView.setBackgroundColor("FF000000");
	 * @param {String} backgroundColor The new background color, in hexidecimal ARGB format (the
	 *		alpha value followed by the RGB color).
	 * @returns {void}
	 * @see UI.AbstractView#getBackgroundColor
	 */
	/**
	 * Retrieve the value of the `backgroundColor` property, which defines the background color for
	 * a view.
	 * @name UI.AbstractView#getBackgroundColor
	 * @function
	 * @returns {String} The current background color, in hexidecimal ARGB format (the alpha value
	 *		followed by the RGB color).
	 * @see UI.AbstractView#setBackgroundColor
	 */
	AbstractView.synthesizeProperty('backgroundColor', Commands.setBackgroundColor);
	/**
	 * Set the `enabled` property, which identifies whether the view is enabled or disabled. Calling
	 * this method with `enabled` set to `true` will clear the view state
	 * `UI.Commands.State.Disabled` from the view.
	 * @name UI.AbstractView#setEnabled
	 * @function
	 * @param {Boolean} enabled Set to `true` to enable the view.
	 * @returns {void}
	 * @see UI.AbstractView#getEnabled
	 * @see UI.AbstractView#clearState
	 */
	/**
	 * Retrieve the `enabled` property, which identifies whether the view is enabled or disabled.
	 * @name UI.AbstractView#getEnabled
	 * @function
	 * @returns {Boolean} The current value of the `enabled` property.
	 * @see UI.AbstractView#setEnabled
	 */
	
	AbstractView.synthesizeProperty('enabled', function(enable) {
		this[ (enable ? 'clearState' : 'setState') ](Commands.State.Disabled);
	});
	/**
	 * Set the `state` property, which defines the view states that apply to a view.
	 * @name UI.AbstractView#setState
	 * @function
	 * @description 
	 * @example
	 * var image = new UI.Image();
	 * image.setState(UI.Commands.State.Focused);
	 * @param {UI.Commands#State} state The new view state. To specify that a view is currently in
	 * 		multiple states, you can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.AbstractView#getState
	 */
	/**
	 * Retrieve the value of the `state` property, which defines the view states that apply to a
	 * view.
	 * @name UI.AbstractView#getState
	 * @function
	 * @returns {Number} The current view state. The returned value corresponds to an enumerated 
	 *		value of`{@link UI.Commands#State}`.
	 * @see UI.AbstractView#setState
	 */
	AbstractView.synthesizeProperty('state', Commands.setState);

	
	/**
	 * Retrieve the value of the `frame` property.
	 * @name UI.AbstractView#getFrame
	 * @function
	 * @returns {Number[]} The current size of the view and its position relative to its parent.
	 *		Specified as an array of four floats.
	 * @see UI.AbstractView#setFrame
	 */
	var getFrame = function() {
		return this._frame;
	};
	/**
	 * Set the `frame` property, which defines the view's size and its position relative to its
	 * parent. This method accepts the following values, which can be passed to the method in
	 * several different ways:
	 * 
	 * + `x`: The view's offset along the X axis relative to its parent.
	 * + `y`: The view's offset along the Y axis relative to its parent.
	 * + `w`: The width of the view.
	 * + `h`: The height of the view.
	 * @name UI.AbstractView#setFrame
	 * @function 
	 * @example
	 * // Set a view's frame by passing in an array of values.
	 * var back = new UI.Button();
	 * back.setFrame([10.0, 10.0, 64.0, 64.0]);
	 * @example
	 * // Set a view's frame by passing in a UI.ViewGeometry.Rect object.
	 * var back = new UI.Button();
	 * var rect = new UI.ViewGeometry.Rect([10.0, 10.0, 64.0, 64.0]);
	 * back.setFrame(rect);
	 * @param {Number[]|Number|UI.Geometry.Rect} arg0 Contains one of the following:
	 * 
	 * 1. An array of four floats that specify the following, in this order:
	 *     + `x`: The view's offset along the X axis relative to its parent.
	 *     + `y`: The view's offset along the Y axis relative to its parent.
	 *     + `w`: The width of the view.
	 *     + `h`: The height of the view.
	 * 2. The four values listed above, passed in as individual parameters.
	 * 3. A `{@link UI.ViewGeometry.Rect}` object that defines the view's size and position.
	 * @returns {void}
	 * @see UI.AbstractView#getFrame
	 */
	var setFrame = function(arg0) {
		if (this.sizeChanged) {
			var w0 = this._frame ? this._frame[2] : 0;
			var h0 = this._frame ? this._frame[3] : 0;
		}
		
		if( arg0 instanceof Rect ){
			this._frame = arg0.array();
		}
		else if( arg0 instanceof Array ){
			this._frame = arg0;
		}
		else {
			this._frame = Array.prototype.slice.call(arguments);
		}
		//Don't allow this error to be thrown out of this method, as we are close to release and some code may be relying on the old behavior.  However, it would be worthwile to have a log of the error.
		try {
			if (!this._frame || isNaN(this._frame[0]) || isNaN(this._frame[1]) || isNaN(this._frame[2]) || isNaN(this._frame[3])) {
				throw new Error("Attempt to call setFrame with at least one undefined element: " + this._frame);
			}
		} catch (e) {
			NgLogException(e);
		}
		
		Commands.setFrame.apply(this, this._frame);
		
		if (this.sizeChanged && ((w0 ^ this._frame[2]) | (h0 ^ this._frame[3]))) {
			this.sizeChanged( this._frame[2], this._frame[3], w0, h0 );
		}
	};
	AbstractView.registerAccessors('frame', getFrame, setFrame);

	/**
	 * Set the `gradient` property for a specified view state. You can use this property to add
	 * outlines, shadows, rounded corners, and gradient fills to a view. For detailed information
	 * about this property, see `{@link UI.Style#setGradient}`.
	 * @name UI.AbstractView#setGradient
	 * @function
	 * @example
	 * // Create a button with an opaque white inner shadow that has a 5-pixel
	 * // blur and no offset.
	 * var button = UI.Button();
	 * var gradient = {
	 *     innerShadow: "FFFFFFFF 5.0 {0.0, 0.0}"
	 * };
	 * button.setGradient(gradient, UI.Commands.State.Normal);
	 * @param {Object} gradient The new `gradient` property, using the format described by
	 * `{@link UI.Style#setGradient}`.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {void}
	 * @see UI.AbstractView#getGradient
	 * @see UI.Style#setGradient
	 */
	/**
	 * Retrieve the value of the `gradient` property for a specified view state.
	 * @name UI.AbstractView#getGradient
	 * @function	
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current gradient, in the format described in
	 *		`{@link UI.Style#setGradient}`.
	 * @see UI.AbstractView#setGradient
	 * @see UI.Style#setGradient
	 */
	AbstractView.synthesizePropertyWithState('gradient', Commands.setGradient);	
	/**
	 * Set the `touchable` property, which indicates whether touch events will affect this view. The
	 * default value is `true`.
	 * @name UI.AbstractView#setTouchable
	 * @function
	 * @example
	 * var image = new UI.Image();
	 * image.setTouchable(false);
	 * @param {Boolean} touchable Set to `true` to allow touch events to affect this view.
	 * @returns {void}
	 * @see UI.AbstractView#getTouchable
	 */
	/**
	 * Retrieve the current value of the `touchable` property, which indicates whether touch events
	 * will affect this view.
	 * @name UI.AbstractView#getTouchable
	 * @function
	 * @returns {Boolean} The current value of the `touchable` property.
	 * @see UI.AbstractView#setTouchable
	 */
	AbstractView.synthesizeProperty('touchable', Commands.setTouchable);
	/**
	 * Set the `alpha` property, which defines the view's opacity.
	 * @name UI.AbstractView#setAlpha
	 * @function
	 * @param {Number} alpha A float ranging from `0.0`, for completely transparent, to `1.0`, for
	 *		completely opaque.
	 * @returns {void}
	 * @see UI.AbstractView#getAlpha
	 * @status iOS, Flash
	 */
	/**
	 * Retrieve the current value of the `alpha` property, which defines the view's opacity.
	 * @name UI.AbstractView#getAlpha
	 * @function
	 * @returns {Number} A float ranging from `0.0`, for completely transparent, to `1.0`,
	 *		for completely opaque.
	 * @see UI.AbstractView#setAlpha
	 * @status Flash
	 */
	AbstractView.synthesizeProperty('alpha', Commands.setAlpha);
	/**
	 * Set the `style` property, which identifies a `{@link UI.Style}` object whose style properties
	 * will be applied to the view.
	 * @name UI.AbstractView#setStyle
	 * @function
	 * @example
	 * // Create a new checkbox, and apply a UI.Style object that specifies
	 * // the text for the checkbox's label.
	 * var checkBox = new UI.CheckBox();
	 * var style = new UI.Style({
	 *     text: "Flip screen"
	 * });
	 * checkBox.setStyle(style);
	 * @param {UI.Style} newStyle A new `UI.Style` object whose style properties will be applied to 
	 *		the view.
	 * @returns {void}
	 * @see UI.AbstractView#getStyle
	 * @see UI.Style
	 * @since 1.6
	 */
	/**
	 * Retrieve the value of the `style` property, which identifies a `{@link UI.Style}` object
	 * whose style properties will be applied to the view.
	 * @name UI.AbstractView#getStyle
	 * @function
	 * @returns {UI.Style} The current `UI.Style` object whose style properties will be applied to
	 *		the view.
	 * @see UI.AbstractView#setStyle
	 * @see UI.Style
	 * @since 1.6
	 */
	AbstractView.synthesizeProperty('style', function(newStyle) {
		if (newStyle instanceof Style) {
			Commands.setStyle.call(this, ObjectRegistry.objectToId(newStyle));
		}
	});

	// Event Handlers
	// the appear event is not implemented, per jyopp
	/**
	 * Set a function to call when an `appear` event occurs.
	 * @name UI.AbstractView#setOnAppear
	 * @event
	 * @cb {Function} appearCallback The function to call when an `appear` event occurs.
	 * @cb-returns {void}
	 * @see UI.AbstractView#event:getOnAppear
	 * @returns {void}
	 * @ignore
	 */
	/**
	 * Retrieve the function to call when an `appear` event occurs.
	 * @name UI.AbstractView#getOnAppear
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnAppear
	 * @ignore
	 */
	AbstractView.registerEventType('appear');
	/**
	 * Set a function to call when a `disappear` event occurs. This event occurs when a view is
	 * hidden.
	 * @name UI.AbstractView#setOnDisappear
	 * @event
	 * @example
	 * var toast = new UI.Toast();
	 * toast.setOnDisappear(function() {
	 *     // We are done with the object after it disappears.
	 *     toast.destroy();
	 * });
	 * @cb {Function} disappearCallback The function to call when a `disappear` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.AbstractView#event:getOnDisappear
	 */
	/**
	 * Retrieve the function to call when a `disappear` event occurs. This event occurs when a view
	 * is hidden.
	 * @name UI.AbstractView#getOnDisappear
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnDisappear
	 */
	AbstractView.registerEventType('disappear');
	/**
	 * Set a function to call when a `click` event occurs. This event occurs when a view is tapped.
	 * 
	 * **Note**: As of version 1.6, `UI.EditText` objects no longer fire `click` events.
	 * @name UI.AbstractView#setOnClick
	 * @event
	 * @example
	 * var checked;
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setOnClick(function(event) {
	 *     checked = event.checked;
	 * });
	 * @cb {Function} clickCallback The function to call when a `click` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Boolean} event.checked Set to `true` if the view is checked.
	 * @cb-returns {void}
	 * @see UI.AbstractView#event:getOnClick
	 * @returns {void}
	 */
	/**
	 * Retrieve the function to call when a `click` event occurs. This event occurs when a view is
	 * tapped.
	 * @name UI.AbstractView#getOnClick
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnClick
	 */
	AbstractView.registerEventType('click');
	
	AbstractView.registerEventType('clickDown');
	AbstractView.registerEventType('clickCancel');

	/**
	 * Set a function to call when a `swipe` event occurs. This event occurs when the user swipes a
	 * finger across the view.
	 * @name UI.AbstractView#setOnSwipe
	 * @event
	 * @example
	 * // Move back or forward in a web view's history when a swipe event occurs.
	 * var webView = new UI.WebView();
	 * webView.setOnSwipe(function(event) {
	 *     if (event.direction == UI.Commands.SwipeDirection.Right &&
	 *         webView.canGoBack()) {
	 *         webView.goBack();
	 *     } else if (event.direction == UI.Commands.SwipeDirection.Left &&
	 *         webView.canGoForward()) {
	 *         webView.goForward();
	 *     }
	 * });
	 * @cb {Function} swipeCallback The function to call when a `swipe` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#SwipeDirection} event.direction The direction of the swipe.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.AbstractView#event:getOnSwipe
	 */
	/**
	 * Retrieve the function to call when a `swipe` event occurs. This event occurs when the user
	 * swipes a finger across the view.
	 * @name UI.AbstractView#getOnSwipe
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnSwipe
	 */
	AbstractView.registerEventType('swipe');
	/**
	 * Set a function to call when a `longPress` event occurs. This event occurs when the user taps
	 * and holds on a view.
	 * @name UI.AbstractView#setOnLongPress
	 * @event
	 * @example
	 * var image = new UI.Image();
	 * image.setOnLongPress(function() {
	 *     console.log("The user is tapping and holding on an image.");
	 * });
	 * @cb {Function} longPressCallback The function to call when a `longPress` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.AbstractView#event:getOnLongPress
	 */
	/**
	 * Retrieve the function to call when a `longPress` event occurs.
	 * @name UI.AbstractView#getOnLongPress
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnLongPress
	 */
	AbstractView.registerEventType('longPress');

	/** @private NOT IMPLEMENTED */
	/*
		AbstractView.registerEventType('touchdown');
		AbstractView.registerEventType('touchup');
		AbstractView.registerEventType('touchmove');
		AbstractView.registerEventType('touchcancel');
	*/
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ViewParent'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ViewParent'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ViewParent'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ViewParent.js';

var Commands = require('NGCore/Client/UI/Commands').Commands;
var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;

// CAREFUL! THIS IS NOT A CLASS!
exports.ViewParent = {
	initialize : function() {
		this._children = [];
	},

	getChildCount : function() {
		return this._children.length;
	},

	getChildren : function() {
		return this._children.slice();
	},

	addChild : function(childNode,index) {
		if (childNode === this) throw new Error("Cannot add " + childNode + " as a child of itself!");
		if (childNode instanceof AbstractView) {
			if (childNode._parent) childNode.removeFromParent();

			if (index === 0 || index > 0) {
				index = Math.min(index, this.getChildCount());
				this._children.splice(index, 0, childNode);
			} else {
				index = -1;
				this._children.push(childNode);
			}

			// Must populate parent before setting visibility
			childNode._parent = this;
			childNode._setVisible(this._visible);

			Commands.addSubview.call(this, childNode.__objectRegistryId, index);

		} else throw new Error(this.type + ".addChild: " + childNode + " is not a view!");
		return this;
	},

	removeChild : function(childNode) {
		if (childNode instanceof AbstractView) {
			if (childNode._parent == this) {
				childNode._setVisible(false);

				// Remove this node from parent's child list
				var nodeIndex = this._children.indexOf(childNode);
				if (nodeIndex != -1) {
					this._children.splice(nodeIndex, 1);
				}
			}
			// Clear parent value
			childNode._parent = undefined;

			// Remove from the parent at the system level
			Commands.removeFromSuperview.call(childNode);
		} else throw {message: this.type + ".removeChild: " + childNode + " is not a view!"};
		return childNode;
	}

};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/WindowLayer'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/WindowLayer'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/WindowLayer'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/WindowLayer.js';

var Element = require('NGCore/Client/UI/Element').Element;
var ViewParent = require('NGCore/Client/UI/ViewParent').ViewParent;
var Commands = require('NGCore/Client/UI/Commands').Commands;

/** @private
 * 	This ENTIRE CLASS is private.
 */
var WindowLayer = exports.WindowLayer = Element.subclass( {
	'type':'windowlayer',
	initialize: function($super, props) {
		if (WindowLayer.init) WindowLayer.init();
		$super(props);
		if (WindowLayer._init) WindowLayer._init();
		ViewParent.initialize.call(this);
		this._visible = true;
	},
	getRoot: function(){
		return this;
	},
	getParent: function(){
		return undefined;
	},
	
	getChildCount: ViewParent.getChildCount,
	getChildren: ViewParent.getChildren,
	addChild: ViewParent.addChild,
	removeChild: ViewParent.removeChild
});

WindowLayer.init = function() {
	delete WindowLayer._init;
	if (Element._init) Element._init();
	
	WindowLayer.synthesizeProperty('level', Commands.setIntValue);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Window'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Window'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Window'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Window.js';

var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Element = require('NGCore/Client/UI/Element').Element;
var Rect = require('NGCore/Client/UI/ViewGeometry').Rect;

var WindowLayer = require('NGCore/Client/UI/WindowLayer').WindowLayer;

// Singleton
// Methods beginning with an underscore are considered private and should
// not be called from outside of the class.

Commands.Window = exports.Window = Class.singleton({
/** @lends UI.Window.prototype */

	/**
	 * @deprecated Replaced by {@link UI.Window#getWidth}.
	 * @ignore
	 */
	_outerWidth: 0,

	/**
	 * @deprecated Replaced by {@link UI.Window#getHeight}.
	 * @ignore
	 */
	_outerHeight: 0,

	/**
	 * @private
	 */
	_width: 0,
	/**
	 * @private
	 */
	_height: 0,

	 /**
	 * @class The `UI.Window` class provides a singleton that manages an application's access to 
	 * native UI controls.
	 *
	 * To display a UI component, your application must add it as a child of the
	 * `UI.Window.document` singleton, either directly or as a child node of another view. See
	 * `{@link UI.Window#document}` for more information.
	 * @singleton
	 * @name UI.Window
	 * @augments Core.Class	
	 * @see UI.Window#document
	 * @since 1.0
	 */
	initialize: function() {
		if (!this._outerWidth || !this._outerHeight) this.setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
		if (!this._width || !this._height) this._setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
		
		Commands.instantiate();
		Device.LayoutEmitter._setWindow(this);
		NgLogD("window: outer = " + this._outerWidth + " × " + this._outerHeight + " frame = " + this._width + " × " + this._height);
	},
	
	/**
	 * A singleton that provides a virtual "document" for the window's UI components. To display a 
	 * UI component, your application must call `UI.Window.document.addChild()` to add the
	 * component to the document.The UI component will also be displayed if you add the component as
	 * a child node of another view, then call `UI.Window.document.addChild()` on the parent view.
	 * 
	 * This singleton has the following methods:
	 * 
	 * + `{Object} UI.Window.document.addChild(childNode, index)`: Add a view or UI component to the 
	 * document, causing it to display on the device's screen. The `childNode` parameter is an 
	 * object that represents a view or UI component. The optional `index` parameter is a positive 
	 * integer indicating the array index at which to insert the view or component; by default, the 
	 * view or component is added after the last index. Returns `this` to support method invocation
	 * chaining.
	 * + `{Number} UI.Window.document.getChildCount()`: Retrieve the number of children of
	 * the document. Returns the number of children.
	 * + `{Object[]} UI.Window.document.getChildren()`: Retrieve all children of the document.
	 * Returns an array of objects that represent UI components.
	 * + `{Object} UI.Window.document.removeChild(childNode)`: Remove a view or UI component from 
	 * the document. The `childNode` parameter is an object that represents a view or UI component. 
	 * Returns the view or component that was removed.
	 * @example
	 * // Set up a new button by doing the following:
	 * // 1. Create the button, and set its frame to an 80-pixel by 20-pixel
	 * //    rectangle in the upper left corner of the screen.
	 * // 2. Add the button to a new view, and set the new view's frame to fill
	 * //    the entire screen.
	 * // 3. Add the view to the document.
	 * var button = new UI.Button();
	 * button.setFrame([0, 0, 80, 20]);
	 * var view = new UI.View();
	 * view.addChild(button);
	 * view.setFrame([0, 0, Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight()]);
	 * UI.Window.document.addChild(view);
	 * // Retrieve the number of children of the document.
	 * var childCount = UI.Window.document.getChildCount();  // returns 1
	 * // Retrieve an array of the document's children.
	 * var children = UI.Window.document.getChildren();  // returns [{view}]
	 * // Remove the view from the document.
	 * var oldView = UI.Window.document.removeChild(view);  // returns {view}
	 * @fieldOf UI.Window#
	 */
	document: WindowLayer.singleton({
		'type': 'document',
		register: function() {
			// This is not a registered object.
			this.__objectRegistryId = 0;
		}
	}),
	
	_layers: {},
	_getLayer: function(level) {
		return this._layers[level] || (this._layers[level] = new WindowLayer({'level':level || 0}));
	},
	
	/**
	 * @private
	 */
	destroyObject: function(obj) {
		obj.removeFromParent();
		Commands.destroy.call(obj);
		ObjectRegistry.unregister(obj);
	},
	
	/**
	 * @private
	 */
	handleCommand: function(command) {
		// this.log(["Raw Command", command]);
		var fields = NgParseCommand2(command, NgParseInt, NgParseBase64);
	//	this.log(["handleCommand:", fields[1]]);
		this.doCommand(fields[1]);
	},
	/**
	* @private
	*/
	setStatusBarHidden: function(value) {
		Commands.setStatusBarHidden(value);
		this._outerHeight = Capabilities.getScreenHeight() - (value ? 0 : (Capabilities.getStatusBarHeight() || 0));
	},
	
	/**
	 * @private
	 */
	doCommand: function(jsonString) {
		//NgLogD(jsonString);
		var command = JSON.parse(jsonString);
		if(command.name == 'callback'){
			var cb = Commands.takeTemporaryCallback(command.callback_id);
			if (typeof cb == 'function') {
				cb(command);
			}
		} else {
			var object = ObjectRegistry.idToObject(command.objId);
			if (object instanceof Element) {
				switch (command.name) {
					case 'event':
						object.performEventCallback(command);
						break;
					case 'update':
						var properties = command.properties || {};
						for (var property in properties) {
							try {
								var setter = object['update' + property.charAt(0).toUpperCase() + property.substr(1)];
								if (typeof setter == 'function') {
									setter.apply(object, [properties[property]]);
								} else {
									// Set read-only properties!
									object['_'+property] = properties[property];
								}
							} catch (e) {}
						}
						break;
					default:
						object.handleCommand(command);
				}
			} else {
				console.log("Message received for non-element object with id " + command.objId);
				return;
			}
		}
		// log(["Got message back", command]);
	},
    
	/**
	 * @private
	 */    
	log: function(object) {
		NgLogD(object.toString());
		// this.postMessage({name: 'log', message: object});
	},
	/**
	 * Retrieve the available screen width, exclusive of orientation and system status bars.
	 *
	 * **Important**: If the device's orientation has recently changed, this method is not
	 * guaranteed to return the current screen width. Call `{@link Device.LayoutEmitter.getWidth}`
	 * to ensure that your application uses the correct screen width.
	 * @name getWidth
	 * @function
	 * @memberOf UI.Window#
	 * @returns {Number} The drawable width of the screen, in logical units. To determine how many
	 *		pixels the device uses per logical unit, call
	 *		`{@link Core.Capabilities#getScreenPixelUnits}`.
	 * @see Core.Capabilities#getScreenPixelUnits
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.1.5
	 */
	getWidth: function()
	{
		return this._width;
	},

	/**
	 * Retrieve the available screen height, exclusive of orientation and system status bars.
	 *
	 * **Important**: If the device's orientation has recently changed, this method is not
	 * guaranteed to return the current screen height. Call `{@link Device.LayoutEmitter.getHeight}`
	 * to ensure that your application uses the correct screen height.
	 * @name getHeight
	 * @function
	 * @memberOf UI.Window#
	 * @returns {Number} The drawable height of the screen, in logical units. To determine how many
	 *		pixels the device uses per logical unit, call
	 *		`{@link Core.Capabilities#getScreenPixelUnits}`.
	 * @see Core.Capabilities#getScreenPixelUnits
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.1.5
	 */
	getHeight: function()
	{
		return this._height;
	},

	getOuterWidth: function() {
		return this._outerWidth;
	},
	
	getOuterHeight: function() {
		return this._outerHeight;
	},

	getFrame: function() {
		return new Rect(0, 0, this._width, this._height);
	}
});

// Cause property access to initialize the singleton. Needed for backward compatibility.
Commands.Window.__defineGetter__("outerWidth", function() {return this.getOuterWidth()});
Commands.Window.__defineGetter__("outerHeight", function() {return this.getOuterHeight()});

/**
 * @private
 */
Commands.Window._setWidthAndHeight = function(width, height)
{
	console.log("window: set layout size to: " + width + ' × ' + height);
	this._width = width;
	this._height = height;
};

/**
 * @private
 */
Commands.Window.setWidthAndHeight = function(width, height)
{
	console.log("window: set outer size to: " + width + ' × ' + height);
	this._outerWidth = width;
	this._outerHeight = height;
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Commands'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Commands'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Commands'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Commands.js';

////////////////////////////////////////////////////////////////////////////////
// Class Commands
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

/** @ignore */
function UIAnimationOptions() {
	this.animationCurve = "EaseInOut";
	return this;
}

var Commands = exports.Commands = Core.Class.singleton(
/** @lends UI.Commands.prototype */
{
	/** @ignore */
	classname: 'Commands',
	
	/**
	 * @class The `UI.Commands` class provides a singleton with enumerated constants that are used 
	 * by other classes in the `UI` module.
	 * @name UI.Commands
	 * @singleton
	 * @augments Core.Class
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this.initializeNative(this.__objectRegistryId);
		this._tempCBs = {};
		this._tempCBCount = 0;
	},
	
	/**
	 * Enumeration for different ways to fit an image within a view. The image is scaled relative
	 * to the boundaries of the view, minus any text insets or image insets that have been applied
	 * to the view.
	 * @name FitMode
	 * @fieldOf UI.Commands#
	 */
	 
	/**
	 * The image will not be scaled. It will be clipped if necessary.
	 * @name FitMode.None
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be proportionally scaled to fit within the view.
	 * @name FitMode.Inside
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be proportionally scaled to fill the entire view. Portions of the image that
	 * fall outside the view will be clipped.
	 * @name FitMode.Fill
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be distorted to fill the entire view.
	 * @name FitMode.Stretch
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be proportionally scaled so that its width fills the view. Portions of the
	 * image that fall outside the view will be clipped.
	 * @name FitMode.AspectWidth
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be proportionally scaled so that its height fills the view. Portions of the
	 * image that fall outside the view will be clipped.
	 * @name FitMode.AspectHeight
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The image will be proportionally scaled down to fit completely within the view. If the image 
	 * is smaller than the view, it will not be upscaled.
	 * @name FitMode.InsideNoUpscaling
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for supported units for dimensions.
	 * @name Scaling
	 * @fieldOf UI.Commands#
	 */
	
	/**
	 * One unit equals one pixel. On Android devices, when your application uses this scaling mode,
	 * use integers to represent coordinates. On iOS devices, it may be appropriate in some cases
	 * to use half-pixels or quarter-pixels to position content.
	 * @name Scaling.Pixels
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * One unit equals roughly one typesetting point, rescaled from 72 dpi to 160 dpi.
	 * @name Scaling.Points
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The value 1.0 represents 100 percent of the view width or height.
	 * @name Scaling.Unit
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * One unit equals one percent of the view width or height.
	 * @name Scaling.Percent
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is scaled so that its width is 320 units.
	 * @name Scaling.iPhone
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for view states that are used by `{@link UI.AbstractView}` and its subclasses.
	 * Your application can set different display properties for each view state, which will cause
	 * a view's appearance to change automatically when its view state changes. For example, a
	 * button's fill color could change when the button is selected, and its text could be displayed
	 * in a lighter color when the button is disabled.
	 * 
	 * A view can be in multiple states simultaneously. You can specify display properties that
	 * apply to a particular combination of view states. For example, you can use one fill color for
	 * a checkbox when it is checked, and a different fill color when it is both pressed and
	 * checked.
	 *
	 * If a view is in multiple states, and there are no display properties defined for that
	 * combination of states, ngCore will use the display properties from the view state that has
	 * the highest priority. The priority order for view states is as follows:
	 *
	 * 1. `{@link UI.Commands#State.Disabled}`
	 * 2. `{@link UI.Commands#State.Custom}`
	 * 3. `{@link UI.Commands#State.Checked}`
	 * 4. `{@link UI.Commands#State.Pressed}`
	 * 5. `{@link UI.Commands#State.Selected}`
	 * 6. `{@link UI.Commands#State.Focused}`
	 * 7. `{@link UI.Commands#State.Normal}`
	 *
	 * Your application can define its own custom view states for UI components. For example, you
	 * could assign two different view states to even and odd rows in a table, so that even and odd
	 * rows could use different background colors. A custom view state should be represented by a
	 * constant that is greater than `0x00FF0000` and less than `0x40000000`. Any value in this
	 * range will have a display priority between `{@link UI.Commands#State.Disabled}` and
	 * `{@link UI.Commands#State.Custom}`; higher numbers will have a higher display priority. If
	 * your application needs only one custom view state, you can use the constant
	 * `{@link UI.Commands#State.Custom}`.
	 *
	 * **Note**: Many methods in the `UI` module are documented as accepting parameters or returning
	 * values that correspond to an enumerated constant of `UI.Commands.State`. These parameters
	 * and return values can also contain a bitwise combination of constants, including any custom
	 * view states that have been defined.
	 * @name State
	 * @fieldOf UI.Commands#
	 * @example
	 * // Create a UI.Button object, defining its text.
	 * var button = new UI.Button({
	 *     text: "Send"
	 * });
	 * // Define a custom view state.
	 * var customViewState = 0x10000000;
	 * // Specify text colors for various view states.
	 * button.setTextColor("4B4B4B", UI.Commands.State.Normal);    // dark gray
	 * button.setTextColor("FFFFFF", UI.Commands.State.Focused);   // black
	 * button.setTextColor("006BDB", UI.Commands.State.Pressed);   // blue
	 * button.setTextColor("DB1A00",                               // red
	 *   customViewState | UI.Commands.State.Pressed);
	 * // Update the button's view state.
	 * button.setState(UI.Commands.State.Focused);    // text is black
	 * button.setState(UI.Commands.State.Pressed);    // text is blue
	 * button.addState(customViewState);              // text is red
	 * button.clearState(customViewState);            // text is blue
	 * button.setState(UI.Commands.State.Normal);     // text is dark gray
	 * @see UI.AbstractView#addState
	 * @see UI.AbstractView#clearState
	 * @see UI.AbstractView#getState
	 * @see UI.AbstractView#setState
	 */
	
	/**
	 * The view is in a normal state.
	 * @name State.Normal
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is focused.
	 * @name State.Focused
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is selected.
	 * @name State.Selected
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is pressed.
	 * @name State.Pressed
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is checked.
	 * @name State.Checked
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is in a custom state whose properties are defined by the application.
	 * @name State.Custom
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The view is disabled.
	 * @name State.Disabled
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Enumeration for the action that will occur when the user types Enter in a text field. For 
	 * devices that have soft keyboards, the device uses this value and the value of 
	 * `{@link UI.Commands#InputType}` to control which keyboard is displayed to the user.
	 * @name EnterKeyType
	 * @fieldOf UI.Commands#
	 * @see UI.Commands#InputType
	 */
	
	/**
	 * Add a line break.
	 * @name EnterKeyType.Return
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Indicate that the user is done editing text.
	 * @name EnterKeyType.Done
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Advance to the next text field.
	 * @name EnterKeyType.Next
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Submit the user's input.
	 * @name EnterKeyType.Submit
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Go to a webpage.
	 * @name EnterKeyType.Go
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Perform a search.
	 * @name EnterKeyType.Search
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Send a message.
	 * @name EnterKeyType.Send
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for the input type to use for a text field. For devices that have soft keyboards,
	 * the device uses this value and the value of `{@link UI.Commands#EnterKeyType}` to control 
	 * which keyboard is displayed to the user.
	 * @name InputType
	 * @fieldOf UI.Commands#
	 * @see UI.Commands#EnterKeyType
	 */
	
	/**
	 * The field will contain text and should not be autocorrected.
	 * @name InputType.None
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain text and should be autocorrected.
	 * @name InputType.TextWithCorrection
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain a password.
	 * @name InputType.Password
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain a numeric value.
	 * @name InputType.Numeric
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain an email address.
	 * @name InputType.Email
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain a URL.
	 * @name InputType.URL
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field will contain a date.
	 * @name InputType.Date
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The field should cover the entire screen in landscape mode. Available only on Android.
	 * @name InputType.ANDROID_LANDSCAPE_FULLSCREEN
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Arrangement of combinations of text and images for buttons. When stacked, the button rect
	 * will be divided proportionally into two rects that completely cover the button. Gravity will
	 * apply to the image and text within their rects.
	 * @name ButtonLayout
	 * @fieldOf UI.Commands#
	 * @ignore
	 */

	
	/**
	 * Enumeration for the direction in which the user swiped a finger.
	 * @name SwipeDirection
	 * @fieldOf UI.Commands#
	 * @see UI.AbstractView#event:setOnSwipe
	 */
	
	/**
	 * The user swiped left.
	 * @name SwipeDirection.Left
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The user swiped right.
	 * @name SwipeDirection.Right
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The user swiped up.
	 * @name SwipeDirection.Up
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The user swiped down.
	 * @name SwipeDirection.Down
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for the orientations in which a view should be visible.
	 * @name OrientationFlag
	 * @fieldOf UI.Commands#
	 * @see UI.AbstractView#setVisibleInOrientations
	 */
	
	/**
	 * Display the view when in landscape mode.
	 * @name OrientationFlag.Landscape
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Display the view when in portrait mode.
	 * @name OrientationFlag.Portrait
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	/**
	 * Enumeration for controlling the types of fields that are autodetected in web views. Available
	 * only on iOS.
	 * @name Autodetect
	 * @fieldOf UI.Commands#
	 * @see UI.WebView#setAutodetection
	 */
	
	/**
	 * Disable autodetection. Available only on iOS.
	 * @name Autodetect.None
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Autodetect phone numbers, and show them as links. Available only on iOS.
	 * @name Autodetect.Phone
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Enumeration for the types of errors that can result from attempting to retrieve a file. In
	 * addition to these enumerated values, the application may receive a numeric HTTP error code.
	 * @name ResourceError
	 * @fieldOf UI.Commands#
	 */
	
	/**
	 * No error occurred.
	 * @name ResourceError.None
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * An unspecified error occurred.
	 * @name ResourceError.Other
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The requested file could not be found.
	 * @name ResourceError.File_Not_Found
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The file could not be loaded because the device is out of memory.
	 * @name ResourceError.Out_Of_Memory
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The file could not be loaded because of a problem with network connectivity.
	 * @name ResourceError.Connectivity_Error
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * The file could not be decoded.
	 * @name ResourceError.Decode_Failed
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Enumeration for screenshot options.
	 * @name ScreenshotType
	 * @fieldOf UI.Commands#
	 */
	
	/**
	 * Capture graphics drawn with both the `UI` and `{@link GL2}` modules.
	 * @name ScreenshotType.Normal
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Only capture graphics drawn with the `{@link GL2}` module.
	 * @name ScreenshotType.GLOnly
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	/**
	 * Only capture graphics drawn with the `UI` module.
	 * @name ScreenshotType.UIOnly
	 * @fieldOf UI.Commands#
	 * @constant
	 */
	
	
	
// {{?Wg Generated Code}}
	
	// Enums.
	FitMode:
	{ 
		None: 0,
		Inside: 1,
		Fill: 2,
		Stretch: 3,
		AspectWidth: 5,
		AspectHeight: 6,
		InsideNoUpscaling: 7
	},
	
	Scaling:
	{ 
		Pixels: 0,
		Points: 1,
		Unit: 2,
		Percent: 3,
		iPhone: 4
	},
	
	FontStyle:
	{ 
		Normal: 0,
		Bold: 1,
		Italic: 2,
		BoldItalic: 3
	},
	
	State:
	{ 
		Normal: 0x00,
		Focused: 0x01,
		Selected: 0x02,
		Pressed: 0x04,
		Checked: 0x08,
		Custom: 0x00FF0000,
		Disabled: 0x40000000
	},
	
	EnterKeyType:
	{ 
		Return: 0,
		Done: 1,
		Next: 2,
		Submit: 3,
		Go: 4,
		Search: 5,
		Send: 6
	},
	
	InputType:
	{ 
		None: 0,
		TextWithCorrection: 1,
		Password: 2,
		Numeric: 4,
		Email: 5,
		URL: 6,
		Date: 7,
		ANDROID_LANDSCAPE_FULLSCREEN: 8
	},
	
	ButtonLayout:
	{ 
		CenterTextOver: 0,
		StackImageLeft: 1,
		StackImageTop: 2,
		StackImageRight: 3,
		StackImageBottom: 4,
		CenterImageOver: 5
	},
	
	SwipeDirection:
	{ 
		Left: 1,
		Right: 2,
		Up: 3,
		Down: 4
	},
	
	OrientationFlag:
	{ 
		Landscape: 0x01,
		Portrait: 0x02
	},
	
	Autodetect:
	{ 
		None: 0,
		Phone: 1
	},
	
	ResourceError:
	{ 
		None: 0,
		Other: -1,
		File_Not_Found: -2,
		Out_Of_Memory: -3,
		Connectivity_Error: -4,
		Decode_Failed: -5
	},
	
	ScreenshotType:
	{ 
		Normal: 0,
		GLOnly: 1,
		UIOnly: 2
	},
	
	///////
	// Class Summary and Generated Constants (for internal use only):
	_classId: 337,
	// Method -1: _initializeNative ( int reservedId )
	// Method -2: _create ( int newObjectId, str className )
	// Method 3: _destroy (  )
	// Method 4: _setActive ( bool active )
	// Method 5: _setTouchable ( bool touchable )
	// Method 6: _enableEvent ( str eventName )
	// Method 7: _disableEvent ( str eventName )
	// Method -8: _eventOccurred ( json eventObject )
	// Method 9: _setIsVisible ( bool visible )
	// Method 10: _setEnabled ( bool enable )
	// Method 11: _setState ( int state )
	// Method 12: _addSubview ( int __objectRegistryId, int index )
	// Method 13: _removeFromSuperview (  )
	// Method -14: _startAnimation ( int durationMs, str callbackId )
	// Method -15: _executeAnimation ( json options )
	// Method 16: _setFrame ( float x, float y, float w, float h )
	// Method 17: _setOrigin ( float x, float y )
	// Method 18: _setAnchor ( float x, float y )
	// Method 19: _setSize ( float w, float h )
	// Method 20: _setTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method 21: _setBackgroundColor ( str color )
	// Method 22: _setImage ( int state, str imageURL )
	// Method 23: _setImageBorder ( int state, json gradientJSON )
	// Method 24: _setImageFitMode ( int fitMode )
	// Method 25: _setImageGravity ( float x, float y )
	// Method 26: _setImageOrigin ( float x, float y )
	// Method 27: _setImageAnchor ( float x, float y )
	// Method 28: _setImageSize ( float w, float h )
	// Method 29: _setImageInsets ( float t, float r, float b, float l )
	// Method 30: _setImageTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method 31: _setText ( int state, str text )
	// Method 32: _setTextColor ( int state, str text )
	// Method 33: _setTextFont ( int state, str fontName )
	// Method 34: _setTextShadow ( int state, str shadow )
	// Method 35: _setTextSize ( float textFontSize )
	// Method 36: _setTextGravity ( float x, float y )
	// Method 37: _setTextInsets ( float t, float r, float b, float l )
	// Method 38: _setTextOverflow ( int overflowMode )
	// Method 39: _setTextMaxLines ( int maxLines )
	// Method 40: _setTextMinSize ( float minSize )
	// Method 41: _setTitle ( int state, str title )
	// Method 42: _setTitleColor ( int state, str title )
	// Method 43: _setTitleFont ( int state, str fontName )
	// Method 44: _setTitleShadow ( int state, str shadow )
	// Method 45: _setTitleSize ( float titleFontSize )
	// Method 46: _setTitleGravity ( float x, float y )
	// Method 47: _setTitleInsets ( float t, float r, float b, float l )
	// Method 48: _setTitleOverflow ( int overflowMode )
	// Method 49: _setTitleMaxLines ( int maxLines )
	// Method 50: _setTitleMinSize ( float minSize )
	// Method 51: _setGradient ( int state, json gradientJSON )
	// Method 52: _setStringValue ( str value )
	// Method 53: _setFloatValue ( float value )
	// Method 54: _setIntValue ( int value )
	// Method 55: _setBoolValue ( bool value )
	// Method 56: _setButtonLayout ( int layoutType )
	// Method 57: _setContentInsets ( float t, float r, float b, float l )
	// Method 58: _setBarGradient ( int state, json gradientJSON )
	// Method 59: _setPlaceholderText ( str placeholder )
	// Method 60: _setPlaceholderTextColor ( str color )
	// Method 61: _setPlaceholderTextShadow ( str shadow )
	// Method 62: _setEnterKeyType ( int enterKeyType )
	// Method 63: _setInputType ( int inputType )
	// Method 64: _setChecked ( bool checked )
	// Method 65: _setScrollPosition ( float x, float y )
	// Method 66: _setScrollableSize ( float w, float h )
	// Method 67: _setSections ( json idArray )
	// Method 68: _setTitleView ( int titleObjectID )
	// Method 69: _setSourceDocument ( str documentURL )
	// Method 70: _setChoices ( json stringArray, int defaultChoiceIndex, int cancelChoiceIndex )
	// Method 71: _show (  )
	// Method 72: _hide (  )
	// Method 73: _setPostData ( str data )
	// Method 74: _loadPostURL ( str url )
	// Method 75: _loadGetURL ( str url )
	// Method 76: _loadURL ( str url, json headers, float timeout )
	// Method 77: _stopLoading (  )
	// Method 78: _reload (  )
	// Method 79: _invoke ( str script )
	// Method 80: _goBack (  )
	// Method 81: _goForward (  )
	// Method 82: _setBasicAuthCredentials ( json credentials )
	// Method 83: _setRightImage ( int state, str rightImageURL )
	// Method 84: _setRightImageBorder ( int state, json gradientJSON )
	// Method 85: _setRightImageFitMode ( int fitMode )
	// Method 86: _setRightImageGravity ( float x, float y )
	// Method 87: _setRightImageOrigin ( float x, float y )
	// Method 88: _setRightImageAnchor ( float x, float y )
	// Method 89: _setRightImageSize ( float w, float h )
	// Method 90: _setRightImageInsets ( float t, float r, float b, float l )
	// Method 91: _setRightImageTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method -92: _setStatusBarHidden ( bool statusBarStatus )
	// Method 93: _pauseAds (  )
	// Method 94: _resumeAds (  )
	// Method 95: _setAdRefreshRate ( int refreshRate )
	// Method 96: _setAdAllowAutoplay ( bool autoplay )
	// Method 97: _setAlpha ( float alpha )
	// Method 98: _postURL ( str url, str data )
	// Method 99: _setProgressGradient ( int state, json gradientJSON )
	// Method 100: _setSecondaryGradient ( int state, json gradientJSON )
	// Method 101: _setProgress ( float progress, float secondaryProgress )
	// Method 102: _useForUpdateProgress ( bool use )
	// Method 103: _setDarkStyle ( bool use )
	// Method -104: _doCompositeImages ( int w, int h, str filename, json infoArray, str callbackId )
	// Method -105: _REMOVED_doChoosePhoto ( int w, int h, str filename, json options, str callbackId )
	// Method -106: _doChooseCamera ( int w, int h, str filename, json options, str callbackId )
	// Method 107: _setScrollable ( bool enabled )
	// Method 108: _setZoomable ( bool enabled )
	// Method 109: _addAnnotation ( int __objectRegistryId )
	// Method 110: _removeAnnotation ( int __objectRegistryId )
	// Method 111: _selectAnnotation ( int __objectRegistryId )
	// Method 112: _setRegion ( float latitude, float longitude, float latitudeDelta, float longitudeDelta, bool animated )
	// Method 113: _setView ( int __objectRegistryId )
	// Method 114: _setCoordinate ( float latitude, float longitude )
	// Method 115: _setCalloutTitle ( str title )
	// Method 116: _setCalloutSubtitle ( str subTitle )
	// Method 117: _setCalloutEnabled ( bool enabled )
	// Method 118: _setCalloutLeftView ( int __objectRegistryId )
	// Method 119: _setCalloutRightView ( int __objectRegistryId )
	// Method 120: _setCenterOffset ( float xOffset, float yOffset )
	// Method -121: _doChoosePhoto ( int w, int h, str filename, json options, str callbackId, int invokingView )
	// Method 122: _setScrollIndicatorsVisible ( bool enabled )
	// Method -123: _measureText ( str string, int w, int h, str font, float fontSize, str callbackId )
	// Method 124: _setFocus ( bool enabled )
	// Method 125: _setViewportEnabled ( bool enabled )
	// Method 126: _clearAnimations (  )
	// Method 127: _setStyle ( int styleID )
	// Method 128: _setVisibleInOrientations ( int orientationFlags )
	// Method 129: _setAutodetection ( int type )
	// Method 130: _playVideo ( str path, str callbackId )
	// Method 131: _setLineHeight ( float lineHeight )
	// Method -132: _hideKeyboard (  )
	// Method -133: _takeScreenshot ( int w, int h, str filename, json options, str callbackId )
	// Method 134: _setPluginsEnabled ( bool enable )
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift() );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift() );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Commands._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -8:
					Commands._eventOccurredRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Commands._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[337] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$_eventOccurredRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Commands.eventOccurred from command: " + cmd );
			return false;
		}
		
		obj[ "eventObject" ] = Core.Proc.parseObject( cmd[ 0 ] );
		if( obj[ "eventObject" ] === undefined )
		{
			NgLogE("Could not parse eventObject in Commands.eventOccurred from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$initializeNative: function( reservedId )
	{
		Core.Proc.appendToCommandString( 0x151ffff, [ +reservedId ] );
	},
	
	/** @private */
	$create: function( newObjectId, className )
	{
		Core.Proc.appendToCommandString( 0x151fffe, [ +newObjectId, Core.Proc.encodeString( className ) ] );
	},
	
	/** @private */
	destroy: function(  )
	{
		Core.Proc.appendToCommandString( 0x1510003, this );
	},
	
	/** @private */
	setActive: function( active )
	{
		Core.Proc.appendToCommandString( 0x1510004, this, [ ( active ? 1 : 0 ) ] );
	},
	
	/** @private */
	setTouchable: function( touchable )
	{
		Core.Proc.appendToCommandString( 0x1510005, this, [ ( touchable ? 1 : 0 ) ] );
	},
	
	/** @private */
	enableEvent: function( eventName )
	{
		Core.Proc.appendToCommandString( 0x1510006, this, [ Core.Proc.encodeString( eventName ) ] );
	},
	
	/** @private */
	disableEvent: function( eventName )
	{
		Core.Proc.appendToCommandString( 0x1510007, this, [ Core.Proc.encodeString( eventName ) ] );
	},
	
	/** @private */
	setIsVisible: function( visible )
	{
		Core.Proc.appendToCommandString( 0x1510009, this, [ ( visible ? 1 : 0 ) ] );
	},
	
	/** @private */
	setEnabled: function( enable )
	{
		Core.Proc.appendToCommandString( 0x151000a, this, [ ( enable ? 1 : 0 ) ] );
	},
	
	/** @private */
	setState: function( state )
	{
		Core.Proc.appendToCommandString( 0x151000b, this, [ +state ] );
	},
	
	/** @private */
	addSubview: function( __objectRegistryId, index )
	{
		Core.Proc.appendToCommandString( 0x151000c, this, [ +__objectRegistryId, +index ] );
	},
	
	/** @private */
	removeFromSuperview: function(  )
	{
		Core.Proc.appendToCommandString( 0x151000d, this );
	},
	
	/** @private */
	$startAnimation: function( durationMs, callbackId )
	{
		Core.Proc.appendToCommandString( 0x151fff2, [ +durationMs, Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	$executeAnimation: function( options )
	{
		Core.Proc.appendToCommandString( 0x151fff1, [ Core.Proc.encodeObject( options ) ] );
	},
	
	/** @private */
	setFrame: function( x, y, w, h )
	{
		Core.Proc.appendToCommandString( 0x1510010, this, [ +x, +y, +w, +h ] );
	},
	
	/** @private */
	setOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510011, this, [ +x, +y ] );
	},
	
	/** @private */
	setAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510012, this, [ +x, +y ] );
	},
	
	/** @private */
	setSize: function( w, h )
	{
		Core.Proc.appendToCommandString( 0x1510013, this, [ +w, +h ] );
	},
	
	/** @private */
	setTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( 0x1510014, this, [ +a, +b, +c, +d, +tx, +ty ] );
	},
	
	/** @private */
	setBackgroundColor: function( color )
	{
		Core.Proc.appendToCommandString( 0x1510015, this, [ Core.Proc.encodeString( color ) ] );
	},
	
	/** @private */
	setImage: function( state, imageURL )
	{
		Core.Proc.appendToCommandString( 0x1510016, this, [ +state, Core.Proc.encodeString( imageURL ) ] );
	},
	
	/** @private */
	setImageBorder: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x1510017, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setImageFitMode: function( fitMode )
	{
		Core.Proc.appendToCommandString( 0x1510018, this, [ +fitMode ] );
	},
	
	/** @private */
	setImageGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510019, this, [ +x, +y ] );
	},
	
	/** @private */
	setImageOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x151001a, this, [ +x, +y ] );
	},
	
	/** @private */
	setImageAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x151001b, this, [ +x, +y ] );
	},
	
	/** @private */
	setImageSize: function( w, h )
	{
		Core.Proc.appendToCommandString( 0x151001c, this, [ +w, +h ] );
	},
	
	/** @private */
	setImageInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( 0x151001d, this, [ +t, +r, +b, +l ] );
	},
	
	/** @private */
	setImageTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( 0x151001e, this, [ +a, +b, +c, +d, +tx, +ty ] );
	},
	
	/** @private */
	setText: function( state, text )
	{
		Core.Proc.appendToCommandString( 0x151001f, this, [ +state, Core.Proc.encodeString( text ) ] );
	},
	
	/** @private */
	setTextColor: function( state, text )
	{
		Core.Proc.appendToCommandString( 0x1510020, this, [ +state, Core.Proc.encodeString( text ) ] );
	},
	
	/** @private */
	setTextFont: function( state, fontName )
	{
		Core.Proc.appendToCommandString( 0x1510021, this, [ +state, Core.Proc.encodeString( fontName ) ] );
	},
	
	/** @private */
	setTextShadow: function( state, shadow )
	{
		Core.Proc.appendToCommandString( 0x1510022, this, [ +state, Core.Proc.encodeString( shadow ) ] );
	},
	
	/** @private */
	setTextSize: function( textFontSize )
	{
		Core.Proc.appendToCommandString( 0x1510023, this, [ +textFontSize ] );
	},
	
	/** @private */
	setTextGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510024, this, [ +x, +y ] );
	},
	
	/** @private */
	setTextInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( 0x1510025, this, [ +t, +r, +b, +l ] );
	},
	
	/** @private */
	setTextOverflow: function( overflowMode )
	{
		Core.Proc.appendToCommandString( 0x1510026, this, [ +overflowMode ] );
	},
	
	/** @private */
	setTextMaxLines: function( maxLines )
	{
		Core.Proc.appendToCommandString( 0x1510027, this, [ +maxLines ] );
	},
	
	/** @private */
	setTextMinSize: function( minSize )
	{
		Core.Proc.appendToCommandString( 0x1510028, this, [ +minSize ] );
	},
	
	/** @private */
	setTitle: function( state, title )
	{
		Core.Proc.appendToCommandString( 0x1510029, this, [ +state, Core.Proc.encodeString( title ) ] );
	},
	
	/** @private */
	setTitleColor: function( state, title )
	{
		Core.Proc.appendToCommandString( 0x151002a, this, [ +state, Core.Proc.encodeString( title ) ] );
	},
	
	/** @private */
	setTitleFont: function( state, fontName )
	{
		Core.Proc.appendToCommandString( 0x151002b, this, [ +state, Core.Proc.encodeString( fontName ) ] );
	},
	
	/** @private */
	setTitleShadow: function( state, shadow )
	{
		Core.Proc.appendToCommandString( 0x151002c, this, [ +state, Core.Proc.encodeString( shadow ) ] );
	},
	
	/** @private */
	setTitleSize: function( titleFontSize )
	{
		Core.Proc.appendToCommandString( 0x151002d, this, [ +titleFontSize ] );
	},
	
	/** @private */
	setTitleGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x151002e, this, [ +x, +y ] );
	},
	
	/** @private */
	setTitleInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( 0x151002f, this, [ +t, +r, +b, +l ] );
	},
	
	/** @private */
	setTitleOverflow: function( overflowMode )
	{
		Core.Proc.appendToCommandString( 0x1510030, this, [ +overflowMode ] );
	},
	
	/** @private */
	setTitleMaxLines: function( maxLines )
	{
		Core.Proc.appendToCommandString( 0x1510031, this, [ +maxLines ] );
	},
	
	/** @private */
	setTitleMinSize: function( minSize )
	{
		Core.Proc.appendToCommandString( 0x1510032, this, [ +minSize ] );
	},
	
	/** @private */
	setGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x1510033, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setStringValue: function( value )
	{
		Core.Proc.appendToCommandString( 0x1510034, this, [ Core.Proc.encodeString( value ) ] );
	},
	
	/** @private */
	setFloatValue: function( value )
	{
		Core.Proc.appendToCommandString( 0x1510035, this, [ +value ] );
	},
	
	/** @private */
	setIntValue: function( value )
	{
		Core.Proc.appendToCommandString( 0x1510036, this, [ +value ] );
	},
	
	/** @private */
	setBoolValue: function( value )
	{
		Core.Proc.appendToCommandString( 0x1510037, this, [ ( value ? 1 : 0 ) ] );
	},
	
	/** @private */
	setButtonLayout: function( layoutType )
	{
		Core.Proc.appendToCommandString( 0x1510038, this, [ +layoutType ] );
	},
	
	/** @private */
	setContentInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( 0x1510039, this, [ +t, +r, +b, +l ] );
	},
	
	/** @private */
	setBarGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x151003a, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setPlaceholderText: function( placeholder )
	{
		Core.Proc.appendToCommandString( 0x151003b, this, [ Core.Proc.encodeString( placeholder ) ] );
	},
	
	/** @private */
	setPlaceholderTextColor: function( color )
	{
		Core.Proc.appendToCommandString( 0x151003c, this, [ Core.Proc.encodeString( color ) ] );
	},
	
	/** @private */
	setPlaceholderTextShadow: function( shadow )
	{
		Core.Proc.appendToCommandString( 0x151003d, this, [ Core.Proc.encodeString( shadow ) ] );
	},
	
	/** @private */
	setEnterKeyType: function( enterKeyType )
	{
		Core.Proc.appendToCommandString( 0x151003e, this, [ +enterKeyType ] );
	},
	
	/** @private */
	setInputType: function( inputType )
	{
		Core.Proc.appendToCommandString( 0x151003f, this, [ +inputType ] );
	},
	
	/** @private */
	setChecked: function( checked )
	{
		Core.Proc.appendToCommandString( 0x1510040, this, [ ( checked ? 1 : 0 ) ] );
	},
	
	/** @private */
	setScrollPosition: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510041, this, [ +x, +y ] );
	},
	
	/** @private */
	setScrollableSize: function( w, h )
	{
		Core.Proc.appendToCommandString( 0x1510042, this, [ +w, +h ] );
	},
	
	/** @private */
	setSections: function( idArray )
	{
		Core.Proc.appendToCommandString( 0x1510043, this, [ Core.Proc.encodeObject( idArray ) ] );
	},
	
	/** @private */
	setTitleView: function( titleObjectID )
	{
		Core.Proc.appendToCommandString( 0x1510044, this, [ +titleObjectID ] );
	},
	
	/** @private */
	setSourceDocument: function( documentURL )
	{
		Core.Proc.appendToCommandString( 0x1510045, this, [ Core.Proc.encodeString( documentURL ) ] );
	},
	
	/** @private */
	setChoices: function( stringArray, defaultChoiceIndex, cancelChoiceIndex )
	{
		Core.Proc.appendToCommandString( 0x1510046, this, [ Core.Proc.encodeObject( stringArray ), +defaultChoiceIndex, +cancelChoiceIndex ] );
	},
	
	/** @private */
	show: function(  )
	{
		Core.Proc.appendToCommandString( 0x1510047, this );
	},
	
	/** @private */
	hide: function(  )
	{
		Core.Proc.appendToCommandString( 0x1510048, this );
	},
	
	/** @private */
	setPostData: function( data )
	{
		Core.Proc.appendToCommandString( 0x1510049, this, [ Core.Proc.encodeString( data ) ] );
	},
	
	/** @private */
	loadPostURL: function( url )
	{
		Core.Proc.appendToCommandString( 0x151004a, this, [ Core.Proc.encodeString( url ) ] );
	},
	
	/** @private */
	loadGetURL: function( url )
	{
		Core.Proc.appendToCommandString( 0x151004b, this, [ Core.Proc.encodeString( url ) ] );
	},
	
	/** @private */
	loadURL: function( url, headers, timeout )
	{
		Core.Proc.appendToCommandString( 0x151004c, this, [ Core.Proc.encodeString( url ), Core.Proc.encodeObject( headers ), +timeout ] );
	},
	
	/** @private */
	stopLoading: function(  )
	{
		Core.Proc.appendToCommandString( 0x151004d, this );
	},
	
	/** @private */
	reload: function(  )
	{
		Core.Proc.appendToCommandString( 0x151004e, this );
	},
	
	/** @private */
	invoke: function( script )
	{
		Core.Proc.appendToCommandString( 0x151004f, this, [ Core.Proc.encodeString( script ) ] );
	},
	
	/** @private */
	goBack: function(  )
	{
		Core.Proc.appendToCommandString( 0x1510050, this );
	},
	
	/** @private */
	goForward: function(  )
	{
		Core.Proc.appendToCommandString( 0x1510051, this );
	},
	
	/** @private */
	setBasicAuthCredentials: function( credentials )
	{
		Core.Proc.appendToCommandString( 0x1510052, this, [ Core.Proc.encodeObject( credentials ) ] );
	},
	
	/** @private */
	setRightImage: function( state, rightImageURL )
	{
		Core.Proc.appendToCommandString( 0x1510053, this, [ +state, Core.Proc.encodeString( rightImageURL ) ] );
	},
	
	/** @private */
	setRightImageBorder: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x1510054, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setRightImageFitMode: function( fitMode )
	{
		Core.Proc.appendToCommandString( 0x1510055, this, [ +fitMode ] );
	},
	
	/** @private */
	setRightImageGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510056, this, [ +x, +y ] );
	},
	
	/** @private */
	setRightImageOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510057, this, [ +x, +y ] );
	},
	
	/** @private */
	setRightImageAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1510058, this, [ +x, +y ] );
	},
	
	/** @private */
	setRightImageSize: function( w, h )
	{
		Core.Proc.appendToCommandString( 0x1510059, this, [ +w, +h ] );
	},
	
	/** @private */
	setRightImageInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( 0x151005a, this, [ +t, +r, +b, +l ] );
	},
	
	/** @private */
	setRightImageTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( 0x151005b, this, [ +a, +b, +c, +d, +tx, +ty ] );
	},
	
	/** @private */
	$setStatusBarHidden: function( statusBarStatus )
	{
		Core.Proc.appendToCommandString( 0x151ffa4, [ ( statusBarStatus ? 1 : 0 ) ] );
	},
	
	/** @private */
	pauseAds: function(  )
	{
		Core.Proc.appendToCommandString( 0x151005d, this );
	},
	
	/** @private */
	resumeAds: function(  )
	{
		Core.Proc.appendToCommandString( 0x151005e, this );
	},
	
	/** @private */
	setAdRefreshRate: function( refreshRate )
	{
		Core.Proc.appendToCommandString( 0x151005f, this, [ +refreshRate ] );
	},
	
	/** @private */
	setAdAllowAutoplay: function( autoplay )
	{
		Core.Proc.appendToCommandString( 0x1510060, this, [ ( autoplay ? 1 : 0 ) ] );
	},
	
	/** @private */
	setAlpha: function( alpha )
	{
		Core.Proc.appendToCommandString( 0x1510061, this, [ +alpha ] );
	},
	
	/** @private */
	postURL: function( url, data )
	{
		Core.Proc.appendToCommandString( 0x1510062, this, [ Core.Proc.encodeString( url ), Core.Proc.encodeString( data ) ] );
	},
	
	/** @private */
	setProgressGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x1510063, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setSecondaryGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( 0x1510064, this, [ +state, Core.Proc.encodeObject( gradientJSON ) ] );
	},
	
	/** @private */
	setProgress: function( progress, secondaryProgress )
	{
		Core.Proc.appendToCommandString( 0x1510065, this, [ +progress, +secondaryProgress ] );
	},
	
	/** @private */
	useForUpdateProgress: function( use )
	{
		Core.Proc.appendToCommandString( 0x1510066, this, [ ( use ? 1 : 0 ) ] );
	},
	
	/** @private */
	setDarkStyle: function( use )
	{
		Core.Proc.appendToCommandString( 0x1510067, this, [ ( use ? 1 : 0 ) ] );
	},
	
	/** @private */
	$doCompositeImages: function( w, h, filename, infoArray, callbackId )
	{
		Core.Proc.appendToCommandString( 0x151ff98, [ +w, +h, Core.Proc.encodeString( filename ), Core.Proc.encodeObject( infoArray ), Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	$doChooseCamera: function( w, h, filename, options, callbackId )
	{
		Core.Proc.appendToCommandString( 0x151ff96, [ +w, +h, Core.Proc.encodeString( filename ), Core.Proc.encodeObject( options ), Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	setScrollable: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x151006b, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	setZoomable: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x151006c, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	addAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x151006d, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	removeAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x151006e, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	selectAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x151006f, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	setRegion: function( latitude, longitude, latitudeDelta, longitudeDelta, animated )
	{
		Core.Proc.appendToCommandString( 0x1510070, this, [ +latitude, +longitude, +latitudeDelta, +longitudeDelta, ( animated ? 1 : 0 ) ] );
	},
	
	/** @private */
	setView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x1510071, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	setCoordinate: function( latitude, longitude )
	{
		Core.Proc.appendToCommandString( 0x1510072, this, [ +latitude, +longitude ] );
	},
	
	/** @private */
	setCalloutTitle: function( title )
	{
		Core.Proc.appendToCommandString( 0x1510073, this, [ Core.Proc.encodeString( title ) ] );
	},
	
	/** @private */
	setCalloutSubtitle: function( subTitle )
	{
		Core.Proc.appendToCommandString( 0x1510074, this, [ Core.Proc.encodeString( subTitle ) ] );
	},
	
	/** @private */
	setCalloutEnabled: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x1510075, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	setCalloutLeftView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x1510076, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	setCalloutRightView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x1510077, this, [ +__objectRegistryId ] );
	},
	
	/** @private */
	setCenterOffset: function( xOffset, yOffset )
	{
		Core.Proc.appendToCommandString( 0x1510078, this, [ +xOffset, +yOffset ] );
	},
	
	/** @private */
	$doChoosePhoto: function( w, h, filename, options, callbackId, invokingView )
	{
		Core.Proc.appendToCommandString( 0x151ff87, [ +w, +h, Core.Proc.encodeString( filename ), Core.Proc.encodeObject( options ), Core.Proc.encodeString( callbackId ), +invokingView ] );
	},
	
	/** @private */
	setScrollIndicatorsVisible: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x151007a, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	$measureText: function( string, w, h, font, fontSize, callbackId )
	{
		Core.Proc.appendToCommandString( 0x151ff85, [ Core.Proc.encodeString( string ), +w, +h, Core.Proc.encodeString( font ), +fontSize, Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	setFocus: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x151007c, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	setViewportEnabled: function( enabled )
	{
		Core.Proc.appendToCommandString( 0x151007d, this, [ ( enabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	clearAnimations: function(  )
	{
		Core.Proc.appendToCommandString( 0x151007e, this );
	},
	
	/** @private */
	setStyle: function( styleID )
	{
		Core.Proc.appendToCommandString( 0x151007f, this, [ +styleID ] );
	},
	
	/** @private */
	setVisibleInOrientations: function( orientationFlags )
	{
		Core.Proc.appendToCommandString( 0x1510080, this, [ +orientationFlags ] );
	},
	
	/** @private */
	setAutodetection: function( type )
	{
		Core.Proc.appendToCommandString( 0x1510081, this, [ +type ] );
	},
	
	/** @private */
	playVideo: function( path, callbackId )
	{
		Core.Proc.appendToCommandString( 0x1510082, this, [ Core.Proc.encodeString( path ), Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	setLineHeight: function( lineHeight )
	{
		Core.Proc.appendToCommandString( 0x1510083, this, [ +lineHeight ] );
	},
	
	/** @private */
	$hideKeyboard: function(  )
	{
		Core.Proc.appendToCommandString( 0x151ff7c );
	},
	
	/** @private */
	$takeScreenshot: function( w, h, filename, options, callbackId )
	{
		Core.Proc.appendToCommandString( 0x151ff7b, [ +w, +h, Core.Proc.encodeString( filename ), Core.Proc.encodeObject( options ), Core.Proc.encodeString( callbackId ) ] );
	},
	
	/** @private */
	setPluginsEnabled: function( enable )
	{
		Core.Proc.appendToCommandString( 0x1510086, this, [ ( enable ? 1 : 0 ) ] );
	},
	

// {{/Wg Generated Code}}







	_eventOccurredRecv: function( cmd ) {
		var str = Core.Proc.parseString( cmd[ 0 ] );
		if(!Commands.Window){
			//Annoying. TODO fix this!
			require("NGCore/Client/UI/Window");
		}
		Commands.Window.doCommand(str);
	},
	
	registerTemporaryCallback: function( callback ) {
		if (typeof callback != 'function') return null;
		var regId = (++this._tempCBCount).toString(36);
		Commands._tempCBs[regId] = callback;
		return regId;
	},
	
	takeTemporaryCallback: function( regId ) {
		var cb = Commands._tempCBs[regId];
		delete Commands._tempCBs[regId];
		return cb;
	},
    
	// documented as UI#animate
	/** @ignore */
	animate: function(action, duration, callback) {
		if (typeof action == 'function') {
			var cbFn = (typeof callback == 'function') ? callback : duration;
			var dur = (typeof duration == 'number') ? duration : callback;
			if (typeof dur != 'number') dur = 400;

			Commands.startAnimation( dur, Commands.registerTemporaryCallback(callback));
			var options = new UIAnimationOptions();
			action(options);
			Commands.executeAnimation(options);
		}
	}
});

exports.Commands.instantiate();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Element'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Element'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Element'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Element.js';

var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

var Element = exports.Element = Class.subclass(
/** @lends UI.Element.prototype */
{
	$subclass: function() {
		if (typeof this._init == 'function') this._init();
		return Class.subclass.apply(this, arguments);
	},
	
	classname: "UI_Element",

	/**
	 * @class The `UI.Element` class is a base class for derived classes that represent components
	 * of a user interface.
	 * 
	 * **Important**: This base class is not exported in the `UI` module. Do not access it directly
	 * or create subclasses of `UI.Element`.
	 * 
	 * Classes that are derived from `UI.Element` include:
	 * 
	 * + `{@link UI.AbstractView}`
	 * + `{@link UI.AlertDialog}`
	 * + `{@link UI.ListViewSection}`
	 * + `{@link UI.ProgressDialog}`	 
	 * @name UI.Element
	 * @constructs Create a user interface component.
	 * @augments Core.Class
	 * @example
	 * // Create a new UI.AlertDialog object without setting any of its properties.
	 * var dialog = new UI.AlertDialog();
	 * @example
	 * // Create a new UI.AlertDialog object, setting its title and text.
	 * var dialogTitle = "Really?";
	 * var dialogText = "Are you sure you want to quit the application?";
	 * var dialog = new UI.AlertDialog({
	 *     title: dialogTitle,
	 *     text: dialogText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.Element` object.
	 * @since 1.0
	 */
	initialize: function(properties) {
		if (Element._init) Element._init();
		
		this.register();
		
		// Enable events that are being handled at the class level...
		var events = this._eventNames;
		if (events) for (var e in events) {
			if (this[events[e]]) Commands.enableEvent.call(this, e);
		}
		
		//	Reimplement setAttributes here for speed
		var setters = this._setters;
		if (setters) for (var k in properties) {
			if (typeof setters[k] == 'function') try {
				setters[k].call(this, properties[k]);
			} catch (e) {
				NgLogD("Unable to set " + this.type + '.' + k);
			}
		}
		
	/*	This is awesome. Maybe use it in production code, but we want to keep
	//	our stylistic constraints for core development.
	
		for (var propName in this._setters) {
			this.__defineSetter__(propName, this._setters[propName]);
		}
		for (propName in this._getters) {
			this.__defineGetter__(propName, this._getters[propName]);
		}
	*/
	
		return this;
	},
	
	register: function() {
		try {
			ObjectRegistry.register(this);
			Commands.create(this.__objectRegistryId, this.type || this.classname);
		} catch (e) {
			// Nothing yet
		} finally {
			return this.__objectRegistryId;
		}
	},
	
	retain: function() {
		(this.__retainCount) ? ++this.__retainCount : (this.__retainCount = 1);
		return this;
	},
	
	release: function() {
		if (--this.__retainCount === 0) {
			this.destroy();
		}
	},
		
	/**
	 * Retrieve the value of the specified style property.
	 * @param {String} key The name of the style property.
	 * @returns {String|String[]|Number|Number[]|Boolean} The current value of the style property.
	 * @see UI.Element#getAttributes
	 * @see UI.Element#setAttribute
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	getAttribute: function(key) {
		var getter = this._getters[key];
		return (typeof getter == 'function') ? getter.call(this) : undefined;
	},
	
	/**
	 * Set the value of the specified style property.
	 * @example
	 * // Create a new UI.AlertDialog object and set its "choices" property,
	 * // which controls the options that are presented to the user.
	 * var dialog = new UI.AlertDialog();
	 * dialog.setAttribute("choices", ["Cancel", "Save Changes"]);
	 * @param {String} key The name of the style property.
	 * @param {String|String[]|Number|Number[]|Boolean} value The new value of the style property.
	 * @returns {this}
	 * @see UI.Element#getAttribute
	 * @see UI.Element#getAttributes
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	setAttribute: function(key, value){
		var setter = this._setters[key];
		if (typeof setter == 'function') {
			return setter.call(this, value);
		} else {
			NgLogD("Unable to set " + this.type + '.' + key);
		}
		return this;
	},
	
	/**
	 * Set the value of multiple style properties, which are passed in as properties of an object.
	 * @example
	 * // Create a new UI.AlertDialog object and set two of its style properties:
	 * // 1) the "choices" property, which controls the options that are
	 * // presented to the user, and 2) the "dialogText" property, which
	 * // specifies the dialog box's text for the default view state.
	 * var dialog = new UI.AlertDialog();
	 * dialog.setAttributes({
	 *     choices: ["Cancel", "Save Changes"],
	 *     dialogText: "Are you sure you want to quit the application?"
	 * });
	 * @param {Object} dict An object whose properties will be added as style properties of the
	 *		specified object.
	 * @returns {this}
	 * @see UI.Element#getAttribute
	 * @see UI.Element#getAttributes
	 * @see UI.Element#setAttribute
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	setAttributes: function(dict) {
		var setters = this._setters;
		if (setters) for (var k in dict) {
			if (typeof setters[k] == 'function') try {
				setters[k].call(this, dict[k]);
			} catch (e) {
				NgLogD("Unable to set " + this.type + '.' + k);
			}
		}
		return this;
	},
	
	/**
	 * Retrieve an object's style properties, either by specifying the style properties to retrieve
	 * or by requesting all of the object's style properties.
	 * @example
	 * // Create a new UI.AlertDialog object; set two of its style properties; and
	 * // retrieve the values of those style properties, printing each one to the
	 * // console.
	 * var dialog = new UI.AlertDialog();
	 * dialog.setAttributes({
	 *     choices: ["Cancel", "Save Changes"],
	 *     dialogText: "Are you sure you want to quit the application?"
	 * });
	 * 
	 * var dialogProperties = dialog.getAttributes(["choices", "dialogText"]);
	 * console.log("The value of the choices property is " + 
	 *     dialogProperties.choices);
	 * console.log("The value of the dialogText property is " +
	 *     dialogProperties.dialogText);
	 * @param {String[]} [list] A list of style properties to retrieve. If this parameter is
	 *		omitted, all of the object's style properties will be retrieved.
	 * @returns {Object} An object whose properties represent style properties of a `UI.Element`
	 *		object.
	 * @see UI.Element#getAttribute
	 * @see UI.Element#setAttribute
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	getAttributes: function(list) {
		var output = {};
	        var key;
		if (list instanceof Array) {
			for (var i = 0; i < list.length; i++) {
				key = list[i];
				output[key] = this._getters[key].call(this);
			}
		} else {
			for (key in this._getters) {
				output[key] = this._getters[key].call(this);
			}
		}
		return output;
	},

	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	enableEvent: Commands.enableEvent,
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	toString: function() {
		return this.type + '(' + this.__objectRegistryId + ')';
	},

	/**
	 * @function
	 * @description Destroy this object, and release the resources allocated by the object.
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	destroy: function() {
		Commands.destroy.call(this);
		ObjectRegistry.unregister(this);
		delete this.prototype;
		var onBadAccess = function () {
			var err = new Error('Object is destroyed.');
			NgLogD(err.stack);
			throw err;
		};
		for (var i in this) {
			var isPrivateProperty = (i.substring(0,1) === '_' || i.substring(0,2) === 'on');
			if (this.hasOwnProperty(i) || !isPrivateProperty) {
				var propType = typeof this[i];
				delete this[i];
				this[i] = ('function' === propType ? onBadAccess : undefined);
			}
		}
		this._destroyed = true;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	*/
	registerCallback: function(func, oneTime) {
		var callbackId = ++this.callbackCounter;
		var obj = this;
		this.callbacks[callbackId] = function(obj, args) {
			try {
				func(obj, args);
				if(oneTime) {
					delete obj.callbacks[callbackId];
				}
			}
			catch(e) {
				NgHandleException(e);
			}
		};
		return callbackId;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	performCallback: function(event) {
		var cb = this.callbacks[event.callbackId];
		if(cb) {
			cb(this, event.arguments);
		}
	},
	
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	performEventCallback: function(event) {
		try {
			// Look up the event by its 'onXXX' name...
			var eName = this._eventNames[event.eventType];
			var fn = this['_'+eName] || this[eName];
			if (typeof fn == 'function') {
				fn.call(this, event);
			}
		}
		catch(e) {
			NgHandleException(e);
		}
	},	
	
	// STATICS: Setter and Getter Registration
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$registerAccessors: function(propName, getterFn, setterFn, deprecationMessage) {
		// Put the new setter / getter functions into the prototype.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		var byKeyOnly = Boolean(deprecationMessage || false);
	//	NgLogD("Synthesizing set" + caseAdjusted + (shouldSetClosure ? " (custom)" : " (standard)") +
	//		" and get" + caseAdjusted + (onGetClosure ? " (custom)" : " (standard)") + " for member variable " + localVar);
	
		// If this is an instance, use the instance. Otherwise, if we are a class constructor, modify the prototype.
		var pType = (this instanceof Element) ? this : this.prototype;
	        var heritableMap;
		if (typeof getterFn == 'function') {

			if (!pType.hasOwnProperty('_getters')) {
				try {
					/** @inner */
					heritableMap = function() {return this;};
					var superGetters = pType.superclass._getters;
					if (superGetters) heritableMap.prototype = superGetters;
					pType._getters = new heritableMap();
				} catch (e) {}
			}
			if (byKeyOnly) {
				pType['get'+caseAdjusted] = function() {
					NgLogD("WARNING: Use of get" + caseAdjusted + "() is deprecated. " + deprecationMessage);
					getterFn.apply(this, arguments);
				};
			} else {
				pType['get'+caseAdjusted] = getterFn;
			}
			pType._getters[propName] = getterFn;
		}
		if (typeof setterFn == 'function') {
			if (!pType.hasOwnProperty('_setters')) {
				try {
					heritableMap = function() {return this;};
					var superSetters = pType.superclass._setters;
					if (superSetters) heritableMap.prototype = superSetters;
					pType._setters = new heritableMap();
				} catch (e) {}
			}
			if (byKeyOnly) {
				pType['set'+caseAdjusted] = function() {
					NgLogD("WARNING: Calling set" + caseAdjusted + "() is deprecated. " + deprecationMessage);
					setterFn.apply(this, arguments);
				};
			} else {
				pType['set'+caseAdjusted] = setterFn;
			}
			pType._setters[propName] = setterFn;
		}
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$registerEventType: function(eventName) {
		var onEventName = 'on' + eventName.charAt(0).toUpperCase() + eventName.substr(1);
		var localVar = '_' + onEventName;
		var pType = this.prototype;
		
		var getterFn = function() {
			return this[localVar] || this[onEventName];
		};
		var setterFn = function(callback) {
			var isFn = (typeof callback == 'function');
			if (isFn) {
				this[localVar] = callback;
			} else {
				delete this[localVar];
			}
			this.enableEvent(eventName, isFn);
		};
		if (!pType.hasOwnProperty('_eventNames')) {
			try {
				/** @inner */
				var heritableMap = function() {return this;};
				var superEvents = pType.superclass._eventNames;
				if (superEvents) heritableMap.prototype = superEvents;
				pType._eventNames = new heritableMap();
			} catch (e) {}
		}
		pType._eventNames[eventName] = onEventName;
		
		this.registerAccessors(onEventName, getterFn, setterFn);
		
		// Legacy support. Let's concentrate on removing this soon or at least fixing the casing.
		pType.__defineGetter__(onEventName.toLowerCase(), getterFn);
		pType.__defineSetter__(onEventName.toLowerCase(), setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizePropertyWithState: function(propName, CommandsFn) {
		var lVarName = '_' + propName + 'Map';
		var setterFn;
		if (propName) {
			/** @inner */
			setterFn = function(value, optState) {
				optState |= 0;
			//	NgLogD("Set " + this.type + "." + propName + "[" + optState + "] = " + value);
				(this[lVarName] || (this[lVarName] = {}))[optState] = value;
				CommandsFn.call(this, optState, value);
				return this;
			};
		} else {
			/** @inner */
			setterFn = function(value, optState) {
				CommandsFn.call(this, (optState | 0), value);
				return this;
			};
		}
		
		var getterFn = function(state) {
			return (this[lVarName] || 0)[(state | 0)];
		};
		
		this.registerAccessors(propName, getterFn, setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizeCompoundProperty: function(propName, CommandsFn) {
		var lVarName = '_' + propName;
		var setterFn;
		if (CommandsFn) {
			// Synthesized setters accept EITHER an array of reasonable length OR individual args.
			/** @inner */
			setterFn = function(args) {
				this[lVarName] = (args instanceof Array)
					? args
					: Array.prototype.slice.call(arguments);
				CommandsFn.apply(this, this[lVarName]);
				return this;
			};
		} else {
			/** @inner */
			setterFn = function(args) {
				this[lVarName] = (args instanceof Array) ? args : Array.prototype.slice.call(arguments);
				return this;
			};
		}
		
		this.registerAccessors(propName, function() {return this[lVarName];} , setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizeProperty: function(propName, CommandsFn) {
		var lVarName = '_' + propName;
		var setterFn;
		if (CommandsFn) {
			// Optional args are still passed through, even though only the first arg is assigned.
			/** @inner */
			setterFn = function(arg) {
				this[lVarName] = arg;
				CommandsFn.apply(this, arguments);
				return this;
			};
		} else {
			/** @inner */
			setterFn = function(arg) {
				this[lVarName] = arg;
				return this;
			};
		}
		
		this.registerAccessors(propName, function() {return this[lVarName];} , setterFn);
	},
	

	$bindPropertyState:function(propertyName, stateName, stateFlags) {
			var caseAdjusted = propertyName[0].toUpperCase() + propertyName.substr(1);
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}

});


// Event Handlers
Element._init = function() {
	delete Element._init;
	
	/**
	 * Set a function to call when a `load` event occurs. This event occurs when data from a URL has
	 * finished loading.
	 * @name UI.Element#setOnLoad
	 * @event
	 * @example
	 * // Create a new UI.Button object, which inherits from UI.Element, and
	 * // set a function to call when a "load" event occurs.
	 * var button = new UI.Button();
	 * button.setOnLoad(function(event) {
	 *     var url = Core.Base64.decode(event.urlEncoded);
	 *     console.log("Loaded the URL " + url);
	 * });
	 * @cb {Function} loadCallback The function to call when the `load` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.urlEncoded A Base64-encoded version of the URL being loaded.
	 * @cb-returns {void}
	 * @see UI.Element#event:getOnLoad
	 * @status Flash
	 * @returns {void}
	 */
	/**
	 * Retrieve the function to call when a `load` event occurs.
	 * @name UI.Element#getOnLoad
	 * @event
	 * @returns {Function} The current function to call when a `load` event occurs.
	 * @see UI.Element#event:setOnLoad
	 * @status Flash
	 */
	Element.registerEventType('load');
	// per JYopp, we never fire `unload` events, so @ignore the next two methods
	/**
	 * Set a function to call when an `unload` event occurs.
	 * @name UI.Element#setOnUnload
	 * @event
	 * @cb {Function} unloadCallback The function to call when an `unload` event occurs.
	 * @cb-returns {void}
	 * @see UI.Element#event:getOnUnload	
	 * @returns {void}
	 * @ignore
	 */
	/**
	 * Retrieve the function to call when an `unload` event occurs.
	 * @name UI.Element#getOnUnload
	 * @event
	 * @returns {Function} The current function to call when an `unload` event occurs.
	 * @see UI.Element#event:setOnUnload
	 * @ignore	 
	 */
	Element.registerEventType('unload');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AlertDialog'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AlertDialog'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AlertDialog'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/AlertDialog.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var AlertDialog = exports.AlertDialog = Element.subclass(
/** @lends UI.AlertDialog.prototype */
{
	'type':'alertdialog',
	/**
	 * @name UI.AlertDialog
	 * @class The `UI.AlertDialog` class provides alert dialogs in an application. When the user
	 * chooses an option in the dialog, `UI.AlertDialog` fires a `choice` event that identifies the
	 * user's choice. Specify a callback function to handle this event by calling
	 * `{@link UI.AlertDialog#event:setOnChoice}`.
	 * 
	 * A `UI.AlertDialog` object's appearance can change automatically when its view state changes. 
	 * For example, the alert dialog's title can change automatically when the view gains focus. To
	 * implement this feature, your application can call a `UI.AlertDialog` setter method more than
	 * once, passing a different value in the `flags` parameter each time. In addition, your
	 * application can include properties for multiple view states in the constructor. See the
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.AlertDialog#setChoices}` to control the
	 * choices that are displayed to the user, the choices you specify will apply in all view
	 * states.
	 * @constructs Create an alert dialog.
	 * @augments UI.Element
	 * @example
	 * // Create a new UI.AlertDialog object without setting any of its properties.
	 * var dialog = new UI.AlertDialog();
	 * @example
	 * // Create a new UI.AlertDialog object, setting its title and text.
	 * var dialogTitle = "Really?";
	 * var dialogText = "Are you sure you want to quit the application?";
	 * var dialog = new UI.AlertDialog({
	 *     title: dialogTitle,
	 *     text: dialogText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.AlertDialog` object.
	 * @see UI.Commands#State
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (AlertDialog._init) AlertDialog._init();
		$super(properties);
	},
	
	/** 
	 * Show the alert dialog.
	 * @function
	 * @status Flash, Test, FlashTested
	 * @returns {void}
	 */
	show: Commands.show,
	/** 
	 * Hide the alert dialog.
	 * @function
	 * @status Flash, Test, FlashTested
	 * @returns {void}
	 */
	hide: Commands.hide
});

// Properties
AlertDialog._init = function() {
	delete AlertDialog._init;
	if (Element._init) Element._init();

	/**
	 * Set the `title` property, which defines the alert dialog's title for a specified view state.
	 * @name UI.AlertDialog#setTitle
	 * @example
	 * var dialog = new UI.AlertDialog();
	 * dialog.setTitle("Settings Saved");
	 * @see UI.AlertDialog#getTitle
	 * @param {String} title The title for the alert dialog.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this title. To specify a title for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
 	 * @status iOS, Android, Flash, Test, FlashTested
	 * @function
	 * @returns {void}
	 */
	/**
	 * Retrieve the value of the `title` property, which defines the alert dialog's title for a
	 * specified view state.
	 * @name UI.AlertDialog#getTitle
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current title.
	 * @see UI.AlertDialog#setTitle
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * Set the `text` property, which defines the alert dialog's text for a specified view state.
	 * @name UI.AlertDialog#setText
	 * @function
	 * @example
	 * var dialog = new UI.AlertDialog();
	 * var text = "Your settings have been saved.";
	 * dialog.setText(text);
	 * @param {String} text The text for the alert dialog.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.AlertDialog#getText
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `text` property, which defines the alert dialog's text for a
	 * specified view state.
	 * @name UI.AlertDialog#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text for the alert dialog.
	 * @see UI.AlertDialog#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizePropertyWithState('text', Commands.setText);
	// Not a compound property; AlertDialog.getChoices() should return the array of strings.
	/**
	 * Set the `choices` property, which defines the options that are presented to the user.
	 * @name UI.AlertDialog#setChoices
	 * @function
	 * @example
	 * var dialog = new UI.AlertDialog();
	 * dialog.setChoices(["Cancel", "Save Changes"], 1, 0);
	 * @param {String[]} choices The options that will be presented to the user.
	 * @param {Number} [defaultChoice] The index of the default choice.
	 * @param {Number} [cancelChoice] The index of the choice that cancels the action.
	 * @returns {void}
	 * @see UI.AlertDialog#getChoices
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `choices` property, which defines the options that are presented to
	 * the user.
	 * @name UI.AlertDialog#getChoices
	 * @function
	 * @returns {String[]} The current options that will be presented to the user.
	 * @see UI.AlertDialog#setChoices
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizeProperty('choices', Commands.setChoices);
	
	// Event will contain .choice, which is the index of the option chosen.
	/**
	 * Set a function to call when a `choice` event occurs. This event occurs when the user selects
	 * an option in an alert dialog.
	 * @name UI.AlertDialog#setOnChoice
	 * @event
	 * @example
	 * // Create an alert dialog, and specify a function to handle choice events.
	 * var dialog = new UI.AlertDialog({
	 *     title: "Unsaved Changes",
	 *     text: "Do you want to save your changes?",
	 *     choices: ["Save", "Don't Save"];
	 * });
	 * dialog.setOnChoice(function(event) {
	 *     if (event.choice == 0) {
	 *         // The user chose "Save"
	 *         // Add code to save
	 *         dialog.hide();
	 *     } else {
	 *         // The user chose "Don't Save"
	 *         dialog.hide();
	 *     }
	 * });
	 * @cb {Function} choiceCallback The function to call when a `choice` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Number} event.choice The index of the option that the user chose.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.AlertDialog#event:getOnChoice
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the function to call when a `choice` event occurs.
	 * @name UI.AlertDialog#getOnChoice
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.AlertDialog#event:setOnChoice
 	 * @status iOS, Android, Flash, Test
	 */
	 AlertDialog.registerEventType('choice');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/ErrorEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/ErrorEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/ErrorEmitter'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/ErrorEmitter.js';

// Class ErrorEmitter
// Emit an error from native to js.
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;

////////////////////////////////////////////////////////////////////////////////

exports.ErrorEmitter = MessageEmitter.singleton(
/** @lends Core.ErrorEmitter.prototype */
{
	classname: 'ErrorEmitter',
	
	/**
	 * @class The <code>Core.ErrorEmitter</code> provides applications a way to gather
	 * data about unexpected error situations. 
	 * It emits two things: 
	 * <ol><li>Errors that have happened in the native side of the Javascript bridge</li>
	 * <li>Uncaught exceptions in the Javascript game code.</li></ol>
	 * 
	 * When these errors occur, they are packaged and sent to a URL specified by 
	 * {@link Core.ErrorEmitter#setErrorReportPostUrl}. The first time an error is 
	 * encountered, the user will be prompted for permission to send this data.<br/><br/>
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @since 1.6
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._errorReportPostUrl = null;
	},

	/**
	 * Set the URL to post the uncaught exception.
	 * If this function is called with a valid URL, the first time an exception is thrown, 
	 * the user will be asked to permit the application to send error diagnosis information 
	 * to the specified URL.
	 * @example
	 * initialize: function ()
	 * {
	 *     Core.ErrorEmitter.setErrorReportPostUrl("https://myhost.com/error_report.php");
	 * }
	 *
	 * @param {String} url The url where the error diagnosis will be sent. For security, 
	 * HTTPS is preferable to HTTP.
	 * @returns {void}
	 * @since 1.7
	 */
	setErrorReportPostUrl: function(url)
	{
		this._errorReportPostUrl = url;
	},

	_raiseRecv: function( cmd )
	{
		var msg = {};
		if (!this._raiseRecvGen(cmd, msg))
			return;

		this.emit(msg.errorMessage);
	},

	_handleUncaughtException: function(error)
	{
		var that = this;
		if (this._hasErrorReportUrl()) {
			this._checkUserHasAcceptedSendingErrorReport(function(hasAccepted) {
				if (hasAccepted) {
					that._sendErrorReport(error);
					return;
				}

				that._checkUserHasAskedForPermission(function(hasAsked) {
					if (hasAsked)
						return;

					that._showErrorReportAskPermissionDialog(function(accepted) {
						if (accepted) {
							that._setUserAcceptedSendingErrorReport();
							that._sendErrorReport(error);
						} else {
							that._setAlreadyAsked();
						}
					});
				});
			});
		}

		this.emit(error);
	},

	_hasErrorReportUrl: function()
	{
		return this._errorReportPostUrl !== null;
	},

	_checkUserHasAcceptedSendingErrorReport: function(callback)
	{
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var ErrorReporterKV = KeyValueCache.global("ErrorReporter");
		return ErrorReporterKV.getItem("userHasAcceptedSendingErrorReport", {}, function(error, value) {
			callback(error ? false : value);
		});
	},

	_checkUserHasAskedForPermission: function(callback)
	{
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var ErrorReporterKV = KeyValueCache.global("ErrorReporter");
		return ErrorReporterKV.getItem("userHasAskedForPermission", {}, function(error, value) {
			callback(error ? false : value);
		});
	},

	_setAlreadyAsked: function()
	{
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var ErrorReporterKV = KeyValueCache.global("ErrorReporter");
		ErrorReporterKV.setItem("userHasAskedForPermission", "true", {}, function() {});
	},

	_setUserAcceptedSendingErrorReport: function()
	{
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var ErrorReporterKV = KeyValueCache.global("ErrorReporter");
		ErrorReporterKV.setItem("userHasAcceptedSendingErrorReport", "true", {}, function() {});
	},

	_showErrorReportAskPermissionDialog: function(callback)
	{
		var AlertDialog = require('NGCore/Client/UI/AlertDialog').AlertDialog;

		// TODO: title and text shuold be customizable
		var dialog = new AlertDialog({
			title: 'Application has a problem',
			text: 'Send an error report to the developer?',
			choices: ['No', 'Yes']
		});
		dialog.setOnChoice(function(event) {
			dialog.hide();
			callback(event.choice === 1);
		});
		dialog.show();
	},

	_sendErrorReport: function(errorString)
	{
		var environment = this._gatherEnvironmentInfo();
		var payload = JSON.stringify({environment:environment, error:errorString});

		var XHR = require('NGCore/Client/Network/XHR').XHR;
		var request  = new XHR();
		request.open('POST', this._errorReportPostUrl, true);
		request.onreadystatechange = function() {
			// TODO:
			//   if cannot post it to the server, like the case user is offline,
			//   retry it or push into the pending queue to post it again when online.
			//NgLogD('XHR request state changed to: ' + this.readyState);
		};
		request.send(payload);
	},

	_gatherEnvironmentInfo: function() {
		var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

		var env = {
			SDKVersion: Capabilities.getSDKVersion(),
			SDKBuildDate: Capabilities.getSDKBuildDate(),
			SDKBuildHash: Capabilities.getSDKBuildHash(),
			BinaryVersion: Capabilities.getBinaryVersion(),
			BinaryBuildDate: Capabilities.getBinaryBuildDate(),
			DeviceName: Capabilities.getDeviceName(),
			PlatformOS: Capabilities.getPlatformOS(),
			PlatformOsVersion: Capabilities.getPlatformOSVersion(),
			PlatformHW: Capabilities.getPlatformHW(),
			PhysicalMem: Capabilities.getPhysicalMem(),
			PhysicalCpus: Capabilities.getPhysicalCpus(),
			ActiveCpus: Capabilities.getActiveCpus(),
			Language: Capabilities.getLanguage(),
			BootDir: Capabilities.getBootDir(),
			GameDir: Capabilities.getGameDir(),
			ProductName: Capabilities.getProductName(),
			ContentUrl: Capabilities.getContentUrl(),
			BootGame: Capabilities.getBootGame(),
			StartingServer: Capabilities.getStartingServer(),
			BundleGame: Capabilities.getBundleGame(),
			BundleServer: Capabilities.getBundleServer(),
			BundleIdentifier: Capabilities.getBundleIdentifier(),
			Game: Capabilities.getGame(),
			Server: Capabilities.getServer(),
			Url: Capabilities.getUrl(),
			ScreenWidth: Capabilities.getScreenWidth(),
			ScreenHeight: Capabilities.getScreenHeight(),
			ScreenUnits: Capabilities.getScreenUnits(),
			ScreenPixelUnits: Capabilities.getScreenPixelUnits(),
			MaxTextureSize: Capabilities.getMaxTextureSize(),
			MaxTextureUnits: Capabilities.getMaxTextureUnits(),
			OglExtentions: Capabilities.getOglExtensions(),
			HasAccel: Capabilities.getHasAccel(),
			HasGyro: Capabilities.getHasGyro(),
			HasTouch: Capabilities.getHasTouch(),
			HasMultiTouch: Capabilities.getHasMultiTouch(),
			HasGps: Capabilities.getHasGps(),
			HasCompass: Capabilities.getHasCompass(),
			HasHwKeyboard: Capabilities.getHasHwKeyboard(),
			HasBackButton: Capabilities.getHasBackButton(),
			HasCamera: Capabilities.getHasCamera(),
			HasWwan: Capabilities.getHasWwan(),
			HasWifi: Capabilities.getHasWifi(),
			Career: Capabilities.getCarrier(),
			Locale: Capabilities.getLocale(),
			AppReleaseVersion: Capabilities.getAppReleaseVersion(),
			SimCountryCode: Capabilities.getSimCountryCode(),
			NetworkCountryCode: Capabilities.getNetworkCountryCode(),
			UdpAvailable: Capabilities.getUdpAvailable(),
			TcpAvailable: Capabilities.getTcpAvailable(),
			SslAvailable: Capabilities.getSslAvailable()
		};

		return env;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 359,
	// Method create = -1
	// Method raise = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._raiseRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in ErrorEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in ErrorEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[359] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_raiseRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in ErrorEmitter.raise from command: " + cmd );
			return false;
		}
		
		obj[ "errorMessage" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "errorMessage" ] === undefined )
		{
			NgLogE("Could not parse errorMessage in ErrorEmitter.raise from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x167ffff, [ +__objectRegistryId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _raiseRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/DiagnosticEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/DiagnosticEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/DiagnosticEmitter'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/DiagnosticEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class DiagnosticEmitter
// Diagnostic emitter to decouple diagnostic generation from updating
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var Class = require('NGCore/Client/Core/Class').Class;
var Base64 = require('NGCore/Client/Core/Base64').Base64;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

////////////////////////////////////////////////////////////////////////////////

/*
 * Publish/subscribe to diagnostic information
 *
 * DiagnosticEmitter allows for the asynchronous publishing of module diagnostic
 * information in an efficient manner.  Producers of diagnostic info implement a
 * callback that will be polled when diagnostic information updates are required,
 * and subscribers to diagnostics do so through the standard emitter pattern.
 * Updates may also be pushed synchronously by the producers or updated outside
 * of the callback.  They may also be pushed from native code.
 *
 * For convenience and discoverability, you can use `{@link Core.DiagnosticRegistry#findEmitter}`
 * {@link Core.DiagnosticRegistry.createEmitter}, defined in the DiagnosticRegistry singleton
 * after the DiagnosticEmitter object below to obtain diagnostic emitters:
 *
 * var emitter = DiagnosticRegistry.findEmitter('Foo');
 * var emitter = DiagnosticRegistry.createEmitter('Bar');
 * etc.
 */

exports.DiagnosticEmitter = MessageEmitter.subclass(
/** @lends Core.DiagnosticEmitter.prototype */
{
    classname: 'DiagnosticEmitter',

////////////////////////////////////////////////////////////////////////////////
// public API

    /**
     * @class The <code>Core.DiagnosticEmitter</code> class allows for the asynchronous
     * publishing of module diagnostic information in an efficient manner.  Producers of
     * diagnostic information implement a callback that will be polled when diagnostic
     * information updates are required, and subscribers to diagnostics do so through the
     * standard emitter pattern. Updates may also be pushed synchronously by the producers
     * or updated outside of the callback.
     * <br /><br />
     * For convenience and discoverability, you can use <code>{@link Core.DiagnosticRegistry.findEmitter}</code>
     * or <code>{@link Core.DiagnosticRegistry.createEmitter}</code> to obtain diagnostic emitters.
     * <br /><br />
     * If you are using ngBuilder 2.1.5 or later to develop your app, you can also use this class to
     * profile a specific event in your app. Call
     * <code>{@link Core.DiagnosticEmitter.startEvent}</code> to start an event and
     * <code>{@link Core.DiagnosticEmitter.stopEvent}</code>. When you run your app from ngBuilder,
     * you will be able to view diagnostic information about the event.
     * @constructs The default constructor. Typically, you will not create diagnostic
     * emitters directly, but instead will use <code>{@link Core.DiagnosticRegistry.createEmitter}</code>.
     * @param {String} name The name of the emitter.
     * @augments Core.MessageEmitter
     * @since 1.7
     */
    initialize: function(name) 
    {
	this.name = name;
	this.reset();

	this.listeners = 0;
	this.native_listeners = 0;

	this.collectors = [];
	this.native_collector =false;
	this.dirty = false;

	ObjectRegistry.register(this);
	this._createSendGen(this.__objectRegistryId, name);
	// attempt registration.  May fail if someone is using the same name.
	exports.DiagnosticRegistry.registerEmitter(this.name, this);
    },


    /**
     * Destroys this DiagnosticEmitter. When using DiagnosticEmitters and other types with
     * a native counterpart, you must explicitly destroy them to avoid leaking memory.
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    destroy: function() 
    {
	exports.DiagnosticRegistry.deregisterEmitter(this.name, this);

	// destroy the emitter base class prior to the C++ class or there will
	// be some commands sent to the deregistered object when the message
	// emitter snuffs its listener array.
	MessageEmitter.prototype.destroy.apply(this);
	this._destroySendGen();
	ObjectRegistry.unregister(this);
    },
    

    /**
     * Set maximum data update rate for all listeners of this emitter.
     * Minimum interval is once per frame; however, producers may force data to be
     * emitted faster by calling <code>{@link Core.DiagnosticEmitter#push}</code>.
     * @param {Number} interval The number of frames to use as a publish interval.
     * @returns {Boolean} Set to <code>true</code> if the update was successful.
     * @since 1.7
     * @status iOS, Android, Flash
     */
    setInterval: function(interval) 
    {
	if(interval <= 0) 
	{
	    NgLogE('DiagnosticEmitter ' + this.name + ': attempt to set invalid interval ' + interval);
	    return false;
	}

	this._set_interval(interval);
	return true;
    },

    /**
     * Add a collector callback function to update data. This will be called once
     * per emission interval if there are listeners.
     * <br /><br />
     * The callback is expected to return a diagnostics object if there is an update, 
     * or <code>null</code> for no current update. The object may be of any type, but only local
     * properties are copied. The DiagnosticEmitter will not copy properties
     * from the prototype chain.
     * <br /><br />
     * Any properties returned by the collector callback are additive in that the 
     * DiagnosticEmitter maintains a copy of the diagnostics object and only updates
     * changed values. So if the collector callback returns an object with a subset of properties,
     * only those properties will be updated in the maintained diagnostics object while other 
     * properties will remain unchanged.
     * <br /><br />
     *
     * In order to clear all previous diagnostics, call <code>{@link Core.DiagnosticEmitter#reset}</code>
     * in the collector callback before returning a new diagnostics object.
     * <br /><br />
     * In addition, functions can also be returned in the diagnostics object and will be
     * emitted to listeners. Use this feature with care.
     * @param {Function} collector The function to be called to collect diagnostics. 
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    pushCollector: function(collector)
    {
	if(collector && !(collector instanceof Function))
	{
	    NgLogE('DiagnosticEmitter ' + this.name + ': attempt to set invalid collector');	    
	} 
	this.collectors.push(collector);
	// get initial values
	if(this.getListenerCount() > 0)
	{
	    this.update(collector(0));
	}
    },

    /**
     * Remove a previously added collector.
     *
     * @param {Function} collector The function to be removed.
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    removeCollector: function(collector)
    {
	for(var i=0;i<this.collectors.length; i++)
	{
	    if(this.collectors[i] == collector)
	    {
		this.collectors.splice(i, 1);
		return;
	    }
	}
    },

    /**
     * Clear this emitter's diagnostics. This will effectively remove all diagnostic
     * properties from the DiagnosticEmitter's diagnostics and replace
     * the contents with properties from the object passed in.
     * @param {Object} [obj] An object to reset the diagnostics to.
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    reset: function(obj) 
    {
	this.diags = {name: this.name};
	if(obj) 
	{
	    this.update(obj);
	}
    },

    /**
     * Manually make a diagnostics update outside of the callback mechanism.
     * Updates are merged into the existing diagnostics.
     * @param {Object} obj The object to update the diagnostics with.
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    update: function(obj) 
    {
	if(obj) 
	{
	    this.dirty = true;
	    for(var key in obj) 
	    {
		if(obj.hasOwnProperty(key)) 
		{
		    this.diags[key] = obj[key];
		}
	    }
	}
    }, 

    /**
     * Force an update to be emitted regardless of update interval.  
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    push: function()
    {
	this.emit(this.diags);
    },

    /**
     * Convenience function to update and force a push in one step.
     * @param {Object} obj the object to update the diagnostics with.
     * @returns {void}
     * @since 1.7
     * @status iOS, Android, Flash
     */
    pushUpdate: function(obj)
    {
	this.update(obj);
	this.push();
    },

    /**
     * Getter for the current diagnostics information.
     * @returns {Object} The current diagnostics object.
     * @since 1.7
     * @status iOS, Android, Flash
     */
    getDiags: function() 
    {
	return this.diags;
    },

    /**
     * Create a closure over a diagnostics producer function so that it will 
     * be called only if we have listeners. It should return a diagnostics 
     * update object.
     * @param {Object} obj
     * @param {Function} fn
     *
     * @returns {Function} A function to call that will update the diagnostics. 
     * @since 1.7
     * @status iOS, Android, Flash
     * @private
     */
    curryProducer: function(obj, fn)
    {
	var that = this;
	return function() {
	    if(that.listeners > 0)
	    {
		var upd = fn.apply(obj, arguments);
		that.update(upd);
	    } 
	};
    },

	/**
	 * Start an event that can be profiled in ngBuilder. Event profiling is supported in ngBuilder
	 * 2.1.5 and later.
	 * @name Core.DiagnosticEmitter.startEvent
	 * @function
	 * @static
	 * @param {String} eventName The event to profile.
	 * @returns {void}
	 * @since 1.8
	 * @status iOS, Android, Flash
	 */
	
	/** @ignore */
	$startEvent: function (eventName) {
		this._startEventSendGen(eventName, new Date().getTime());
	},

	/**
	 * Stop an event that can be profiled in ngBuilder. Event profiling is supported in ngBuilder
	 * 2.1.5 and later.
	 * @name Core.DiagnosticEmitter.stopEvent
	 * @function
	 * @static
	 * @param {String} eventName The event to profile.
	 * @returns {void}
	 * @since 1.8
	 * @status iOS, Android, Flash
	 */
	
	/** @ignore */
	$stopEvent: function (eventName) {
		this._stopEventSendGen(eventName, new Date().getTime());
	},


////////////////////////////////////////////////////////////////////////////////

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 362,
	// Method create = -1
	// Method destroy = 2
	// Method currentListeners = 3
	// Method updateDiagnostics = 4
	// Method nativeCollector = 5
	// Method collectNative = 6
	// Method _runTests = 7
	// Method nativeListeners = 8
	// Method setCurrentState = 9
	// Method tick = 10
	// Method startEvent = -11
	// Method stopEvent = -12
	// Method _set_interval = 13
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._updateDiagnosticsRecv( cmd );
					break;
				case 5:
					instance._nativeCollectorRecv( cmd );
					break;
				case 8:
					instance._nativeListenersRecv( cmd );
					break;
				case 10:
					instance._tickRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in DiagnosticEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in DiagnosticEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[362] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_updateDiagnosticsRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in DiagnosticEmitter.updateDiagnostics from command: " + cmd );
			return false;
		}
		
		obj[ "jsonData" ] = Proc.parseObject( cmd[ 0 ] );
		if( obj[ "jsonData" ] === undefined )
		{
			NgLogE("Could not parse jsonData in DiagnosticEmitter.updateDiagnostics from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_nativeCollectorRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in DiagnosticEmitter.nativeCollector from command: " + cmd );
			return false;
		}
		
		obj[ "exists" ] = Proc.parseBool( cmd[ 0 ] );
		if( obj[ "exists" ] === undefined )
		{
			NgLogE("Could not parse exists in DiagnosticEmitter.nativeCollector from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_nativeListenersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in DiagnosticEmitter.nativeListeners from command: " + cmd );
			return false;
		}
		
		obj[ "num" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "num" ] === undefined )
		{
			NgLogE("Could not parse num in DiagnosticEmitter.nativeListeners from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_tickRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in DiagnosticEmitter.tick from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId, name )
	{
		Proc.appendToCommandString( 0x16affff, [ +__objectRegistryId, Proc.encodeString( name ) ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Proc.appendToCommandString( 0x16a0002, this );
	},
	
	/** @private */
	_currentListenersSendGen: function( num )
	{
		Proc.appendToCommandString( 0x16a0003, this, [ +num ] );
	},
	
	/** @private */
	_collectNativeSendGen: function( frame_interval )
	{
		Proc.appendToCommandString( 0x16a0006, this, [ +frame_interval ] );
	},
	
	/** @private */
	__runTestsSendGen: function( emitter_list )
	{
		Proc.appendToCommandString( 0x16a0007, this, [ Proc.encodeString( emitter_list ) ] );
	},
	
	/** @private */
	_setCurrentStateSendGen: function( jsonData )
	{
		Proc.appendToCommandString( 0x16a0009, this, [ Proc.encodeObject( jsonData ) ] );
	},
	
	/** @private */
	$_startEventSendGen: function( eventName, timeMs )
	{
		Proc.appendToCommandString( 0x16afff5, [ Proc.encodeString( eventName ), +timeMs ] );
	},
	
	/** @private */
	$_stopEventSendGen: function( eventName, timeMs )
	{
		Proc.appendToCommandString( 0x16afff4, [ Proc.encodeString( eventName ), +timeMs ] );
	},
	
	/** @private */
	__set_intervalSendGen: function( num )
	{
		Proc.appendToCommandString( 0x16a000d, this, [ +num ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId, name ) {}
	
	// destroy: function(  ) {}
	
	// currentListeners: function( num ) {}
	
	// _updateDiagnosticsRecv: function( cmd ) {}
	// _nativeCollectorRecv: function( cmd ) {}
	// collectNative: function( frame_interval ) {}
	
	// _runTests: function( emitter_list ) {}
	
	// _nativeListenersRecv: function( cmd ) {}
	// setCurrentState: function( jsonData ) {}
	
	// _tickRecv: function( cmd ) {}
	// $startEvent: function( eventName, timeMs ) {}
	
	// $stopEvent: function( eventName, timeMs ) {}
	
	// _set_interval: function( num ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


    ,
////////////////////////////////////////////////////////////////////////////////
// internal-only funcs and overrides
    _set_interval: function( num ) 
    {	
	this.__set_intervalSendGen(num);
    },

    // override for MessageEmitter
    addListener: function(listener, func, priority) 
    {
	MessageEmitter.prototype.addListener.apply(this, [listener, func, priority]);
	this.listeners = MessageEmitter.prototype.getListenerCount.apply(this);
	this.sendCurrentListeners(this.listeners);
    },
    // override for MessageEmitter
    removeListener: function(listener) 
    {
	MessageEmitter.prototype.removeListener.apply(this, [listener]);
	this.listeners = MessageEmitter.prototype.getListenerCount.apply(this);
	this.sendCurrentListeners(this.listeners);
    },

    // override for MessageEmitter
    getListenerCount: function() 
    {
	return this.listeners + this.native_listeners;
    },

    // send the current listeners to the C++ side 
    sendCurrentListeners: function(num) 
    {
	this._currentListenersSendGen(num);
    },
	
    // got diags from native code
    _updateDiagnosticsRecv: function(cmd) 
    {
	var diagblob = {};
	try {
	    if(this._updateDiagnosticsRecvGen(cmd, diagblob))
	    {
		var diagobj = diagblob.jsonData; 
		this.update(diagobj);
	    }
	}
	catch(e) {
	    NgLogE('DiagnosticEmitter: error parsing JSON received from C++, error is: ' + e);
	}
    },

    _nativeCollectorRecv: function(cmd) 
    {
	var obj = {};
	if(this._nativeCollectorRecvGen(cmd, obj))
	{
	    this.native_collector = obj.exists;
	}
    },
    
    collectNative: function(interval) 
    {
	this._collectNativeSendGen(interval);
    },
	
    _nativeListenersRecv: function( cmd ) 
    {
	var obj = {};
	if(this._nativeListenersRecvGen(cmd, obj))
	{
	    this.native_listeners = obj.num;
	}
    },
	
    setCurrentState: function( jsonData ) 
    {
	this._setCurrentStateSendGen(jsonData);
    },
	
    // Process update ticks.  If we have had a diag update collected or pushed 
    // and the update interval has expired, emit the update.
    _tickRecv: function(cmd) 
    {
	// if no listeners, do not collect or emit.
	if(this.getListenerCount() === 0) { return; }

	for(var c = 0; c < this.collectors.length; c++)
	{
	    var cfun = this.collectors[c];
	    this.update(cfun(this.last));
	}

	if(this.dirty)
	{
	    //NgLogD('DiagnosticEmitter ' + this.name + ' onTick emitting, delta=' + delta + ' last=' + this.last);
	    
	    this.dirty = false;
	    this.emit(this.diags);
	    this.setCurrentState(this.diags);
	}
    },
    
    // no-op unless conditionally compiled in on the C++ side.
    _runTests: function(emitter_list)
    {
	this.__runTestsSendGen(emitter_list);
    }
});

//
// Tools can use this to access all the registered emitters
//
exports.DiagnosticRegistry = Class.singleton({
    /** @lends Core.DiagnosticRegistry */

    classname: 'DiagnosticRegistry',
    /**
     * @class The <code>Core.DiagnosticRegistry</code> enables location and creation
     * of diagnostic emitters.<br/><br/>
     * 
     * You can define any number and type of diagnostic emitters that you would like to use
     * in your app. In order to create the emitter, call 
     * <code>{@link Core.DiagnosticRegistry.createEmitter}</code> with the name you want to use for
     * the emitter. The app can then add its collector callback and
     * set the reporting interval on the DiagnosticEmitter.
     *
     * @singleton
     * @constructs The default constructor.
     * @augments Core.Class
     * @since 1.7
     */
    initialize: function() 
    {
	ObjectRegistry.register(this);
	this.registry = {};
    },

    /** 
     * Returns the diagnostics emitter of the specified name.  
     * This method should be used by consumers of diagnostics.
     * @example
     * var myDiagEmitter = Core.DiagnosticRegistry.findEmitter("myEmitter");
     * 
     * if (myDiagEmitter) {
     *     myDiagEmitter.addListener (this, function (diagObj) {
     *         console.log("Diagnostics: ", JSON.stringify(diagObj));
     *     });
     * }
     * @param {String} name The name of the emitter you are looking for.
     * @returns {Core.DiagnosticEmitter} The emitter for that name, or undefined if it does not exist.
     * @since 1.7
     * @status iOS, Android, Flash
     */
    findEmitter: function(name)
    {
	return this.registry[name];
    },

    /** 
     * Returns the diagnostics emitter of the specified name, creating it if necessary.
     * This method should be used by diagnostic producers; it is idempotent and can be
     * called any number of times, returning the same emitter each time.
     * @example
     * function myDiagnosticsGatherer()
     * {
     *     // This assumes getDiagObject() returns an object of some type.
     *     var diagObject = getDiagObject();
     *     return diagObject;
     * }
     * var myDiagEmitter = Core.DiagnosticRegistry.createEmitter("myEmitter");
     *
     * myDiagEmitter.pushCollector(myDiagnosticsGatherer);
     *
     * myDiagEmitter.setInterval (100);
     *
     * @param {String} name The name of the emitter you are going to produce diagnostics for.
     * @returns {Core.DiagnosticEmitter} The emitter for that name
     * @since 1.7
     * @status iOS, Android, Flash
     */
    createEmitter: function(name)
    {
	var e = this.findEmitter(name);
	if(!e)
	{
	    e = new exports.DiagnosticEmitter(name);
	    // ctor registers, we done
	}
	return e;
    },

    /** 
     * Returns a list of all emitter names.
     *
     * This method should be used by consumers of diagnostics.
     * @example
     * var emitterList = Core.DiagnosticRegistry.listEmitters();
     *
     * for (e in emitterList) {
     *     console.log ("Emitter: ", emitterList[e]);
     * }
     *
     * @returns {Array} A list of the names of all of the registered DiagnosticEmitters.
     * @since 1.7
     * @status iOS, Android, Flash
     */
    listEmitters: function()
    {
	var rc = [];
	for(var key in this.registry) 
	{
	    rc.push(key);
	}
	return rc;
    },
    
    // internal functions follow
    registerEmitter: function(name, emitter)
    {
	if(this.registry[name])
	{
	    NgLogE('Duplicate registration of diagnostic emitter ' + name);
	    return false;
	}
	this.registry[name] = emitter;
	return true;
    }, 
    
    deregisterEmitter: function(name, emitter)
    {
	if(this.registry[name] != emitter)
	{
	    NgLogE('Non-registered deregistration attempt of diagnostic emitter ' + name);
	    return false;
	}
	this.registry[name] = undefined;
	return true;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// Core diagnostic emitter; collects info from Core subsystem and also collects 
// general info.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var DiagnosticEmitter = require('NGCore/Client/Core/DiagnosticEmitter').DiagnosticEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

////////////////////////////////////////////////////////////////////////////////
    
//
// Create and export a DiagnosticEmitter for Core.  Other modules should do this 
// this way too.
//

exports.Diagnostics = DiagnosticEmitter.singleton(
/** @lends Core.Diagnostics.prototype */
{
    classname: 'Core_Diagnostics',

    /**
     * @class The <code>Core.Diagnostics</code> class constructs a singleton object
     * to obtain overall frame tick diagnostic timing information and other diagnostics
     * generally applicable to the frame processing itself.  Other modules implement
     * module-specific detailed diagnostics.<br/><br/>
	 *
     * The emitter currently emits an object of the form:
     * <pre>
     *     {
     *         "name": "Core",             // The name of the emitter
     * 
     *         "frame": {Number},           // Frame number for which these Diagnostics apply.
     *         "fps": {Number},             // Instantaneous fps rate over the last sampling interval
     *         "skipped": {Number},         // Frames skipped in the last interval
     *         "skipped_fps": {Number},     // Instantaneous skipped fps rate over last interval
     * 
     *         "frame_total": {Timer},     // A Timer object reporting total time processing the frame:
     *                                     // See below for the object definition of Timer.
     *
     *         "tick_total": {Timer},      // Total time spent processing the current engine tick.
     *         "draw_total": {Timer},      // Total time spent drawing.
     *         "game_tick": {Timer},       // Total time spent executing the game JS.
     *         "priv_tick": {Timer},       // Total time spent executing the privileged JS.
     *         "app_tick": {Timer},        // Total time spent ticking the Application object.
     *         "physics_tick": {Timer},    // Total time spent in Physics.
     *         "audio_tick": {Timer},      // Total time spent in Audio.
     *         "motion_tick": {Timer},     // Total time spent processing motion input.
     *         "animations_tick": {Timer}  // Total time spent processing Animations.
     *     }
     * </pre>
     *
     * A Timer is an object of the form:
     * <pre>
     *      {
     *         "samples": {Number},        // number of timer executions captured this interval
     *         "average": {Number},        // average time spent in the timed block
     *         "min": {Number},            // minimum time spent in the timed block
     *         "max": {Number}             // maximum time spent in the timed block
     *      }
     * </pre>
     * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.DiagnosticEmitter
	 * @since 1.7
     */
    initialize: function($super) 
    {
	$super('Core');
    }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Buffer'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Buffer'] || {}; $MODULE_REGISTRY['NGCore/Shared/Buffer'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/Buffer.js';

var Class = require('NGCore/Shared/Class').Class;

exports.Buffer = Class.subclass(
/** @lends Core.Buffer.prototype */
{
  classname: 'Buffer',

  /**
   * @class The <code>Core.Buffer</code> class provides buffers for storing binary data. Use this
   * class in combination with <code>{@link Network.Socket}</code> to transmit data through a
   * socket.<br /><br />
   * In general, when you use this class' methods to read data from a buffer, the data is removed
   * from the buffer. If you need to retrieve data from a buffer without altering the buffer's
   * contents, do one of the following:
   * <ul>
   * <li>Retrieve the buffer's contents using <code>{@link Core.Buffer#toString}</code>.</li>
   * <li>Clone the buffer using <code>{@link Core.Buffer#clone}</code>, then read data from the
   * cloned buffer.</li>
   * </ul>
   * @example
   * // Create an empty data buffer.
   * var buffer = new Core.Buffer();
   * @example
   * // Create a data buffer that contains a string of text.
   * var buffer = new Core.Buffer("data");
   * @example
   * // Create a data buffer by copying data from an existing buffer.
   * var buffer1 = new Core.Buffer("data");
   * var buffer2 = new Core.Buffer(buffer1);
   * @constructs Create a data buffer.
   * @augments Core.Class
   * @param {Core.Buffer|String} [data] An existing data buffer whose contents will be copied to the
   *     new buffer, or a string that will be stored in the buffer.
   * @see Network.Socket
   * @since 1.6.5
   */
  initialize: function()
  {
    this._log2 = function(x) {
      return Math.floor(Math.log(x) / Math.LN2);
    };

    this._toIEEE754 = function(val, ctx, bitWidth) {
      var EBITS;  // num of bits in exponent field
      var FBITS;  // num of bits in significand field

      switch(bitWidth) {
        case 32:
          EBITS = 8;
          FBITS = 23;
          break;
        case 64:
          EBITS = 11;
          FBITS = 52;
          break;
        default:
          throw "Invalid bit width";
      }

      var BIAS = Math.pow(2, EBITS-1) - 1;

      ctx.neg = (val < 0)? 1:0;
      ctx.expo = 0;
      ctx.sigd = 0;

      val = Math.abs(val);

      if(isNaN(val)) {
        ctx.neg = 0;
        ctx.expo = 0;
        ctx.sigd = 1;
      } else if(!isFinite(val)) {
        ctx.expo = Math.pow(2, EBITS) - 1;
        ctx.sigd = 0;
      } else if(val === 0) {
        ctx.expo = 0;
        ctx.sigd = 0;
      } else {
        ctx.expo = this._log2(val);
        if(ctx.expo < (1-BIAS) || (ctx.expo == (1-BIAS) && val < Math.pow(2, (1-BIAS)))) {
          ctx.sigd = Math.round((val / Math.pow(2, (1-BIAS))) * Math.pow(2, FBITS));
          ctx.expo = 0;
        } else {
          ctx.sigd = Math.round((val / Math.pow(2, ctx.expo) - 1) * Math.pow(2, FBITS));
          ctx.expo += BIAS;
        }
      }
    };

    this._fromIEEE754 = function(ctx, bitWidth) {
      var EBITS;  // num of bits in exponent field
      var FBITS;  // num of bits in significand field

      switch(bitWidth) {
        case 32:
          EBITS = 8;
          FBITS = 23;
          break;
        case 64:
          EBITS = 11;
          FBITS = 52;
          break;
        default:
          throw "Invalid bit width";
      }

      var BIAS = Math.pow(2, EBITS-1) - 1;

      if(ctx.expo === 0) {
        if(ctx.sigd === 0) {
          return 0.0;
        }

        return ctx.neg * ctx.sigd * Math.pow(2, (1-BIAS) - FBITS);
      }

      if(ctx.expo == Math.pow(2, EBITS) - 1) {
        if(ctx.sigd === 0) {
          return ctx.neg * Number.POSITIVE_INFINITY;
        }

        return NaN;
      }

      return ctx.neg * (1 + ctx.sigd * Math.pow(2, -FBITS)) * Math.pow(2, ctx.expo - BIAS);
    };

    this._array2val = function(bytes, isLE) {
      var val = 0;
      if(isLE) bytes.reverse();
      for(var i = 0; i < bytes.length; ++i) {
        val += bytes[i] * Math.pow(2, (bytes.length - i - 1) * 8);
      }
      return val;
    };

    this._array2str = function(bytes, isLE) {
      if(isLE) bytes.reverse();
      return String.fromCharCode.apply(String, bytes);
    };

    this._isBinary = function(str) {
      for(var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if(c < 0 && c >= 0x100) {
          return false;
        }
      }
      return true;
    };

    if(typeof(arguments[0]) == 'object') {
      this._bytes = arguments[0]._bytes;
    } else if(typeof(arguments[0]) == 'string') {
      this._bytes = arguments[0];
    } else {
      this._bytes = '';
    }

    if(!this._isBinary(this._bytes)) {
      this._bytes = '';
    }
  },

  /**
   * Retrieve the number of characters in the buffer.
   * @returns {Number} The number of characters in the buffer.
   * @since 1.6.5
   */
  getSize: function() {
    return this._bytes.length;
  },

  /**
   * Read an 8-bit unsigned integer value from the beginning of the buffer, and remove the character
   * at index 0 of the buffer.
   * @returns {Number} An 8-bit unsigned integer value, or <code>NaN</code> if the buffer is empty.
   * @since 1.6.5
   */
  readUint8: function() {
    if(this._bytes.length < 1) return NaN;
    var ret = this._bytes.charCodeAt(0);
    this._bytes = this._bytes.slice(1);
    return ret;
  },

  /**
   * Read a 16-bit unsigned integer value from the beginning of the buffer, and remove the 
   * characters at indexes 0 and 1 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 16-bit unsigned integer value, or <code>NaN</code> if the buffer contains
   *     fewer than 16 bits of data.
   * @since 1.6.5
   */
  readUint16: function(isLE) {
    if(this._bytes.length < 2) return NaN;
    var ret = this._array2val([
      this._bytes.charCodeAt(0),
      this._bytes.charCodeAt(1)
    ], isLE);
    this._bytes = this._bytes.slice(2);
    return ret;
  },

  /**
   * Read a 32-bit unsigned integer value from the beginning of the buffer, and remove the 
   * characters at indexes 0 through 3 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 32-bit unsigned integer value, or <code>NaN</code> if the buffer contains
   *     fewer than 32 bits of data.
   * @since 1.6.5
   */
  readUint32: function(isLE) {
    if(this._bytes.length < 4) return NaN;
    var ret = this._array2val([
      this._bytes.charCodeAt(0),
      this._bytes.charCodeAt(1),
      this._bytes.charCodeAt(2),
      this._bytes.charCodeAt(3)
    ], isLE);
    this._bytes = this._bytes.slice(4);
    return ret;
  },

  /**
   * Read an 8-bit signed integer value from the beginning of the buffer, and remove the character
   * at index 0 of the buffer.
   * @returns {Number} An 8-bit signed integer value, or <code>NaN</code> if the buffer is empty.
   * @since 1.6.5
   */
  readInt8: function() {
    var ret = this.readUint8();
    if(ret >>> 7) {
      return ret - 0x100;
    }
    return ret;
  },

  /**
   * Read a 16-bit signed integer value from the beginning of the buffer, and remove the characters
   * at indexes 0 and 1 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 16-bit signed integer value, or <code>NaN</code> if the buffer contains
   *     fewer than 16 bits of data.
   * @since 1.6.5
   */
  readInt16: function(isLE) {
    var ret = this.readUint16(isLE);
    if(ret >>> 15) {
      return ret - 0x10000;
    }
    return ret;
  },

  /**
   * Read a 32-bit signed integer value from the beginning of the buffer, and remove the characters
   * at indexes 0 through 3 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 32-bit signed integer value, or <code>NaN</code> if the buffer contains
   *     fewer than 32 bits of data.
   * @since 1.6.5
   */
  readInt32: function(isLE) {
    var ret = this.readUint32(isLE);
    if(ret >>> 31) {
      return ret - 0x100000000;
    }
    return ret;
  },

  /**
   * Read a 64-bit signed float value from the beginning of the buffer, and remove the characters at
   * indexes 0 through 7 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 64-bit float value, or <code>NaN</code> if the buffer contains fewer than
   *     64 bits of data.
   * @since 1.6.5
   */
  readFloat64: function(isLE) {
    if(this._bytes.length < 8) return NaN;
    var b = [
      this._bytes.charCodeAt(0),
      this._bytes.charCodeAt(1),
      this._bytes.charCodeAt(2),
      this._bytes.charCodeAt(3),
      this._bytes.charCodeAt(4),
      this._bytes.charCodeAt(5),
      this._bytes.charCodeAt(6),
      this._bytes.charCodeAt(7)
    ];

    if(isLE) b.reverse();
    this._bytes = this._bytes.slice(8);

    var ctx = {
      neg: 1 - (2 * (b[0] >> 7)), // 1 or -1
      expo: (((b[0] << 1) & 0xff) << 3) | (b[1] >> 4),
      sigd: ((b[1] & 0x0f) * 0x1000000000000) +
            (b[2] * 0x10000000000) +
            (b[3] * 0x100000000) +
            (b[4] * 0x1000000) +
            (b[5] * 0x10000) +
            (b[6] * 0x100) +
            b[7]
    };

    return this._fromIEEE754(ctx, 64);
  },

  /**
   * Read a 32-bit float value from the beginning of the buffer, and remove the characters at
   * indexes 0 through 3 of the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to read data in little-endian format. By
   *     default, data is read in big-endian format.
   * @returns {Number} A 32-bit float value, or <code>NaN</code> if the buffer contains fewer than
   *     32 bits of data.
   * @since 1.7
   */
  readFloat32: function(isLE) {
    if(this._bytes.length < 4) return NaN;
    var b = [
      this._bytes.charCodeAt(0),
      this._bytes.charCodeAt(1),
      this._bytes.charCodeAt(2),
      this._bytes.charCodeAt(3)
    ];

    if(isLE) b.reverse();
    this._bytes = this._bytes.slice(4);

    var ctx = {
      neg: 1 - (2 * (b[0] >> 7)),
      expo: (((b[0] << 1) & 0xff) | (b[1] >> 7)) & 0xffff,
      sigd: ((b[1] & 0x7f) * 0x10000) +
            (b[2] * 0x100) +
            b[3]
      };

    return this._fromIEEE754(ctx, 32);
  },

  /**
   * Read the specified number of characters from the buffer, and remove the characters from the
   * buffer.
   * @param {Number} len The number of characters to read.
   * @returns {String} The characters read from the buffer.
   * @since 1.6.5
   */
  readBytes: function(len) {
    if(len > this._bytes.length) {
      len = this._bytes.length;
    }
    var ret = this._bytes.slice(0, len);
    this._bytes = this._bytes.slice(len);
    return ret;
  },

  /**
   * Write a value to the end of the buffer as an 8-bit unsigned integer. One character will be
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @returns {void}
   * @since 1.6.5
   */
  writeUint8: function(val) {
    this._bytes += String.fromCharCode(val);
  },

  /**
   * Write a value to the end of the buffer as a 16-bit unsigned integer. Two characters will be
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @since 1.6.5
   */
  writeUint16: function(val, isLE) {
    this._bytes += this._array2str([
      val>>>8,
      val & 0xff
    ], isLE);
  },

  /**
   * Write a value to the end of the buffer as a 32-bit unsigned integer. Four characters will be
   * appended to the buffer. The value is written in big-endian format.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @since 1.6.5
   */
  writeUint32: function(val, isLE) {
    this._bytes += this._array2str([
      (val >>> 24) & 0xff,
      (val >>> 16) & 0xff,
      (val >>> 8) & 0xff,
      val & 0xff
    ], isLE);
  },

  /**
   * Write a value to the end of the buffer as an 8-bit signed integer. One character will be
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @returns {void}
   * @throws {Error} The specified value cannot be represented as an 8-bit signed integer.
   * @since 1.6.5
   */
  writeInt8: function(val) {
    if(val < -0x80 || val > 0x7f) throw new Error('Invalid argument');
    if(val < 0) {
      val = 0x100 + val;
    }
    this.writeUint8(val);
  },

  /**
   * Write a value to the end of the buffer as a 16-bit signed integer. Two characters will be
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @throws {Error} The specified value cannot be represented as a 16-bit signed integer.
   * @since 1.6.5
   */
  writeInt16: function(val, isLE) {
    if(val < -0x8000 || val > 0x7fff) throw new Error('Invalid argument');
    if(val < 0) {
      val = 0x10000 + val;
    }
    this.writeUint16(val, isLE);
  },

  /**
   * Write a value to the end of the buffer as a 32-bit signed integer. Four characters will be
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @throws {Error} The specified value cannot be represented as a 32-bit signed integer.
   * @since 1.6.5
   */
  writeInt32: function(val, isLE) {
    if(val < -0x80000000 || val > 0x7fffffff) throw new Error('Invalid argument');
    if(val < 0) {
      val = 0x100000000 + val;
    }
    this.writeUint32(val, isLE);
  },

  /**
   * Write a value to the end of the buffer as a 64-bit signed float. Eight characters will be 
   * appended to the buffer.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @since 1.6.5
   */
  writeFloat64: function(val, isLE) {
    var ctx = {};
    this._toIEEE754(val, ctx, 64);

    var sigdu = Math.floor(ctx.sigd / 0x100000000);
    var sigdl = ctx.sigd % 0x100000000;

    this._bytes += this._array2str([
      (ctx.neg << 7) | (ctx.expo >> 4),
      (ctx.expo & 0x0f) << 4 | ((sigdu >> 16) & 0x0f),
      (sigdu >> 8) & 0xff,
      sigdu & 0xff,
      (sigdl >>> 24) & 0xff,
      (sigdl >>> 16) & 0xff,
      (sigdl >>> 8) & 0xff,
      sigdl & 0xff
    ], isLE);
  },

  /**
   * Write a value to the end of the buffer as a 32-bit float. Four characters will be appended to
   * the buffer.
   * @param {Number} val The value to write into the buffer.
   * @param {Boolean} [isLE=false] Set to <code>true</code> to write data in little-endian format.
   *     By default, data is written in big-endian format.
   * @returns {void}
   * @since 1.7
   */
  writeFloat32: function(val, isLE) {
    var ctx = {};
    this._toIEEE754(val, ctx, 32);

    this._bytes += this._array2str([
      (ctx.neg << 7) | (ctx.expo >>> 1),
      ((ctx.expo << 7) & 0xff) | ((ctx.sigd >> 16) & 0x7f),
      (ctx.sigd >> 8) & 0xff,
      ctx.sigd & 0xff
    ], isLE);
  },

  /**
   * Write characters to the end of the buffer.
   * @param {String} str The characters to write into the buffer.
   * @returns {void}
   * @since 1.6.5
   */
  writeBytes: function(str) {
    if(this._isBinary(this._bytes)) {
      this._bytes += str;
    }
  },

  /**
   * Retrieve the buffer's contents as a string.
   * @returns {String} The contents of the buffer.
   * @since 1.6.5
   */
  toString: function() {
      return this._bytes;
  },

  clear: function() {
    this._bytes = '';
  },

  /**
   * Create a copy of the <code>Core.Buffer</code> object.
   * @returns {Core.Buffer} A copy of the <code>Core.Buffer</code> object.
   * @since 1.6.5
   */
  clone: function() {
    return new exports.Buffer(this);
  },

  /**
   * Remove a portion of the buffer's data, and create a new buffer containing the data that was
   * removed.
   * @param {Number} begin The index of the first character to remove from the buffer.
   * @param {Number} [end] The index of the last character to remove from the buffer. If you omit
   *     omit this parameter, all of the data after the starting index will be removed.
   * @returns {Core.Buffer} A new <code>Core.Buffer</code> object containing the data that was
   *     removed from the original buffer.
   * @since 1.6.5
   */
  slice: function(begin, end) {
    return new exports.Buffer(this._bytes.slice(begin, end));
  }
});

// vim: ts=2:sw=2:expandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Buffer'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Buffer'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Buffer'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Buffer.js';

exports.Buffer = require('NGCore/Shared/Buffer').Buffer;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/libutf8'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/libutf8'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/libutf8'] = exports; 
var __dirname = 'NGCore/Shared/Lib';
var __filename = 'NGCore/Shared/Lib/libutf8.js';

/*
 * A JavaScript implementation of UTF-8 encoder and decoder.
 */

var UTF8 = (function() {

  /**
   * Encode a string in UTF-8 format.
   * @name encode
   * @function
   * @memberOf Core.UTF8
   * @example
   * var str = "Test string";
   * var utf8 = Core.UTF8.encode(str);
   * @param {String} str The string to encode.
   * @returns {String} A UTF-8 encoded string.
   * @since 1.7
   */
  var _toUTF8 = function(str) {
    var utf8 = "";

    for (var n = 0; n < str.length; n++) {
      var c = str.charCodeAt(n);

      if(c < 128) {
        utf8 += String.fromCharCode(c);
      } else if((c > 127) && (c < 2048)) {
        utf8 += String.fromCharCode((c >> 6) | 192);
        utf8 += String.fromCharCode((c & 63) | 128);
      } else {
        utf8 += String.fromCharCode((c >> 12) | 224);
        utf8 += String.fromCharCode(((c >> 6) & 63) | 128);
        utf8 += String.fromCharCode((c & 63) | 128);
      }
    }

    return utf8;
  };

  /**
   * Decode a string in UTF-8 format.
   * @name decode
   * @function
   * @memberOf Core.UTF8
   * @example
   * var str = Core.UTF8.decode(utf8);
   * @param {String} utf8 A UTF-8 encoded string.
   * @returns {String} Decodeded string.
   * @since 1.7
   */
  var _fromUTF8 = function(utf8) {
    var str = "";
    var i = 0;
    var c = 0, c1 = 0, c2 = 0;

    while ( i < utf8.length ) {
      c = utf8.charCodeAt(i);

      if(c < 128) {
        str += String.fromCharCode(c);
        i++;
      } else if((c > 191) && (c < 224)) {
        c2 = utf8.charCodeAt(i+1);
        str += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
        i += 2;
      } else {
        c2 = utf8.charCodeAt(i+1);
        var c3 = utf8.charCodeAt(i+2);
        str += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        i += 3;
      }
    }

    return str;
  };

  return { encode: _toUTF8, decode: _fromUTF8 };
})();

exports.UTF8 = UTF8;

// vim: ts=2:sw=2:expandtab
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/UTF8'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/UTF8'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/UTF8'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/UTF8.js';

exports.UTF8 = require('NGCore/Shared/Lib/libutf8').UTF8;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/TypeCheck'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/TypeCheck'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/TypeCheck'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/TypeCheck.js';

// TypeCheck.js

// lowest level validate functions.
var isNumber = function (x) { return typeof x === 'number' && x === x; };  // NOTE: if x !== x it's a NaN
var isInteger = function (x) { return typeof x === 'number' && ((x % 1) === 0); }; 
var isString = function (x) { return typeof x === 'string'; };
var isFunction = function (x) { return typeof x === 'function'; };
var isBoolean = function (x) { return typeof x === 'boolean'; };
var isUndefined = function (x) { return typeof x === 'undefined'; };
var isAny = function (x) { return true; };
var isInstanceMaker = function (ctor) { return function (x) { return x instanceof ctor; }; };

// maps string to appropriate validate function
var typeToValidateFunctionMap = {
	'number': isNumber,
	'integer': isInteger,
	'string': isString,
	'function': isFunction,
	'boolean': isBoolean,
	'undefined': isUndefined,
	'any': isAny
};

// Pretty printing helper.
// Useful because it differentiates between the following:
//   * The number 10 = 10
//   * The string 10 = '10'
//   * An array with a single element which is the number 10 = [10]
//   * An array with a single element which is the string 10 = ['10']
// Also, it doesn't invoke toString on functions.
var pp = function(x) {
	if (x instanceof Array) {
		return '[' + x + ']';  // slap braces around x
	} else if (typeof x === 'string') {
		return "'" + x + "'";  // slap quotes around x
	} else if (typeof x === 'function') {
		return 'function';
	} else {
		return x;
	}
};

// Internal class used to hold Arg, OptionalArg, ArgArray, OptionalArgArray, NonEmptyArgArray, OptionalNonEmptyArgArray.
var TypeDef = function (type, check, verify) {
	this.type = type;
	this.check = check;
	this.verify = verify;
};
TypeDef.prototype.toString = function () {
	return '#TypeDef(' + pp(this.type) + ')';
};

// looks up validate function and returns it.
var lookupValidateFunc = function (typeOrFunc) {
	// validate just checks to see if a value is of a specific type.
	var validate;
	if (typeof typeOrFunc === 'string') {
		validate = typeToValidateFunctionMap[typeOrFunc];
		if (validate === undefined) {
			throw new TypeError("Unknown type '" + typeOrFunc + "'");
		}
	} else if (typeof typeOrFunc === 'function') {
		validate = isInstanceMaker(typeOrFunc);
	}
	return validate;
};

// User facing functions to construct new Args
var Arg = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidMaker(validate, false), verifyFunc);
};
var OptionalArg = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidMaker(validate, true), verifyFunc);
};
var ArgArray = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidArrayMaker(validate, 0, false), verifyFunc);
};
var OptionalArgArray = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidArrayMaker(validate, 0, true), verifyFunc);
};
var NonEmptyArgArray = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidArrayMaker(validate, 1, false), verifyFunc);
};
var OptionalNonEmptyArgArray = function (typeOrFunc, verifyFunc) {
	var validate = lookupValidateFunc(typeOrFunc);
	return new TypeDef(typeOrFunc, ifNotValidArrayMaker(validate, 1, true), verifyFunc);
};

// A union of primitive types, constructed by Or function.
var TypeUnion = function (typeDefs) {
	this.typeDefs = typeDefs;
	var last = typeDefs[typeDefs.length - 1];
	if (typeof last === 'function') {
		this.typeDefs = typeDefs.slice(0, -1);
		this.verify = last;
	} else {
		this.typeDefs = typeDefs;
	}
};
TypeUnion.prototype.toString = function () {
	return '#TypeUnion(' + this.typeDefs.join(', ') + ')';
};

// user facing function for creating type unions.
var Or = function () {
	var typeDefs = Array.prototype.slice.call(arguments);
	return new TypeUnion(typeDefs);
};

// An array of primitive types, constructed by the Array function.
var TypeArray = function (typeDefs) {
	var last = typeDefs[typeDefs.length - 1];
	if (typeof last === 'function') {
		this.typeDefs = typeDefs.slice(0, -1);
		this.verify = last;
	} else {
		this.typeDefs = typeDefs;
	}
};
TypeArray.prototype.toString = function () {
	return '#TypeArray(' + this.typeDefs.join(', ') + ')';
};

// User facing function for creating type arrays.  NOTE: Not named Array here so it won't shadow the built-in JavaScript Array class constructor.
// NOTE: if the last argument is a function, it will be used as a user supplied verification function.
var ArrayFunc = function () {
	var typeDefs = Array.prototype.slice.call(arguments);
	return new TypeArray(typeDefs);
};

// Object of primitive types, constructed by the Object function.
var TypeObject = function (obj, verify) {
	this.obj = obj;
	this.verify = verify;
};
TypeObject.prototype.toString = function () {
	return '#TypeObject()';
};

// User facing function for creating object args with optional verify functions.
var ObjectFunc = function (obj, verify) {
	if (typeof obj !== 'object') {
		throw TypeError('Object expected object parameter');
	}
	return new TypeObject(obj, verify);
};

// Helper higher-order function which wraps the isTypeFunc with error reporting.
var ifNotValidMaker = function (isTypeFunc, isOptional) {
	return function (schema, x, name) {
		if (!(isOptional && isUndefined(x)) && !isTypeFunc(x)) {
			if (typeof schema.type === 'function')
				return name + ' ' + pp(x) + ' is not a valid class instance';
			else
				return name + ' ' + pp(x) + ' is not a valid ' + schema.type;
		}
	};
};

// Helper higher-order function which wraps the isTypeFunc for arrays with iteration over the array and error reporting.
var ifNotValidArrayMaker = function (isTypeFunc, minLen, isOptional) {
	return function (schema, x, name) {
		var i;
		if (isOptional && isUndefined(x))
			return;
		if (!(x instanceof Array)) {
			return name + ' ' + pp(x) + ' is not an array';
		}
		if (x.length < minLen) {
			return name + ' ' + pp(x) + ' must have at least ' + minLen + ' element' + ((minLen !== 1) ? 's' : '');
		}
		for (i = 0; i < x.length; i++) {
			if (!isTypeFunc(x[i])) {
				return name + '[' + i + '] ' + x[i] + ' is not a valid ' + schema.type;
			}
		}
	};
};

// Assumes schema is an array of schemas.
// Iterates over x, and returns an error if any elements do not match the associated sub-schema.
// NOTE: if the last element of the schema is a function, that function is assumed to be a user supplied validation function, and is invoked on x.
var checkArray = function (schema, x, name) {
	//console.log('checkArray: x = ' + pp(x));
	if (!(x instanceof Array)) {
		return name + ' ' + x + ' is not an array';
	}

	// Check to see if the last element of the schema is a function, if so use it as the verify function.
	var last = schema[schema.length - 1];
	var len = schema.length;
	var verify;
	if (typeof last === 'function') {
		var length = schema.length - 1;
		verify = last;
	}

	// Iterate over each element of the array, stop at first error.
	var error;
	for (var i = 0; i < len; i++) {
		error = check(schema[i], x[i], name + '[' + i + ']');
		if (error)
			return error;
	}

	// Invoke user-supplied verify function.
	if (verify) {
		error = verify(x);
		if (error) {
			return name + ' ' + error;
		}
	}
};

// Assumes schema is an object with string keys, and schema values.
// Iterates over object, and returns error if any elements do not match the associated sub-schema.
// NOTE: there is no way a user can pass in a user-supplied verification function for this.
var checkObject = function (schema, x, name) {
	//console.log('checkObj: x = ' + pp(x));

	if (typeof x !== 'object') {
		return name + ' ' + x + ' is not an object';
	}

	var error;
	for (var key in schema) {
		error = check(schema[key], x[key], name + '.' + key);
		if (error)
			return error;
	}
};

// Assume schema is a TypeDef instance.
// Invoke the TypeDef.check function, followed by the TypeDef.verify function if present.
var checkTypeDef = function (schema, x, name) {
	//console.log('checkTypeDef: x = ' + pp(x) + ', schema = ' + schema);
	var error;
	var func = schema.check;
	if (!func) {
		throw new TypeError(schema.type + ' is not a valid TypeDef type!');
	}

	error = func(schema, x, name);
	if (error) {
		return error;
	}

	if (schema.verify) {
		error = schema.verify(x);
		if (error) {
			return name + ' ' + error;
		}
	}
};

// Assume schema is a TypeUnion instance.
// Try each sub-schema of the union, in order.  Only return an error if they ALL fail.
var checkTypeUnion = function (schema, x, name) {
	//console.log('checkTypeUnion: x = ' + pp(x) + ', schema = ' + schema);
	var i, error, errors = [];
	for (i = 0; i < schema.typeDefs.length; i++) {
		error = check(schema.typeDefs[i], x, name);
		if (!error)
			return;
		errors.push(error);
	}
	if (errors) {
		return errors.join(', ');
	}

	// Invoke user-supplied verify function.
	if (schema.verify) {
		error = schema.verify(x);
		if (error) {
			return name + ' ' + error;
		}
	}
};

// Assume schema is a TypeArray instance.
// check each element against it's sub-schema, return first error.
var checkTypeArray = function (schema, x, name) {
	//console.log('checkTypeArray: x = ' + pp(x) + ', schema = ' + schema);
	var i, error;
	for (i = 0; i < schema.typeDefs.length; i++) {
		error = check(schema.typeDefs[i], x[i], name);
		if (error)
			return error;
	}

	// Invoke user-supplied verify function.
	if (schema.verify) {
		error = schema.verify(x);
		if (error) {
			return name + ' ' + error;
		}
	}
};

// Assume schema is a TypeObject instance.
// check each object value against it's sub-schema, return first error.
var checkTypeObject = function (schema, x, name) {
	//console.log('checkTypeObject: x = ' + pp(x));

	if (typeof x !== 'object') {
		return name + ' ' + x + ' is not an object';
	}

	var error;
	for (var key in schema.obj) {
		error = check(schema.obj[key], x[key], name + '.' + key);
		if (error)
			return error;
	}

	// Invoke user-supplied verify function.
	if (schema.verify) {
		error = schema.verify(x);
		if (error) {
			return name + ' ' + error;
		}
	}
};

// Dispatch to specialized check function based on type of schema.
var check = function (schema, x, name) {
	//console.log('check: x = ' + pp(x));
	var func, error, i;
	if (schema instanceof Array) {
		return checkArray(schema, x, name);
	} else if (schema instanceof TypeDef) {
		return checkTypeDef(schema, x, name);
	} else if (schema instanceof TypeUnion) {
		return checkTypeUnion(schema, x, name);
	} else if (schema instanceof TypeArray) {
		return checkTypeArray(schema, x, name);
	} else if (schema instanceof TypeObject) {
		return checkTypeObject(schema, x, name);
	} else if (typeof schema === 'object') {
		return checkObject(schema, x, name);
	}
};

/** Function which checks arguments against the given type schema.
 *  The simplest case of type schema are basic types, constructed with the Arg() function.
 *  @example
 *    function add(a, b) {
 *      validate(arguments, [Arg('number'), Arg('number')]);
 *    }
 *
 *  There are several basic type strings that can be passed as parameters to the Arg function:
 *    * 'number'
 *    * 'integer'
 *    * 'string'
 *    * 'function'
 *    * 'undefined'
 *    * 'boolean'
 *    * constructor function - used to see if object is an instanceof the given constructor function.
 *
 *  Additionally there is the ability to specify optional and array argument types.
 *    * OptionalArg
 *    * ArgArray
 *    * NonEmptyArgArray
 *    * OptionalArgArray
 *    * OptionalNonEmptyArgArray
 *
 *  Compound types can be created by using arrays or maps of Arg's:
 *    * [Arg('string'), OptionalArg('number')] - an array with a string followed by an optional number
 *    * {name: Arg('string'), size: OptionalArg('number')} - a map where the name key must be a string, but the size key is an optional number.
 *
 *  Custom validation functions can be passed as a second argument to the Arg function.
 *  They are expected to return strings on error, and undefined otherwise.
 *
 *  @example
 *    function reciprocal(numerator) {
 *      validate(arguments, [Arg('number', function (x) {
 *        if (x === 0) {
 *           return 'divide by zero';
 *        }
 *      })]);
 *
 *  @throws TypeError if types within args do not match the schema.
 *  @param {array|Arguments} args parameters to check against the type schema.
 *  @param schema - descriptive structure of the types, names and additional verification functions for the args.
 */
var validateArgs = function () {
	var args = Array.prototype.slice.call(arguments);
	var first = args.shift();
	first = Array.prototype.slice.call(first);
	var rest = args;
	var schema = Or.apply(undefined, rest);
	var ex;
	var error = check(schema, first, 'arguments');
	if (error) {
		// output to log, because sometimes exeptions go down a hole.
		console.log('validateArgs: ' + error);
		ex = new TypeError(error);
		ex.stacklevel = 2;  // this will report exception occuring at the call made before the call to validateArgs
		throw ex;
	}
};

var validate = function (args, schema) {
	var error = check(schema, args, 'arguments');
	var ex;
	if (error) {
		ex = new TypeError(error);
		ex.stacklevel = 2;  // this will report exception occuring at the call made before the call to validateArgs
		throw ex;
	}
};

exports.TypeCheck = {
	validate: validate,
	validateArgs: validateArgs,
	Arg: Arg,
	OptionalArg: OptionalArg,
	ArgArray: ArgArray,
	OptionalArgArray: OptionalArgArray,
	NonEmptyArgArray: NonEmptyArgArray,
	OptionalNonEmptyArgArray: OptionalNonEmptyArgArray,
	Or: Or,
	Array: ArrayFunc,
	Object: ObjectFunc
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core'] || {}; $MODULE_REGISTRY['NGCore/Client/Core'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Core.js';

/**
 * <p>Classes and objects contained by the Core module.</p>
 * @name Core
 * @namespace Create an app's framework, and get information about a device's capabilities.
 * @description <p>The Core module is a collection of classes that provide apps with access to:</p>
 * <ul>
 * <li>Core components of a device.</li>
 * <li>APIs that define a class-based structure for development.</li>
 * <li>Objects that support app updates.</li>
 * </ul>
 * <p>Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link Core.Analytics}</code>: Construct objects that keep track of game-specific items that require analysis and counting.</li>
 * <li><code>{@link Core.Base64}</code>: Provides methods to encode and decode Base64 data.</li>
 * <li><code>{@link Core.Buffer}</code>: Provides buffers for binary data that is used by network operations.</li>
 * <li><code>{@link Core.Capabilities}</code>: A singleton object that contains data about device hardware components.</li>
 * <li><code>{@link Core.Class}</code>: Provides an object-oriented programming (OOP) framework for ngCore apps.</li>
 * <li><code>{@link Core.Color}</code>: Control the RGB color components of a device.</li>
 * <li><code>{@link Core.DiagnosticEmitter}</code>: A base class object for constructing objects that emit diagnostic notifications.</li>
 * <li><code>{@link Core.Diagnostics}</code>: A singleton object that emits diagnostics pertaining to frame tick and timing information generally applicable to frame processing.</li>
 * <li><code>{@link Core.ErrorEmitter}</code>: A singleton object that emits errors resulting from unexpected situations, such as exceptions in the native OS or uncaught exceptions in JavaScript.</li>
 * <li><code>{@link Core.LocalGameList}</code>: Construct objects that manage a user's game list.</li>
 * <li><code>{@link Core.Localization}</code>: Provides apps with access to localized strings.</li>
 * <li><code>{@link Core.MessageEmitter}</code>: A base class object for constructing objects that emit app notifications.</li>
 * <li><code>{@link Core.MessageListener}</code>: A base class object for constructing objects that handle app notifications.</li>
 * <li><code>{@link Core.Point}</code>: Control the point values for <i>x</i> and <i>y</i> coordinates.</li>
 * <li><code>{@link Core.Rect}</code>: Construct rectangle objects.</li>
 * <li><code>{@link Core.Size}</code>: Control the values for <i>height</i> and <i>width</i> components.</li>
 * <li><code>{@link Core.Time}</code>: A singleton that contains data about device timing values.</li>
 * <li><code>{@link Core.UpdateEmitter}</code>: Control the app update time rate.</li>
 * <li><code>{@link Core.Vector}</code>: Control the vector values for <i>x</i> and <i>y</i> coordinates.</li>
 * </ul>
 * @this CoreLoader
 */
function CoreLoader(map) {
	this.add = function(key, toEval) {
		this.__defineGetter__(key, function() {
			delete this[key];
			return this[key] = toEval();
		});
	};
	for (var k in map) {
		if (map.hasOwnProperty(k)) this.add(k, map[k]);
	}
}

exports.Core = new CoreLoader({
	'Analytics': function() { return require('NGCore/Client/Core/Analytics').Analytics; },
	'Base64': function() { return require('NGCore/Client/Core/Base64').Base64; },
	'Capabilities': function() { return require('NGCore/Client/Core/Capabilities').Capabilities; },
	'Class': function() { return require('NGCore/Client/Core/Class').Class; },
	'Color': function() { return require('NGCore/Client/Core/Color').Color; },
	'Vector': function() { return require('NGCore/Client/Core/Vector').Vector; },
	'Point': function() { return require('NGCore/Client/Core/Point').Point; },
	'Size': function() { return require('NGCore/Client/Core/Size').Size; },
	'Rect': function() { return require('NGCore/Client/Core/Rect').Rect; },
	'MessageEmitter': function() { return require('NGCore/Client/Core/MessageEmitter').MessageEmitter; },
	'MessageListener': function() { return require('NGCore/Client/Core/MessageListener').MessageListener; },
	'ObjectRegistry': function() { return require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry; },
	'Time': function() { return require('NGCore/Client/Core/Time').Time; },
	'toMD5': function() { return require('NGCore/Client/Core/toMD5').toMD5; },
	'SHA1': function() { return require('NGCore/Client/Core/SHA1').SHA1; },
	'UpdateEmitter': function() { return require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter; },
	'Proc': function() { return require('NGCore/Client/Core/Proc').Proc; },
	'Logger': function() { return require('NGCore/Client/Core/Logger').Logger; },
	'LocalGameList': function() { return require('NGCore/Client/Core/LocalGameList').LocalGameList; },
	'Localization': function() { return require('NGCore/Client/Core/Localization').Localization; },
	'_LocalGameList': function() { return require('NGCore/Client/Core/_LocalGameList')._LocalGameList; },
	'NativeAppLaunch': function() { return require('NGCore/Client/Core/NativeAppLaunch').NativeAppLaunch; },
	'ErrorEmitter': function() { return require('NGCore/Client/Core/ErrorEmitter').ErrorEmitter; },
	'Diagnostics': function() { return require('NGCore/Client/Core/Diagnostics').Diagnostics; },
	'DiagnosticEmitter': function() { return require('NGCore/Client/Core/DiagnosticEmitter').DiagnosticEmitter; },
	'DiagnosticRegistry': function() { return require('NGCore/Client/Core/DiagnosticEmitter').DiagnosticRegistry; },
	'Buffer': function() { return require('NGCore/Client/Core/Buffer').Buffer; },
	'UTF8': function() { return require('NGCore/Client/Core/UTF8').UTF8; },
	'TypeCheck': function() { return require('NGCore/Client/Core/TypeCheck').TypeCheck; }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// Network diagnostic emitter; collects info from Network subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

//
// Create and export a DiagnosticEmitter for Network.
//

exports.Diagnostics = Core.DiagnosticEmitter.singleton(
{
	classname: 'Network_Diagnostics',

	/**
	 * @class The <code>Network.Diagnostics</code> class provides detailed diagnostic information
	 * about classes in the <code>Network</code> module. You can use this information to debug your
	 * app's use of the <code>Network</code> module and learn more about the app's performance.
	 * <br /><br />
	 * The emitter emits an object of the form:
	 * <br /><br />
	 * <pre>
	 * {
	 *     name: "Network",         // The emitter's name
	 *     socket_fds: {Number},    // Number of file descriptors used by network sockets
	 *     bytes_in: {Number},      // Total amount of data read, in bytes (excluding headers)
	 *     bytes_out: {Number},     // Total amount of data sent, in bytes (excluding headers)
	 *     bps_in: {Number},        // Current instantaneous download rate, in bits per second
	 *     bps_out: {Number},       // Current instantaneous upload rate, in bits per second
	 *     downloads: {Requests},   // Information about file downloads
	 *     xhr: {Requests}          // Information about Network.XHR requests
	 * }
	 * </pre>
	 * The <code>Requests</code> type is an object of the form:
	 * <br /><br />
	 * <pre>
	 * {
	 *     complete: {Number},  // Number of completed requests
	 *     current: {Number},   // Number of requests in progress
	 *     failed: {Number}     // Number of failed downloads
	 * }
	 * </pre>
	 * @name Network.Diagnostics
	 * @constructs
	 * @augments Core.DiagnosticEmitter
	 * @singleton
	 * @since 1.8
	 */
	initialize: function($super)
	{
	$super('Network');
	}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network'] || {}; $MODULE_REGISTRY['NGCore/Client/Network'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Network.js';

////////////////////////////////////////////////////////////////////////////////
// Class Network
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
/**
 * @name Network
 * @namespace Connect to remote servers.
 * @description The Network module is a collection of classes that support manipulation of network flow.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:
 *
 * + `{@link Network.DNS}`: Obtain the IP address associated with a domain name.
 * + `{@link Network.Diagnostics}`: Provide diagnostic information about the app's use of the
 * `Network` module.
 * + `{@link Network.DownloadFile}`: Construct objects that conduct a file download.
 * + `{@link Network.DownloadManifest}`: Construct objects that keep manifests up-to-date.
 * + `{@link Network.Socket}`: Connect to a server using TCP or UDP sockets.
 * + `{@link Network.XHR}`: Construct XmlHttpRequest objects.
 */
function NetworkLoader(map) {
	this.add = function(key, toEval) {
		this.__defineGetter__(key, function() {
			delete this[key];
			return this[key] = toEval();
		});
	};
	for (var k in map) {
		if (map.hasOwnProperty(k)) this.add(k, map[k]);
	}
}

exports.Network = new NetworkLoader({
	'XHR': function() { return require("NGCore/Client/Network/XHR").XHR; },
	'DownloadFile': function() { return require("NGCore/Client/Network/DownloadFile").DownloadFile; },
	'DownloadManifest': function() { return require("NGCore/Client/Network/DownloadManifest").DownloadManifest; },
	'Util': function() { return require("NGCore/Client/Network/Util").Util; },
	'_int_Util': function() { return require("NGCore/Client/Network/_int_Util")._int_Util; },
	'Socket': function() { return require("NGCore/Client/Network/Socket").Socket; },
	'DNS': function() { return require("NGCore/Client/Network/DNS").DNS; },
	'Diagnostics': function() { return require("NGCore/Client/Network/Diagnostics").Diagnostics; }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/NgPipesRemote'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/NgPipesRemote'] || {}; $MODULE_REGISTRY['NGCore/Shared/NgPipesRemote'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/NgPipesRemote.js';

var Network = require('NGCore/Client/Network').Network;

var ngPipesRequestNum = 0;

var NgPipesRemote = {
  listeners: [],
  debug: false,

  possibleStates: {
    unknown: {ngPipesRemote:"unknown"},
    finished: {ngPipesRemote:"finished"},
    error: {ngPipesRemote:"error"}
  }
};

NgPipesRemote.addListener = function(listner) {
  this.listeners.push(listner);
  return true;
};

NgPipesRemote.clearQueue = function(queue, callback) {

  if (!queue) {
    return false;
  }

  if (!this.getUrl()) {
    if (callback) {
      callback(NgPipesRemote.possibleStates.finished, []);
    }
    return false;
  }
	var copy_array = queue.slice(0, queue.length);

	var _j, _len2, data;
  while (copy_array && copy_array.length > 0) {
    var to_send = copy_array.slice(0, 10);
    copy_array = copy_array.slice(10);
    data = "";

    for (_j = 0, _len2 = to_send.length; _j < _len2; _j++) {
      data += JSON.stringify(to_send[_j]);
      if (_j+1 < _len2) {
         data += "\r\n";
      } //if len
    } //for

    if (data) {
      NgPipesRemote._makeRequest(data, to_send, callback);
    } //if data
  }//while

};

NgPipesRemote._makeRequest = function(json_data, objs, callback) {
    var request = new Network.XHR(), url = this.getUrl();
    if (this.debug) {
        NgPipesRemote._debugOutput(json_data);
    }

    ngPipesRequestNum++;
    var reqKey = 'pipe'+ngPipesRequestNum;

    var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
    LifecycleEmitter.requestEngineKeepAlive(reqKey);

    request.onreadystatechange = function() {
        var status = null;
        try {
            if (this.readyState === 4) {
                LifecycleEmitter.cancelEngineKeepAlive(reqKey);
                status = NgPipesRemote._handleResponse(request.responseText);
            } else {
                status = NgPipesRemote.possibleStates.unknown;
            }
        } catch (ex) {
            status = NgPipesRemote.possibleStates.error;
            NgLogException(ex);
        }

        if (callback) {
            callback(status, objs);
        }

        NgPipesRemote._notifyListeners(status);
        return true;
    };

    request.open("POST", url, true);

    request.setRequestHeader("X-Ngpipes-Api", "1.0");
    request.setRequestHeader("Content-Type", "application/json+batch");
    request.setRequestHeader("If-None-Match", "0");

    request.send(json_data);

    NgPipesRemote._notifyListeners('started');
    return true;
};

NgPipesRemote.setUrl = function(url) {
    this.url = url;
};
NgPipesRemote.getUrl = function() {
    if (this.url)
        return this.url;
    var Capabilities = require("NGCore/Client/Core/Capabilities").Capabilities;
    var url = null;
    
    if (Capabilities) {
      //Get the url from the configuration.json
      url = (Capabilities.getConfigs() || {} )["analyticsServer"] || null;
      if (url) {
        url = "https://"+url+"/pipes/r.2/bulk_record_stats";
        if (this.debug) {
          NgLogD("Pipes URL => " + url );
        }
      }
    }
    return url;
};


NgPipesRemote._handleResponse = function(respText) {
  var respObj, result;
  result = NgPipesRemote.possibleStates.unknown;
  if (respText && respText.length > 0) {
    try {
    respObj = JSON.parse(respText);
    } catch (e) {
      //Clean up after ourselves.
      respObj = null;
    }
	if (respObj  && (respObj.success !== null && respObj.success !== undefined ) && respObj.success) {
      if (this.debug) {
        NgLogD("[NgPipesRemote] Got Success" );
      }
      result = NgPipesRemote.possibleStates.finished;
    } else {
      result = NgPipesRemote.possibleStates.error;
    }
  } else {
      if (this.debug) {
        NgLogD('[NgPipesRemote] ERROR posting');
      }

    result = NgPipesRemote.possibleStates.error;
  }
  return result;
};

NgPipesRemote._debugOutput = function(str) {
  var _i, _len, _result, msg, msgs;
  msgs = str.split("\r\n");
  for (_i = 0, _len = msgs.length; _i < _len; _i++) {
    msg = msgs[_i];
    NgLogD("[NgPipesRemote] Message sent: " + msg);
  }
  return false;
};

NgPipesRemote._notifyListeners = function(state) {
  var _i, _len, _ref, l;
  for (_i = 0, _len = (_ref = this.listeners).length; _i < _len; _i++) {
    l = _ref[_i];
    l(state);
  }
  return true;
};

exports.NgPipesRemote = NgPipesRemote;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] = exports; 
var __dirname = 'NGCore/Client/Social/US/_Internal';
var __filename = 'NGCore/Client/Social/US/_Internal/_RequireLoader.js';

/** RequireLoader.js
	Include files lazily, using throwaway property getters.
*/

function _generateGetter(name, requireFn) {
	// Need this for scoping
	return function() {
		// Remove the getter on first access and replace it with the evaluated require_.
		delete this[name];
		return this[name] = requireFn(require); // Passes in require_ for some Interface Magic!
	};
}

exports.RequireLoader = function(map) {
	if (map instanceof Object) {
		for (var req in map) {
			this.__defineGetter__(req, _generateGetter(req, map[req]));
		}
	}
	return this;
};

exports.RequireLoader.prototype = {
	load: function(name) {
		// A little syntactic sugar if things need to be loaded.
		// require_s.load("Thing") explains what is happening pretty well.
		this[name];
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] = exports; 
var __dirname = 'NGCore/Client/Social/_Internal';
var __filename = 'NGCore/Client/Social/_Internal/GSGlobals.js';

/**
 * Annoyingly necessary file to break circular dependencies.
 */
var theRouter = null;
exports.setRouterInstance = function(router){
	theRouter = router;
};
exports.getRouterInstance = function(){
	return theRouter;
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Appdata.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class 
 * @name Social.Common.Appdata
 * @description
 * Mobage provides a common API for application data, which you can use for both Japan and the US. 
 * <code>Appdata</code> is consistent with the Open Social <code>osapi.appdata</code> interface 
 * and enables the application to store name/value pairs for arbitrary application data.
 * To add or update application data, call <code>updateEntries()</code>. To retrieve entries, call
 * <code>getEntries()</code>. To delete entries, call <code>deleteEntries()</code>.
 * <br /><br />
 * To use the <code>Appdata</code> API, you must indicate on the Mobage Developer Portal that your
 * application uses this API. To do this, follow these steps:
 * <ol>
 * <li>Log into the Developer Portal at
 * <a href="https://developer-sandbox.mobage.com/en/portal/dashboard">https://developer-sandbox.mobage.com/en/portal/dashboard</a>.</li>
 * <li>Click the Apps tab at the top of the page, then click the name of your application.</li>
 * <li>Scroll to the bottom of the page and click Edit Product Details, then scroll
 * to the bottom of the page and ensure that the "Use userdata api" box is selected.</li>
 * <li>Click Save to save your changes.</li>
 * </ol>
 * <br /><br />
 * <strong>Note</strong>: You can also use ngCore's <code>{@link Storage.KeyValue}</code> and
 * <code>{@link Storage.FileSystem}</code> classes to store application data on the user's device.
 * In addition, you can use the <code>{@link Social.US.AppData}</code> class to store application
 * data; however, if you use this class, you must rewrite portions of your application before
 * releasing it in Japan.
 * @see Social.US.AppData
 * @see Storage.KeyValue
 * @see Storage.FileSystem
 */
exports.Appdata = {
/** @lends Social.Common.Appdata.prototype */
		
	/**
	 * Retrieves a hash of one or more key/value pairs.
	 * If the <code>keys</code> parameter is <code>null</code>, <code>undefined</code> or an empty array, <code>getEntries()</code> 
	 * returns all key/value pairs to the callback function.
	 *
	 * @name Social.Common.Appdata.getEntries
	 * @function
	 * @public
	 * 
	 * @param {Array} keys Set as an array of key names. For example, <code>['key1', 'key2']</code>.
	 * @cb {Function} callback The function to call after retrieving the key-value pairs.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} keys The key/value pairs that were retrieved. The object's properties 
	 *		represent keys, and the value of each property represents the value of the 
	 *		corresponding key.
	 * @cb-returns {void}
	 * @see Social.Common.Appdata.updateEntries
	 * @example 
	 * Appdata.getEntries(['key1', 'key2'], callback );
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	getEntries: function(keys, callback) {
		var cmd = {apiURL:"Common.Appdata.getEntries", keys:keys, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	},
	
	/**
	 * Inserts or updates the submitted key/value pairs. 
	 * <b>Note:</b> Limited to 30 key/value pairs per user, per game. 
	 * Maximum key name limited to 32 bytes. Maximum value limited to 1,024 bytes.
	 * To use key/value pairs without the foregoing constraints, use ngCore's
	 * <code>{@link Storage.KeyValue}</code> class.
	 *
	 * @name Social.Common.Appdata.updateEntries
	 * @function
	 * @public
	 * 
	 * @param {Object} entries The key/value pairs to insert or update. The object's properties 
	 *		represent keys, and the value of each property represents the value of the 
	 *		corresponding key.
	 * @cb {Function} callback The function to call after inserting or updating the key/value pairs.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} keys The key/value pairs that were inserted or updated. The object's 
	 *		properties represent keys, and the value of each property represents the value of the 
	 *		corresponding key.
	 * @cb-returns {void}
	 * @see Social.Common.Appdata.getEntries
	 * @example
	 * Appdata.updateEntries(
	 *              {   'favoriteMovie':'Pulp Fiction',    
	 *                  'petName':'Rover' }, 
	 *              callback );
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	updateEntries: function(entries, callback) {
		if(entries) {
			var cmd = {apiURL:"Common.Appdata.updateEntries", entries:entries, callbackFunc:callback};
			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
		} else {
			if(typeof callback === 'function') {
				callback({ 
						errorCode: 400,
						description: "Entries to update are a required parameter"
					}, null);
			}
		}
	},
	
	
	/**
	 * Deletes one or more key/value pairs.
	 *
	 * @name Social.Common.Appdata.deleteEntries
	 * @function
	 * @public
	 * 
	 * @param {Array} keys An array of key names to delete. For example, <code>['petName']</code>.
	 * @cb {Function} callback The function to call after deleting the key/value pairs.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} keys The key/value pairs that were deleted. The object's properties 
	 *		represent keys, and the value of each property represents the value of the corresponding
	 *		key.
	 * @cb-returns {void}
	 * @example
	 * Appdata.deleteEntries(['petName'], callback );
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	deleteEntries: function(keys, callback) {
		if(keys && keys.length > 0) {
			var cmd = {apiURL:"Common.Appdata.deleteEntries", keys:keys, callbackFunc:callback};
			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
		} else {
			if(typeof callback === 'function') {
				callback({ 
						errorCode: 400,
						description: "Keys to delete are a required parameter"
					}, null);
			}
		}
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Auth'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Auth'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Auth'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Auth.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class
 * @name Social.Common.Auth
 * @description
 * Retrieves a verification code.
 * Games call <code>Auth.authorizeToken()</code> if the game server is using the Mobage REST API.
 * For more information, refer to the Mobage RESTful API documentation on the
 * <a href="https://developer.mobage.com/">Developer Portal</a>.
 */
exports.Auth = {
		
		
	/**
	 * Authorizes a temporary credential and returns a verification code.
	 *
	 * 
	 * @name Social.Common.Auth.authorizeToken
	 * @function
	 * @public
	 *
	 * @param {String} token The temporary credential identifier. 
	 * @cb {Function} callback The function to call after authorizing the temporary credential.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} verifier The verification code.
	 * @cb-returns {void}
	 * @example
	 * var token = "abcdefghi";
     * ...
	 * Social.Common.Auth.authorizeToken (token, callback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	authorizeToken: function(token, callback) {
		var cmd = {apiURL:"Common.Auth.authorizeToken", token:token, callbackFunc: callback };
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
		//callback(error, verifier)
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Blacklist.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class 
 * @name Social.Common.Blacklist
 * @description
 * Provides an interface for checking the user's blacklist.
 */
exports.Blacklist = {

	/**
	 * Checks whether the specified user's blacklist contains a targeted user ID.
	 * If the target user ID parameter is <code>null</code>, this call retrieves the entire blacklist. The callback function also receives the total number of 
	 * target user IDs, the starting index, and the number of target IDs returned for paging the results.
	 *
	 * @name Social.Common.Blacklist.checkBlacklist
	 * @function
	 * @public
	 *
	 * @param {String} userId The user ID for the user who owns the blacklist. 
	 * @param {String} targetUserId The target user ID to check in the blacklist. <br/>If <code>null</code>, it checks the entire blacklist.
	 * @param {Object} opt The start index and count for pagination. <br/>E.g., <code>{'start': 1, 'count': 100}</code> 
     * Requires start index and count. The minimum start index is 1. 
     * If <code>null</code>, undefined or an empty array, the start index is 1 and the count is 50.
	 * @cb {Function} callback The function to call after checking the blacklist for the specified
	 *		user.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Array} listedUsers The users that appear on the blacklist.
	 * @cb-param {Object} result Information about the results that were returned.
	 * @cb-param {Number} result.total The total number of users on the blacklist.
	 * @cb-param {Number} result.start The starting index for this group of users within the user's 
	 *		entire blacklist.
	 * @cb-param {Number} result.count The number of users that were returned.
	 * @cb-returns {void}
  	 * @returns {void}
  	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */			
	checkBlacklist: function(userId, targetUserId, opt, callback) {
		var cmd = {apiURL:"Common.Blacklist.checkBlacklist", userId:userId, targetUserId:targetUserId, opt:opt, callbackFunc: function(error, args) {
			callback(error, args.users, args.result);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Cache'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Cache'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Cache'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/Cache.js';

var Class = require("NGCore/Client/Core/Class").Class;
var SocialR = require("NGCore/Client/Social");

/**
 * <code>Cache</code> provides caching for a user's objects residing in the local interpreter.
 * @class 
 * @name Social.US.Cache
 * @private
 */
var Cache = exports.Cache = Class.subclass({


	classname: "Cache",
	inMemoryObjects: {},
	caches: {},
	
	/**
	 * Initializes a cache object upon instantiation. 
	 * @name Social.US.Cache.initialize
	 * @constructs
	 * @private
	 */			
	initialize: function(){
	},

	
	/**
	* Takes a classname and a unique record ID and returns the object or <code>null</code> if it doesn't find the object.
	*
	* @name Social.US.Cache.getObjectWithRecordID
	* @function
	* @private
	*
	* @param {String} classname The name of the class.
	* @param {Number} recordID The object ID.
	*
	* @return Returns the object corresponding to the <code>recordID</code> parameter or <code>null</code> if it doesn't find the object.
	*/
	getObjectWithRecordID: function(classname, recordID){
		var category = this.inMemoryObjects[classname];
		if(category){
			return category[recordID] || null;
		}else{
			return null;
		}
	},
	
	/**
	* Takes an object and adds it to the cache.
	* <code>addObject()</code> takes an object, ensures that it is not already in the cache, and adds it to the cache.
	*
	* @name Social.US.Cache.addObject
	* @function
	* @private
	*	
	* @param {Object} obj The object to add to the cache.
	* @return Returns the record ID of the object added to the cache.
	*/	
	addObject: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		if(!category){
			category = {};
			this.inMemoryObjects[classname] = category;
		}

		var object = category[obj.recordID];
		if(object){
			return object;
		}else{
			category[obj.recordID] = obj;
			return obj;
		}
	},
	
	/**
	* Takes an object reference and removes the object from the cache.
	* 
	* @name Social.US.Cache.removeObject
	* @function
	* @private
	*	
	* @param {Object} obj The object to remove from the cache.
	*/	
	removeObject: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		if(category){
			delete category[obj.recordID]; // ZOMG THE DELETE OPERATOR
		}
	},
	
	/**
	* Takes an object reference and returns whether the object is in the cache.
	* 
	* @name Social.US.Cache.isObjectCached
	* @function
	* @private
	*	
	* @param {Object} obj The object to select in the cache.
	*
	* @return Returns <code>true</true> if the object is in the cache; otherwise, it returns <code>false</code>.
	*/		
	isObjectCached: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		return (category && (category[obj.recordID] == obj));
	},
	
	
	saveCache: function(){
		
	},
	
	
	loadCache: function(){
		
	},
	
	/**
	* Takes a JSON array of objects and loads them into the cache.
	*
	* @name Social.US.Cache.loadCacheFromJSONArray
	* @function
	* @private
	*
	* @param {JSON} jsonArray The JSON object array to load into the cache.
	* @param {function} cb <code>loadCacheFromJSONArray()</code> takes an optional callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
	*/			
	loadCacheFromJSONArray: function(jsonArray, cb){
		var objects = [];
        
		for(var idx = 0; idx < jsonArray.length; idx++){
			var hash = jsonArray[idx];
			if(hash && hash.hasOwnProperty("classname") && hash.hasOwnProperty("recordID")){
				var theClassname = hash.classname;
				var theClass = SocialR.Social.US[theClassname];
				var theRecordID = hash.recordID;
				if(theClass && theRecordID){
					var theInstance = this.getObjectWithRecordID(theClassname, theRecordID);
					if(!theInstance){
						theInstance = new theClass(theRecordID, {});
					}
        
					theInstance._deserializeFromHash(hash);
					this.addObject(theInstance);
				}
			}
		}
        
		cb(null, this);
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Data';
var __filename = 'NGCore/Client/Social/US/Data/Dispatcher.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

var Core = require("NGCore/Client/Core").Core;
var CacheR = require("NGCore/Client/Social/US/Models/Cache");

var SocialR = require('NGCore/Client/Social');
var SessionR = require('NGCore/Client/Social/US/Data/Session');

/**
 * <code>Dispatcher</code> objects know about <code>DataModel</code> objects and can "push" <code>DataModel</code> objects between interpreters.
 * <code>Dispatcher</code> objects can find classes and specific instances of objects, and may invoke their functions.
 * <code>Dispatcher</code> objects also provide a series of convenience functions to facilitate communication between interpreters.
 * @class 
 * @name Social.US.Dispatcher
 * @private
 */
var Dispatcher = exports.Dispatcher = {
				
	classname: "Dispatcher",
	callbackUIDCounter: 0,
	callbacks: {
		"-2": {},
		"-1": {}
	},
	
	/**
	 * Returns the data cache for the current session.
	 * @name Social.US.Dispatcher.cache
	 * @function
	 * @private
	 *
	 * @return {Social.US.Cache} The data cache for the current session.
	 * @see Social.US.Cache
	 */		
	cache: function(){		
		try {		
			return SessionR.Session.getCurrentSession().dataCache();
		}
		catch (err) {
			NgLogD("Mobage/Dispatcher/cache-Warning: cannot get cache. NOTE: This may be expected behavior if early on in initialization. Err=" 
				+ err);

			return null;
		}
	},
	
	
	/**
	 * Gets the current session and loads session data.
	 * If there is no current session, <code>receiveSession()</code> creates a new session.
	 *	 
	 * @name Social.US.Dispatcher.receiveSession
	 * @function
	 * @private
	 *
	 * @param {Type} command Takes a command, which may include the platform version, server mode, application name and application version. 
	 */		
	receiveSession: function(command){		
		var session = SessionR.Session.getCurrentSession();
		if(!session){
			session = new SessionR.Session();
			SessionR.Session._currentSession = session;
		}
		
		var userData = command.data.userData;
		if(userData){
			// the User object will be cached implicitly, then loaded in _loadSessionData
			Dispatcher.receiveObject({data: userData});
		}
		
		session._loadSessionData(command.data);
		
		if(SessionR.Session._emitter){
			SessionR.Session._emitter.emit({session: session});
		}
	},
	
	// DataModel communication
	/**
	 * Finds a particular instance of an object in the local interpreter and calls a method on the object.
	 *	 
	 * @name Social.US.Dispatcher.callMethodOnLocalObject
	 * @function
	 * @private
	 *
	 * @param {Command} command Takes a command object that identifies the class name of the object, 
     * its record ID, the method name to call, and any parameters for the method.
	 * The command object takes an optional callback and <code>callMethodOnLocalObject()</code> returns returns the result 
     * and/or any error code and description to the callback function.
	 */		
	callMethodOnLocalObject: function(command){		
		var recordID = command.recordID;
		var classname = command.classname;
		
		var object = Dispatcher.cache().getObjectWithRecordID(classname, recordID);
		if(object){
			var methodName = command.methodName;

			var error = false;
			var args;
			var retVal;
			if(methodName instanceof Array) {
				var methodOwner = object;
				for(var idx = 0; idx < methodName.length; idx++) {
					if(typeof methodOwner[methodName[idx]] == "function") {
						args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments[idx] || []);
						retVal = methodOwner[methodName[idx]].apply(methodOwner, args);
						methodOwner = retVal;						
					}
					else {
						error = true;
						break;
					}
				}
			}
			else {
				if(typeof object[methodName] == "function") {
					args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
					retVal = object[methodName].apply(object, args);
				}
				else {
					error = true;
				}
			}
			
			if(error) {
				NgLogD("ERROR: Invalid methods for calling on local object: " + command.recordID + " " + methodName);
			}
			else if(command.callback){
				var callback = Dispatcher.convertFunctionFromJSON({callbackUID: command.callback});
				if(callback){
					callback(retVal);
				}
			}
		}
	},
	
	
	/**
	 * Finds a particular instance of an object in a remote interpreter and calls a method on the remote object.
	 *	 
	 * @name Social.US.Dispatcher.callMethodOnRemoteObject
 	 * @function
 	 * @private
 	 *
	 * @param {Number} object The object reference (i.e., typically the keyword 'this').
	 * @param {String} method The method name to call.
	 * @param {Array} args An array of parameters for the method, including other <code>DataModel</code> objects or functions.
	 * @param {Function} cb Returns the result and/or any error code and description to the callback function.
	 *
	 * <b>Note:</b> If the target method wants a callback as one/more of its arguments, supply it as an element in the argument array, <b>NOT</b> as the fourth parameter.
	 */			
	callMethodOnRemoteObject: function(object, method, args, cb){		
		if(!object || !method){
			NgLogD("Public.Dispatcher.callMethodOnRemoteObject - bailing");
			if(cb){
				cb();
			}
			return;
		}

		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.callMethodOnLocalObject",
			recordID: object.recordID,
			classname: object._classname(),
			methodName: method,
			arguments: args,
			callback: Dispatcher.convertFunctionToJSON(cb)
		};
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Calls a static method on a class in the local interpreter.
	 *	 
	 * @name Social.US.Dispatcher.callClassMethodOnLocalObject	
	 * @function
	 * @private
	 *
	 * @param {Command} command Takes a command object that identifies the class name of the object, the method name to call, and any parameters for the method.
	 * The command parameter takes an optional callback function and <code>callMethodOnLocalObject()</code> returns returns the result and/or any error code and description to the callback function.
	 */		
	callClassMethodOnLocalObject: function(command){		
		Dispatcher.beginBatching();
		
		var classname = command.classname;
		var methodName = command.methodName;
		if(classname && methodName){
			var theClass = SocialR.Social.US[classname];
			if(!theClass){
				theClass = SocialR.Social.US.Service[classname];
			}
			
			if(theClass){
				var error = false;
				var args;
				var retVal;
				if(methodName instanceof Array) {
					var methodOwner = theClass;
					for(var idx = 0; idx < methodName.length; idx++) {
						if(typeof methodOwner[methodName[idx]] == "function") {
							args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments[idx] || []);
							retVal = methodOwner[methodName[idx]].apply(methodOwner, args);
							methodOwner = retVal;						
						}
						else {
							error = true;
							break;
						}
					}
				}
				else {
					if(typeof theClass[methodName] == "function") {
						args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
						retVal = theClass[methodName].apply(theClass, args);
					}
					else {
						error = true;
					}
				}
				
				if(error) {
					NgLogD("ERROR: Invalid methods for calling on local Class: " + classname + " " + methodName);
				}
				else if(command.callback){
					var callback = Dispatcher.convertFunctionFromJSON({callbackUID: command.callback});
					if(callback){
						callback(retVal);
					}
				}				
			}
		}
		
		Dispatcher.endBatching();
	},

	/**
	 * Calls a static method on a class in a remote interpreter.
	 *	 
	 * @name Social.US.Dispatcher.callClassMethodOnRemoteObject
	 * @function
	 * @private
	 *
	 * @param {String} theClass The name of the class.
	 * @param {String} method The method name to call.
	 * @param {Array} args An array of parameters for the method.
	 * @param {Function} cb <code>callClassMethodOnRemoteObject()</code> returns returns the result and/or any error code and description to the callback function.
	 * 
	 */			
	callClassMethodOnRemoteObject: function(theClass, methodName, args, cb){		
		if(!theClass || !methodName){
			NgLogD("Public.Dispatcher.callClassMethodOnRemoteObject - bailing");
			if(cb){
				cb();
			}
			return;
		}

		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.callClassMethodOnLocalObject",
			classname: (theClass.classname ? theClass.classname : theClass),
			methodName: methodName,
			arguments: args,
			callback: (cb ? Dispatcher.convertFunctionToJSON(cb) : null)
		};
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},


	// callback communication

	/**
  	 * Takes a callback and sends it to a remote interpreter.
	 *	 
	 * @name Social.US.Dispatcher.sendCallbackToRemote
	 * @function
	 * @private
	 *
	 * @param {String} callbackUID The user ID of the user receiving the callback.
	 * @param {Array} args An array of parameters for the callback function.
	 */		
	sendCallbackToRemote: function(callbackUID, args){		
		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.receiveCallbackFromRemote",
			callbackUID: callbackUID,
			arguments: args,
			zone: GSGlobals.getRouterInstance().zone
		};

		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Receives a callback from a remote interpreter and provides the arguments to the local callback function.
	 *	 
	 * @name Social.US.Dispatcher.receiveCallbackFromRemote
	 * @function
	 * @private
	 *
	 * @param {Type} command A JSON object containing the user ID of the user receiving the callback and the callback arguments array.
	 */			
	receiveCallbackFromRemote: function(command){
		var callback = Dispatcher.callbacks[GSGlobals.getRouterInstance().zone][command.callbackUID]; //Dispatcher.convertFunctionFromJSON(command);
		if(!callback){
			return;
		}

		var args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
		
		callback.apply(callback, args);
	},
	

	// convenience functions to facilitate communication of all objects
	
	/**
	 * Parses a JSON array of function parameters and returns an array of function parameters.
	 *	 
	 * @name Social.US.Dispatcher.convertArgumentsArrayFromJSON
	 * @function
	 * @private
	 * 
	 * @param {Array} args An array of function parameters in JSON format.
	 * @return {Array} Returns an array of function parameters.
	 */	
	convertArgumentsArrayFromJSON: function(args){		
		var newArgs = [];
		for(var idx=0; idx < args.length; idx++){
			var arg = args[idx];
			
			if(arg && ((arg.recordID && arg.classname) || arg instanceof Array)){
				newArgs[idx] = Dispatcher.convertModelObjectFromJSON(arg);
			}else if(arg && arg.callbackUID){
				newArgs[idx] = Dispatcher.convertFunctionFromJSON(arg);
			}else{
				newArgs[idx] = arg;
			}
		}
		return newArgs;
	},

	/**
	 * Parses an array of function parameters and returns the array in JSON format.	 
	 * @name Social.US.Dispatcher.convertArgumentsArrayToJSON
	 * @function
	 * @private
	 *
	 * @param {Array} args An array of function parameters.
	 * 
	 * @returns {JSON} An array of function parameters in JSON format.
	 */
	convertArgumentsArrayToJSON: function(args){		
		var newArgs = [];
		for(var idx=0; idx < args.length; idx++){
			var arg = args[idx];
			if(arg && (arg.recordID && arg._classname && typeof arg._classname == "function" && arg._classname())){
				Dispatcher.sendObjectImmediately(arg);

				arg = Dispatcher.convertModelObjectToJSON(arg);
				newArgs[idx] = arg;
			}else if(arg && arg instanceof Array){
				arg = Dispatcher.convertArgumentsArrayToJSON(arg);
				newArgs[idx] = arg;
			}else if(arg && typeof arg == "function"){
				newArgs[idx] = Dispatcher.convertFunctionToJSON(arg);
			}else{
				newArgs[idx] = arg;
			}
		}
		return newArgs;
	},

	// convenience functions to facilitate communication of DataModel objects
	
	/**
	 * Takes a <code>DataModel</code> object and returns the object in JSON format.
	 *	 
	 * @name Social.US.Dispatcher.convertModelObjectToJSON
	 * @function
	 * @private
	 * 
	 * @param {Social.Models.DataModel} object A reference to a <code>DataModel</code> object (i.e., typically a subclass of <code>Models.DataModel</code>).
	 *
	 * @return {JSON} A <code>DataModel</code> object in JSON format.
	 */		
	convertModelObjectToJSON: function(object){		
		if(object && object.recordID && object._classname()){
			object = {
				classname: object._classname(),
				recordID:  object.recordID
			};
		}
		return object;
	},


	/**
	 * Takes a <code>DataModel</code> object in JSON format and returns the object.
	 *	 
	 * @name Social.US.Dispatcher.convertModelObjectFromJSON
 	 * @function
 	 * @private
 	 *
	 * @param {JSON} json A <code>DataModel</code> object in JSON format.
	 * 
	 * @return {Social.US.DataModel} A <code>DataModel</code> object.
	 */		
	convertModelObjectFromJSON: function(json){		
		var object = json;
		if(json.recordID && json.classname){
			var obj = Dispatcher.cache().getObjectWithRecordID(json.classname, json.recordID);
			if(obj){
				object = obj;
				if(json.data){
					object._deserializeFromHash(json.data);
				}
			}
		}else if(json instanceof Array){
			for(var idx=0; idx < json.length; idx++){
				var arg = json[idx];
				json[idx] = Dispatcher.convertModelObjectFromJSON(arg);
			}
		}
		return object;
	},

	// convenience functions to facilitate communication of functions
	
	/**
	 * Takes a function and returns the function in JSON format.
	 *	 
	 * @name Social.US.Dispatcher.convertFunctionToJSON
	 * @function
	 * @private	 
	 * 
	 * @param {function} The function to conver to JSON format.
	 * 
	 * @return {JSON} Returns a function in JSON format.
	 */		
	convertFunctionToJSON: function(fn){		
		if(fn && typeof fn == "function"){
			
			var callbackUID = ++Dispatcher.callbackUIDCounter;
			var zone = GSGlobals.getRouterInstance().zone;
			Dispatcher.callbacks[zone][callbackUID] = fn;

			fn = {
				callbackUID: callbackUID,
				zone: zone
			};
		}
		return fn;
	},


	
	/**
 	 * Takes a function expressed in JSON format and returns the function.
	 * @name Social.US.Dispatcher.convertFunctionFromJSON
	 * @function
	 * @private
	 * 
	 * @param {JSON} A function in JSON format.
	 * 
	 * @return {Function} Returns a function.
	 */	
	convertFunctionFromJSON: function(json){		
		var fn = json;
		var callbackUID = fn.callbackUID;
		var zone = fn.zone;
		
		if(callbackUID){
			var callback = Dispatcher.callbacks[zone][callbackUID];
			if(callback){
				fn = callback;
				delete Dispatcher.callbacks[zone][callbackUID];
			}else{
				fn = Dispatcher.generateCallbackForUID(callbackUID);
			}
		}
		return fn;
	},


	
	/**
	 * Takes a user ID and sends the callback to the remote interpreter.
	 *
	 * @name Social.US.Dispatcher.generateCallbackForUID
	 * @function
	 * @private
	 *	 
	 * @param {Number} The user ID.
	 * @return {Function} Returns a callback to the remote interpreter.
	 */	
	generateCallbackForUID: function(uid){		
		if(uid.callbackUID){
			uid = uid.callbackUID;
		}
		
		return function(){
			Dispatcher.sendCallbackToRemote(uid, arguments);
		};
	},
	
	
	// object sending and batching
	_batchCount: 0,
	_queuedObjects: [],
	
	/**
	 * <code>beginBatching()</code> increments the batch count.
	 * 
	 * @name Social.US.Dispatcher.
	 * @function
	 * @private
	 */	
	beginBatching: function(){		
		++Dispatcher._batchCount;
	},

	/**
	 * Decrements the batch count.
	 * Decrements the batch count and sends any objects remaining in the queue immediately.
	 *
	 * @name Social.US.Dispatcher.endBatching
	 * @function
	 * @private
	 */	
	endBatching: function(){		
		if((--Dispatcher._batchCount) === 0){
			for(var objKey in Dispatcher._queuedObjects){
				var obj = Dispatcher._queuedObjects[objKey];
				Dispatcher._queuedObjects[objKey] = undefined;
				Dispatcher.sendObjectImmediately(obj);
			}
		}
	},

	/**
	 * Takes an object and adds it to a queue, which pushes the object to the remote interpreter.
	 *
	 * @name Social.US.Dispatcher.sendObject
	 * @function
	 * @private
	 */
	sendObject: function(obj){		
		if(Dispatcher._queuedObjects.indexOf(obj) == -1){
			Dispatcher.beginBatching();
			
			var key = "" + obj.classname + "---" + obj.recordID;
			Dispatcher._queuedObjects[key] = obj;
			
			Dispatcher.endBatching();
		}
	},

	/**
	 * Takes an object and pushes it to the remote interpreter immediately (i.e., bypassing the queue).
	 *
	 * @name Social.US.Dispatcher.sendObjectImmediately
	 * @function
	 * @private
	 */
	sendObjectImmediately: function(obj){		
		if(!obj){
			return;
		}
		
		var cmd = {
			apiURL: "US.Dispatcher.receiveObject",
			data:   obj._serializedHash()
		};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Receives a serialized object from the remote interpreter, retrieves the local version of the same object from the cache, and deserializes the received object to the local object.
	 * If there is no local version of the received object, <code>receiveObject()</code> creates a local version and adds it to the cache; then, it deserializes the received object to the newly created local object.
	 *
	 * @name Social.US.Dispatcher.receiveObject
	 * @function
	 * @private
	 */
	receiveObject: function(command){		
		var data = command.data;
		var theRecordID  = data.recordID;
		var theClassname = data.classname;
		var theData      = data.data;
		
		if(theRecordID && theClassname && Dispatcher.cache()){
			var obj = Dispatcher.cache().getObjectWithRecordID(theClassname, theRecordID);
			if(!obj){
				var theClass = SocialR.Social.US[theClassname];
				obj = new theClass(theRecordID);
				
				Dispatcher.cache().addObject(obj);
			}

			// TODO disable emitting somehow
			if(theData){
				obj._deserializeFromHash(theData);
			}
		}
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Data/Session'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Session'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Session'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Data';
var __filename = 'NGCore/Client/Social/US/Data/Session.js';

var CoreReq = require('NGCore/Client/Core');
//var UserReq = require_('../Models/User');
var MessageEmitterReq = require("NGCore/Client/Core/MessageEmitter");
var CacheReq = require('NGCore/Client/Social/US/Models/Cache');
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * <code>Session</code> manages a user's game sessions.
 * @class 
 * @name Social.US.Session
 */
var Session = exports.Session = MessageEmitterReq.MessageEmitter.subclass({
		
	classname: "Session",
	
	/**
	 * Constructs a session object.
	 * @name Social.US.Session.initialize
	 * @private
	 * @constructs 
	 */	
	initialize: function(gameData){
		if(gameData){
			this._loadSessionData(gameData);
		}
	},
	
	/**
	 * Loads the user's game data into the current session.
	 *
	 * @name Social.US.Session._loadSessionData
	 * @function
	 * @private
	 *
	 * @param {Type} gameData Takes game data and loads it into the current session.
	 */		
	_loadSessionData: function(gameData){
		this._appKey = gameData.appId || this._appKey || null;
		this._appVersion = gameData.appVersion || this._appVersion || null;
		this._platformVersion = gameData.platformVersion || this._platformVersion || "1.0";
		this._serverMode = gameData.serverMode || this._serverMode || null;

		this._user = (gameData.userID ? this.dataCache().getObjectWithRecordID("User", gameData.userID) : null);		
		this.emit({user: this._user});
	},
	
	/**
	 * Returns the cache for the current session. If a session cache does not exist, this call creates a new cache, loads it and returns it.
	 *
	 * @name Social.US.Session.dataCache
	 * @function
	 * @private
	 *
	 * @return {Social.US.Cache} The cache for the current session.
	 */			
	dataCache: function(){
		if(!this._cache){
			this._cache = new CacheReq.Cache();
			this._cache.loadCache(function(err){
				NgLogD("Loaded cache: " + err);
			});
		}
		return this._cache;
	},
	
	
	/**
	 * Returns the user for this session.
	 *
	 * @name Social.US.Session.user
	 * @function
	 *
	 * @returns {Social.US.User} The user for the current session.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */					
	user: function(){
		return this._user;
	},
	
	

	// data you probably don't need
	/**
	 * Returns the name of the game for this session.
	 *
	 * @name Social.US.Session.appKey
	 * @function
	 *
	 * @returns {String} The application name.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	appKey: function(){
		return this._appKey;
	},
	
	/**
	 * Returns the version of the game for this session.	 
	 *
	 * @name Social.US.Session.appVersion
	 * @function
	 *
	 * @returns {String} The application version.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	appVersion: function(){
		return this._appVersion;
	},
	
	/**
	 * Returns the server mode of the game for this session.
	 *
	 * @name Social.US.Session.serverMode
	 * @function
	 *
	 * @returns {String} The server mode.
	 * <b>Note:</b> Valid settings for the server mode include:<br/>
	 * <ul>
	 * <li>staging</li>
	 * <li>integration</li>
	 * <li>sandbox</li>
	 * <li>production</li>
	 * <li>unknown</li>
	 * </ul>
	 * @see Social.US.Session.serverModes
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	serverMode: function(){
		return this._serverMode;
	},
	
	/**
	 * Returns the platform version of the game for this session.
	 *
	 * @name Social.US.Session.platformVersion
	 * @function
	 *
	 * @returns {String} The platform version.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	platformVersion: function(){
		return this._platformVersion;
	},
	

	/**
	 * Takes a consumer key and retrieves the session tokens for the the consumer key.
	 *
	 * @name Social.US.Session.getSessionTokensForConsumerKey
	 * @function
	 * 
	 * @param {String} consumerKey The consumer key.
	 * @cb {Function} cb The function to call after retrieving the session tokens for the
	 *		consumer key.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} error.description A description of the error.
	 * @cb-param {String} error.errorCode A code identifying the error type.
	 * @cb-param {Object} tokens The session tokens for the consumer key.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	getSessionTokensForConsumerKey: function(consumerKey, cb){
		Dispatcher.callClassMethodOnRemoteObject("Session", ["getCurrentSession", "getSessionTokensForConsumerKey"], [[], [consumerKey, cb]]);
	}
});


/**
 * The session modes for the server. Session modes include:
 * <ul>
 * <li><code>staging</code></li>
 * <li><code>integration</code></li>
 * <li><code>sandbox</code></li>
 * <li><code>production</code></li>
 * <li><code>unknown</code></li>
 * </ul>
 * @name Social.US.Session.serverModes
 * @field
 * @public
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.serverModes = {
	staging: "staging",
	integration: "integration",
	partner: "sandbox",
	sandbox: "sandbox",
	production: "production",
	unknown: "unknown"
};

/**
 * Returns the current session.  
 * @name Social.US.Session.getCurrentSession
 * @function
 * @static
 *
 * @returns {Social.US.Session} The current session.
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */	
Session.getCurrentSession = function(){
	return Session._currentSession;
};



Session._emitter = null;

/**
 * Adds a listener to the current session.
 *
 * @name Social.US.Session.addCurrentSessionListener
 * @function
 * @static
 *  
 * @param {Core.MessageListener} listener The listener to add to the current session.
 * @cb {Function} callback The function to call when a session event occurs.
 * @cb-returns {void}
 * @param priority The priority for this <code>MessageListener</code>.
 *
 * @see Core.MessageListener
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.addCurrentSessionListener = function(listener, callback, priority){	
	if(!Session._emitter){
		Session._emitter = new MessageEmitterReq.MessageEmitter();
	}
	
	Session._emitter.addListener(listener, callback, priority);
};

/**
 * Removes the listener from the current session.
 *
 * @name Social.US.Session.removeCurrentSessionListener 
 * @function
 * @static
 *
 * @param {Core.MessageListener} listener The listener for the current session.
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.removeCurrentSessionListener = function(listener){
	if(Session._emitter){
		Session._emitter.removeListener(listener);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Config'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Config'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Config'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Config.js';

var Session = require("NGCore/Client/Social/US/Data/Session").Session;

/**
 * @class 
 * @name Social.Common.Config
 * @description
 * An API to determine whether the social server is a sandbox server or a production server. 
 */
exports.Config = {
/** @lends Social.Common.Config.prototype */

    /**
     * Determine whether the server is a sandbox server or a production server.
     * @name getServerEnvironment
     * @memberOf Social.Common.Config#
     * @public
     * @function
     * @returns {String} One of the following values:
     * <ul>
     *     <li><code>production</code>: Production server.</li>
     *     <li><code>sandbox</code>: Sandbox server.</li>
     *     <li><code>unknown</code>: The current session cannot be retrieved, or  the server mode is
     *     neither <code>sandbox</code> nor <code>production</code>.</li>
     * </ul>
     * @see Social.US.Session#serverMode
     * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	getServerEnvironment: function(){
		var session = Session.getCurrentSession();
		if(!session){
			return "unknown";
		}
		
		var serverMode = Session.getCurrentSession().serverMode();
		if(serverMode == Session.serverModes.production){
			return "production";
		}else if(serverMode == Session.serverModes.sandbox){
			return "sandbox";
		}else{
			return "unknown";
		}
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/People'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/People'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/People'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/People.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class 
 * @name Social.Common.People
 * @description
 * Provides access to information about users, including their personal information and their 
 * friends. A user's network of friends is sometimes referred to as the user's "social graph."
 * <br /><br />
 * The data that is available for each user varies between the Japan and US/worldwide platforms. On
 * both platforms, you can retrieve a user's ID and display name, as well as a URL for the user's
 * thumbnail image. You can also determine whether the user has installed the application that is
 * currently running. See the individual methods in this class for more details about which fields
 * are available on each platform.
 */
exports.People = {

	/**
	 * Retrieves information about the specified user. By default, only a limited amount of 
	 * information is retrieved. Use the <code>fields</code> parameter to retrieve additional 
	 * information.
	 *
	 * @name Social.Common.People.getUser
	 * @function 
	 * @public 
	 *
	 * @param {String} userId The user ID of the user to retrieve.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>user</code> parameter. The
	 *		required properties of the <code>user</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the specified
	 *		user.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} user Information about the user.
	 * @cb-param {String} [user.aboutMe] Brief introductory text for the user. Available only on the
	 *		Japan platform.
	 * @cb-param {String} [user.addresses] The prefecture where the user lives. Available only on 
	 *		the Japan platform.
	 * @cb-param {Number} [user.age] The user's age.
	 * @cb-param {Boolean} [user.ageRestricted] Set to <code>true</code> if the user has been 
	 *		restricted based on their age. Not available on the Japan platform.
	 * @cb-param {String} [user.birthday] The user's birthday. Uses the format
	 *		<code><em>YYYY</em>-<em>MM</em>-<em>DD</em></code>, where <code><em>YYYY</em></code> is
	 *		the four-digit year, <code><em>MM</em></code> is the two-digit month, and
	 *		<code><em>DD</em></code> is the two-digit day. Available only on the Japan platform.
	 * @cb-param {String} [user.bloodType] The user's blood type. Available only on the Japan 
	 *		platform.
	 * @cb-param {String} user.displayName The name displayed for the user.  Matches the user's 
	 *		nickname.
	 * @cb-param {String} [user.gender] The user's gender. Available only on the Japan platform.
	 * @cb-param {Boolean} user.hasApp Set to <code>true</code> if the user has installed the 
	 *		current application.
	 * @cb-param {String} user.id The user's ID.
	 * @cb-param {String} [user.interests] A list of the user's interests. Available only on the 
	 *		Japan platform.
	 * @cb-param {String} [user.jobType] The user's job type. Available only on the Japan platform.
	 * @cb-param {String} [user.nickname] The user's nickname.
	 * @cb-param {String} user.thumbnailUrl The URL for the user's thumbnail image.
	 * @cb-returns {void}
	 * @see Social.Common.People.getCurrentUser
	 * @example
	 * var recordID = 2;
	 *
	 * Social.Common.People.getUser(recordID, 
	 *                              ['id','nickname','thumbnailUrl'], 
	 *                              callback
	 *		});
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	getUser: function(userId, fields, callback) {
		var cmd = {apiURL:"Common.People.getUser", userId:userId, fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Retrieves information about as many as 100 users. By default, only a limited amount of 
	 * information is retrieved. Use the <code>fields</code> parameter to retrieve additional
	 * information.
	 *	 
	 * @name Social.Common.People.getUsers
	 * @function 
	 * @public
	 * 
	 * @param {String[]} userIds The user IDs of the users to retrieve. The array must contain
	 *		between 1 and 100 user IDs.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available 
	 *		fields, see the properties of the callback function's <code>users</code> parameter. The
	 *		required properties of the <code>users</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the specified
	 *		users.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object[]} users Information about individual users.
	 * @cb-param {String} [users[].aboutMe] Brief introductory text for the user. Available only on 
	 *		the Japan platform.
	 * @cb-param {String} [users[].addresses] The prefecture where the user lives. Available only on
	 *		the Japan platform.
	 * @cb-param {Number} [users[].age] The user's age.
	 * @cb-param {Boolean} [users[].ageRestricted] Set to <code>true</code> if the user has been 
	 *		restricted based on their age. Not available on the Japan platform.
	 * @cb-param {String} [users[].birthday] The user's birthday. Uses the format
	 *		<code><em>YYYY</em>-<em>MM</em>-<em>DD</em></code>, where <code><em>YYYY</em></code> is
	 *		the four-digit year, <code><em>MM</em></code> is the two-digit month, and
	 *		<code><em>DD</em></code> is the two-digit day. Available only on the Japan platform.
	 * @cb-param {String} [users[].bloodType] The user's blood type. Available only on the Japan
	 *		platform.
	 * @cb-param {String} users[].displayName The name displayed for the user. Matches the user's 
	 *		nickname.
	 * @cb-param {String} [users[].gender] The user's gender. Available only on the Japan platform.
	 * @cb-param {Boolean} users[].hasApp Set to <code>true</code> if the user has installed the 
	 *		current application.
	 * @cb-param {String} users[].id The user's ID.
	 * @cb-param {String} [users[].interests] A list of the user's interests. Available only on the
	 *		Japan platform.
	 * @cb-param {String} [users[].jobType] The user's job type. Available only on the Japan 
	 *		platform.
	 * @cb-param {String} [users[].nickname] The user's nickname.
	 * @cb-param {String} users[].thumbnailUrl The URL for the user's thumbnail image.
	 * @cb-param {Object} result Information about the results that were returned.
	 * @cb-param {Number} result.total The total number of users.
	 * @cb-param {Number} result.start The starting index for this group of users within the entire
	 *		list of users.
	 * @cb-param {Number} result.count The number of users that were returned.
	 * @cb-returns {void}
	 * @see Social.Common.People.getUser
	 * @example
	 * People.getUsers([1,2,3],null, callback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
	getUsers: function(userIds, fields, callback) {
		var cmd = {apiURL:"Common.People.getUsers", userIds:userIds, fields:fields, callbackFunc:function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves information about the current user. By default, only a limited amount of 
	 * information is retrieved. Use the <code>fields</code> parameter to retrieve additional
	 * information.
	 *
	 * @name Social.Common.People.getCurrentUser
	 * @function
	 * @public
	 *
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available 
	 *		fields, see the properties of the callback function's <code>user</code> parameter. The
	 *		required properties of the <code>user</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the current
	 *		user.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} user Information about the user.
	 * @cb-param {String} [user.aboutMe] Brief introductory text for the user. Available only on the
	 *		Japan platform.
	 * @cb-param {String} [user.addresses] The prefecture where the user lives. Available only on 
	 *		the Japan platform.
	 * @cb-param {Number} [user.age] The user's age.
	 * @cb-param {Boolean} [user.ageRestricted] Set to <code>true</code> if the user has been 
	 *		restricted based on their age. Not available on the Japan platform.
	 * @cb-param {String} [user.birthday] The user's birthday. Uses the format
	 *		<code><em>YYYY</em>-<em>MM</em>-<em>DD</em></code>, where <code><em>YYYY</em></code> is
	 *		the four-digit year, <code><em>MM</em></code> is the two-digit month, and
	 *		<code><em>DD</em></code> is the two-digit day. Available only on the Japan platform.
	 * @cb-param {String} [user.bloodType] The user's blood type. Available only on the Japan
	 *		platform.
	 * @cb-param {String} user.displayName The name displayed for the user. Matches the user's
	 *		nickname.
	 * @cb-param {String} [user.gender] The user's gender. Available only on the Japan platform.
	 * @cb-param {Boolean} user.hasApp Set to <code>true</code> if the user has installed the 
	 *		current application.
	 * @cb-param {String} user.id The user's ID.
	 * @cb-param {String} [user.interests] A list of the user's interests. Available only on the 
	 *		Japan platform.
	 * @cb-param {String} [user.jobType] The user's job type. Available only on the Japan platform.
	 * @cb-param {String} [user.nickname] The user's nickname.
	 * @cb-param {String} user.thumbnailUrl The URL for the user's thumbnail image.
	 * @cb-returns {void}
	 * @see Social.Common.People.getUser
	 * @example
	 * People.getCurrentUser(null, callback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
	getCurrentUser: function(fields, callback) {
		var cmd = {apiURL:"Common.People.getCurrentUser", fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves information about a user's friends. By default, only a limited amount of 
	 * information is retrieved. Use the <code>fields</code> parameter to retrieve additional
	 * information.
	 *
	 * @name Social.Common.People.getFriends
	 * @function
	 * @public
	 * 
	 * @param {String[]} userId The user ID of the user whose friends will be retrieved.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>users</code> parameter. The
	 *		required properties of the <code>users</code> parameter are retrieved by default.
	 * @param {Object} opt Options for the number of users to retrieve. Used to support
	 *                     pagination.
	 * @param {Number} [opt.start] The index of the first user to retrieve. For example, if the user
	 *		has 50 friends, and you have already retrieved 10 friends, set this parameter to
	 *		<code>11</code> to retrieve the next group of friends.
	 * @param {Number} [opt.count] The number of friends to retrieve. For example, if you want to
	 *		display 10 friends per page, set this parameter to <code>10</code>.
	 * @cb {Function} callback The function to call after retrieving information about the specified
	 *		user's friends.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object[]} users Information about individual users.
	 * @cb-param {String} [users[].aboutMe] Brief introductory text for the user. Available only on 
	 *		the Japan platform.
	 * @cb-param {String} [users[].addresses] The prefecture where the user lives. Available only on
	 *		the Japan platform.
	 * @cb-param {Number} [users[].age] The user's age.
	 * @cb-param {Boolean} [users[].ageRestricted] Set to <code>true</code> if the user has been 
	 *		restricted based on their age. Not available on the Japan platform.
	 * @cb-param {String} [users[].birthday] The user's birthday. Uses the format
	 *		<code><em>YYYY</em>-<em>MM</em>-<em>DD</em></code>,  where <code><em>YYYY</em></code> is
	 *		the four-digit year, <code><em>MM</em></code> is the two-digit month, and
	 *		<code><em>DD</em></code> is the two-digit day. Available only on the Japan platform.
	 * @cb-param {String} [users[].bloodType] The user's blood type. Available only on the Japan
	 *		platform.
	 * @cb-param {String} users[].displayName The name displayed for the user. Matches the user's 
	 *		nickname.
	 * @cb-param {String} [users[].gender] The user's gender. Available only on the Japan platform.
	 * @cb-param {Boolean} users[].hasApp Set to <code>true</code> if the user has installed the 
	 *		current application.
	 * @cb-param {String} users[].id The user's ID.
	 * @cb-param {String} [users[].interests] A list of the user's interests. Available only on the
	 *		Japan platform.
	 * @cb-param {String} [users[].jobType] The user's job type. Available only on the Japan
	 *		platform.
	 * @cb-param {String} [users[].nickname] The user's nickname.
	 * @cb-param {String} users[].thumbnailUrl The URL for the user's thumbnail image.
	 * @cb-param {Object} result Information about the results that were returned.
	 * @cb-param {Number} result.total The total number of this user's friends.
	 * @cb-param {Number} result.start The starting index for this group of users within the user's
	 *		entire list of friends.
	 * @cb-param {Number} result.count The number of users that were returned.
	 * @cb-returns {void}
	 * @see Social.Common.People.getFriendsWithGame
	 * @example
	 * People.getFriends(4, null, {'start': 2}, callback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */					
	getFriends: function(userId, fields, opt, callback) {
		var cmd = {apiURL:"Common.People.getFriends", userId:userId, fields:fields, opt:opt, callbackFunc: function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves a list of a user's friends who are playing the current game.
	 *
	 * @name Social.Common.People.getFriendsWithGame
	 * @function
	 * @public
	 *
	 * @param {String} userId The user ID of the user whose friends are playing the current game.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>users</code> parameter. The
	 *		required properties of the <code>users</code> parameter are retrieved by default.
	 * @param {Object} opt Options for the number of users to retrieve. Used to support pagination.
	 * @param {Number} [opt.start] The index of the first user to retrieve. For example, if the 
	 *		user has 50 friends, and you have already retrieved 10 friends, set this parameter to
	 *		<code>11</code> to retrieve the next group of friends.
	 * @param {Number} [opt.count] The number of friends to retrieve. For example, if you want to 
	 *		display 10 friends per page, set this parameter to <code>10</code>.
	 * @cb {Function} callback The function to call after retrieving a list of the user's friends 
	 *		who are playing the current game.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object[]} users Information about individual users.
	 * @cb-param {String} [users[].aboutMe] Brief introductory text for the user. Available only on
	 *		the Japan platform.
	 * @cb-param {String} [users[].addresses] The prefecture where the user lives. Available only on
	 *		the Japan platform.
	 * @cb-param {Number} [users[].age] The user's age.
	 * @cb-param {Boolean} [users[].ageRestricted] Set to <code>true</code> if the user has been
	 *		restricted based on their age. Not available on the Japan platform.
	 * @cb-param {String} [users[].birthday] The user's birthday. Uses the format
	 *		<code><em>YYYY</em>-<em>MM</em>-<em>DD</em></code>, where <code><em>YYYY</em></code> is
	 *		the four-digit year, <code><em>MM</em></code> is the two-digit month, and
	 *		<code><em>DD</em></code> is the two-digit day. Available only on the Japan platform.
	 * @cb-param {String} [users[].bloodType] The user's blood type. Available only on the Japan 
	 *		platform.
	 * @cb-param {String} users[].displayName The name displayed for the user. Matches the user's 
	 *		nickname.
	 * @cb-param {String} [users[].gender] The user's gender. Available only on the Japan platform.
	 * @cb-param {Boolean} users[].hasApp Set to <code>true</code> if the user has installed the
	 *		current application.
	 * @cb-param {String} users[].id The user's ID.
	 * @cb-param {String} [users[].interests] A list of the user's interests. Available only on the
	 *		Japan platform.
	 * @cb-param {String} [users[].jobType] The user's job type. Available only on the Japan
	 *		platform.
	 * @cb-param {String} [users[].nickname] The user's nickname.
	 * @cb-param {String} users[].thumbnailUrl The URL for the user's thumbnail image.
	 * @cb-param {Object} result Information about the results that were returned.
	 * @cb-param {Number} result.total The total number of users who are friends of the user and 
	 *		are playing the current game.
	 * @cb-param {Number} result.start The starting index for this group of users within the 
	 *		entire list of friends playing the current game.
	 * @cb-param {Number} result.count The number of users that were returned.
	 * @cb-returns {void}
	 * @see Social.Common.People.getFriends
	 * @example 
	 * People.getFriendsWithGame(4, null, null, callback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	getFriendsWithGame: function(userId, fields, opt, callback) {
		var cmd = {apiURL:"Common.People.getFriendsWithGame", userId:userId, fields:fields, opt:opt, callbackFunc: function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
	
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Profanity.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");	

/**
 * @class 
 * @name Social.Common.Profanity
 * @description
 * Provides an interface to check games for profanity.
 */
exports.Profanity = {
	
	/**
	 * Checks a text string to determine if it contains profanity.
	 * This call only conducts a check and does not attempt to cleanup the string.<br /><br />
	 * <b>Note:</b> The server handles locale and language automatically.
	 *
	 * @name Social.Common.Profanity.checkProfanity
	 * @function
	 * @public
	 * 
	 * @param {String} text The string to check for profanity.
	 * @cb {Function} callback The function to call after checking the string for profanity.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Boolean} valid Set to <code>false</code> if the string contains profanity.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	checkProfanity: function(text, callback) {
		var cmd = {apiURL:"Common.Profanity.checkProfanity", text:text, callbackFunc:function(error, args) {
			callback(error, args.profanity);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	}	
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Request'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Request'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Request'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Request.js';

var Class = require('NGCore/Client/Core/Class').Class;


//Don't need to document
exports.Request = Class.subclass({
	execute: function(callback) {
		// [call US function here]	
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/RemoteNotification'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/RemoteNotification'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/RemoteNotification'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/RemoteNotification.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class
 * @name Social.Common.RemoteNotification
 * @description
 * Mobage provides a Common API for the sending of remote notifications to others within the Mobage Service.
 * The messages are sent and received by games using ngCore's network-based notification capabilities.
 * The Mobage platform service acts an intermediary to enqueue and send remote messages, while local notification
 * support is provided elsewhere in the ngCore SDK.
 * <br />
 * <code>RemoteNotification</code> Sends a remote notification (push message) to a user's device.
 * This API can be used to send a message to a single user within a given application.  Broadcast notifications
 * can be sent via the server's HTTP REST endpoints, but only when game server's OAuth tokens.
 * @since 1.7
 */
exports.RemoteNotification = {

    /**
     * Sends a remote notification to another user who is also playing a Mobage-enabled game. This API covers only
     * the "user to user" remote notification. This API is not currently rate limited, but Mobage reserves the
     * right to throttle or suspend accounts sending excessive remote notifications.
     *
     * @name Social.Common.RemoteNotification.send
     * @function
     * @public
     *
     * @param {String} recipientId Recipient user's identifier.  This can be either a user's gamertag or user ID.
     * @param {Object} payload Additional parameters passed to the device.
     * @param {String} [payload.message] (required) UTF-8 message body
     * @param {Integer} [payload.badge] (optional) If the notification is sent to an iOS device, this number is used
     *      to badge the application icon.  If no badge is included, no numeric badge will be sent.  Including this
     *      field for target Android devices has no affect and does not count toward payload size constraints.
     * @param {String} [payload.sound] (reserved for future use) (optional) If the notification is sent to an iOS device,
     *      this is the name of the sound file in the application bundle.  If the sound file doesn't exist, or "default"
     *      is specified as the value, the default alert sound is played.  Including this field for target Android
     *      devices has no affect and does not count toward payload size constraints.
     * @param {String} [payload.collapseKey] (optional) If the notification is sent to an Android device, this is
     *      the collapse key to coalesce multiple messages into a single group, so that only the last received
     *      notification is visible.  If no key is specified, all notifications will use the same collapseKey.
     *      Including this field for target iOS devices has no affect and doesn't count toward payload size constraints.
     * @param {String} [payload.style] (optional) If the notification is sent to an Android device, this is a hint
     *      containing the preferred layout style for the system notification tray.  If no style is given, or the
     *      provided style is not available, the default Mobage style will be used.  Valid styles are "normal" and
     *      "largeIcon".  Including this field for target iOS devices has no affect and does not count toward payload
     *      size constraints.
     * @param {String} [payload.iconUrl] (optional) If the notification is sent to an Android device, and the
     *      notification payload includes a style attribute, this icon URL is used to determine the image shown in the
     *      Android notification bar.  If this field is not specified, the default Mobage icon image will be shown.
     *      Including this field for target iOS devices has no affect and doesn't count toward payload size constraints.
     * @param {Object} [payload.extras] (optional) Custom 1 level hash of key/value parameters defined by the developer.
     *      Note; the string key for each item in this section cannot contain any of the payload's defined key values.
     * @cb {Function} callback The function to call after sending the remote notification.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} remoteNotification Sent notification after successful enqueuing on the Mobage server.
     * @cb-param {String} [remoteNotification.id] Unique identifier for the remote notification.
	 * @cb-param {Object} [remoteNotification.payload] payload value specified in the send() method.
	 * @cb-param {String} [remoteNotification.published] ISO 8601 Timestamp when the Mobage API server received the request.
	 *
	 * @cb-returns {void}
	 * @see Device.NotificationEmitter
	 * @example
	 * var recipientId = 10028;
     * var payload     = {
     *   "message": "Simon! Come join my quest.",
     *   "extras": {
     *      "foo": 1,
     *      "bar": "twenty one!"
     *   }
     * };
     *
     * Social.Common.RemoteNotification.send(recipientId, payload, function(error, remoteNotification) {
     *   if (error) {
     *     // error handling code is here
     *   } else {
     *     // successful queueing of the remote notification
     *   }
     * });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.7
	 */
	send: function(recipientId, payload, callback) {
		var cmd = {apiURL:"Common.RemoteNotification.send", recipientId:recipientId, payload:payload, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
    },

    /**
     * Returns true if the current logged in user can receive remote notifications for the current running application.
     * This can be called from within each application to determine if the current user is capable of receiving remote
     * notifications.
     *
     * @name Social.Common.RemoteNotification.getRemoteNotificationsEnabled
     * @function
     * @public
     *
     * @param {Function} callback The function to call after determining if the current user can be notified.
     * @cb {Function} callback The function to call after determining if the current user can be notified.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Boolean} canBeNotified True if the current logged in user is capable of receiving remote notifications.
     *
	 * @cb-returns {void}
	 * @see Device.NotificationEmitter
	 * @example
	 * Social.Common.RemoteNotification.getRemoteNotificationsEnabled(function(error, canBeNotified) {
     *   if (error) {
     *     // error handling code is here
     *   }
     *   if (canBeNotified) {
     *     // User in the current application can receive remote notifications
     *   }
     * });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.7
	 */
    getRemoteNotificationsEnabled: function(callback) {
        var cmd = {apiURL:"Common.RemoteNotification.getRemoteNotificationsEnabled", callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
     * Boolean setter value for whether or not the current logged in user may receive remote notifications for the
     * current running application.  This can be called from within each application to set the remote notification
     * receipt capability.
     *
     * @name Social.Common.RemoteNotification.setRemoteNotificationsEnabled
     * @function
     * @public
     *
     * @param {Boolean} enabled The enabled or disabled state of the current user's remote notifications.
     * @param {Function} callback The function to call after setting if the current user can be notified.
     * @cb {Function} callback The function to call after setting if the current user can be notified.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Boolean} canBeNotified True if the current logged in user is capable of receiving remote notifications.
     *
	 * @cb-returns {void}
	 * @see Device.NotificationEmitter
	 * @example
	 * Social.Common.RemoteNotification.setRemoteNotificationsEnabled(true, function(error) {
     *   if (error) {
     *     // error handling code is here
     *   }
     *   // User is configured to receive remote notifications
     * });
	 * @returns {void}
     * @status iOS, Android, Test, iOSTested, AndroidTested
     * @since 1.7
     */
    setRemoteNotificationsEnabled: function(enabled, callback) {
        var cmd = {apiURL:"Common.RemoteNotification.setRemoteNotificationsEnabled", enabled:enabled, callbackFunc:callback};
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
    }
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] = exports; 
var __dirname = 'NGCore/Client/Social/_Internal';
var __filename = 'NGCore/Client/Social/_Internal/GSCommand.js';

/**
 * GSCommand.js
 * GameService Command Helper
 *
 * @summary Converts hashes for sending across the interpreter bounds, specifically:
 *		- Takes a hash with a callbackFunc
 * 			- Takes callbackFunc and converts to callbackId
 *		- Takes a hash with a callbackId
 *			- Takes the callbackId and looks up a callbackFunc from the local cache
 */
 
var GameServiceCommandCallbackStore = {};
GameServiceCommandCallbackStore.uidGenerator = 0;

/** @private */
var storeCallbackIdForFunc = function(callbackFunc) {
	var uid = GameServiceCommandCallbackStore.uidGenerator++;
	GameServiceCommandCallbackStore[uid] = callbackFunc;
	return uid;
};
/** @private */
var extractFuncForCallbackId = function(callbackId) {
	if(GameServiceCommandCallbackStore.hasOwnProperty(callbackId)){
		var callbackFunc = GameServiceCommandCallbackStore[callbackId];
		delete GameServiceCommandCallbackStore[callbackId];
		return callbackFunc;
	}
	return null;
};

var blindConvert = function(hash) {
	if ( typeof hash == "object" ) {
		// Case we have a hash
		if ( hash.hasOwnProperty("callbackFunc") ) {
			//	with a callback func to convert
			hash["callbackId"] = storeCallbackIdForFunc(hash["callbackFunc"]);
			
			delete hash["callbackFunc"];
		}
		else if (hash.hasOwnProperty("callbackId")) {
			hash["callbackFunc"] = extractFuncForCallbackId(hash["callbackId"]);
			delete hash["callbackId"];
		}
		return hash;
	}
	
	NgLogD("Error: invalid or non-object passed to gsCmdConvert.");
	return null;
};
exports.makeSafe = function(hash) {
	if (hash && typeof hash == "object" && hash.hasOwnProperty("callbackFunc"))
	{
		return blindConvert(hash);
	}
	return hash;
};
exports.makeExecutable = function(hash) {
	if (hash && typeof hash == "object" && hash.hasOwnProperty("callbackId"))
	{
		return blindConvert(hash);
	}
	return hash;
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] = exports; 
var __dirname = 'NGCore/Client/Social/_Internal';
var __filename = 'NGCore/Client/Social/_Internal/Privileged.js';

/**
 * Privileged API for GameService (Public Stub)
 * 
 * Access this file as NGCore/Client/Social.js
 */
exports.Social = {
	// stubbed out for the SDK
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/_Router'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/_Router'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/_Router'] = exports; 
var __dirname = 'NGCore/Client/Social/_Internal';
var __filename = 'NGCore/Client/Social/_Internal/_Router.js';

////////////////////////////////////////////////////////////////////////////////
// Class Router INTERNAL ROUTING CLASS
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Shared/Class').Class;
var Core = require('NGCore/Client/Core').Core;
var GSCommand = require("NGCore/Client/Social/_Internal/GSCommand");
var Public = require("NGCore/Client/Social").Social;

////////////////////////////////////////////////////////////////////////////////
var RouterVerbose = false;

exports.Router = Class.subclass(
/** @lends GameService.Router.prototype */
{
	classname: 'Router',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	/** Member var to help shortcircuit uneccessary bounces out to native. */
	zone:-2,
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
			* Zone for this Router Singleton (per-process)
			* @private */
	Zone:
	{ 
		/** Public Zone */
		Public: -2,
		/** GameService Zone */
		GameService: -1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 346,
	// Method create = -1
	// Method sendToOtherProcess = 2
	// Method onCreate = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._sendToOtherProcessRecv( cmd );
					break;
				case 3:
					instance._onCreateRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Router._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Router._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[346] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_sendToOtherProcessRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Router.sendToOtherProcess from command: " + cmd );
			return false;
		}
		
		obj[ "gsCommand" ] = Core.Proc.parseObject( cmd[ 0 ] );
		if( obj[ "gsCommand" ] === undefined )
		{
			NgLogE("Could not parse gsCommand in Router.sendToOtherProcess from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onCreateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Router.onCreate from command: " + cmd );
			return false;
		}
		
		obj[ "zone" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "zone" ] === undefined )
		{
			NgLogE("Could not parse zone in Router.onCreate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x15affff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_sendToOtherProcessSendGen: function( gsCommand )
	{
		Core.Proc.appendToCommandString( 0x15a0002, this, [ Core.Proc.encodeObject( gsCommand ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _sendToOtherProcessRecv: function( cmd ) {}
	// sendToOtherProcess: function( gsCommand ) {}
	
	// _onCreateRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,
	_onCreateRecv:function(cmd) {
		if (!this._onCreateRecvGen(cmd,this)){
			return;
		}
		NgLogD("_Router/_onCreateRecv: "+this.zone);
		//We already stored the zone directly in ourselves (by passing in 'this').
	},
	_sendToOtherProcessRecv: function( cmd )
	{
		var decodedCommand = {};
		if(!this._sendToOtherProcessRecvGen(cmd,decodedCommand)){
			NgLogE("Decode of data for router, failed.");
			return;
		}
		
		var commandObject = decodedCommand["gsCommand"];
		
		//Incoming commands all get executed immediately.
		if(this.zone == this.Zone.Public) {
			if(RouterVerbose) {
				NgLogD("_Router/_sendToOtherProcessRecv - in public");
			}
			
			this.dispatchGameCommand(commandObject);
		}
		else if(this.zone == this.Zone.GameService) {
			if(RouterVerbose) {
				NgLogD("_Router/ _sendToOtherProcessRecv - not in public");
			}
			
			// Dispatch Immediately, because we are in the game interpreter
			this.dispatchGameServiceCommand(commandObject);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume public
			this.dispatchGameCommand(commandObject);
		}
	},
 	sendToOtherProcess: function( gsCommand ) 
	{
		var jsonCommand = GSCommand.makeSafe(gsCommand);
		if(!jsonCommand) {
			NgLogD("Couldn't prep GSCommand message for sending!");
			return;
		}
		
		if(RouterVerbose) {
			NgLogD("_Router.js/sendToOtherProcess: " + JSON.stringify(jsonCommand));
		}
		
		this._sendToOtherProcessSendGen(jsonCommand);
	},
	sendCommandToGameService:function(gsCommand) 
	{		
		if(this.zone == this.Zone.Public) {
			if(RouterVerbose) {
				NgLogD("_Router: sendCommandToGameService - in public");
			}
			
			// In the Public Interface, this is an alias for sendToOtherProcess
			this.sendToOtherProcess(gsCommand);
		}
		else if(this.zone == this.Zone.GameService) {
			if(RouterVerbose) {
				NgLogD("_Router: sendCommandToGameService - not in public");
			}
			
			// Dispatch Immediately, because we are in the game interpreter
			this.dispatchGameServiceCommand(gsCommand);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume public
			this.sendToOtherProcess(gsCommand);
		}
	},
	sendCommandToGame:function(gsCommand)
	{
		if(this.zone == this.Zone.GameService) {
			// In the GameService Interface, this is an alias for sendToOtherProcess
			this.sendToOtherProcess(gsCommand);
		}
		else if(this.zone == this.Zone.Public) {
			// Dispatch Immediately, because we are in the game interpreter
			this.dispatchGameCommand(gsCommand);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume this is not the game
			this.sendToOtherProcess(gsCommand);
		}
	},
	dispatchGameCommand:function(jsonCommand) 
	{
		var tCommand = GSCommand.makeExecutable(jsonCommand);
		//For the time being we expect this to almost always be callbacks
		if(tCommand && tCommand.hasOwnProperty("callbackFunc")) {	
			if( typeof tCommand["callbackFunc"] == "function" ) {
				var args = null;
				var error = null;
				if(tCommand.hasOwnProperty("error")) {
					error = tCommand["error"];
				}
				if(tCommand.hasOwnProperty("callbackData")) {
					args = tCommand["callbackData"];
				}

				//Time to execute the callback function!
				tCommand["callbackFunc"](error,args);
			}
		}
		else if(tCommand) {
			// Case there was no callbackFunc this is odd!!
			var apiURL = null;
			if(tCommand && tCommand.hasOwnProperty("apiURL") ) {
				apiURL = tCommand["apiURL"];

				var apiPieces = apiURL.split(".");
				var curPackage = Public;

				
				exports._dispatchHelper(curPackage, apiPieces, jsonCommand);
			}
		}
	},
	dispatchGameServiceCommand:function(jsonCommand) 
	{
		//Don't decode the callbackId into a func when on a different interpreter!
		var apiURL = null;
		if(jsonCommand && jsonCommand.hasOwnProperty("apiURL") ) {
			apiURL = jsonCommand["apiURL"];

			var apiPieces = apiURL.split(".");
			var curPackage = require("NGCore/Client/Social/_Internal/Privileged").Social;
			
			exports._dispatchHelper(curPackage, apiPieces, jsonCommand);
		}
		else {
			NgLogE("Someone called GameService without the proper parameters.\n");
		}
	},
	setVerboseLogging:function(useVerbose)
	{
		RouterVerbose = useVerbose;
	}
});
/** @protected */
exports._dispatchHelper = function(curPackage, apiPieces, jsonCommand){
	var nibble;
	var handedOwnership = false;
	
	while(apiPieces.length && !handedOwnership)
	{
		if (curPackage.dispatchCommand){
			curPackage.dispatchCommand(apiPieces, jsonCommand);
			handedOwnership = true;
		}
		else if (curPackage.hasOwnProperty((nibble = apiPieces.shift()))) {
			try {
				curPackage = curPackage[nibble];
			}
			catch (e){
				NgLogException(e);
			}
		}
		else {
			//Total Fail
			NgLogE("Cannot find namespace " + jsonCommand.apiURL + " in GameService");
			curPackage = null;
			break;
		}
	}

	if(!handedOwnership && curPackage && typeof curPackage == "function" ) {
		try {
			curPackage(jsonCommand);
		} catch(gsException) {
			NgLogException(gsException);
		}

		return; //done dispatching!
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] = exports; 
var __dirname = 'NGCore/Client/Social/_Internal';
var __filename = 'NGCore/Client/Social/_Internal/RouterInit.js';

var Router = require('NGCore/Client/Social/_Internal/_Router').Router;
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

//Generate 1 instance of our router now and treat as the global instance!
GSGlobals.setRouterInstance(new Router());; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/DataModel.js';

var MessageEmitter = require("NGCore/Client/Core/MessageEmitter").MessageEmitter;
var SocialR = require("NGCore/Client/Social");
var SessionR        = require("NGCore/Client/Social/US/Data/Session");
var DispatcherR     = require("NGCore/Client/Social/US/Data/Dispatcher");

/**
 * <code>DataModel</code> constructs objects that emit messages when properties of an object change, and provides automatic caching,
 * serialization and deserialization between interpreters. 
 * <br/><br/>
 * <b>Note:</b> Do not instantiate this class directly. Use classes derived from <code>DataModel</code> for instantiation. These include:
 * <ul>
 * <li>{@link Social.US.User}</li>
 * <li>{@link Social.US.AppData}</li>
 * <li>{@link Social.US.Game}</li>
 * <li>{@link Social.US.Score}</li>
 * <li>{@link Social.US.Leaderboard}</li>
 * </ul>
 * @class 
 * @name Social.US.DataModel
 */
var DataModel = exports.DataModel = MessageEmitter.subclass({
		
	/**
	 * The default constructor.
	 * @constructs
	 * @private
	 */		
	initialize: function(recordID){
		this.recordID = recordID;

		this._cache();
	},
	beginChanges: function(){
		DispatcherR.Dispatcher.beginBatching();
	},
	endChanges: function(){
		DispatcherR.Dispatcher.endBatching();
	},
	_classname: function(){
		var classname = this.classname;
		return classname;
	},
	_cache: function(){
		if(!this._dataCache){
			var session = SessionR.Session.getCurrentSession();
			if(session){
				var cache = session.dataCache();
				if(cache){
					cache.addObject(this);
					this._dataCache = cache;
				}
			}
		}
		return this._dataCache;
	},
	$_serializedDataModel: function(obj){
		if(obj instanceof(DataModel)){
			obj = {
				classname: obj.classname,
				recordID:  obj.recordID
			};
		}
		return obj;
	},
	$_deserializedDataModel: function(value, cache){
		if(value && value.hasOwnProperty && value.hasOwnProperty("classname") && value.hasOwnProperty("recordID")){
			var theClassname = value.classname;
			var theClass = SocialR.Social.US[theClassname];
			var theRecordID = value.recordID;
			if(theClass && theRecordID){
				var theInstance = cache.getObjectWithRecordID(theClassname, theRecordID);
				if(!theInstance){
					theInstance = new theClass(theRecordID);
				}
				
				theInstance._deserializeFromHash(value.data);
				cache.addObject(theInstance);
    
				value = theInstance;
			}
		}
		return value;
	},
	_serializedHash: function(full){
		var theClass = this.constructor;
		var hash = {classname: theClass.classname, recordID: this.recordID};
		if(full === false){
			return hash; // if it's undefined, assume we want all the data
		}
		
		hash.data = {};
		
		var properties = this.constructor.properties || [];
		for(var idx = 0; idx < properties.length; idx++){
			var propertyName = properties[idx];
			var propertyValue = this[propertyName];

			if(propertyValue instanceof(Array)){
				for(var propertyIndex = 0; propertyIndex < propertyValue.length; propertyIndex++){
					propertyValue[propertyIndex] = DataModel._serializedDataModel(propertyValue[propertyIndex]);
				}
			}else{
				propertyValue = DataModel._serializedDataModel(propertyValue);
			}
			
			hash.data[propertyName] = propertyValue;
		}
		
		return hash;
	},
	_deserializeFromHash: function(data){
		if(!data){
			NgLogD("No public hash data for " + this.classname + " " + this.recordID);
			return;
		}
		
		var cache = this._cache();
		for(var key in data){
			var value = data[key];
			if(value instanceof(Array)){
				for(var propertyIndex = 0; propertyIndex < value.length; propertyIndex++){
					value[propertyIndex] = DataModel._deserializedDataModel(value[propertyIndex], cache);
				}
			}else{
				value = DataModel._deserializedDataModel(value, cache);
			}
			this[key] = value;
		}
	}
});

DataModel._oldSubclass = DataModel.subclass;
DataModel.subclass = function(contents){
	var theClass = DataModel._oldSubclass(contents);
	var properties = contents.properties || [];
	for(var idx = 0; idx < properties.length; idx++){
		var propertyName = properties[idx];
		
		(function(name){
			theClass.prototype.__defineSetter__(name, function(value){
				this["___" + name] = value;
				
				var msg = {};
				msg[""+name] = value;
				
				this.emit(msg);
			});
			theClass.prototype.__defineGetter__(name, function(value){
				return this["___" + name];
			});
		})(propertyName);
	}
	return theClass;
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Friends'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Friends'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Friends'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/Friends.js';

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

var MessageEmitter = require("NGCore/Client/Core/MessageEmitter").MessageEmitter;

var DataModelR = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
 * @class 
 * @name Social.US.Service.Friends
 */
var Friends = exports.Friends = DataModelR.DataModel.subclass({
    classname: "Friends"
});

/**
 * Opens the "Find Friends" view.
 *
 * @name Social.US.Service.Friends.showFindFriends
 * @function
 * @static
 *
 * @param {String} [selectedTab] Takes an optional tab reference.
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */		
Friends.showFindFriends = function(selectedTab) {
		NgLogD("Public call showFindFriends");
	
		var cmd = {
			apiURL:"US.Service.Friends.showFindFriends"
		};
		
		if(selectedTab){
            cmd.data = {};
			cmd.data.tab = selectedTab;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
};

/**
 * Shows the "Friend Picker" view.
 * 
 * @name Social.US.Service.Friends.showFriendPicker
 * @function
 * @static
 * 
 * @param maxFriendsToPick The maximum number of friends to pick. <code>0</code> for unlimited.
 * @cb {Function} callback The function to call after opening the Friend Picker view.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} [error.description] A description of the error.
 * @cb-param {String} [error.errorCode] A code identifying the error type.
 * @cb-param {String[]} users The user IDs of the selected users. 
 * @cb-returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */		
Friends.showFriendPicker = function(maxFriendsToPick, callback) { 
    Dispatcher.callClassMethodOnRemoteObject(Friends, "showFriendPicker", [maxFriendsToPick, callback]);
};

/**
* <code>Social.US.Service.Friends</code> has an invited user message emitter. 
* To add a message listener to the message emitter, see the example below.
*
* @name Social.US.Service.Friends.invitedUserEmitter
* @field
* @example
* 
* Social.US.Service.Friends.invitedUserEmitter.addListener(
*				new Core.MessageListener(), 
*				function(user){ 
*				// do sth. w/ User object 
*				}
* Social.US.Service.Friends.invitedUserEmitter.emit({user: user});
* @see Core.MessageListener
* @see Core.MessageEmitter
* @returns {void}
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
Friends.invitedUserEmitter = new MessageEmitter();; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Profile'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Profile'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Profile'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/Profile.js';

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class
 * @name Social.US.Service.Profile
 */

exports.Profile = {
	
	/**
	 * Shows the user profile of the user specified by the <code>userOrGamertag</code> parameter.
	 * 
	 * @name Social.US.Service.Profile.showUserProfile
	 * @function
	 * @public
	 * 
	 * @param userOrGamertag Identifies the user or gamertag corresponding to the user profile.
	 * @param tab Specifies the name of the tab to show when the UI opens. If <code>null</code>, it opens the default tab.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */			
	showUserProfile:function(userOrUserGamertag,tab){		
		var cmd = {
			apiURL:"US.Service.Profile.showUserProfile", 
			data:{
				user:userOrUserGamertag
			}
		};
		if(tab){cmd.tab = tab;}
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/OrderedList.js';

var Dispatcher = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
 * @class 
 * @name Social.US.OrderedList
 * @description
 * Do not instantiate <code>OrderedList</code> objects directly. This description is for information purposes only. 
 * <code>DataModel</code> subclasses that return <code>OrderedList</code> interfaces include:<br/><br/>
 * <ul>
 * <li>{@link Social.US.User}</li>
 * <li>{@link Social.US.Leaderboard}</li>
 * </ul><br/>
 * Some <code>DataModel</code> subclasses can return an <code>OrderedList</code>,
 * which is an interface for iterating over a range of values. You determine the iteration range by
 * selecting one of three common functions: <br/><br/>
 * <ul>
 * <li><code>forAll(iterCb, doneCb):</code> Iterates over all values.</li>
 * <li><code>forRange(start, count, iterCb, doneCb):</code> Iterates from the starting index to the count.</li>
 * <li><code>forItem(index, iterCb, doneCb):</code> Iterates over a particular item given by its index.</li>
 * </ul>
 * Each of the functions calls an iteration callback (iterCb) for every available item. 
 * When the function iterates over all items or an error occurs, it calls the done callback (doneCb). You <b>MUST</b> provide both callbacks.
 * <br/><br/>
 * <b>Note:</b> The <code>OrderedList</code> interface invokes an iterator on the server. Do NOT assume it will execute your callback functions immediately.
 *
 * @example
 * //NOTE: You MUST provide both callback functions.
 * userBuddiesList.forAll( 
 *      function(error, details){//per item cb body}, 
 *      function(error, details){//done cb body}
 * );
 *
 * @example
 * //Callback examples
 * var done = false;
 * var err = null;
 *
 * currentUser.getFriendsList().forAll(
 *          function(continueCb, user, index){
 *				if(user == otherUser){
 *					foundBuddy = true;
 *					continueCb(false);
 *				}else{
 *					continueCb(true);
 *				}
 *			}, 
 *          function(error){
 *                  if (!error){
 *                      done = true;
 *                   } else {
 *                      err = error;
 *                   }
 *          }
 * );
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
var OrderedList = {

    /**
    * Returns a public interface for an object.
    * 
    * To expose a privelegee ordered list of a <code>DataModel</code> object in the public interface, 
    * add a function to the object of the corresponding <code>DataModel</code>
    * subclass in the public interface.
    * @example
    * getFollowersList: function(cb){
 	* 	return OrderedList.getObjectPublicInterface(this, "getFollowersList", "_followersListInterface");
	* },
    *
    * @name Social.US.OrderedList.getObjectPublicInterface
    * @function    
    * @private
    *
    * @param {Object} ownerObject The object that will "own" the public interface.
    * @param {Function} getListFn The function that returns a list of values to the <code>OrderedList</code>.
    * @param interfaceName The name of the interface.
    *
    * @return {Social.US.OrderedList} The public interface.
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
    getObjectPublicInterface: function(ownerObject, getListFn, interfaceName) {
		if(ownerObject[interfaceName]) {
			return ownerObject[interfaceName];
		}
		
		var args = Array.apply(null, arguments);
		if(args && args.length > 3){
			args.splice(0, 3);
		}else{
			args = [];
		}
		
		var newInterface = {
			forAll: function(perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forAll"], [args,[perItemCb, doneCb]]);		
			},
			forRange: function(start, count, perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forRange"], [args,[start, count, perItemCb, doneCb]]);
			},
			forItem: function(index, perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forItem"], [args,[index, perItemCb, doneCb]]);
			}
		};
		
		ownerObject[interfaceName] = newInterface;
		
		return newInterface;
	},

    /**
    * Returns a public interface for a class.
    * To expose a priveleged ordered list of a <code>DataModel</code> subclass in the public interface, 
    * add a function to the subclass of the corresponding <code>DataModel</code>
    * subclass in the public interface.
    * @example
    * getFollowersList: function(cb){
 	* 	return OrderedList.getClassPublicInterface(this, "getFollowersList", "_followersListInterface");
	* },    
    *
    * @name Social.US.OrderedList.getClassPublicInterface
    * @function
    * @private
    *
    * @param {Object} owner The owner of the the public interface.
    * @param {Function} getListFn The function to call on each iteration.
    * @param interfaceName The name of the interface.
    * 
    * @return {Social.US.OrderedList} The public interface.
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
    getClassPublicInterface: function(owner, getListFn, interfaceName) {
		if(owner[interfaceName]) {
			return owner[interfaceName];
		}
		
		var newInterface = {
			forAll: function(perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forAll"], [[],[perItemCb, doneCb]]);
			},
			forRange: function(start, count, perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forRange"], [[],[start, count, perItemCb, doneCb]]);
			},
			forItem: function(index, perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forItem"], [[],[index, perItemCb, doneCb]]);
			}
		};
		
		owner[interfaceName] = newInterface;
		
		return newInterface;
	}
};

exports.OrderedList = OrderedList;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/User'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/User'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/User'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/User.js';

var DataModelR  = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher  = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;
var OrderedList = require("NGCore/Client/Social/US/Models/OrderedList").OrderedList;
var Social      = require("NGCore/Client/Social").Social;

/**
* <code>User</code> constructs objects that provide a service interface for the current user. 
* <code>User</code> objects enable the current user to retrieve:
* <ul>
* <li>user details</li>
* <li>a list of friends</li>
* <li>games</li>
* </ul>
* @class
* @name Social.US.User
* @augments Social.US.DataModel
*/
var User = exports.User = DataModelR.DataModel.subclass({
		
    /**
    * @constructs
    * @ignore
    */
	classname: "User",

	 /**
	 * The user's gamer tag. Read-only.
	 * @name Social.US.User.gamertag
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The user's avatar ID. Read-only.
	 * @name Social.US.User.avatarId
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's motto. Read-only.
	 * @name Social.US.User.motto
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The relation to this user. Read-only.
	 * @name Social.US.User.relation
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Sparse limits attributes in search results. Read-only.
	 * @name Social.US.User.sparse
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's photo ID. Read-only.
	 * @name Social.US.User.photoId
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's email address. Read-only.
	 * @name Social.US.User.emailAddress
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A hash of the user's email address. Read-only.
	 * @name Social.US.User.emailHash
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's phone number. Read-only.
	 * @name Social.US.User.phoneNumber
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */


	 /**
	 * The user's password. Read-only.
	 * @name Social.US.User.password
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's first name. Read-only.
	 * @name Social.US.User.firstName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */


	 /**
	 * The user's last name. Read-only.
	 * @name Social.US.User.lastName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Whether to hide the user's full name. Read-only.
	 * @name Social.US.User.hideFullName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * Whether the user is age restricted. Read-only.
	 * @name Social.US.User.ageRestricted
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the relationship to the user is new. Read-only.
	 * @name Social.US.User.isNewRelationship
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the user is a mutual friend. Read-only.
	 * @name Social.US.User.isMutualFriend
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the user shows his/her presence. Read-only.
	 * @name Social.US.User.showsPresence
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * Whether the user only shows friend notifications. Read-only.
	 * @name Social.US.User.setOnlyShowFriendNotifications
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's capabilities. Read-only.
	 * @name Social.US.User.capabilities
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's gamer score. Read-only.
	 * @name Social.US.User.gamerscore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's gamer level. Read-only.
	 * @name Social.US.User.gamerLevel
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's gamer level name. Read-only.
	 * @name Social.US.User.gamerLevelName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The gamer level score. Read-only.
	 * @name Social.US.User.gamerLevelScore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The gamer score for the next level. Read-only.
	 * @name Social.US.User.gamerNextLevelScore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's games. Read-only.
	 * @name Social.US.User.games
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	properties: [
		// public
		"gamertag",
		"avatarId",
		"motto",
		"relation",
		"sparse",
		"photoId",
		"emailHash",
		"ageRestricted",
		"isMutualFriend",
		
		// private
		"phoneNumber",
		"password",
		"firstName",
		"lastName",
		"hideFullName",
		"emailAddress",
		"isNewRelationship",
		"showsPresence",
		"onlyShowFriendNotifications",
        "allowFriendPostsOnly",
		"capabilities",
		"gamerscore",
		"gamerLevel",
		"gamerLevelName",
		"gamerLevelScore",
		"gamerNextLevelScore",
		"games"
	],
	
	/**
	 * @constructs The default constructor constructs <code>User</code> objects.
	 * @name Social.US.User.initialize 
	 * @private
	 */
	initialize: function($super, recordID){
		$super(recordID);
		NgLogD("User Public! " + recordID + " " + this.recordID);
	},
	
	
	/**
	* Adds a user to the buddies list and ensures the added user is not on the blocked users list.
	* @name Social.US.User.addBuddy
	* @function
	* @private
	*
	* @param {Social.US.User} buddy The user to add to the buddies list. If not a user, the callback error is "No user."
	* @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var buddyData = data;
    * &nbsp;&nbsp;  }
	* }
	* </pre>
	* @returns {void}
	*/	
	addBuddy: function(buddy, cb){
		Dispatcher.callMethodOnRemoteObject(this, "addBuddy", [buddy, cb]);
	},
	
	
	/**
	* Removes a user from the buddies list.
	* @name Social.US.User.removeBuddy
	* @function
	* @private
	*
	* @param {User} buddy The user to remove from the buddies list. If not a user, the callback error is "No user."
	* @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var buddyData = data;
    * &nbsp;&nbsp;  }
	* }
	* </pre>
	* @returns {void}
	*/		
	removeBuddy: function(buddy, cb){
		Dispatcher.callMethodOnRemoteObject(this, "deleteBuddy", [buddy, cb]);
	},
	ignoreBuddy: function(buddy, cb){
		Dispatcher.callMethodOnRemoteObject(this, "ignoreBuddy", [buddy, cb]);
	},
	/**
	 * Retrieves a user object with all of the user's details.
	 *
	 * @name Social.US.User.getUserDetails
	 * @function
	 * 
	 * @cb {Function} cb The function to call after retrieving the user's details.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
 	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Social.US.User} user Detailed information about the user.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */			
	getUserDetails: function(cb){
		Dispatcher.callMethodOnRemoteObject(this, "getUserDetails", [cb]);		
	},
	
	/**
	* Retrieves an ordered list of the user's friend requests on Mobage.
	* @name Social.US.User.getMobageFriendRequestLists
	* @function
	*
	* @returns {Social.US.OrderedList} A list of the user's friend requests.
    * @example
    * var myMobageFriendRequests = userA.getMobageFriendRequestsList();
    * @see Social.US.OrderedList
	*/			
	getMobageFriendRequestsList: function(){
		return OrderedList.getObjectPublicInterface(this, "getInvitesList", "_followersListInterface");
	},
	
	/**
	* Returns the user's friends list on Mobage.
	* @name Social.US.User.getMobageFriendsList
	* @function
	*
	* @returns {Social.US.OrderedList} The user's friend list on Mobage.
    * @example
    * var myMobageFriendsList = userA.getMobageFriendsList();
    * @see Social.US.OrderedList
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	getMobageFriendsList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFriendsList", "_friendsListInterface");
	},
	
	/**
	* Returns the user's blocked user list.
	* @name Social.US.User.getMobageBlockedUserList
	* @function
	*
	* @returns {Social.US.OrderedList} The user's blocked user list on Mobage.
	* @see Social.US.OrderedList
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	getMobageBlockedUserList: function(){
		return OrderedList.getObjectPublicInterface(this, "getBlockedUserList", "_enemyListInterface");
	},
	
	/**
	* Returns the user's games list.
	* @name Social.US.User.getOwnedGamesList
	* @function
	*
	* @returns {Social.US.OrderedList} The user's Mobage game list.
    * @example
    * var myGamesList = userA.getOwnedGamesList();
    * @see Social.US.OrderedList
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/			
	getOwnedGamesList: function(){
		return OrderedList.getObjectPublicInterface(this, "getOwnedGamesList", "_ownedGamesListInterface");
	},
	
	/**
	* MAX: TODO: DOCUMENT
	* returns achievements list for current game for this user
	*/			
	getAchievementsList: function(){
		return OrderedList.getObjectPublicInterface(this, "getAchievementsList", "_achievementsListInterface");
	},

	/**
	* Returns the list of "featured" users.
	* @name Social.US.User.getFeaturedUsersList
	* @function
	*
	* @returns {Social.US.OrderedList} The list of "featured" users.
    * @example
    * var mobageFeaturedUsers = userA.getFeaturedUsersList();
    * @see Social.US.OrderedList
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/	
	getFeaturedUsersList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFeaturedUsersList", "_featuredUsersListInterface");
	},

	/**
	* Invites the user to the current game.
	* @name Social.US.User.inviteToCurrentGame
	* @function
	* @cb {Function} cb The function to call after inviting the user to the current game.
	* @cb-param {Object} error Information about the error, if any.
 	* @cb-param {String} [error.description] A description of the error.
 	* @cb-param {String} [error.errorCode] A code identifying the error type.
	* @cb-returns {void}
 	* @returns {void}
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	inviteToCurrentGame: function(cb){
		var user = this;
		Dispatcher.callMethodOnRemoteObject(this, "inviteToCurrentGame", [function(err){
			if(!err){
				Social.Common.Service.invitedUserEmitter.emit({userId: user.recordID});
				Social.US.Service.Friends.invitedUserEmitter.emit({user: user});
			}
			cb.apply(this, Array.apply(null, arguments));
		}]);		
	},
	
	/**
	 * Send a Push notification to this user through the GameService back end.
	 * @name Social.US.User.sendNotificationToUser
	 * @function
	 *
	 * @param {Alert Text} alertText The displayed message when the push is received.
	 * @param {Badge ID} badgeId Badge displayed on the push.
	 * @param {Sound} sound Sound played when push is received.
	 * @param {Extra Data} extraData Additional payload.
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	sendNotificationToUser: function(alertText, badgeId, sound, extraData) {
		Dispatcher.callMethodOnRemoteObject(this, "sendNotificationToUser", [alertText, badgeId, sound, extraData]);
	},

    /**
     * Adds a user to the current user's friend list for the current game. Implies a one-directional relationship or "follower" model.
     * Takes an optional group parameter to add the user to a particular group. Current user can only 
     * add the user to one group. If the current user adds the user to a second group in the friend list, 
     * the user is moved from the first group.
     *
     * A group is an arbitrary classification of friends. The <code>group</code> parameter is a string, which 
     * takes the name of the group. You may allow users to manage their own groups, create game-level groups, 
     * or omit groups altogether. A user may only reside in one group of another user's friend list.<br /><br />
     * <b>Note:</b> This is part of the Game Graph API. 
     *
     * @example
     * //Retrieve a user and set up a follower relationship.
     * var userA = Social.US.User; 
     * Social.US.User.getUserWithGamertag("chuck", function(error, user){
     *   if(!user) {
     *       var errorCode = error.errorCode;
     *       var errorDesc = error.description;
     *   } else {
     *        userA = user;
     *   }
     * });
     * var userB = Social.US.Session.getCurrentSession().user();
     * userB.addFriend(userA, callback);
     * //...
     * @example
     * //To make the relationship bi-directional, 
     * //you must make the same call for the other user.
     * userA.addFriend(userB, callback);
     *
     * @name Social.US.User.addFriend
     * @function
     *
     * @param {Social.US.User} user The user to add to the current user's friend list. If <code>null</code>, <code>undefined</code> or not a 
     * <code>Social.US.User</code> object, the callback error is "No user."
     * @param {String} [group] An optional parameter for adding the friend into a group within the friend list.
     * @cb {Function} cb The function to call after adding a user to the current user's friend list.
 	 * @cb-param {Object} error Information about the error, if any.
 	 * @cb-param {String} [error.description] A description of the error.
 	 * @cb-param {String} [error.errorCode] A code identifying the error type.
     * @cb-param {Object} data Information about the user.
     * @cb-returns {void}
     * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */	
	addFriend: function(user, group, cb){
		if(typeof arguments[1] == "function" && !arguments[2]){
			cb = arguments[1];
			group = undefined;
		}
		Dispatcher.callMethodOnRemoteObject(this, "addGameFriend", [user, group, cb]);
	},

    /**
     * Removes a user from the current user's friend list for the current game.<br /><br />
     * Does not require a group parameter, friends are only associated to one group in a friend list.
     * @name Social.US.User.removeFriend
     * @function
     *
     * @param {Social.US.User} user The user to remove from the current user's friend list. If <code>null</code>, <code>undefined</code> or not a 
     * <code>Social.US.User</code> object, the callback error is "No user."
     * @cb {Function} cb The function to call after removing a user from the current user's
     *                   friend list.
 	 * @cb-param {Object} error Information about the error, if any.
 	 * @cb-param {String} error.description A description of the error.
 	 * @cb-param {String} error.errorCode A code identifying the error type.
     * @cb-param {Object} data Information about the user.
     * @cb-returns {void}
     * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */		
	removeFriend: function(user, cb){
		Dispatcher.callMethodOnRemoteObject(this, "removeGameFriend", [user, cb]);
	},
	
	report: function(reason, cb){
		Dispatcher.callMethodOnRemoteObject(this, "report", [reason, cb]);
	},

    /**
	 * Returns the user's friend list for the current game. If you specify the <code>group</code>
	 * parameter, this call only returns friends within the group.<br /><br />
	 * <b>Note:</b> This is part of the Game Graph API.
	 * @name Social.US.User.getFriendsList
	 * @function
	 *
	 * @param {String} group If specified, returns only friends in the group.
	 * @returns {Social.US.OrderedList} The user's friend list for the current game.
	 * @example
	 * var myFriendsList = userA.getFriendsList ("Best Buddies");
	 * @see Social.US.OrderedList
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	getFriendsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-friends-" + group ) : "_gameFriendsList-friends"), "friends", group);
	},


    /**
    * Returns the user's mutual friends.
    * Mutual friends result when two users add each other to their respective friend list.<br /><br />
    * <b>Note:</b> This is part of the game graph API.
    * @name Social.US.User.getMutualFriendsList
    * @function
    *
    * @param {String} group The group within the friend list. If specified, returns only mutual friends within the group.
    * @returns {Social.US.OrderedList} The user's mutual friend list.
    * @example
    * userA.addFriend(userB);
    * userB.addFriend(userA);
    * var myMutualFriends = userA.getMutualFriendsList();
    * //userA appears in userB's mutual friends list, 
    * //because they are in each other's friend lists.
    * @see Social.US.OrderedList
    * @status iOS, Android, Test, iOSTested, AndroidTested    
    */	
	getMutualFriendsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-mutual-" + group) : "_gameFriendsList-mutual"), "mutual", group);
	},


    /**
    * Returns the user's friend requests list. If the <code>group</code> parameter is specified, returns
    * only friends within the group.
    * @name Social.US.User.getFriendRequestsList
    * @function
    *
    * @param {String} group The group within the friend request list.
    * @returns {Social.US.OrderedList} The user's friend requests list.
    * @example
    * var myFriendRequestsList = userA.getFriendRequestsList ();
    * @see Social.US.OrderedList
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */	
	getFriendRequestsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-invitation-" + group) : "_gameFriendsList-invitation"), "invitation", group);
	},

	/**
	* Updates the email address for the current user.
	* @name Social.US.User.setEmailAddress
	* @function
	* @private
	*
	* @param {String} newAddress The email address for the current user.
	* @param {Function} cb The callback function if an error occurs (for example, invalid email address format).
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setEmailAddress:function(newAddress,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setEmailAddress", [newAddress, cb]);
	},
	
	/**
	* Sets whether the current user will receive notifications from other Mobage users or just from Mobage friends.
	* @name Social.US.User.setOnlyShowFriendNotifications
	* @function
	* @private
	*
	* @param {Boolean} isFriendsOnly Set to <code>true</code> if the current user will only receive notifications from Mobage users who are also Mobage friends. 
    * If set to <code>false</code>, the user receives notifications from all Mobage users. 
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setOnlyShowFriendNotifications:function(isFriendsOnly,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setOnlyShowFriendNotifications", [isFriendsOnly, cb]);
	},
	
	/**
	* Sets whether the current user will receive game news and updates from Mobage.
	* @name Social.US.User.setOptsIn
	* @function
	* @private
	*
	* @param {Boolean} optIn Set to <code>true</code> if the current user will receive news and updates from Mobage. 
    * If set to <code>false</code>, the user will not receive news or updates from Mobage. 
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setOptsIn:function(optIn,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setOptsIn", [optIn, cb]);
	},

    /**
	* Sets whether the current user can receive wall post messages from other Mobage users or just from Mobage friends.
	* @name Social.US.User.setAllowFriendPostsOnly
	* @function
	* @private
	*
	* @param {Boolean} isFriendsOnly Set to <code>true</code> if the current user can only receive wall post messages from Mobage users who are also Mobage friends.
    * If set to <code>false</code>, the user can receive wall post messages from all Mobage users.
	* @param {Function} cb The callback function if an error occurs.
	* <br/>
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status ?
	*/
	setAllowFriendPostsOnly:function(isFriendsOnly,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setAllowFriendPostsOnly", [isFriendsOnly, cb]);
	},

	/**
	* Sets a motto for the current user. In other words, the user's "about me" text string.
	* @name Social.US.User.setMotto
	* @function
	* @private
	*
	* @param {String} motto The motto for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setMotto:function(motto,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setMotto", [motto, cb]);
	},
	
	/**
	* Updates the first name for the current user.
	* @name Social.US.User.setFirstName
	* @function
	* @private
	*
	* @param {String} firstName The first name for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setFirstName:function(firstName,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setFirstName", [firstName, cb]);
	},
	
	/**
	* Updates the last name for the current user.
	* @name Social.US.User.setLastName
	* @function
	* @private
	*
	* @param {String} lastName The last name for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setLastName:function(lastName,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setLastName", [lastName, cb]);
	},
	

	/**
	* Sets a password for the current user.
	* @name Social.US.User.setPassword
	* @function
	* @private
	*
	* @param {String} password The password for the current user.
    * @param {String} confirmation The password confirmation for the current user.
	* @param {Function} cb The callback function if an error occurs. For example, password does not meet requirements; password and confirmation do not match, and so on.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setPassword:function(password,confirmation, cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setPassword", [password, confirmation, cb]);
	},

	/**
	* Sets whether the target user is in the logged-in user's blocked user list.
	* @name Social.US.User.setBlocked
	* @function
	* @private
	*
	* @param {Social.US.User} user The user that is the subject of blocking or unblocking.
    * @param {Boolean} blocked Whether the current user blocks the specified user. If <code>true</code>, the specified user is blocked.
    	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setBlocked:function(blocked, cb){
		Dispatcher.callMethodOnRemoteObject(this, "setBlocked", [blocked, cb]);
	},
	
	/**
	 * Gets the origin of the user's registration.
	 * Mobage records the origin of a user's registration. The "origin" may be the name of an alliance partner.
	 * The origin is typically used as a means of tracking revenue sharing events, such as the promotional activity 
	 * of an alliance partner that attracts new users to Mobage and thereby entitles the alliance partner 
	 * to share in revenue generated by the application.  
	 *
	 * @name Social.US.User.getOriginOfRegistration
	 * @private
	 * @static
	 * @function
	 *
	 * @param {Function} cb The callback function returns the origin of registration, or an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, originOfRegistration){
	 *     if(!originOfRegistration) {
	 *          var errorCode = error.errorCode;
	 *          var errorDesc = error.description;
	 *     } else {
	 *          var origin = originOfRegistration;
	 *     }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getOriginOfRegistration: function(cb) {
		Dispatcher.callMethodOnRemoteObject(this, "getOriginOfRegistration", [cb]);
	}
});

User.GamertagKey = "gamertag";
User.AvatarKey = "badge_id";
User.MottoKey = "motto";
User.RelationKey = "relation";
User.FirstNameKey = "first_name";
User.LastNameKey = "last_name";
User.BirthdateKey = "birth_date";
User.GenderKey = "gender";
User.PrivacyKey = "fullname_privacy";
User.PhotoKey = "photo_url";
User.EmailAddressKey = "email";
User.EmailHashKey = "email_hash";
User.PhoneNumberKey = "phone_number";
User.AgeRangeKey = "age_restricted";
User.SpamKey = "opt_in";

User.PasswordKey = "password";
User.PasswordConfirmKey = "password_confirmation";
User.GamesKey = "games";
User.CapabilitiesKey = "capabilities";
User.NewBuddyKey = "new_buddy";
User.IsMutualFriendKey = "mutual_friends";
User.HidePresenceKey = "hide_presence";
User.OnlyShowFriendNotificationsKey = "friend_only_notification";
User.AllowFriendPostsOnly = "friend_only_wallpost";

User.GamerScoreKey = "gamerscore";
User.LevelNumberKey = "level_position";
User.LevelNameKey = "level_name";
User.CurrentLevelScoreKey = "level_points";
User.NextLevelScoreKey = "level_next_points";

// properties that are not returned in sparse search results
User.NonSparseKeys = [User.PhotoKey, User.EmailAddressKey,
User.EmailHashKey, User.PhoneNumberKey, User.PasswordKey,
User.FirstNameKey, User.LastNameKey, User.PrivacyKey,
User.NewBuddyKey, User.CapabilitiesKey, User.HidePresenceKey,
User.OnlyShowFriendNotificationsKey, User.AllowFriendPostsOnly, User.GamerScoreKey,
User.LevelNumberKey, User.LevelNameKey, User.CurrentLevelScoreKey,
User.NextLevelScoreKey, User.GamesKey];


/**
 * Retrieves the user corresponding to the <code>userID</code> parameter.
 * @name Social.US.User.getUserWithID
 * @static
 * @function
 * 
 * @param {String} userID The ID for the user.
 * @cb {Function} cb The function to call after retrieving the user.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} [error.description] A description of the error.
 * @cb-param {String} [error.errorCode] A code identifying the error type.
 * @cb-param {Social.US.User} user Detailed information about the user.
 * @cb-returns {void}
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */	
User.getUserWithID = function(userID, cb){
	Dispatcher.callClassMethodOnRemoteObject(User, "getUserWithID", [userID, cb]);
};

/**
 * Retrieves the user corresponding to the <code>gamertag</code> parameter.
 * @name Social.US.User.getUserWithGamertag
 * @static
 * @function
 * 
 * @param {String} gamertag The user's gamertag.
 * @cb {Function} cb The function to call after retrieving the user.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} [error.description] A description of the error.
 * @cb-param {String} [error.errorCode] A code identifying the error type.
 * @cb-param {Social.US.User} user Detailed information about the user.
 * @cb-returns {void}
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */	
User.getUserWithGamertag = function(gamertag, cb){
	Dispatcher.callClassMethodOnRemoteObject(User, "getUserWithGamertag", [gamertag, cb]);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/ButtonOverlays.js';

var Rect = require("NGCore/Client/UI/ViewGeometry").Rect;

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

var MessageEmitter = require("NGCore/Client/Core/MessageEmitter").MessageEmitter;

var Friends = require("NGCore/Client/Social/US/Service/Friends").Friends;
var Profile = require("NGCore/Client/Social/US/Service/Profile").Profile;
var User    = require("NGCore/Client/Social/US/Models/User").User;

/**
 * @class 
 * @name Social.US.Service.ButtonOverlays
 */
exports.ButtonOverlays = {
	/**
	* Displays the "Mobage Community" button.
	*	
	* @name Social.US.Service.ButtonOverlays.showCommunityButton
	* @function
	* @public 
	* 
	* @param {exports.Gravity} gravity Displays the button in the specified corner.
	* @param {Function} callback The callback function if there is an error related to <code>gravity</code> or <code>theme</code> usage.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @see exports.Gravity
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/   
	showCommunityButton: function(gravity, callback) {
		NgLogD("Public - showCommunityButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.showCommunityButton"
		};
		
		cmd.gravity = gravity = gravity || [0,0];
		if (( gravity[0] !== 0 && gravity[0] !== 1)
			|| ( gravity[1] !== 0 && gravity[1] !== 1) )
		{
			throw new Error("showCommunityButton: Illegal/Out-of-Bounds parameter: gravity "+JSON.stringify(gravity));
		}
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	* Hides the "Mobage Community" button.
	*
	* @name Social.US.Service.ButtonOverlays.hideCommunityButton
	* @function
	* @public 
	*	
	* @param {Function} callback The callback function if there is an error hiding the button.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/	
	hideCommunityButton: function(callback) {
		NgLogD("Public - hideCommunityButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.hideCommunityButton"
		};
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Shows the balance button.
	 * Shows the balance button where the <code>rect</code> parameter 
	 * determines the size and position of the button.
	 *
	 * @name Social.US.Service.ButtonOverlays.showBalanceButton
	 * @function
	 * @public
	 *	 
	 * @param {UI.ViewGeometry.Rect} rect Determines the size and position of the balance button.
	 * @param {Function} callback The callback function if there is an error with the <code>rect</code> parameter.
     * @param {String} sourcePage String for the Analytics class to event the originating transacting page.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
	 * </pre>
	 * @see UI.ViewGeometry.Rect
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	showBalanceButton: function(rect, callback, sourcePage) {
		NgLogD("Public - showBalanceButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.showBalanceButton"
		};
		
		if (rect != undefined) {
			cmd["rect"] = (new Rect(rect)).array(); //Rects Don't travel cleanly.
		} else {
			cmd["rect"] = undefined;
		}
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
		
		if(sourcePage != undefined) {
			cmd["sourcePage"] = sourcePage.toString();
		} else {
			cmd["sourcePage"] = "somewhere_game";
		}
	
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Hides the balance button.	
	 * @name Social.US.Service.ButtonOverlays.hideBalanceButton
	 * @function
	 * @public 
	 * 
	 * @param {Function} callback The callback function called after the view closes.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	hideBalanceButton: function(callback) {
		NgLogD("Public - hideBalanceButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.hideBalanceButton"
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
	
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Leaderboards'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Leaderboards'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Leaderboards'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/Leaderboards.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class
 * @name Social.US.Service.Leaderboards
 */

exports.Leaderboards = {
	
	/**
	 * Shows the leaderboards.
	 * 
	 * @name Social.US.Service.Leaderboards.showLeaderboards
	 * @function
	 * @public
	 * 
	 * @status un tested
	 */			
	showLeaderboards:function(){
		var cmd = {
			apiURL:"US.Service.Leaderboards.showLeaderboards"
		};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Service'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Service'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Service'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Service.js';

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

var MessageEmitter = require("NGCore/Client/Core/MessageEmitter").MessageEmitter;

var ButtonOverlays = require("NGCore/Client/Social/US/Service/ButtonOverlays").ButtonOverlays;
var Friends = require("NGCore/Client/Social/US/Service/Friends").Friends;
var Leaderboards = require("NGCore/Client/Social/US/Service/Leaderboards").Leaderboards;
var Profile = require("NGCore/Client/Social/US/Service/Profile").Profile;
var User    = require("NGCore/Client/Social/US/Models/User").User;

/**
 * This interface provides the following social game services:
 * <ul>
 * <li>Balance Button</li>
 * <li>Community Button</li>
 * <li>Friend Picker</li>
 * <li>User Finder</li>
 * <li>User Profile</li>
 * <li>Leaderboard</li>
 * </ul>
 * @class 
 * @name Social.Common.Service
 */
exports.Service = {

	/**
	* Opens the leaderboard screen.
	* Launches stand alone leaderboards over the game service with the games leaderboard data
	* @name Social.Common.Service.showLeaderboards
	* @function
	* @public
	* @returns {void}
	* @status not tested
    */
	showLeaderboards: function() {
		Leaderboards.showLeaderboards();
	},

	
	/**
	* Opens the user finder screen.
	* The user finder provides a way for users to find other users using the following filters:
	* <ul>
	* <li>Suggested Friends</li>
	* <li>Contacts</li> 
	* <li>Requests</li>
	* <li>Search</li>
	* </ul>
	*
	* @name Social.Common.Service.openUserFinder 
	* @function
	* @public
	* @returns {void}
	* @status iOS, Android, Test, iOSTested, AndroidTested
    */		
	openUserFinder: function() {
		Friends.showFindFriends(undefined);
	},

	
	/**
	 * Opens the friend picker.
	 *
	 * @name Social.Common.Service.openFriendPicker 
	 * @function
	 * @public 
	 * 
	 * @param {Number} maxFriendsToSelect The maximum number of friends the user may select.
	 * @cb {Function} callback The function to call after opening the friend picker.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String[]} friendUserIds The user IDs of the friends that were chosen.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	openFriendPicker: function(maxFriendsToSelect, callback) {
		Friends.showFriendPicker(maxFriendsToSelect, function(err, friends){
			var userIDs = [];
			friends = friends || [];
			for(var idx = 0; idx < friends.length; idx++){
				userIDs.push(friends[idx].recordID);
			}
			callback( userIDs );
		});
	},

	
	/**
	 * Opens the specified profile page.
	 *
	 * @name Social.Common.Service.openUserProfile 
	 * @function
	 * @public 
	 * 
	 * @param {String} userId The user ID or gamer name of the profile page to open.
	 * @cb {Function} callback The function to call after opening the profile page.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-returns {void}	 
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	openUserProfile: function(userId, callback) {
		if(typeof userId == "string"){
			// if the userId string contains no non-numeral characters:
			//   parse it into a number
			// else null it out, because it's not a valid userId
			if(userId.match(/[^0-9]/) === null){
				userId = parseInt(userId, 10);
			}else{
				userId = null;
			}
		}
		
		if( !userId ){
			callback({errorCode: 400, description: "userid is invalid"});
		}
		else{
			User.getUserWithID(userId, function(err, user){
				if(err){
					if( err==="Sorry, we can't find anyone with that name." ){
						callback({errorCode: 404, description: err});
					} else {
						callback({errorCode: 500, description: err});
					}
				}else if(!user){
					callback({errorCode: 404, description: "User not found"});
				}else{
					Profile.showUserProfile(user, undefined);
				}
			});
	}
	},


	/**
	 * Displays the <b>Mobage Community</b> button.
	 *	
	 * @name Social.Common.Service.showCommunityButton
	 * @function
	 * @public 
	 * 
	 * @param {UI.ViewGeometry.Gravity} gravity Displays the button in the specified corner. 
	 * <b>Note:</b> Only supported for the US. Japan uses the top-left corner only.
	 * @param {String} theme Displays the theme for the button (for example, "default", "dark", "light"). 
	 * <b>Note:</b> Only supported for Japan. You can specify <code>null</code> for the US region.
	 * @cb {Function} callback The function to call after displaying the Mobage Community button.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-returns {void}
	 * @see UI.ViewGeometry.Gravity
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */           
	showCommunityButton: function(gravity, theme, callback) {
		ButtonOverlays.showCommunityButton(gravity, callback);
	},

	/**
	 * Hides the <b>Mobage Community</b> button.
	 *
	 * @name Social.Common.Service.hideCommunityButton
	 * @function
	 * @public 
	 *	
	 * @cb {Function} callback The function to call after hiding the Mobage Community button.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	hideCommunityButton: function(callback) {
		ButtonOverlays.hideCommunityButton(callback);
	},

	
	/**
	* A message emitter object for adding a message emitter when inviting a user.
	*
	* @name Social.Common.Service.invitedUserEmitter
	* @field
	* @public
	* @example 
	* Social.Common.Service. ...
	* ... invitedUserEmitter.addListener(
	*			new Core.MessageListener(), 
	*			function(userId){
	*				NgLogD("New Emitter! " + userId);
	*			}
	*		);
	* @returns {void}
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	invitedUserEmitter : new MessageEmitter(),

	
	/**
	 * Shows the balance button where the <code>rect</code> parameter 
	 * determines the size and position of the button.
     * The minimum size of the button is:<br/>
     * <ul>
     * <li>10% of height in Landscape, and the absolute minimum size is 150 x 50.</li>
     * <li>6% of height in Portrait, and the absolute minimum size is 150 x 50.</li>
	 * </ul>
	 *
	 * @name Social.Common.Service.showBalanceButton
	 * @function
	 * @public
	 *	 
	 * @param {UI.ViewGeometry.Rect} rect Determines the size and position of the balance button.
	 * @cb {Function} callback The function to call after showing the balance button.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-returns {void}
	 * @param {String} sourcePage The originating page for the transaction. This value will be
	 *		displayed in your Analytics data.
	 * @see UI.ViewGeometry.Rect
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	showBalanceButton: function(rect, callback, sourcePage) {		
		ButtonOverlays.showBalanceButton(rect, callback, sourcePage);
	},
	
	/**
	 * Hides the balance button.	
	 * @name Social.Common.Service.hideBalanceButton
	 * @function
	 * @public 
	 * 
	 * @cb {Function} callback The function to call after hiding the balance button.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	hideBalanceButton: function(callback) {
		ButtonOverlays.hideBalanceButton(callback);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Analytics.js';

var SessionReq = require("NGCore/Client/Social/US/Data/Session");

/**
 * @private
 * @name Social.Common.Analytics
 * @description Private interface for analytics data
 *
 * TODO: These should be going into the priv interpreter. But need to check with Japan.
 */
exports.Analytics = {
  getUserId: function() {
	var cur_sess =	this._getSession(), cur_u = null;
	if (cur_sess) {
	  cur_u = (cur_sess.user() || {}).recordID;
	}
	return cur_u;
  },
  getUsername: function() {
	var cur_sess =	this._getSession(), cur_u = null;
	if (cur_sess) {
	  cur_u = (cur_sess.user() || {}).gamertag;
	}
	return cur_u;
  },
  getPlatformVersion: function() {
	var cur_sess =	this._getSession(), cur_pver = null;
	if (cur_sess) {
	  cur_pver = cur_sess.platformVersion();
	}
	return cur_pver;
  },
  getServiceId: function() { 
	return "US"; 
  },
  _getSession: function() {
	return SessionReq.Session.getCurrentSession();
  }
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Leaderboard'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Leaderboard'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Leaderboard'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Common';
var __filename = 'NGCore/Client/Social/US/Common/Leaderboard.js';

var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

/**
 * @class 
    * @name Social.Common.Leaderboard
 * @description
 * Mobage provides a Common API for updating and retrieving leaderboard information.
 * <br />
 * <code>Leaderboard</code> allows game to configure a collection of leaderboards through the
 * Developer Portal or via HTTP REST endpoints which are then subsequently accessed via this API.
 */
exports.Leaderboard = {

    /**
     * Retrieves information about the specified leaderboard. By default, only a limited amount of
     * information is retrieved. Use the <code>fields</code> parameter to retrieve additional
     * information.
     *
     * @name Social.Common.Leaderboard.getLeaderboard
     * @function
     * @public
     *
     * @param {String} leaderboardId The leaderboard ID of the leaderboard to retrieve.
     * @param {String[]} fields Additional fields to retrieve. For a complete list of available
     *		fields, see the properties of the callback function's <code>Leaderboard</code> parameter. The
     *		required properties of the <code>Leaderboard</code> parameter are retrieved by default.
     * @cb {Function} callback The function to call after retrieving information about the specified leaderboard.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} Leaderboard Information about the requested object.
	 * @cb-param {String} [leaderboard.id] Leaderboard identifier.
	 * @cb-param {String} [leaderboard.appId] The application ID associated with this Leaderboard.
	 * @cb-param {String} [leaderboard.title] The title of the leaderboard.
	 * @cb-param {String} [leaderboard.scoreFormat] The format of the <code>displayValue</code> in this leaderboard.
	 * @cb-param {Number} [leaderboard.scorePrecision] The decimal place value for the <code>displayValue</code> in this leaderboard.
	 * @cb-param {String} [leaderboard.iconUrl] The URL of the leaderboard icon.
	 * @cb-param {Boolean} [leaderboard.allowLowerScore] If true, the leaderboard will allow a user to post
     *      a lower score to this leaderboard.  If false, a user's preexisting higher score will NOT be replaced
     *      by an attempt to post a lower score.  This flag allows the developer to avoid "get and set if lower" logic.
	 * @cb-param {Boolean} [leaderboard.reverse] If true, lower scores are treated as more desirable.
     *      For example, in golf a lower score is more desirable.
	 * @cb-param {Boolean} [leaderboard.archived] Future enhancement field to archive a leaderboard.  Archived
     *      leaderboards will be readable but not writeable.  Currently this field always returns false.
	 * @cb-param {Number} [leaderboard.defaultScore] Default score value given to a user if no score attribute is
     *      specified in previous calls to <code>updateCurrentUserScore</code>.
	 * @cb-param {Date} [leaderboard.published] The date and time when this leaderboard was created.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 * @cb-param {Date} [leaderboard.updated] The date and time when this leaderboard was updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboards
	 * @see Social.Common.Leaderboard.getAllLeaderboards
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getLeaderboard("SanFranciscoGiants",
	 *                              ['id','title','scoreFormat', 'iconUrl'],
	 *                              function(error, leaderboard) {
     *                                  if (error) {
     *                                      // something went wrong
     *                                  }
     *                                  if (leaderboard) {
     *                                      console.log(leaderboard.title);
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getLeaderboard: function(leaderboardId, fields, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getLeaderboard", leaderboardIds:leaderboardId, fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Retrieves information about the specified leaderboards. By default, only a limited amount of
	 * information is retrieved about each leaderboard. Use the <code>fields</code> parameter to retrieve additional
	 * information.
	 *
	 * @name Social.Common.Leaderboard.getLeaderboards
	 * @function
	 * @public
	 *
	 * @param {String[]} leaderboardIds The leaderboard IDs of the leaderboards to retrieve.  This is provided as an
     *      an array of leaderboard IDs.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>Leaderboard</code> parameter. The
	 *		required properties of the <code>Leaderboard</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the specified leaderboards.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} Leaderboards Information about the requested leaderboard object or array of objects.
	 * @cb-param {String} [leaderboard.id] Leaderboard identifier.
	 * @cb-param {String} [leaderboard.appId] The application ID associated with this Leaderboard.
	 * @cb-param {String} [leaderboard.title] The title of the leaderboard.
	 * @cb-param {String} [leaderboard.scoreFormat] The format of the <code>displayValue</code> in this leaderboard.
	 * @cb-param {Number} [leaderboard.scorePrecision] The decimal place value for the <code>displayValue</code> in this leaderboard.
	 * @cb-param {String} [leaderboard.iconUrl] The URL of the leaderboard icon.
	 * @cb-param {Boolean} [leaderboard.allowLowerScore] If true, the leaderboard will allow a user to post
     *      a lower score to this leaderboard.  If false, a user's preexisting higher score will NOT be replaced
     *      by an attempt to post a lower score.  This flag allows the developer to avoid "get and set if lower" logic.
	 * @cb-param {Boolean} [leaderboard.reverse] If true, lower scores are treated as more desirable.
     *      For example, in golf a lower score is more desirable.
	 * @cb-param {Boolean} [leaderboard.archived] Future enhancement field to archive a leaderboard.  Archived
     *      leaderboards will be readable but not writeable.  Currently this field always returns false.
	 * @cb-param {Number} [leaderboard.defaultScore] Default score value given to a user if no score attribute is
     *      specified in previous calls to <code>updateCurrentUserScore</code>.
	 * @cb-param {Date} [leaderboard.published] The date and time when this leaderboard was created.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 * @cb-param {Date} [leaderboard.updated] The date and time when this leaderboard was updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboard
	 * @see Social.Common.Leaderboard.getAllLeaderboards
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getLeaderboards(["SanFranciscoGiants","TopPlayers"],
	 *                              ['id','title','scoreFormat', 'scorePrecision', 'reverse'],
	 *                              function(error, leaderboards) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  }
     *                                  for (var i in leaderboards) with ({leaderboard: leaderboards[i]}) {
     *                                      // stuff each item into leaderboard local variable
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    getLeaderboards: function(leaderboardIds, fields, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getLeaderboards", leaderboardIds:leaderboardIds, fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Retrieves information about all of the current user's game leaderboards. By default, only a limited amount of
	 * information about each leaderboard is retrieved. Use the <code>fields</code> parameter to retrieve additional
	 * information.
	 *
	 * @name Social.Common.Leaderboard.getAllLeaderboards
	 * @function
	 * @public
	 *
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>Leaderboard</code> parameter. The
	 *		required properties of the <code>Leaderboard</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the specified leaderboards.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} Leaderboards Information about the requested leaderboard object or array of objects.
	 * @cb-param {String} [leaderboard.id] Leaderboard identifier.
	 * @cb-param {String} [leaderboard.appId] The application ID associated with this Leaderboard.
	 * @cb-param {String} [leaderboard.title] The title of the leaderboard.
	 * @cb-param {String} [leaderboard.scoreFormat] The format of the <code>displayValue</code> in this leaderboard.
	 * @cb-param {Number} [leaderboard.scorePrecision] The decimal place value for the <code>displayValue</code> in this leaderboard.
	 * @cb-param {String} [leaderboard.iconUrl] The URL of the leaderboard icon.
	 * @cb-param {Boolean} [leaderboard.allowLowerScore] If true, the leaderboard will allow a user to post
     *      a lower score to this leaderboard.  If false, a user's preexisting higher score will NOT be replaced
     *      by an attempt to post a lower score.  This flag allows the developer to avoid "get and set if lower" logic.
	 * @cb-param {Boolean} [leaderboard.reverse] If true, lower scores are treated as more desirable.
     *      For example, in golf a lower score is more desirable.
	 * @cb-param {Boolean} [leaderboard.archived] Future enhancement field to archive a leaderboard.  Archived
     *      leaderboards will be readable but not writeable.  Currently this field always returns false.
	 * @cb-param {Number} [leaderboard.defaultScore] Default score value given to a user if no score attribute is
     *      specified in previous calls to <code>updateCurrentUserScore</code>.
	 * @cb-param {Date} [leaderboard.published] The date and time when this leaderboard was created.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 * @cb-param {Date} [leaderboard.updated] The date and time when this leaderboard was updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboard
	 * @see Social.Common.Leaderboard.getLeaderboards
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getAllLeaderboards(['id','title','appId', 'defaultScore'],
	 *                              function(error, leaderboards) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  }
     *                                  for (var i in leaderboards) with ({leaderboard: leaderboards[i]}) {
     *                                      // stuff each item into leaderboard local variable
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    getAllLeaderboards: function(fields, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getAllLeaderboards", fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Retrieves information about the top users of a given leaderboard.  An array of <code>Score</code> objects
     * are returned. By default, only a limited amount of information about each user's <code>Score</code>
     * is retrieved. Use the <code>fields</code> parameter to retrieve additional information.
	 *
	 * @name Social.Common.Leaderboard.getTopScoresList
	 * @function
	 * @public
	 *
     * @param {String} leaderboardId The leaderboard ID to fetch top scores from.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>Score</code> parameter. The
	 *		required properties of the <code>Score</code> parameter are retrieved by default.
     * @param {Object} opts Additional request options for the scores to fetch.  Permitted options are:
     *      <code>count</code> The number of records to return.  If no count variable is provided, 50 scores will be fetched.
     *      <code>startIndex</code> The record offset when striding through the leaderboard's records.  Default value is 1
     *      and should be treated as an offset value.
	 * @cb {Function} callback The function to call after retrieving information about the specified scores.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} [Scores] Information about the requested leaderboard's user scores as an array of Score objects.
	 * @cb-param {String} [Score[].userId] User ID for this score record.
	 * @cb-param {Number} [Score[].value] Raw score value for this user.
	 * @cb-param {String} [Score[].displayValue] Formatted score value based upon the formatting rules for the
     *      requested leaderboard.
	 * @cb-param {Number} [Score[].rank] User's numerical rank for their placement in this leaderboard.
	 * @cb-param {Date} [Score[].updated] The date and time when this score was last updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboard
	 * @see Social.Common.Leaderboard.getLeaderboards
	 * @see Social.Common.Leaderboard.getAllLeaderboards
	 * @see Social.Common.Leaderboard.getFriendsScoresList
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getTopScoresList("Top Patriot Fans",
     *                              ['userId','value','displayValue', 'rank'],
     *                              { startIndex:1, count:50 },
	 *                              function(error, scores) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  }
     *                                  var userIds = [];
     *                                  var scoreMap = {};
     *                                  scores.forEach(function(i, score) {
     *                                      userIds.push(score.userId);
     *                                      scoreMap[score.userId] = score;
     *                                  });
     *
     *                                  Social.Common.People.getUsers(userIds, ["id", "nickname", "thumbnailUrl"], function(error, users) {
     *                                      users.forEach(function(i, user) {
     *                                          scoreMap[user.id]["nickname"] = user.nickname;
     *                                          scoreMap[user.id]["thumbnailUrl"] = user.thumbnailUrl;
     *                                      });
     *
     *                                      for (var i in scores) with ({score: scores[i]}) {
     *                                          // insert each score into a local variable
     *                                      }
     *                                  });
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getTopScoresList: function(leaderboardId, fields, opts, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getTopScoresList", leaderboardIds:leaderboardId, fields:fields, opts:opts, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Retrieves information about the top scores for the specified user's leaderboards.  Said in another way, this API
     * gets the scores for the given user's specified leaderboard.  An array of <code>Score</code> objects
     * are returned. By default, only a limited amount of information about each user's <code>Score</code>
     * is retrieved. Use the <code>fields</code> parameter to retrieve additional information.
	 *
	 * @name Social.Common.Leaderboard.getFriendsScoresList
	 * @function
	 * @public
	 *
     * @param {String} leaderboardId The leaderboard ID to fetch top scores from.
     * @param {String} userId The user whose leaderboards you're fetching.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>Score</code> parameter. The
	 *		required properties of the <code>Score</code> parameter are retrieved by default.
     * @param {Object} opts Additional request options for the scores to fetch.  Permitted options are:
     *      <code>count</code> The number of records to return.  If no count variable is provided, 50 scores will be fetched.
     *      <code>startIndex</code> The record offset when striding through the leaderboard's records.  Default value is 1
     *      and should be treated as an offset value.
	 * @cb {Function} callback The function to call after retrieving information about the specified scores.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} [Scores] Information about the requested leaderboard's user scores as an array of Score objects.
	 * @cb-param {String} [Score[].userId] User ID for this score record.
	 * @cb-param {Number} [Score[].value] Raw score value for this user.
	 * @cb-param {String} [Score[].displayValue] Formatted score value based upon the formatting rules for the
     *      requested leaderboard.
	 * @cb-param {Number} [Score[].rank] User's numerical rank for their placement in this leaderboard.
	 * @cb-param {Date} [Score[].updated] The date and time when this score was last updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboard
	 * @see Social.Common.Leaderboard.getLeaderboards
	 * @see Social.Common.Leaderboard.getAllLeaderboards
	 * @see Social.Common.Leaderboard.getTopScoresList
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getFriendsScoresList("Top Patriot Fans",
     *                              "coolGamerDude",
     *                              ['userId','value','displayValue', 'rank', 'updated'],
     *                              { startIndex:1, count:50 },
	 *                              function(error, scores) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  }
     *                                  var userIds = [];
     *                                  var scoreMap = {};
     *                                  scores.forEach(function(i, score) {
     *                                      userIds.push(score.userId);
     *                                      scoreMap[score.userId] = score;
     *                                  });
     *
     *                                  Social.Common.People.getUsers(userIds, ["id", "nickname", "thumbnailUrl"], function(error, users) {
     *                                      users.forEach(function(i, user) {
     *                                          scoreMap[user.id]["nickname"] = user.nickname;
     *                                          scoreMap[user.id]["thumbnailUrl"] = user.thumbnailUrl;
     *                                      });
     *
     *                                      for (var i in scores) with ({score: scores[i]}) {
     *                                          // insert each score into a local variable
     *                                      }
     *                                  });
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    getFriendsScoresList: function(leaderboardId, userId, fields, opts, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getFriendsScoresList", leaderboardIds:leaderboardId, userId:userId, fields:fields, opts:opts, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Retrieves top score for the specified user's specified leaderboard.  A single <code>Score</code> object
     * is returned. By default, only a limited amount of information the user's <code>Score</code>
     * is retrieved. Use the <code>fields</code> parameter to retrieve additional information.
	 *
	 * @name Social.Common.Leaderboard.getScore
	 * @function
	 * @public
	 *
     * @param {String} leaderboardId The leaderboard ID to fetch the top score from.
     * @param {String} userId The user whose scores you're fetching.
	 * @param {String[]} fields Additional fields to retrieve. For a complete list of available
	 *		fields, see the properties of the callback function's <code>Score</code> parameter. The
	 *		required properties of the <code>Score</code> parameter are retrieved by default.
	 * @cb {Function} callback The function to call after retrieving information about the specified score.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Object} [Score] Information about the requested leaderboard's user score as a single JSON Object.
	 * @cb-param {String} [Score.userId] User ID for this score record.
	 * @cb-param {Number} [Score.value] Raw score value for this user.
	 * @cb-param {String} [Score.displayValue] Formatted score value based upon the formatting rules for the
     *      requested leaderboard.
	 * @cb-param {Number} [Score.rank] User's numerical rank for their placement in this leaderboard.
	 * @cb-param {Date} [Score.updated] The date and time when this score was last updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getLeaderboard
	 * @see Social.Common.Leaderboard.getLeaderboards
	 * @see Social.Common.Leaderboard.getAllLeaderboards
	 * @see Social.Common.Leaderboard.getTopScoresList
	 * @see Social.Common.Leaderboard.getFriendsScoresList
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.getScore("Boston Red Socks Top Fans",
     *                              "myFriend42",
     *                              ['userId','value','displayValue', 'updated'],
	 *                              function(error, score) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  }
     *                                  if (score) {
     *                                      console.log("user score is: "+score.value);
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    getScore: function(leaderboardId, userId, fields, callback) {
		var cmd = {apiURL:"Common.Leaderboard.getScore", leaderboardIds:leaderboardId, userId:userId, fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Updates the current user's score in the specified leaderboard.  No additional information is returned.
	 *
	 * @name Social.Common.Leaderboard.updateCurrentUserScore
	 * @function
	 * @public
	 *
     * @param {String} leaderboardId The leaderboard ID in which to update the given user's score.
	 * @param {Number} value Numerical score value to assign to this user.
	 * @cb {Function} callback The function to call after updating information about the specified user.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
     * @cb-param {Object} [Score] The user's updated score object as a single JSON Object.
	 * @cb-param {String} [Score.userId] User ID for this score record.
	 * @cb-param {Number} [Score.value] Raw score value for this user.
	 * @cb-param {String} [Score.displayValue] Formatted score value based upon the formatting rules for the
     *      requested leaderboard.
	 * @cb-param {Number} [Score.rank] User's numerical rank for their placement in this leaderboard.
	 * @cb-param {Date} [Score.updated] The date and time when this score was last updated.
     *      Uses the date format YYYY-MM-DDThh:mm:ss.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.deleteCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.updateCurrentUserScore("BiggestFish", 42, function(error, score) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  } else {
     *                                      // score updated successfully
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    updateCurrentUserScore: function(leaderboardId, value, callback) {
		var cmd = {apiURL:"Common.Leaderboard.updateCurrentUserScore", leaderboardId:leaderboardId, value:value, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

    /**
	 * Deletes the current user's score in the specified leaderboard.
	 *
	 * @name Social.Common.Leaderboard.deleteCurrentUserScore
	 * @function
	 * @public
	 *
     * @param {String} leaderboardId The leaderboard ID in which to delete the given user's score.
	 * @cb {Function} callback The function to call after updating information about the specified user.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 *
	 * @cb-returns {void}
	 * @see Social.Common.Leaderboard.getScore
	 * @see Social.Common.Leaderboard.updateCurrentUserScore
	 * @example
	 * Social.Common.Leaderboard.deleteCurrentUserScore("BiggestFish", function(error) {
     *                                  if (error) {
     *                                      // error handling code is here
     *                                  } else {
     *                                      // score deleted successfully
     *                                  }
     *                              });
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    deleteCurrentUserScore: function(leaderboardId, callback) {
		var cmd = {apiURL:"Common.Leaderboard.deleteCurrentUserScore", leaderboardIds:leaderboardId, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LocationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LocationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LocationEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/LocationEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class LocationEmitter
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.LocationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.LocationEmitter.prototype */
{
	classname: 'LocationEmitter',
	
	/**
	 * Enumeration for the desired accuracy of the location measurement.
	 * @fieldOf Device.LocationEmitter#
	 */
	Accuracy:
	{
		/**
		 * Low accuracy. The location that is reported will be within several miles of the actual 
		 * location. This setting minimizes the device's power consumption.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		LOW:    0, // equivalent to "3km"  in iOS
		
		/**
		 * Medium accuracy. The location that is reported will be within roughly 100 yards of the
		 * actual location.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		MEDIUM: 1, // equivalent to "100m" in iOS
		
		/**
		 * High accuracy. The location that is reported will be within a few yards of the actual
		 * location. This setting results in the highest power consumption.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		HIGH:   2  // equivalent to "Best" in iOS
	},
	
	/**
	 * Enumeration to choose which data about the device's location will be sent to the application.
	 * @fieldOf Device.LocationEmitter#
	 */
	Elements:
	{
		/**
		 * Receive latitude data.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		LATITUDE:  1,
		
		/**
		 * Receive longitude data.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		LONGITUDE: 2,
		
		/**
		 * Receive altitude data.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		ALTITUDE:  4,
		
		/**
		 * Receive heading data.
		 * @fieldOf Device.LocationEmitter#
		 * @constant
		 */
		HEADING:   8  // equivalent to "bearing" in Android
	},

	/**
	 * @class The <code>LocationEmitter</code> class constructs a singleton object that sends its
	 * listeners a <code>{@link Device.LocationEmitter.Location}</code> object when the device's
	 * location changes.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @see Device.LocationEmitter.Location
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._lastLocation = undefined;
		this._forceListeners = [];
		this.elements = this.Elements.LATITUDE | this.Elements.LONGITUDE | this.Elements.ALTITUDE | this.Elements.HEADING;
	},

	/**
	 * Set the desired accuracy for each update, as well as the information to include in each
	 * update.
	 * @param {LocationEmitter#Accuracy} accuracy Accuracy of updates. The default value is HIGH.
	 * @param {Number} elements OR-ed <code>LocationEmitter.Elements</code>. Example: LATITUDE | LONGITUDE. The default value is LATITUDE | LONGITUDE | ALTITUDE | HEADING (i.e. listens to all elements).
	 * @returns {void}
	 * @status
	 * @since 1.1.1.2
	 */
	setProperties: function(accuracy, elements)
	{
		if (typeof accuracy != 'number') accuracy = this.Accuracy.HIGH;
		if (! elements) elements = this.Elements.LATITUDE | this.Elements.LONGITUDE | this.Elements.ALTITUDE | this.Elements.HEADING;
		this.accuracy = accuracy;
		this.elements = elements;
		this._setPropertiesSendGen(accuracy,elements);
	},

	/**
	 * Add a <code>MessageListener</code> to this emitter. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * <br /><br />
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br /><br />
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, false);
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, true, 200);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @cb {Function} func The function to call when a location event occurs.
	 * @cb-param {Device.LocationEmitter.Location} location Information about the device's location.
	 * @cb-returns {void}
	 * @param {Boolean} forceStart Set to <code>true</code> if the application requires location services to function properly.
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {Error} The specified listener is already listening to the emitter.
	 * @throws {Error} The specified listener is not an instance of <code>Core.MessageListener</code>.
	 * @see Device.LocationEmitter#removeListener
	 * @see Core.MessageEmitter#emit
	 * @see Core.MessageEmitter#chain
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	addListener: function($super, listener, func, forceStart, priority) {
		if(forceStart === undefined)
		{
			this._startUpdatingSendGen(true);
			this._forceListeners.push(listener);
		}
		else
		{
			this._startUpdatingSendGen(forceStart);
			if(forceStart === true)
				this._forceListeners.push(listener);
		}

		$super(listener, func, priority);
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this emitter.<br /><br /> 
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @see Device.LocationEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	removeListener: function($super, listener) {
		$super(listener);

		var index = this._forceListeners.indexOf(listener);
		if(index != -1)
		{
			this._forceListeners.splice(index,1);
			if(this._forceListeners.length === 0)
				this._stopUpdatingSendGen();
		}
	},
    
	/**
	 * Retrieve the last location returned by this <code>LocationEmitter</code>.
	 * @returns {Device.LocationEmitter.Location} The last location returned.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getLastLocation: function()
	{
		if(this._lastLocation === undefined || !this._lastLocation.getPosition()) return undefined;
		
		return this._lastLocation;
	},
	
    _locationUpdatedRecv: function( cmd ) {
		var msg = {};
		if (!this._locationUpdatedRecvGen(cmd, msg))
		    return;

		if (((this.elements & this.Elements.LATITUDE) === 0)  &&
			((this.elements & this.Elements.LONGITUDE) === 0) &&
			((this.Elements & this.Elements.ALTITUDE) === 0))
			return;

		this._lastLocation = new this.Location(
			new Core.Point(msg["latitude"], msg["longitude"]),
			msg["altitude"],
			this._lastLocation ? this._lastLocation.getHeading() : undefined,
			msg["accuracy"],
			msg["timestamp"]);

		this.emit(this._lastLocation);
    },
	
	_headingUpdatedRecv: function( cmd ) 
	{
		var msg = {};
		if (!this._headingUpdatedRecvGen(cmd, msg))
			return;
			
		if ((this.elements & this.Elements.HEADING) === 0)
			return;

		this._lastLocation = new this.Location(
			this._lastLocation ? this._lastLocation.getPosition() : undefined,
			this._lastLocation ? this._lastLocation.getAltitude() : undefined,
			msg['magneticHeading'],
			this._lastLocation ? this._lastLocation.getAccuracy() : undefined,
			msg['timestamp']);
		
		if(msg['magneticHeading']) {
			this.emit(this._lastLocation);
		}
	},
	
	Location: Core.Class.subclass(
	/** @lends Device.LocationEmitter.Location.prototype */
	{
		classname: 'Location',
		
		/**
		 * @class <code>Location</code> constructs objects that encapsulate the location of a device.
		 * <code>Location</code> objects contain spatial components, like position and heading information, and a timestamp that indicates when a location is measured.
		 * 
		 * @constructs The default constructor. 
		 * @param {Core.Point} position The latitude / longitude of the device.
		 * @param {Number} altitude The altitude of the device.
		 * @param {Number} heading The heading of the device.
		 * @param {Number} accuracy The accuracy of the measurement.
		 * @param {Number} timestamp The timestamp when the location was measured.
		 * @augments Core.Class
		 * @since 1.0
		 */
		initialize: function(position, altitude, heading, accuracy, timestamp)
		{
			this._position = position;
			this._altitude = altitude;
			this._accuracy = accuracy;
			this._heading = heading;
			this._timestamp = timestamp;
		},
		
		/**
		 * Return the position of this <code>Location</code> as latitude / longitude.
		 * @returns {Core.Point} The current latitude / longitude.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getPosition: function()
		{
			return this._position;
		},
		
		/**
		 * Return the altitude of this <code>Location</code> in feet (ft).
		 * @returns {Number} The current altitude.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getAltitude: function()
		{
			return this._altitude;
		},
		
		/**
		 * Return the heading of this <code>Location</code> in degrees east of north.
		 * @returns {Number} The current heading.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getHeading: function()
		{
			return this._heading;
		},
		
		/**
		 * Return the accuracy of the measurement for this <code>Location</code>.
		 * @returns {Number} The current location accuracy.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getAccuracy: function()
		{
			return this._accuracy;
		},
		
		/**
		 * Return the timestamp when this measurement was taken.
		 * Expressed in milliseconds since Epoch (Unix time).
		 * @returns {Number} The timestamp of the measurement.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getTimestamp: function()
		{
			return this._timestamp;
		}
	}),
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 333,
	// Method create = -1
	// Method destroy = 2
	// Method startUpdatingLocation = 3
	// Method stopUpdatingLocation = 4
	// Method locationUpdated = 5
	// Method startUpdatingHeading = 6
	// Method stopUpdatingHeading = 7
	// Method headingUpdated = 8
	// Method setProperties = 9
	// Method startUpdating = 10
	// Method stopUpdating = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._locationUpdatedRecv( cmd );
					break;
				case 8:
					instance._headingUpdatedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[333] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_locationUpdatedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 5 )
		{
			NgLogE("Could not parse due to wrong argument count in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "timestamp" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "timestamp" ] === undefined )
		{
			NgLogE("Could not parse timestamp in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "latitude" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "latitude" ] === undefined )
		{
			NgLogE("Could not parse latitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "longitude" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "longitude" ] === undefined )
		{
			NgLogE("Could not parse longitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "altitude" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "altitude" ] === undefined )
		{
			NgLogE("Could not parse altitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "accuracy" ] = Core.Proc.parseFloat( cmd[ 4 ] );
		if( obj[ "accuracy" ] === undefined )
		{
			NgLogE("Could not parse accuracy in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_headingUpdatedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 4 )
		{
			NgLogE("Could not parse due to wrong argument count in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "timestamp" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "timestamp" ] === undefined )
		{
			NgLogE("Could not parse timestamp in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "magneticHeading" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "magneticHeading" ] === undefined )
		{
			NgLogE("Could not parse magneticHeading in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "trueHeading" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "trueHeading" ] === undefined )
		{
			NgLogE("Could not parse trueHeading in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "accuracy" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "accuracy" ] === undefined )
		{
			NgLogE("Could not parse accuracy in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14dffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14d0002, this );
	},
	
	/** @private */
	_startUpdatingLocationSendGen: function( accuracy, distanceFilter )
	{
		Core.Proc.appendToCommandString( 0x14d0003, this, [ +accuracy, +distanceFilter ] );
	},
	
	/** @private */
	_stopUpdatingLocationSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14d0004, this );
	},
	
	/** @private */
	_locationUpdatedSendGen: function( timestamp, latitude, longitude, altitude, accuracy )
	{
		Core.Proc.appendToCommandString( 0x14d0005, this, [ +timestamp, +latitude, +longitude, +altitude, +accuracy ] );
	},
	
	/** @private */
	_startUpdatingHeadingSendGen: function( orientation, angularFilter )
	{
		Core.Proc.appendToCommandString( 0x14d0006, this, [ +orientation, +angularFilter ] );
	},
	
	/** @private */
	_stopUpdatingHeadingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14d0007, this );
	},
	
	/** @private */
	_headingUpdatedSendGen: function( timestamp, magneticHeading, trueHeading, accuracy )
	{
		Core.Proc.appendToCommandString( 0x14d0008, this, [ +timestamp, +magneticHeading, +trueHeading, +accuracy ] );
	},
	
	/** @private */
	_setPropertiesSendGen: function( accuracy, elements )
	{
		Core.Proc.appendToCommandString( 0x14d0009, this, [ +accuracy, +elements ] );
	},
	
	/** @private */
	_startUpdatingSendGen: function( force )
	{
		Core.Proc.appendToCommandString( 0x14d000a, this, [ ( force ? 1 : 0 ) ] );
	},
	
	/** @private */
	_stopUpdatingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14d000b, this );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// startUpdatingLocation: function( accuracy, distanceFilter ) {}
	
	// stopUpdatingLocation: function(  ) {}
	
	// _locationUpdatedRecv: function( cmd ) {}
	// locationUpdated: function( timestamp, latitude, longitude, altitude, accuracy ) {}
	
	// startUpdatingHeading: function( orientation, angularFilter ) {}
	
	// stopUpdatingHeading: function(  ) {}
	
	// _headingUpdatedRecv: function( cmd ) {}
	// headingUpdated: function( timestamp, magneticHeading, trueHeading, accuracy ) {}
	
	// setProperties: function( accuracy, elements ) {}
	
	// startUpdating: function( force ) {}
	
	// stopUpdating: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/MemoryEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/MemoryEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/MemoryEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/MemoryEmitter.js';

var Core = require('NGCore/Client/Core').Core;

exports.MemoryEmitter = Core.MessageEmitter.singleton(
/** @lends Device.MemoryEmitter.prototype */
{
	classname: 'MemoryEmitter',
		
	/**
	 * @class The <code>MemoryEmitter</code> class constructs a singleton object that notifies its
	 * listeners when a low memory warning is received from the system. The information that is
	 * sent to listeners is configurable and can vary by platform if desired. See
	 * <code>{@link Device.MemoryEmitter#addSummaryStatisticsListener}</code> for details about the
	 * information that can be sent to listeners.<br /><br />
	 * Applications can respond to these notifications by destroying unused objects, allowing the
	 * system to re-allocate free memory. Failure to respond to low memory warnings may cause the
	 * operating system to terminate the application.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._summaryStatisticsEmitter = null;
		this._summaryStatisticsOption = this.StatisticsOption['common'];
		this._summaryStatisticsInterval = 1000;
	},
	
	_memoryEventRecv: function( cmd ) 
	{
		this.emit();
		
		//Cascade the original message back out to native for forwarding
		this._memoryEventSendGen();
	},
													  
	/**
	 * Enumeration values for use with {@link Device.MemoryEmitter#setSummaryStatisticsOption}.
	 * @fieldOf Device.MemoryEmitter.prototype
	 */
	StatisticsOption:
	{
		/**
		 * Map iOS and Android platform-specific information to platform-neutral information. See
		 * {@link Device.MemoryEmitter#addSummaryStatisticsListener} for more detail.
		 * @fieldOf Device.MemoryEmitter.prototype
		 * @constant
		 */
		common: 1,

		/**
		 * Provide platform-specific information for iOS and Android. See
		 * {@link Device.MemoryEmitter#addSummaryStatisticsListener} for more detail.
		 * @fieldOf Device.MemoryEmitter.prototype
		 * @constant
		 */
		raw: 2
	},

	/**
	 * Set whether the <code>MemoryEmitter</code> will provide platform-specific information,
	 * platform-neutral information, or both. The default option is 
	 * <code>{@link Device.MemoryEmitter#StatisticsOption.common}</code>.
	 * @example
	 * Device.MemoryEmitter.setSummaryStatisticsOption(Device.MemoryEmitter.
	 *   StatisticsOption.common | Device.MemoryEmitter.StatisticsOption.raw);
	 * @param {Device.MemoryEmitter#StatisticsOption} option The option to use for the
	 *		<code>MemoryEmitter</code>. To select multiple options, you can use the <code>|</code>
	 *		operator to combine multiple values. Use the value <code>0</code> to disable the
	 *		emitter.
	 * @returns {void}
	 * @since 1.4.1
	 */	
	setSummaryStatisticsOption: function( option )
	{
		this._summaryStatisticsOption = option;

		if( this._summaryStatisticsEmitter )
		{
			this._enableSummaryStatisticsSendGen( this._summaryStatisticsOption, this._summaryStatisticsInterval );
		}
	},

	/**
	 * Set the amount of time, in milliseconds, between calls to the callback function. The 
	 * default value is <code>1000</code>.
	 * @param {Number} interval The amount of time, in milliseconds, between calls to the callback
	 *		function.
	 * @returns {void}
	 * @since 1.4.1
	 */	
	setSummaryStatisticsInterval: function( interval )
	{
		this._summaryStatisticsInterval = interval;

		if( this._summaryStatisticsEmitter )
		{
			this._enableSummaryStatisticsSendGen( this._summaryStatisticsOption, this._summaryStatisticsInterval );
		}
	},

	/**
	 * Add a listener for memory statistics. 
	 * @example
	 * var MyListener = Core.MessageListener.subclass({
	 *     myCallback: function(statistics) {
	 *         if (statistics.rawValues.ActivityManager.getMemoryInfo) {
	 *             var info = JSON.stringify(statistics.rawValues.ActivityManager.
	 *               getMemoryInfo);
	 *             console.log("Android info about available memory: " + info);
	 *         }
	 *         if (statistics.totalFreeMemory) {
	 *             console.log("Platform-neutral info about available memory: " +
	 *               statistics.totalFreeMemory);
	 *         }
	 *     }
	 * });
	 * var listener = new MyListener();
	 * 
	 * Device.MemoryEmitter.addSummaryStatisticsListener(listener,
	 *   listener.myCallback);
	 * @param {Object} listener The listener that memory statistics will be sent to.
	 * @cb {Function} callback The function to call when the system sends a low memory warning.
	 * @cb-param {Object} statistics An object containing information about the amount of memory
	 *		that is available. The object's properties will vary depending on what value was
	 *		specified in <code>{@link Device.MemoryEmitter#setSummaryStatisticsOption}</code>. By
	 *		default, Android-only and iOS-only properties are not included.
	 * @cb-param {String} [statistics.rawValues./proc/pid/statm] The contents of 
	 *		<code>/proc/{application pid}/statm</code>. Android-only.
	 * @cb-param {Object} [statistics.rawValues.ActivityManager.getMemoryInfo] The value returned by
	 *		<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryInfo(android.app.ActivityManager.MemoryInfo)">
	 *		ActivityManager.getMemoryInfo()</a>. Android only.
	 * @cb-param {Object} [statistics.rawValues.ActivityManager.getProcessMemoryInfo] The value
	 *		returned by
	 *		<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getProcessMemoryInfo(int[])">
	 *		ActivityManager.getProcessMemoryInfo()</a>. Android only.
	 * @cb-param {Object} [statistics.rawValues.host_statistics] The value returned by 
	 *		<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/host_statistics.html">
	 *		host_statistics()</a>. iOS only.
	 * @cb-param {Object} [statistics.rawValues.task_info] The value returned by
	 *		<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_info.html">
	 *		task_info()</a>. iOS only.
	 * @cb-param {Number} [statistics.residentSize] The resident memory size of the process, in
	 *		bytes.
	 * @cb-param {Number} [statistics.totalFreeMemory] The amount of free memory on the device, in
	 *		bytes.
	 * @cb-param {Number} [statistics.virtualSize] The virtual memory size of the process, in bytes.
	 * @cb-returns {void}
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @returns {void}
	 * @see Device.MemoryEmitter#setSummaryStatisticsInterval
	 * @see Device.MemoryEmitter#setSummaryStatisticsOption
	 * @since 1.4.1
	 */	
	addSummaryStatisticsListener: function( listener, callback, priority )
	{
		if( !this._summaryStatisticsEmitter )
		{
			this._summaryStatisticsEmitter = new Core.MessageEmitter();
		}
		this._summaryStatisticsEmitter.addListener( listener, callback, priority );

		if( this._summaryStatisticsEmitter.getListenerCount() == 1 )
		{
			this._enableSummaryStatisticsSendGen( this._summaryStatisticsOption, this._summaryStatisticsInterval );
		}
	},

	/**
	 * Remove a listener for memory statistics.
	 * @param {Object} listener The memory statistics listener to remove.
	 * @returns {void}
	 * @since 1.4.1
	 */	
	removeSummaryStatisticsListener: function( listener )
	{
		if( this._summaryStatisticsEmitter )
		{
			this._summaryStatisticsEmitter.remove( listener );

			if( this._summaryStatisticsEmitter.getListenerCount() === 0 )
			{
				this._enableSummaryStatisticsSendGen( 0, 0 );
				this._summaryStatisticsEmitter = null;
			}
		}
		else
		{
			NgLogD("removeRealtimeSummaryStatisticsListener: memoryEmitter does not exist");
		}
	},

	_statisticsRecv: function( cmd )
	{
		var json, msg = {};
		if( !this._statisticsRecvGen( cmd, msg ))
			return;
	        
		try
		{
			json = JSON.parse( msg.data );
		}
		catch(e)
		{
			NgLogE("_statisticsRecv: error occured while parsing JSON");
			return;
		}		

		if(this._summaryStatisticsEmitter)
		{
			this._summaryStatisticsEmitter.emit( json );
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 331,
	// Method create = -1
	// Method memoryEvent = 2
	// Method enableSummaryStatistics = 3
	// Method statistics = 4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._memoryEventRecv( cmd );
					break;
				case 4:
					instance._statisticsRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MemoryEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MemoryEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[331] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_memoryEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in MemoryEmitter.memoryEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_statisticsRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in MemoryEmitter.statistics from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in MemoryEmitter.statistics from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14bffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_memoryEventSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14b0002, this );
	},
	
	/** @private */
	_enableSummaryStatisticsSendGen: function( option, interval )
	{
		Core.Proc.appendToCommandString( 0x14b0003, this, [ +option, +interval ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _memoryEventRecv: function( cmd ) {}
	// memoryEvent: function(  ) {}
	
	// enableSummaryStatistics: function( option, interval ) {}
	
	// _statisticsRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/MotionEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/MotionEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/MotionEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/MotionEmitter.js';

var Core = require('NGCore/Client/Core').Core;

exports.MotionEmitter = Core.MessageEmitter.singleton(
/** @lends Device.MotionEmitter.prototype */
{
	classname: 'MotionEmitter',
	
	/**
	 * @class The <code>MotionEmitter</code> class constructs a singleton object that tracks a 
	 * device's movement through 3D space. When the device moves, the <code>MotionEmitter</code>
	 * sends its listeners a <code>{@link Device.MotionEmitter.Motion}</code> object that provides
	 * spatial information about the device.
	 * @singleton
	 * @constructs The default constructor.
	 * @see Device.MotionEmitter.Motion
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._lastAccel = null;
		this._lastGyro  = null;
		this._lastCompass = null;
	},

	Motion: Core.Class.subclass(
	/** @lends Device.MotionEmitter.Motion.prototype */
	{
		classname: 'Motion',
		
		/**
		 * @class <code>MotionEmitter</code> objects use <code>Motion</code> objects to provide
		 * spatial information about a device's movement. These objects report the information
		 * obtained from the device's accelerometer, gyroscope, and compass instruments during the
		 * most recent event.<br /><br />
		 * <strong>Important</strong>: By default, accelerometer data is returned using the
		 * right-hand rule on iOS and the left-hand rule on Android. To use the right-hand rule on
		 * both platforms, call <code>{@link Device.MotionEmitter#useCommonAccelerometerMode}</code>
		 * before you call <code>{@link Device.MotionEmitter.Motion#getAccelData}</code>.
		 * @constructs The default constructor. 
		 * @param {Object} accel accelerometer data for the device, indexed by "x", "y", and "z".
		 * @param {Object} gyro gyroscope accelerometer data for the device, indexed by "x", "y", and "z".
		 * @param {Object} compass compass data for the device, indexed by "x", "y", and "z".
		 * @see Device.MotionEmitter
		 * @augments Core.Class
		 * @since 1.0
		 */
		initialize: function(accel, gyro, compass)
		{
			this._accel = accel;
			this._gyro  = gyro;
			this._compass = compass;
		},
		
		/**
		 * Retrieve accelerometer data from the device. A call to <code>getAccelData()</code> on a device that contains an accelerometer
		 * returns an object that contains the accelerometer data. In all other cases, calling <code>getAccelData()</code> returns 
		 * <code>undefined</code>. The accelerometer value is based on the default orientation mode and is not affected by orientation
		 * changes.<br /><br />
		 * On iOS, the value is returned using the right-hand rule, and on Android, the value is returned using the left-hand rule.
		 * To make the value consistent across platforms, call <code>{@link Device.MotionEmitter#useCommonAccelerometerMode}</code>
		 * before you call <code>getAccelData()</code>.<br /><br />
		 * <b>Note:</b> Use <code>{@link Core.Capabilities#getHasAccel}</code> to programmatically check a 
		 * device for an accelerometer.
		 * @returns {Object} An object that contains the accelerometer data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasAccel
		 * @see Device.MotionEmitter#useCommonAccelerometerMode
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getAccelData: function()
		{
			return this._accel;
		},
		
		/**
		 * Retrieve gyroscope data from the device. A call to <code>getGyroData()</code> on a device that contains a gyroscope
		 * returns an object that contains the gyroscope data. In all other cases,
		 * this call returns <code>undefined</code>. <br /><br />
		 * <b>Note:</b> Use <code>{@link Core.Capabilities#getHasGyro}</code> to programmatically check a
		 * device for a gyroscope. 
		 * @returns {Object} An object that contains the gyroscope data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasGyro
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getGyroData: function()
		{
			return this._gyro;
		},
		
		/**
		 * Retrieve compass data from the device. A call to <code>getCompassData()</code> on a device that contains a magnetic compass
		 * returns an object that contains the compass data. In all other cases,
		 * this call returns <code>undefined</code>.<br /><br />
		 * <b>Note:</b> Use <code>{@link Core.Capabilities#getHasCompass}</code> to programmatically check a device for a compass. 
		 * @returns {Object} An object that contains the compass data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasCompass
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 * @since 1.0
		 */
		getCompassData: function()
		{
			return this._compass;
		}
	}),

	/**
	 * Register a <code>MessageListener</code> object with the <code>MotionEmitter</code>. If an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameter for the callback function is a <code>Motion</code> object.<br /><br />
	 * <b>Note:</b> Each listener can only listen to an emitter once.<br /><br />
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @cb {Function} func The function to call when a motion event occurs.
	 * @cb-param {Device.MotionEmitter.Motion} motion Information about the motion event.
	 * @cb-returns {void}
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @see Core.MessageEmitter#emit
	 * @see Core.MessageEmitter#chain
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	addListener: function($super, listener, func, priority)
	{
		if (this.getListenerCount() === 0) {
			// start the Accelerometer if this is the first listener
			this._startMotionSendGen();
		}

		$super(listener, func, priority);
	},

	/**
	 * Remove a <code>MessageListener</code> object from this <code>MotionEmitter</code> object. 
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.	 
	 * @returns {Boolean} Returns <code>true</code> when the registered listener was removed. Returns <code>false</code> in all other cases.
	 * @see Core.MessageEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	removeListener: function($super, listener)
	{
		$super(listener);

		if (this.getListenerCount() === 0) {
			// stop the Accelerometer if this is the last listener
			this._stopMotionSendGen();
		}
	},

	_emitMotion: function()
	{
		var motion = new Device.MotionEmitter.Motion(this._lastAccel, this._lastGyro, this._lastCompass);
		this.emit(motion);
	},

	_accelChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._accelChangedRecvGen(cmd, msg))
			return;

		this._lastAccel = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._accelChangedSendGen(msg.x, msg.y, msg.z);
	},

	_gyroChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._gyroChangedRecvGen(cmd, msg))
			return;

		this._lastGyro = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._gyroChangedSendGen(msg.x, msg.y, msg.z);
	},
	
	_magneticChangedRecv: function( cmd ) 
	{
		var msg = {};
		if(!this._magneticChangedRecvGen(cmd, msg))
			return;
		
 		this._lastCompass = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._magneticChangedSendGen(msg.x, msg.y, msg.z);
	},

	/**
	 * Specify whether the <code>MotionEmitter</code> should use the right-hand rule to return 
	 * accelerometer data on both iOS and Android. By default, iOS uses the right-hand rule, and
	 * Android uses the left-hand rule.
	 * @param {Boolean} use Set to <code>true</code> to use the right-hand rule on both iOS and
	 *		Android. Set to <code>false</code> to use the right-hand rule on iOS and the left-hand
	 *		rule on Android.
	 * @returns {void}
	 * @see Device.MotionEmitter.Motion#getAccelData
	 * @since 1.6
	 */
	useCommonAccelerometerMode: function(use) {
		this._useCommonAccelerometerModeSendGen(use);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 330,
	// Method create = -1
	// Method accelChanged = 2
	// Method gyroChanged = 3
	// Method magneticChanged = 4
	// Method startMotion = 5
	// Method stopMotion = 6
	// Method useCommonAccelerometerMode = 7
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._accelChangedRecv( cmd );
					break;
				case 3:
					instance._gyroChangedRecv( cmd );
					break;
				case 4:
					instance._magneticChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MotionEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MotionEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[330] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_accelChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_gyroChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_magneticChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14affff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_accelChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( 0x14a0002, this, [ +x, +y, +z ] );
	},
	
	/** @private */
	_gyroChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( 0x14a0003, this, [ +x, +y, +z ] );
	},
	
	/** @private */
	_magneticChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( 0x14a0004, this, [ +x, +y, +z ] );
	},
	
	/** @private */
	_startMotionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14a0005, this );
	},
	
	/** @private */
	_stopMotionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14a0006, this );
	},
	
	/** @private */
	_useCommonAccelerometerModeSendGen: function( use )
	{
		Core.Proc.appendToCommandString( 0x14a0007, this, [ ( use ? 1 : 0 ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _accelChangedRecv: function( cmd ) {}
	// accelChanged: function( x, y, z ) {}
	
	// _gyroChangedRecv: function( cmd ) {}
	// gyroChanged: function( x, y, z ) {}
	
	// _magneticChangedRecv: function( cmd ) {}
	// magneticChanged: function( x, y, z ) {}
	
	// startMotion: function(  ) {}
	
	// stopMotion: function(  ) {}
	
	// useCommonAccelerometerMode: function( use ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/NetworkEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/NetworkEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/NetworkEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/NetworkEmitter.js';

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.NetworkEmitter = Core.MessageEmitter.singleton(
/** @lends Device.NetworkEmitter.prototype */
{
	classname: 'NetworkEmitter',
	
	/**
	 * @class The <code>NetworkEmitter</code> class constructs a singleton object that sends its
	 * listeners a unique value when any of the following changes occur:
	 * <ul>
	 * <li>The device loses access to a network.</li>
	 * <li>The device gains access to a network.</li>
	 * <li>The device switches between cellular and wi-fi network access.</li>
	 * </ul>
	 * The unique value that the listeners receive corresponds to an enumerated value of 
	 * <code>{@link Device.NetworkEmitter#Status}</code>.<br /><br />
	 * In addition, the <code>NetworkEmitter</code> class provides listeners that receive updates on
	 * the number of active HTTP requests, the average data traffic, and the maximum time it is
	 * taking to set up a new HTTP connection.<br /><br />
	 * @singleton
	 * @constructs The default constructor. 
	 * @see Device.NetworkEmitter#Status
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

    this._lastStatus = null;
    this._perfEmitter = null;
    this._connEmitter = null;
    this._minRate = 5*1024;  // B/s
    this._duration = 5000;   // in msec
    this._samples = [];
    this._sum = 0;
    this._unconformFor = 0;
    this._lastSampleAt = 0;
    this._maxConnTime = 5000; // in msec
	},

	/**
	 * Retrieve the network status of the device.
	 * @returns {Device.NetworkEmitter#Status} The current device network status.
	 * @status iOS, Android, Test
	 * @since 1.0
	 */
	getLastStatus: function()
	{
		return this._lastStatus;
	},

	/** 
	 * Enumeration values for device network status.
	 * @fieldOf Device.NetworkEmitter.prototype
	 */
	Status:
	{
		/** 
		* No network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		None: 0,
		
		/** 
		* Cellular network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		Cellular: 1,
		
		/** 
		* Wi-Fi network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		Wifi: 2
	},

  /** private */
  _flags:
  {
    enable: 0x00000001
  },

  /**
   * Add a listener to monitor the device's network performance and execute a callback function if
   * performance is currently poor.
   * @example
   * Device.NetworkEmitter.addPerformanceListener(perfListener, function(perfStatus) {
   * 	// Set your own thresholds for acceptable performance for your application.
   *	if (perfStatus.actReqs > 10 &amp;&amp; perfStatus.aveRate < 10240) {  // 10 KB/second
   *		// Modify the application's behavior appropriately
   *    }
   * });
   * @param {Core.MessageListener} perfListener Performance listener.
   * @cb {Function} perfCb The function to call when network performance is poor.
   * @cb-param {Object} perfStatus An object containing information about network performance.
   * @cb-param {Number} perfStatus.actReqs The number of active HTTP requests.
   * @cb-param {Number} perfStatus.aveRate The average inbound and outbound data traffic in bytes
   *		per second.
   * @cb-returns {void}
   * @param {Number} [priority=0] The priority for this <code>NetworkListener</code>.
   * @returns {void}
   * @since 1.4
   */
  addPerformanceListener: function(perfListener, perfCb, priority)
  {
    if(!this._perfEmitter)
    {
      this._perfEmitter = new Core.MessageEmitter();
    }

    this._perfEmitter.addListener(perfListener, perfCb, priority);
    NgLogD("addPerformanceListener: count=" + this._perfEmitter.getListenerCount());

    if(this._perfEmitter.getListenerCount() == 1)
    {
      // Tell native to report stats.
      this._enablePerfEmitterSendGen( this._flags['enable'], this._minRate, this._duration );
    }
  },

  /**
   * Remove a listener that is monitoring the device's network performance.
   * @param {Core.MessageListener} perfListener Performance listener to remove.
   * @returns {void}
   * @since 1.4
   */
  removePerformanceListener: function(perfListener)
  {
    if(this._perfEmitter)
    {
      this._perfEmitter.removeListener(perfListener);
      NgLogD("removePerformanceListener: count=" + this._perfEmitter.getListenerCount());

      if(this._perfEmitter.getListenerCount() === 0)
      {
        // Tell native to stop reporting stats.
        this._enablePerfEmitterSendGen( 0, 0, 0 );
        this._perfEmitter = null;
      }
    }
    else
    {
      NgLogD("removePerformanceListener: perf-emitter does not exist");
    }
  },

  /**
   * Retrieve the number of <code>MessageListener</code> objects that have been registered with this
   * <code>NetworkEmitter</code> through <code>addPerformanceListener()</code>.
   * @returns {Number} The number of registered <code>MessageListener</code> objects.
   * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
   * @since 1.4.1
   */
  getPerformanceListenerCount: function() 
  {
    if(this._perfEmitter)
    {
      return this._perfEmitter.getListenerCount();
    }

    return 0;
  },

  /**
   * Add a listener to monitor the time it is taking to set up a new HTTP connection, and to execute
   * a callback function when it is taking an excessively long time to set up a new connection.
   * The listener will receive an event for every network frame until the lingering connection is 
   * established; the lingering connection has timed out; or the listener is removed.
   * @example Device.NetworkEmitter.addConnectionListener(connListener, function(connTime) {...});
   * @param {Core.MessageListener} connListener Connection listener.
   * @cb {Function} connCb The function to call when it is taking an excessively long time to set up
   *		a new HTTP connection.
   * @cb-param {Number} connTime The amount of time, in milliseconds, that it has taken so far to
   *		set up the most delayed network connection.
   * @cb-returns {void}
   * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
   * @returns {void}
   * @since 1.4
   */
  addConnectionListener: function(connListener, connCb, priority)
  {
    if(!this._connEmitter)
    {
      this._connEmitter = new Core.MessageEmitter();
    }

    this._connEmitter.addListener(connListener, connCb, priority);
    NgLogD("addConnectionListener: count=" + this._connEmitter.getListenerCount());

    if(this._connEmitter.getListenerCount() == 1)
    {
      // Tell native to report stats.
      this._enableConnEmitterSendGen( this._flags['enable'], this._maxConnTime );
    }
  },

  /**
   * Remove a connection listener that is monitoring the time it takes to set up a new HTTP 
   * connection.
   * @param {Core.MessageListener} connListener Connection listener to remove.
   * @returns {void}
   * @since 1.4
   */
  removeConnectionListener: function(connListener)
  {
    if(this._connEmitter)
    {
      this._connEmitter.removeListener(connListener);
      NgLogD("removeConnectionListener: count=" + this._connEmitter.getListenerCount());

      if(this._connEmitter.getListenerCount() === 0)
      {
        // Tell native to stop reporting stats.
        this._enableConnEmitterSendGen( 0, 0 );
        this._connEmitter = null;
      }
    }
    else
    {
      NgLogD("removeConnectionListener: already removed");
    }
  },

  /**
   * Retrieve the number of <code>MessageListener</code> objects that have been registered with this
   * <code>NetworkEmitter</code> through <code>addConnectionListener()</code>.
   * @returns {Number} The number of registered <code>MessageListener</code> objects.
   * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
   * @since 1.4.1
   */
  getConnectionListenerCount: function() 
  {
    if(this._connEmitter)
    {
      return this._connEmitter.getListenerCount();
    }

    return 0;
  },

  /**
   * @private
   * Set performance threshold parameters.
   * @param {Object} params Performance threshold parameters. Following parameters are available:
   * <pre>
   *  {
   *    minRate: {Number},  // minimum rate in B/s.
   *    duration: {Number}, // duration in msec for which it waits
   *                        // before emitting event.
   *  }
   * </pre>
   * For example, if minRate = 5*1024 (bytes) and duration = 5000 (msec), a message is emitted
   * in 5 seconds since the actual transmission rate became below the 'minRate'. If the 
   * transmission rate recovers (becomes more than minRate), the duration will be reset.
   * @returns {void}
   */
  setPerformanceThreshold: function(params)
  {
    if(params['minRate'])
    {
      this._minRate = params['minRate'];
    }
    if(params['duration'])
    {
      this._duration = params['duration'];
    }

    if(this._perfEmitter)
    {
      // Tell native that thresholds are updated.
      this._enablePerfEmitterSendGen( this._flags['enable'], this._minRate, this._duration );
    }
  },

  /**
   * @private
   * Set connection threshold parameters.
   * @param {Object} params Connection threshold parameters. Following parameters are available:
   * <pre>
   *  {
   *    maxConnTime: {Number},  // maximum connection setup time in milliseconds.
   *                            // Default is 5000, or 5 seconds.
   *  }
   * </pre>
   * @returns {void}
   */
  setConnectionThreshold: function(params)
  {
    if(params['maxConnTime'])
    {
      this._maxConnTime = params['maxConnTime'];
    }

    if(this._connEmitter)
    {
      // Tell native that thresholds are updated.
      this._enableConnEmitterSendGen( this._flags['enable'], this._maxConnTime );
    }
  },

	_statusChangedRecv: function( cmd )
	{
		var msg = {};
		if (!this._statusChangedRecvGen(cmd, msg))
		    return;

		this._lastStatus = msg['status'];
		this.emit(this._lastStatus);
	},

	_activityRecv: function( cmd )
 {
		var msg = {};
		if (!this._activityRecvGen(cmd, msg))
		    return;

    var actReqs = msg['numActiveReqs'];
    var actConns = msg['numActiveConns'];
    var opens = msg['numOpens'];
    var conns = msg['numConns'];
    var closes = msg['numCloses'];
    var sent = msg['bytesSent'];
    var rcvd = msg['bytesRcvd'];
    var connTime = msg['maxConnTime'];

    var now = Core.Time.getRealTime();

    //NgLogD('NetworkEmitter::_activityRecv: actReqs=' + actReqs + ' actConns=' + actConns + ' opens=' + opens + ' conns=' + conns + ' closes=' + closes + ' sent=' + sent + ' rcvd=' + rcvd + ' connTime=' + connTime);

    // Reset conditions
    // 1) actConns == conn: all new connections, and;
    // 2) !actConns: no connection, and;
    // 3) took more than the 'duration' since the last sampling.
    if(actConns == conns || !actConns)
    {
      if(now - this._lastSampleAt >= this._duration)
      {
        this._samples = [];
        this._sum = 0;
        this._unconformFor = 0;
      }
    }

    if(actConns > 0)
    {
      var latest = 0;
      if(this._samples.length == 150)
      {
        latest = this._samples.shift();
        if(this._sum >= latest)
        {
          this._sum -= latest;
        }
      }

      var dt = Core.Time.getFrameDelta();
      var rate = (sent + rcvd) / (dt / 1000);
      this._samples.push(rate);
      this._sum += rate;
      this._lastSampleAt = now;

      var ave = this._sum / this._samples.length;

      if(ave < this._minRate)
      {
        //NgLogD('NetworkEmitter::_activityRecv: aveRate=' + ave + ' sum=' + this._sum + ' numSamples=' + this._samples.length + ' since=' + this._unconformFor + ' now=' + now + ' deltaT=' + (now - this._unconformFor) + ' hasPerfEmitter=' + (this._perfEmitter? 'yes':'no'));
        this._unconformFor += dt;

        if(this._unconformFor >= this._duration)
        {
          if(this._perfEmitter)
          {
            //NgLogD('NetworkEmitter::_activityRecv: emitting performance event');
            this._unconformFor = 0;
            this._perfEmitter.emit({ actReqs: actReqs, actConns: actConns, aveRate: ave });
          }
        }
      }
      else
      {
        // Now it conforms to the min rate. Reset the timestamp.
        this._unconformFor = 0;
      }
    }

    if(connTime >= this._maxConnTime)
    {
      if(this._connEmitter)
      {
        //NgLogD('NetworkEmitter::_activityRecv: emitting connection event');
        this._connEmitter.emit(connTime);
      }
    }
 },

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 336,
	// Method create = -1
	// Method statusChanged = 2
	// Method activity = 3
	// Method enablePerfEmitter = 4
	// Method enableConnEmitter = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._statusChangedRecv( cmd );
					break;
				case 3:
					instance._activityRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in NetworkEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in NetworkEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[336] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_statusChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in NetworkEmitter.statusChanged from command: " + cmd );
			return false;
		}
		
		obj[ "status" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "status" ] === undefined )
		{
			NgLogE("Could not parse status in NetworkEmitter.statusChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_activityRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 8 )
		{
			NgLogE("Could not parse due to wrong argument count in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numActiveReqs" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "numActiveReqs" ] === undefined )
		{
			NgLogE("Could not parse numActiveReqs in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numActiveConns" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "numActiveConns" ] === undefined )
		{
			NgLogE("Could not parse numActiveConns in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numOpens" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "numOpens" ] === undefined )
		{
			NgLogE("Could not parse numOpens in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numConns" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "numConns" ] === undefined )
		{
			NgLogE("Could not parse numConns in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numCloses" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "numCloses" ] === undefined )
		{
			NgLogE("Could not parse numCloses in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "bytesSent" ] = Core.Proc.parseInt( cmd[ 5 ] );
		if( obj[ "bytesSent" ] === undefined )
		{
			NgLogE("Could not parse bytesSent in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "bytesRcvd" ] = Core.Proc.parseInt( cmd[ 6 ] );
		if( obj[ "bytesRcvd" ] === undefined )
		{
			NgLogE("Could not parse bytesRcvd in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "maxConnTime" ] = Core.Proc.parseInt( cmd[ 7 ] );
		if( obj[ "maxConnTime" ] === undefined )
		{
			NgLogE("Could not parse maxConnTime in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x150ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_enablePerfEmitterSendGen: function( flags, minRate, duration )
	{
		Core.Proc.appendToCommandString( 0x1500004, this, [ +flags, +minRate, +duration ] );
	},
	
	/** @private */
	_enableConnEmitterSendGen: function( flags, maxConnTime )
	{
		Core.Proc.appendToCommandString( 0x1500005, this, [ +flags, +maxConnTime ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _statusChangedRecv: function( cmd ) {}
	// _activityRecv: function( cmd ) {}
	// enablePerfEmitter: function( flags, minRate, duration ) {}
	
	// enableConnEmitter: function( flags, maxConnTime ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/ShakeEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/ShakeEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/ShakeEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/ShakeEmitter.js';

var Core = require('NGCore/Client/Core').Core;
var MotionEmitter = require('NGCore/Client/Device/MotionEmitter').MotionEmitter;

var ProxyListener = Core.MessageListener.subclass(
{
	onUpdate: function() {}
});

exports.ShakeEmitter = Core.MessageEmitter.singleton(
/** @lends Device.ShakeEmitter.prototype */
{
	classname: 'ShakeEmitter',
		
	/**
	 * @class The <code>ShakeEmitter</code> class constructs a singleton object that sends a message
	 * to its listeners when a user shakes the device.
	 * <br /><br />
	 * In addition, this class provides the method <code>{@link Device.ShakeEmitter#vibrate}</code>,
	 * which causes the device to vibrate briefly.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._proxyListener = new ProxyListener();
		
	},
	
	/**
	 * Add a <code>MessageListener</code> to this emitter. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * <br /><br />
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br /><br />
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @cb {Function} func The function to call when the device is shaken.
	 * @cb-returns {void}
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {Error} The specified listener is already listening to the emitter.
	 * @throws {Error} The specified listener is not an instance of <code>Core.MessageListener</code>.
	 * @see Device.ShakeEmitter#removeListener
	 * @see Core.MessageEmitter#emit
	 * @see Core.MessageEmitter#chain
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	addListener: function($super, listener, func, priority)
	{
		if (this.getListenerCount() === 0) {
			MotionEmitter.addListener(this._proxyListener, function(){});
		}

		$super(listener, func, priority);
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this emitter.
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @see Device.ShakeEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	removeListener: function($super, listener)
	{
		$super(listener);

		if (this.getListenerCount() === 0) {
			MotionEmitter.removeListener(this._proxyListener);
		}
	},
	
	/**
	 * Turn on the device's vibrator briefly.
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.6
	 */
	vibrate: function ()
	{
		this._vibrateSendGen();
	},
    
	_shakeRecv: function( cmd )
	{
		this.emit();
		
		//Cascade the original message back out to native for forwarding
		this._shakeSendGen();
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 332,
	// Method create = -1
	// Method shake = 2
	// Method vibrate = -3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._shakeRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in ShakeEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in ShakeEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[332] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_shakeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in ShakeEmitter.shake from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14cffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_shakeSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14c0002, this );
	},
	
	/** @private */
	$_vibrateSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14cfffd );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _shakeRecv: function( cmd ) {}
	// shake: function(  ) {}
	
	// $vibrate: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/KeyEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/KeyEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/KeyEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/KeyEmitter.js';

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

// Private Class Statics
var keyCodeReverseMap = null;

exports.KeyEmitter = Core.MessageEmitter.singleton(
/** @lends Device.KeyEmitter.prototype */
{
	classname: 'KeyEmitter',

	/**
	 * @class The <code>KeyEmitter</code> class constructs a singleton object that sends its
	 * listeners a <code>{@link Device.KeyEmitter.KeyEvent}</code> object when the user presses or
	 * releases a device hardware key.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @example
	 * var KeyListener = Core.MessageListener.subclass({
	 *   onUpdate: function(keyEvent) {
	 *     // back to the launcher when the back button is pressed
	 *     if (keyEvent.code === Device.KeyEmitter.Keycode.back) {
	 *        this.destroy();
	 *        LGL.runUpdatedGame('/Samples/Launcher');
	 *        return;
	 *     }
	 *
	 *     var text = '';
	 *     switch (keyEvent.type) {
	 *        case Device.KeyEmitter.EventType.onDown:
	 *           text += 'onDown :';
	 *           break;
	 *        case Device.KeyEmitter.EventType.onUp:
	 *           text += 'onUp :';
	 *           break;
	 *     }
	 *
	 *     text += Device.KeyEmitter.keyCodeToSymbol(keyEvent.code);
	 *     console.log(text);
	 *   }
	 * });
	 *
	 * var keyListener = new KeyListener();
	 * Device.KeyEmitter.addListener(keyListener, keyListener.onUpdate);
	 * @status Android, Test, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * Convert a keycode into the equivalent human-readable symbol. The keycode to convert is passed in as a parameter.
	 * The following code example illustrates how to convert a keycode into a human-readable symbol.
	 * @param {String} keyCode The keycode to convert.
	 * @example
	 *   var symbol = Device.KeyEmitter.keyCodeToSymbol(0x1d);
	 *   // symbol => 'a'
	 * @returns {String} The keycode as a human-readable symbol.
	 * @status
	 * @since 1.0
	 */
	keyCodeToSymbol: function(keyCode)
	{
		if (!keyCodeReverseMap) {
			keyCodeReverseMap = {};
			for (var codename in this.Keycode) {
				keyCodeReverseMap[this.Keycode[codename]] = codename;
			}
		}
		return keyCodeReverseMap[keyCode] || '';
	},

	KeyEvent: Core.Class.subclass(
	/** @lends Device.KeyEmitter.KeyEvent.prototype */
	{
		classname: 'KeyEvent',

		/**
		 * @class <code>KeyEvent</code> constructs objects that contain the parcel of a keyboard event. 
		 * The keycode of the key that triggered the event is passed in as a parameter.
		 * @constructs The default constructor. 
		 * @augments Core.Class
		 * @param {Device.KeyEmitter.EventType} type The type of the keyboard event.
		 * @param {Integer} modifiers the bit-and of {@link Device.KeyEmitter#Modifier} combination.
		 * @param {Device.KeyEmitter.Keycode} code The actual keycode.
		 * @since 1.0
		 */
		initialize: function(type, modifiers, code)
		{
			this.type      = type;
			this.modifiers = modifiers;
			this.code      = code;
		}
	}),

	_onKeyEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._onKeyEventRecvGen(cmd, msg))
			return;

		var keyEvent = new Device.KeyEmitter.KeyEvent(msg.type, msg.modifiers, msg.code);
		
		if(!this.chain(keyEvent)) {
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onKeyEventSendGen(msg.type, msg.modifiers, msg.code);
		}
	},
	
	/** 
	 * Enumeration identifying whether the key was pressed or released.
	 * @name EventType
	 * @fieldOf Device.KeyEmitter#
	 */
	 
	/** 
	 * The key was released.
	 * @name EventType.onUp
	 * @fieldOf Device.KeyEmitter.prototype
	 * @constant
	 */
	
	/** 
	 * The key was pressed.
	 * @name EventType.onDown
	 * @fieldOf Device.KeyEmitter.prototype
	 * @constant
	 */
	
	
	/** 
	 * Enumeration identifying any modifier keys that are being pressed.
	 * @name Modifier
	 * @fieldOf Device.KeyEmitter#
	 * @example
	 * var keyEvent; // emitted from KeyEmitter
	 * if (keyEvent.modifiers &amp; Device.KeyEmitter.Modifier.ALT &amp;&amp; 
	 *     keyEvent.modifiers &amp; Device.KeyEmitter.Modifier.SHIFT) {
	 *     console.log("ALT+SHIFT");
	 * }
	 */
	
	/**
	 * No modifier key is pressed.
	 * @name Modifier.NONE
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The SYMBOL modifier key is pressed.
	 * @name Modifier.SYMBOL
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The ALT modifier key is pressed.
	 * @name Modifier.ALT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The left ALT modifier key is pressed.
	 * @name Modifier.ALT_LEFT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The right ALT modifier key is pressed.
	 * @name Modifier.ALT_RIGHT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The SHIFT modifier key is pressed.
	 * @name Modifier.SHIFT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/** 
	 * The left SHIFT modifier key is pressed.
	 * @name Modifier.SHIFT_LEFT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The right SHIFT modifier key is pressed.
	 * @name Modifier.SHIFT_RIGHT
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */


	/** 
	 * Enumeration identifying the key that is pressed.
	 * @name Keycode
	 * @fieldOf Device.KeyEmitter#
	 */
	 
	/**
	 * The a key is pressed.
	 * @name Keycode.a
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The b key is pressed.
	 * @name Keycode.b
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The c key is pressed.
	 * @name Keycode.c
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The d key is pressed.
	 * @name Keycode.d
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The e key is pressed.
	 * @name Keycode.e
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The f key is pressed.
	 * @name Keycode.f
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The g key is pressed.
	 * @name Keycode.g
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The h key is pressed.
	 * @name Keycode.h
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The i key is pressed.
	 * @name Keycode.i
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The j key is pressed.
	 * @name Keycode.j
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The k key is pressed.
	 * @name Keycode.k
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The l key is pressed.
	 * @name Keycode.l
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The m key is pressed.
	 * @name Keycode.m
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The n key is pressed.
	 * @name Keycode.n
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The o key is pressed.
	 * @name Keycode.o
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The p key is pressed.
	 * @name Keycode.p
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The q key is pressed.
	 * @name Keycode.q
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	
	/**
	 * The r key is pressed.
	 * @name Keycode.r
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The s key is pressed.
	 * @name Keycode.s
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/** 
	 * The t key is pressed.
	 * @name Keycode.t
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The u key is pressed.
	 * @name Keycode.u
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The v key is pressed.
	 * @name Keycode.v
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The w key is pressed.
	 * @name Keycode.w
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The x key is pressed.
	 * @name Keycode.x
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The y key is pressed.
	 * @name Keycode.y
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The z key is pressed.
	 * @name Keycode.z
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The Up key is pressed.
	 * @name Keycode.up
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The Down key is pressed.
	 * @name Keycode.down
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The Left key is pressed.
	 * @name Keycode.left
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */
	 
	/**
	 * The Right key is pressed.
	 * @name Keycode.right
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * The Enter key is pressed.
	 * @name Keycode.enter
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/** 
	 * The Backspace key is pressed.
	 * @name Keycode.backspace
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/** 
	 * The Back key is pressed.
	 * @name Keycode.back
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 */

	/**
	 * Special KeyCode to tell MobageService that the back was unhandled by the game, after the
	 * service declined first dibs. Stole MAX_KEYCODE (deprecated constant).
	 * @name Keycode.backunhandled
	 * @fieldOf Device.KeyEmitter#
	 * @constant
	 * @ignore
	 */
	
	/**
	 * The Menu key is pressed.
	 * @name Keycode.menu
	 * @fieldOf Device.KeyEmitter.prototype
	 * @constant
	 */
	

// {{?Wg Generated Code}}
	
	// Enums.
	EventType:
	{ 
		onUp: 0,
		onDown: 1
	},
	
	Modifier:
	{ 
		NONE: 0,
		SYMBOL: 1 << 0,
		ALT: 1 << 1,
		ALT_LEFT: 1 << 2,
		ALT_RIGHT: 1 << 3,
		SHIFT: 1 << 4,
		SHIFT_LEFT: 1 << 5,
		SHIFT_RIGHT: 1 << 6
	},
	
	Keycode:
	{ 
		a: 0x1d,
		b: 0x1e,
		c: 0x1f,
		d: 0x20,
		e: 0x21,
		f: 0x22,
		g: 0x23,
		h: 0x24,
		i: 0x25,
		j: 0x26,
		k: 0x27,
		l: 0x28,
		m: 0x29,
		n: 0x2a,
		o: 0x2b,
		p: 0x2c,
		q: 0x2d,
		r: 0x2e,
		s: 0x2f,
		t: 0x30,
		u: 0x31,
		v: 0x32,
		w: 0x33,
		x: 0x34,
		y: 0x35,
		z: 0x36,
		up: 0x13,
		down: 0x14,
		left: 0x15,
		right: 0x16,
		enter: 0x42,
		backspace: 0x43,
		back: 0x04,
		backunhandled: 0x54,
		menu: 0x52
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 343,
	// Method create = -1
	// Method onKeyEvent = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onKeyEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in KeyEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in KeyEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[343] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onKeyEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "type" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "type" ] === undefined )
		{
			NgLogE("Could not parse type in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "modifiers" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "modifiers" ] === undefined )
		{
			NgLogE("Could not parse modifiers in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "code" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "code" ] === undefined )
		{
			NgLogE("Could not parse code in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x157ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_onKeyEventSendGen: function( type, modifiers, code )
	{
		Core.Proc.appendToCommandString( 0x1570002, this, [ +type, +modifiers, +code ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onKeyEventRecv: function( cmd ) {}
	// onKeyEvent: function( type, modifiers, code ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/_PushNotificationEmitter.js';

var Core = require('NGCore/Client/Core').Core;

/*
	NOTE: 	THIS IS FOR INTERNAL USE ONLY AND WILL BE DEPRECATED IN THE FUTURE.
			DO NOT USE IT IN ANY OF YOUR CODE.
*/

exports.PushNotificationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.PushNotificationEmitter.prototype */
{
	classname: 'PushNotificationEmitter',
		
	/**
	 * @class Emits when native code recieves a push notification
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 */
	
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_onPushNotificationRecv: function( cmd )
	{
		var msg = {};
		if (!this._onPushNotificationRecvGen(cmd, msg))
			return;
			
		this._lastMsgPayload = msg.msgPayload;
		
		if(!this.chain(msg.msgPayload))	{
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onPushNotificationSendGen(msg.msgPayload);
		}
		
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 345,
	// Method create = -1
	// Method onPushNotification = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onPushNotificationRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in PushNotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in PushNotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[345] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onPushNotificationRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in PushNotificationEmitter.onPushNotification from command: " + cmd );
			return false;
		}
		
		obj[ "msgPayload" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "msgPayload" ] === undefined )
		{
			NgLogE("Could not parse msgPayload in PushNotificationEmitter.onPushNotification from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x159ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_onPushNotificationSendGen: function( msgPayload )
	{
		Core.Proc.appendToCommandString( 0x1590002, this, [ Core.Proc.encodeString( msgPayload ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onPushNotificationRecv: function( cmd ) {}
	// onPushNotification: function( msgPayload ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/_InAppPurchaseEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class InAppPurchaseEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.InAppPurchaseEmitter = Core.MessageEmitter.singleton(
/** @lends Device.InAppPurchaseEmitter.prototype */
{
	classname: 'InAppPurchaseEmitter',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_onPurchaseEventRecv: function( cmd ) {
		var msg = {};
		if (!this._onPurchaseEventRecvGen(cmd, msg))
			return;
		if(!this.chain(msg.err, msg.data, msg.verificationToken))	{
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onPurchaseEventSendGen(msg.err, msg.data, msg.verificationToken);
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 347,
	// Method create = -1
	// Method onPurchaseEvent = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onPurchaseEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in InAppPurchaseEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in InAppPurchaseEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[347] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onPurchaseEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "err" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "err" ] === undefined )
		{
			NgLogE("Could not parse err in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "verificationToken" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "verificationToken" ] === undefined )
		{
			NgLogE("Could not parse verificationToken in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x15bffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_onPurchaseEventSendGen: function( err, data, verificationToken )
	{
		Core.Proc.appendToCommandString( 0x15b0002, this, [ Core.Proc.encodeString( err ), Core.Proc.encodeString( data ), Core.Proc.encodeString( verificationToken ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onPurchaseEventRecv: function( cmd ) {}
	// onPurchaseEvent: function( err, data, verificationToken ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_InAppPurchase'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchase'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchase'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/_InAppPurchase.js';

////////////////////////////////////////////////////////////////////////////////
// Class InAppPurchase
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var Analytics = require('NGCore/Client/Core/Analytics').Analytics;
var DeviceReq = require('NGCore/Client/Device');
var Localization = require('NGCore/Client/Core/Localization').Localization;

////////////////////////////////////////////////////////////////////////////////

exports.InAppPurchase = Class.singleton(
/** @lends Device.InAppPurchase.prototype */
{
	classname: 'InAppPurchase',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	initService: function(ordercb, donecb, options) {
        NgLogD("initService called");
		if(this._iapInited) {
            NgLogD("initService has been called");
            return;
        }

		if ((!this._isIOS()) && (!this._isAndroid())) {
			NgLogE("ERROR: Neither Android nor iOS platform, IAP will not work");
			donecb();
			return;
		}

		this._initDonecb = donecb;
		this._initOrdercb = ordercb;

		if(options) {
			var options2 = JSON.parse(options);
			if(options2.service === "boku") {
				this._paymentProvider = "boku";
			}
		}
		if (!this._iapInited) {
			var IAPListener = Core.MessageListener.subclass({
				onPurchaseEvent: this._iapCallback.bind(this)
			});
			
			// Register for Android / iOS IAP callbacks the same way
			this.listener = new IAPListener();
	        DeviceReq.Device.InAppPurchaseEmitter.addListener(
				this.listener, this.listener.onPurchaseEvent);
	    	// listener will be called when purchase state changes
		}
		if (this._isAndroid()) {
			this._iapCallback('morenonces', '', '');
			/*
			 * Gets persisted unfulfilled orders, calls back ordercb for each
			 * unfulfilled order.
			 */
			var self = this;
			Storage.KeyValueCache.local.getItem(this._IAB_ORPHANED, {},
			function(err, currorder) {
                    NgLogD("_iap getting orphaned order callback");
	   			if (currorder) {
					var order = JSON.parse(currorder);
   					// _restoreOrder eventually calls _initService when fully
					// done.
                    NgLogD("_iap restoring order");
					self._restoreOrder(order, options);
				} else {
                    NgLogD("_iap initService 0");
					self._initService(options);
				}
			});
		} else {
			// _isIOS - call _initService directly.  It will call back with
			// orphaned order if any.
                    NgLogD("_iap initService 1");
			this._initService(options);
		}
	},

	launchPurchaseView: function(productID, quantity, purchasecb, failcb, cancelcb, options) {
		if (!this._iapInited) {
            Analytics.reportGameEvent( "MobaIAPInitFailed" );
			NgLogE("ERROR: function initService must be called and its donecb " +
			"called back, before launchPurchaseView may be used.");
			failcb(false, "failed:initservice_not_done");
			return;
		}

		this._currentOrderProductID = productID;

		this._currentOrderCancelcb = cancelcb;
		this._currentOrderFailcb = failcb;
		this._currentOrderPurchasecb = purchasecb;

		// Android IAB currently only supports quantity of 1
		if (quantity !== 1 && this._isAndroid()) {
			failcb(false, "failed:unsupported_quantity");
            Analytics.reportGameEvent( "MobaIAPInvalidQuantity" );
			return;
		}

		if (this._isIOS() || this._isAndroid()) {
	        DeviceReq.Device.InAppPurchase._requestPurchase(productID, quantity, options);
			// Note that _iapCallback will call the *cb callback function(s)
			return;
		}
            
		var capabilities = Core.Capabilities;
        Analytics.reportGameEvent( "MobaIAPUnsupportPlatorm"+capabilities.getPlatformOS() );
		NgLogE('launchPurchaseView failed: only Android and iOS platforms are currently supported.');
		failcb(false, "failed:unsupported_platform");
		return;
	},

    // depreicated function
	pushSingleNonce: function(nonce){
		var noncePool = [];
		noncePool.push(nonce);
		this._fillIABNoncePool(JSON.stringify(noncePool));
	},

	/**
	 * get a product information specified by productId.
	 * @param {String} productId the product ID registered at iTunes connect.
	 * @param {Function} callback called back when it gets a response. The signature for the callback is equivalent to:<br /><br />
	 * <pre>function(productData, err)</pre><br />
	 * The <code>productData</code> is an product information like "JPY,115.000000".
	 * When something bad happenes, <code>err</code> is set to the error message. Otherwise, err will be null or undefined.
	 * @status iOS, iOSTested
	 */
	getProductInformation: function(productId, callback) {
		this._getProductInformationCB = callback;
		this._getProductInformationSendGen(productId);
	},

	/**
	 * get product information specified by set of product ids
	 * @param {String} productSet the set ofproduct ID registered at iTunes connect. JSON format: {"items":["sku1", "sku2"]}
	 * @param {Function} callback called back when it gets a response. The signature for the callback is equivalent to:<br><br>
	 * <pre>function(productData, err)</pre><br>
	 * The <code>productData</code> is product information like "{"currency":"US", "items":[{"sku":"webgame_test_D", "price":0.99},{"sku":"abc", "price":1.00}]}"
	 * @status iOS, iOSTested
	 */
	getProductSetInfo: function(productSet, callback) {
		this._getProductSetInfoCB = callback;
		this._getProductSetInfoSendGen(productSet);
	},

	/*
	 * For Google IAB, these constants come from
	 * Consts.java in IAB sample code
	 *
	 *	public enum PurchaseState {
     *   PURCHASED,   // User was charged for the order. -- 0
     *   CANCELED,    // The charge failed on the server. -- 1
	 *   REFUNDED;    // User received a refund for the order. -- 2
	 */
	_IAB_PURCHASED: 0,
	_IAB_CANCELED: 1,
	_IAB_REFUNDED: 2,
	_IAB_ORPHANED: "com.ngmoco.in_app_purchase.iab_orphaned_orders",

	_capIsAndroid: undefined,
	_capIsIOS: undefined,

	// at most one outstanding order is supported
	_currentOrderCancelcb : undefined,
	_currentOrderFailcb : undefined,
	_currentOrderProductID : undefined,
    // This flag is used by Google IAB only
	_currentOrderPurchasecb : undefined,

	_initDonecb : undefined,
	_initOrdercb : undefined,
	_iapInited: false,

	_generateIABNonce: function(){
		var timestamp = new Date().getTime();
		var random = Math.floor(Math.random() * 1000);
		var nonce = (timestamp * 1000) + random;
		NgLogD("Generated nonce: " + nonce);
		return nonce;
	},

    // For Android, this function will be called for the following scenarios:
    // 1. First initService after start the game
    // 2. After each IAB purchase
    // 
    // Looks like during restart, if there are un-ack orders, this _iapCallback
    // is being called twice.
    // First, it will be called after the service has been established
    // Second time, it will be alled if there are un-ack order with orders, receipt
    //
    //
    // For iOS
    // Only after IAP purchase
    //
	_iapCallback: function( err, data, verificationToken ) {
        NgLogD("8 _iapCallback with err: "+err + " data: "+data + " verficationToken: "+verificationToken);
		if (err == 'morenonces') {
			var count = 10;
			var noncePool = [];
			while(noncePool.length < count){
				noncePool.push(this._generateIABNonce());
			}
			this._fillIABNoncePool(JSON.stringify(noncePool));
			return true;
		}
		if ((err == 'initdone') || (err == 'initcheckdone')) {
			if (typeof this._initDonecb == 'function') {
				this._iapInited = true;
				this._initDonecb();
                NgLogD("_iap initService Done");
			} else {
				NgLogW("WARN: " + err + " callback with empty donecb");
			}
	        // at most one listener gets iap events
	        return true;
		}
		if (err == 'getProductInformationDone') {
			if (data && data.length > 0) {
				var datajsonp = JSON.parse(data);
				try {
					this._productInformationExtras = JSON.parse(verificationToken);
				} catch (e) {
					NgLogE("Error parsing Product Information");
				}
				
				this._getProductInformationCB(datajsonp.productId);
			} else {
				this._getProductInformationCB('', "no information on this product");
			}
			this._getProductInformationCB = undefined;
			delete this._productInformationExtras;
			return true;
		}
		if (err == 'getProductSetInfoDone') {
			this._getProductSetInfoCB(data);
			this._getProductSetInfoCB = undefined;
			return true;
		}

		var orderId;
		var prodId = "";
	        var datajson, receiptj;
        // There are two scenarios we will get the orders from Google
        // 1. during initService to the Googel market
        // 2. after the initService, user makes purchase.
        // before pop up the Google UI

		if (data && data.length > 0) {
		    datajson = JSON.parse(data);
		    if ((datajson.orders) && (datajson.orders.length > 0)) {
                this._dumpOrderIds(datajson.orders); // for debugging and troubleshooting

                // note: see the NGStoreObserver.m to understand how we contrust this JSON block

                orderId = datajson.orders[0].orderid;

 				if (this._isAndroid() && (!this._currentOrderPurchasecb)) {
					// this callback comes in 'out of band', when user did
					// not attempt a purchase.  This happens on Android
					// when async callbacks are not confirmed due to
					// connectivity issue.  This callback will come in
					// the time when we establish the connection to MarketService
                    // which is when the game restart
					//
                    // we only come to here when we first start the game
                    var order0 = datajson.orders[0];
			        receiptj = {
					    data: data,
					    signature: verificationToken
				    };
				    order0.receipt = JSON.stringify(receiptj);

                    // We overwrite the existing data if there is one
                    // Google will include all the previous un-ack orders in the latest
                    // signData
                     if(!order0.receipt) {
                        Analytics.reportGameEvent("NGNILRECEIPT2");
                     }
                     this._initOrdercb(order0.productId, order0.orderId, order0.receipt);
	                return true;
				}

            }
		}

		if (err && err.length > 0) {
			if (err == 'cancelled') {
				if ((typeof this._currentOrderCancelcb) == 'function') {
					this._currentOrderCancelcb();
					this._currentOrderCancelcb = undefined;
				} else {
                    Analytics.reportGameEvent("MobaIAPERR02");
                }
			} else {
				if (err) {
					NgLogD("DEBUG: iapCallback: got error: " + err);
				} else {
					// _IAB_CANCELED
					NgLogD("DEBUG: iapCallback: got canceled purchaseState.");
				}
				if ((typeof this._currentOrderFailcb) == 'function') {
					this._currentOrderFailcb(false, err);
					this._currentOrderFailcb = undefined;
				} else {
                    Analytics.reportGameEvent("MobaIAPERR01");
                }
			}

	        // at most one listener gets iap events
	        return true;
	    }

		if ((typeof this._currentOrderPurchasecb) == 'function') {
			var receipt = verificationToken;
			if (this._isAndroid()) {
				// on Android, both the data and signature are require_d
				// for verification
				receiptj = {
					data: data,
					signature: verificationToken
				};
				receipt = JSON.stringify(receiptj);
			}
            // prodId is undefined if it is Android.
            // We are OK for this since we never use this prodId on narwhal side anyway.
            // For iOS, we converted to uppercase. SKU is casesensitve. We are OK here. Again it is because
            // we don't use the prodId on the narwhal side.
            // Might be we should just fix the prodId logic
            if(!receipt) {
                Analytics.reportGameEvent("NGNILRECEIPT");
            }
		    this._currentOrderPurchasecb(prodId, orderId, receipt);
			this._currentOrderPurchasecb = undefined;
		} else if ((!this._iapInited) && ((typeof this._initOrdercb) ==
		 			'function')) {
            // KLO - I don't understand how we will get to this flow
			// part of initService flow
            // initOrdercb is pointing to the first function while calling
            // in the Purchase.js DeviceReq.Device.InAppPurchase.initService
		    this._initOrdercb(prodId, orderId, verificationToken);
		} else {
            Analytics.reportGameEvent("MobaIAPERR04");                    
        }
        // at most one listener gets iap events
        return true;
    },

	_isAndroid: function() {
		if (typeof this._capIsAndroid != 'undefined') {
			return this._capIsAndroid;
		}
		// Find out from capabilities
	    var capabilities = Core.Capabilities;
	    if ((typeof capabilities.getPlatformOS() != "undefined") &&
	        (capabilities.getPlatformOS().toLowerCase() == 'android')) {
	        this._capIsAndroid = true;
	    } else {
	        this._capIsAndroid = false;
		}
		return this._capIsAndroid;
	},

	_isIOS: function() {
		if (typeof this._capIsIOS != 'undefined') {
			return this._capIsIOS;
		}
		// Find out from capabilities
	    var capabilities = Core.Capabilities;
	    if ((typeof capabilities.getPlatformOS() != "undefined") &&
	        (capabilities.getPlatformOS().toLowerCase() == 'iphone os')) {
	        this._capIsIOS = true;
	    } else {
	        this._capIsIOS = false;
		}
		return this._capIsIOS;
	},

	_fillIABNoncePool: function(nonces) {
		this._fillIABNoncePoolSendGen(nonces);
	},

    _dumpOrderIds: function(orders) {
        for(var i=0; i < orders.length; i++) {
            var theOrder = orders[i];
            Analytics.reportGameEvent("NGIABRECEIVED", {orderId: theOrder.orderId});
        }
    },

    // deprecated
	_filterSuccessOrders: function(datajson, verificationToken, data) {
		var successOrders = [];
		for (var kdx in datajson.orders) {
			if (datajson.orders[kdx].purchaseState === this._IAB_PURCHASED) {
				var theorder = datajson.orders[kdx];
	            if(this._isAndroid()) {
			        var receiptj = {
					    data: data,
					    signature: verificationToken
				    };
				    theorder.receipt = JSON.stringify(receiptj);
                } else {
                    theorder.verificationToken = verificationToken;
                }
				successOrders.push(theorder);
			} else {
				//Send ACK for non-success orders
                // For success orders, we won't ACK until we get confirm from
                // Bank in the Mobage JS level
                // We don't need to this before because we ack everything 
                // right away in the old Google IAB example
				this._sendOrderProcessedAck(datajson.orders[kdx].notificationId);
				NgLogD("Sending ACK to google for filterorders");
			}
		}
        NgLogD("successOrders length = "+successOrders.length);
		return successOrders;
	},
    // deprecated
	_persistOrphanedOrders: function(successOrders) {
		// add orders to existing list of persisted orders
		Storage.KeyValueCache.local.getItem(this._IAB_ORPHANED, {},
			(function(err, currorders){
				if (currorders && (currorders.length > 0)) {
					var orderlist = JSON.parse(currorders);
                    // append the new orders to the existing orders
					for (var idx in orderlist) {
						var o = orderlist[idx];
                        var foundOrder = false;
                        // If we don't ack the Google callback, it 
                        // will just keep coming back until we ack it.
                        // Therefore, don't add the older to the queue anymore
                        // This O(n^2) performance won't be a problem because
                        // we most likely have 2 - 3 orders in the callback.
                        for(var jdx in successOrders) {
                            var t = successOrders[jdx];
                            if(t.orderId === o.orderId) {
                                foundOrder = true;
                                break;
                            }
                        }
                        if(!foundOrder) {
                            successOrders.push(orderlist[idx]);
                        }
					}
				}
				var content = JSON.stringify(successOrders);
				Storage.KeyValueCache.local.setItem(this._IAB_ORPHANED, content, {},
				function(){
					NgLogD("Orphaned orders added to persistent store: " + content);
					NgLogD("Number of orders: " + successOrders.length);
			    });
			}).bind(this));
	},
	_initService: function(options) {
		if(options) {
            Analytics.reportGameEvent("MobaIAPERR06");
			this._initService2SendGen(options);
		} else {
            NgLogD("_iap calling initServiceSendGen");
			this._initServiceSendGen();
		}
	},

	_requestPurchase: function( sku, quantity, options ) {
		if(options){
			this._requestPurchase2SendGen(sku, quantity, options);
		} else {
			this._requestPurchaseSendGen(sku, quantity);
		}
	},
	
    // Send ACK to Google 
	_sendOrderProcessedAck: function( notificationId, orderId ) {
		NgLogD("sending ACK to Google with orderId: "+orderId);
        Analytics.reportGameEvent("MobaIABACK", {orderId: orderId});
		this._sendOrderProcessedAckSendGen( notificationId );
	},

	/* Deprecated
	 * Given unfulfilled orders, calls back ordercb for each unfulfilled order.
	 * Resets persisted store using removeItem when done, then call
	 * _initService to continue init process.
	 */
	_restoreOrder: function(order, options) {
		var self = this;

        // send the order back to Mobage application layer so it can forward
        // these order to bank
        // initOrdercb is pointing to the first function while calling
        // in the Purchase.js DeviceReq.Device.InAppPurchase.initService
        if(this._isAndroid()) {
		    this._initOrdercb(order.productId, order.orderId, order.receipt, order);
        } else {
		    this._initOrdercb(order.productId, order.orderId, order.verificationToken, order);
        }
		Storage.KeyValueCache.local.removeItem(this._IAB_ORPHANED, {},
			function() {
                NgLogD("_iap removeItem callback");
                    NgLogD("_iap initService 2");
				self._initService(options);
			});
	
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 348,
	// Method create = -1
	// Method initService = 2
	// Method requestPurchase = 3
	// Method fillIABNoncePool = 4
	// Method getProductInformation = 5
	// Method sendOrderProcessedAck = 6
	// Method getProductSetInfo = 7
	// Method initService2 = 8
	// Method requestPurchase2 = 9
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in InAppPurchase._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in InAppPurchase._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[348] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x15cffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_initServiceSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x15c0002, this );
	},
	
	/** @private */
	_requestPurchaseSendGen: function( sku, quantity )
	{
		Core.Proc.appendToCommandString( 0x15c0003, this, [ Core.Proc.encodeString( sku ), +quantity ] );
	},
	
	/** @private */
	_fillIABNoncePoolSendGen: function( nonces )
	{
		Core.Proc.appendToCommandString( 0x15c0004, this, [ Core.Proc.encodeString( nonces ) ] );
	},
	
	/** @private */
	_getProductInformationSendGen: function( productId )
	{
		Core.Proc.appendToCommandString( 0x15c0005, this, [ Core.Proc.encodeString( productId ) ] );
	},
	
	/** @private */
	_sendOrderProcessedAckSendGen: function( orderId )
	{
		Core.Proc.appendToCommandString( 0x15c0006, this, [ Core.Proc.encodeString( orderId ) ] );
	},
	
	/** @private */
	_getProductSetInfoSendGen: function( skuIds )
	{
		Core.Proc.appendToCommandString( 0x15c0007, this, [ Core.Proc.encodeString( skuIds ) ] );
	},
	
	/** @private */
	_initService2SendGen: function( options )
	{
		Core.Proc.appendToCommandString( 0x15c0008, this, [ Core.Proc.encodeString( options ) ] );
	},
	
	/** @private */
	_requestPurchase2SendGen: function( sku, quantity, options )
	{
		Core.Proc.appendToCommandString( 0x15c0009, this, [ Core.Proc.encodeString( sku ), +quantity, Core.Proc.encodeString( options ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// initService: function(  ) {}
	
	// requestPurchase: function( sku, quantity ) {}
	
	// fillIABNoncePool: function( nonces ) {}
	
	// getProductInformation: function( productId ) {}
	
	// sendOrderProcessedAck: function( orderId ) {}
	
	// getProductSetInfo: function( skuIds ) {}
	
	// initService2: function( options ) {}
	
	// requestPurchase2: function( sku, quantity, options ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/IPCEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/IPCEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/IPCEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/IPCEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class IPCEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;
var Class          = require('NGCore/Client/Core/Class').Class;
var Proc           = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Base64         = require('NGCore/Client/Core/Base64').Base64;
var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var DownloadFile   = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var Util           = require('NGCore/Client/Network/Util').Util;
var FileSystem     = require('NGCore/Client/Storage/FileSystem').FileSystem;

////////////////////////////////////////////////////////////////////////////////

exports.IPCEmitter = MessageEmitter.singleton(
/** @lends Device.IPCEmitter.prototype */
{

	classname: 'IPCEmitter',

	/**
	 * @class The IPCEmitter class is a singleton that enables an ngCore app to launch another
	 * app on the device, or to switch to that app if it is already running. For example, you can
	 * use this class to launch Google Play (on Android devices) or the App Store (on iOS devices).
	 * <br /><br />
	 * To launch another app, you pass a URL to <code>{@link Device.IPCEmitter#launch}</code>. The
	 * device examines the first part of the URL, then determines whether the device has an app that
	 * can handle the request. For example, on Android devices, a URL that begins with
	 * <code>market://</code> will be handled by the Google Play app. The remainder of the URL will
	 * be passed to the app that is being launched.
	 * <br /><br />
	 * In addition, you can use the method <code>{@link Device.IPCEmitter#canLaunch}</code> to check
	 * whether the device has an app that can handle a URL.
	 * @example
	 * // Require the user to download an updated copy of the app from Google Play.
	 * // NOTE: This example works only on Android. In addition, this example will
	 * // not work correctly in the sandbox environment, because ngCore apps have
	 * // different bundle IDs in the sandbox and production environments.
	 * 
	 * var bundleId = Core.Capabilities.getBundleIdentifier();
	 * var url = "market://details?id=" + bundleId;
	 *
	 * var Updater = Core.Class.singleton({
	 *     classname: "Updater",
	 *
	 *     showToast: function(message) {
	 *         var toast = new UI.Toast({
	 *             text: message
	 *         });
	 *         toast.setOnDisappear(function() {
	 *             toast.destroy();
	 *         });
	 *         toast.show();
	 *     },
	 *
	 *     launch: function() {
	 *         showToast("Update required. Opening Google Play...");
	 *
	 *         // Wait 3 seconds, then launch Google Play.
	 *         setTimeout(function() {
	 *             Device.IPCEmitter.launch(uri, function(error) {
	 *                 if (error) {
	 *                     showToast("Please open Google Play to download the update.");
	 *                 }
	 *             });
	 *         }, 3000);
	 *     }
	 * });
	 *
	 * Updater.update();
	 * @constructs
	 * @augments Core.MessageEmitter
	 * @singleton
	 */
	initialize: function()
	{
		console.log('IPCEmitter.initialize');
		this._callbackID = 0;
		this._callbacks = [];
		
		this._shouldEmitIntents = false;

		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * Check whether the device has an app that can handle a URL.
	 * @example
	 * var urlToLaunch = "mobagesample://example?test=test";
	 * Device.IPCEmitter.canLaunch(urlToLaunch, function(canLaunch) {
	 *     if (canLaunch) {
	 *         console.log("Launching URL: " + canLaunch);
	 *         Device.IPCEmitter.launch(urlToLaunch, function(error) {
	 *             console.log("An error occurred while launching " + urlToLaunch +
	 *               ": " + error);
	 *         });
	 *     } else {
	 *         console.log("Cannot launch the URL: " + urlToLaunch);
	 *     }
	 * });
	 * @param {String} url A URL to test.
	 * @cb {Function} callback The function to call after checking whether the URL can be launched.
	 * @cb-param {Boolean} canLaunch Set to <code>true</code> if the URL can be launched.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status
	 * @since 1.0
	 */
	canLaunch: function(url, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._canLaunchSendGen(url,this._callbackID);
		this._callbackID++;
	},

	/**
	 * Launch an app that can handle the specified URL, or switch to the app if it is already
	 * running.
	 * @example
	 * var urlToLaunch = "mobagesample://example?test=test";
	 * Device.IPCEmitter.launch(urlToLaunch, function(error) {
	 *     console.log("An error occurred while launching " + urlToLaunch +
	 *       ": " + error);
	 * });
	 * @param {String} url A URL to launch.
	 * @cb {Function} callback The function to call after attempting to launch the URL.
	 * @cb-param {String} error Information about the error, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.0
	 */
	launch: function(url, callback)
	{
		 this._callbacks[this._callbackID] = callback;
		 this._launchSendGen(url,this._callbackID);
		 this._callbackID++;
	},

	launchIntent: function( intent, extras, packageName )
	{
		// Similar to launchService, stash the packageName in extras.
		if (typeof(packageName) == "string")
		{
			if (typeof(extras) == "string")
			{
				extras = JSON.parse(extras);
			}
			extras["packageName"] = packageName;
		}
		if (typeof extras == 'object') {
			extras = JSON.stringify(extras);
		}
		this._launchIntentSendGen(intent, extras);
	},
	
	launchService: function( intent, extras, packageName )
	{
		//This function originally did not take a "packageName" parameter, it was part of the extrasObj.
		//The separate parameter is added to make it a bit more clear that it is necessary to pass in a packageName.
		//Not sure it's going to help though, because we're trying to preserve backwards compatibility here.
		if (typeof(packageName) == "string")
		{
			var extrasObj;
			if (typeof(extras) == "string")
			{
				extrasObj = JSON.parse(extras);
			}
			else
			{
				extrasObj = {};
			}
			extrasObj["packageName"] = packageName;
			extras = JSON.stringify(extrasObj);
		}
		this._launchServiceSendGen(intent,extras);
	},

	/**
	 * Launch a Single Sign-on URL.
	 * @private
	 * @example var appToLaunch = 'mobage//auth?packageName=xxx.xxx&amp;className=xxx.xxx';
	 * Device.IPCEmitter.launchForSSO(appToLaunch, function(error) {
	 *     label.setText('failed in  launching the URL:' + appToLaunch);
	 * });
	 * @param {String} url The URL to launch. The URL must include the following as part of the query string: packageName=xxxx&amp;className=yyyy.
	 * @cb {Function} callback The function to call after launching the URL.
	 * @cb-param {String} error The error message, if any.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status
	 * @since 1.0
	 */
	launchForSSO: function(url, callback)
	{
		url += '&sso_auth';
		this.launch(url, callback);
	},

	/**
	 * Retrieve an array of signatures for the packageName.
	 * @private
	 * @param {String} packageName packageName is like "com.ngmoco.gamejs"
	 * @cb {Function} callback The function to call after retrieving the signatures.
	 * @cb-param {String[]} signatures An array of signatures.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status Android
	 * @since 1.0
	 */
	getAppSignatures: function(packageName, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getAppSignaturesSendGen(packageName,this._callbackID);
		this._callbackID++;
	},

	/**
	 * Retrieve the package name that invokes this ngCore app.
	 * @private
	 * @cb {Function} callback The function to call after retrieving the package name.
	 * @cb-param {String} packageName The package name.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status Android
	 * @since 1.1.5
	 */
	getCallingPackage: function(callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getCallingPackageSendGen(this._callbackID);
		this._callbackID++;
	},
	
	/**
	 * Determine whether a service is running.
	 * @private
	 * @param {Device.IPCEmitter.Service} serviceEnum The service to query.
	 * @cb {Function} callback The function to call after determining whether the service is
	 *		running.
	 * @cb-param {Boolean} isServiceRunning Set to <code>true</code> if the service is running.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status Android
	 * @since 1.3.1b
	 */
	getIsServiceRunning: function(serviceEnum, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getIsServiceRunningSendGen(serviceEnum, this._callbackID);
		this._callbackID++;
	},


	app: function()
	{
		return this._app;
	},

	App: Class.subclass(
	/** @lends Device.IPCEmitter.App.prototype */
	{
		classname: 'App',

		/**
		 * @class Information about the app.
		 * @ignore
		 */
		initialize: function(sourceAppID, intentURL)
		{
			this._sourceAppID   = sourceAppID;
			this._intentURL     = intentURL;
		},

		/**
		 * information for checking if application has launched or resumed with custom URL scheme.
		 * @type String
		 * @ignore
		 */
		getID: function()
		{
			return this._sourceAppID;
		},

		/**
		 * Returns the URL used to launch this app, or an empty string if not launched via URL
		 * @type String
		 * @ignore
		 */
		getURL: function()
		{
			return this._intentURL;
		}
	}),

	Intent: Class.subclass(
	/** @lends Device.IPCEmitter.App.prototype */
	{
		classname: 'Intent',

		/**
		 * @class Information about the app.
		 * @ignore
		 */
		initialize: function(action, extras)
		{
			this._action   = action;
			this._extras   = extras;
		},

		/**
		 * information for checking if application has launched or resumed with custom URL scheme.
		 * @type String
		 * @ignore
		 */
		getAction: function()
		{
			return this._action;
		},

		/**
		 * Returns the URL used to launch this app, or an empty string if not launched via URL
		 * @type String
		 * @ignore
		 */
		getExtras: function()
		{
			return this._extras;
		}
	}),

	/**
	 * Create home screen shortcut icon.
	 * @private
	 * @param {String} name Displayed shortcut name
	 * @param {String} url Invoked url when icon clicked.
	 * @param {String} icon_path Local file path that stores icon file.
	 * @returns {void}
	 * @status Android
	 * @since 1.3.1b
	 */
	createShortcut: function( name, url, icon_path )
	{
		this._createShortcutSendGen(name, url, icon_path);
	},

	/**
	 * Create home screen shortcut icon with downloading its image.
	 * @private
	 * @param {String} name Displayed shortcut name.
	 * @param {String} url Invoked url when icon clicked.
	 * @param {String} icon_url Icon image url.
	 * @cb {Function} [callback] The function to call after creating the shortcut icon.
	 * @cb-param {Boolean} hasDownloadError Returns <code>true</code> if there was an error
	 *		downloading the icon.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status Android
	 * @since 1.3.1b
	 */
	createShortcutByIconUrl: function( name, url, icon_url, callback )
	{
                NgLogD("createShortcutByIconUrl called", name, url, icon_url);

                var df = new DownloadFile();
                var filename = 'shortcut_icon_image'+(new Date().getTime());
                var self = this;
                NgLogD("Icon download begin");
		Util.OperationWithRetries(function(failCb, abortCb) {
			df.start(filename, 'GET', icon_url, [], function( statusCode, fileSignature ) {
				NgLogD("Icon download finished status="+statusCode);
				if(statusCode == 200) {
					self.createShortcut( name, url, filename );
					FileSystem.deleteFile( filename, {}, function() {
						if(callback)
							callback(false);
					});
				}
				else if(statusCode == 404)
				{
					NgLogE("Unable download icon file: icon_url="+icon_url+", status="+statusCode);
					abortCb();
				}
				else
				{
					NgLogE("Unable download icon file: icon_url="+icon_url+", status="+statusCode);
					failCb();
				}
			});
		},
		function() {
			NgLogE("Unable download icon file");
			if(callback)
				callback(true);
		}, 
		true);
	},

	// ------------------------------------------------------------------
	// private
	//

	/**
	 * invoked from native when the app is resumed back from other app.
	 * @private
	 * @since 1.0
	 */
	_onResumedFromOthers: function (url, sourceAppID)
	{
		this._app = new Device.IPCEmitter.App(sourceAppID, url);
		this.emit(this._app);

		//Cascade the original message back out to native for forwarding
		this._onResumeFromOthersSendGen(url, sourceAppID);
	},
	
	// The game should not call this
	_setEmitIntents: function ( emit ) {
		this._shouldEmitIntents = Boolean(emit);
	},

	_onIntentReceived: function (action, extras)
	{
		console.log("On IntentReceived: " + action + " / " + JSON.stringify(extras));
		if (this._shouldEmitIntents) {
			this.emit( new exports.IPCEmitter.Intent(action, extras) );
		}
	},

	// private
	_canLaunchCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._canLaunchCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.canLaunch);
		}
	},

	_onResumeFromOthersRecv: function(cmd)
	{
		var msg = {};
		if (! this._onResumeFromOthersRecvGen(cmd, msg))
			return;

		this._onResumedFromOthers(msg.url, msg.sourceAppID);
	},

	_launchFailedRecv: function( cmd )
	{
		var msg = {};
		if (! this._launchFailedRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.canLaunch);
		}
	},

	_getAppSignaturesCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getAppSignaturesCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.signatures.split(','));
		}
	},

	_getCallingPackageCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getCallingPackageCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.packageName);
		}
	},
	
	
	_getIsServiceRunningCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getIsServiceRunningCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.running);
		}
	},
	
	_onIntentReceivedRecv: function( cmd )
	{
		var msg = {};
		if (! this._onIntentReceivedRecvGen(cmd, msg))
			return;
		
		this._onIntentReceived( msg.action, JSON.parse(msg.extras, 10) );
	},
	
	/**
	 * Enumeration for services whose status can be queried.
	 * @private
	 * @name Service
	 * @fieldOf Device.IPCEmitter#
	 */
	
	/**
	 * The download provider for the system.
	 * @private
	 * @name Service.SystemDownloadProvider
	 * @fieldOf Device.IPCEmitter#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Service:
	{ 
		SystemDownloadProvider: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 349,
	// Method create = -1
	// Method canLaunch = 2
	// Method launch = 3
	// Method onResumeFromOthers = 4
	// Method launchFailed = 5
	// Method canLaunchCallback = 6
	// Method getAppSignatures = 7
	// Method getAppSignaturesCallback = 8
	// Method getCallingPackage = 9
	// Method getCallingPackageCallback = 10
	// Method launchIntent = 11
	// Method launchService = 12
	// Method onIntentReceived = 13
	// Method getIsServiceRunning = 14
	// Method getIsServiceRunningCallback = 15
	// Method createShortcut = 16
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._onResumeFromOthersRecv( cmd );
					break;
				case 5:
					instance._launchFailedRecv( cmd );
					break;
				case 6:
					instance._canLaunchCallbackRecv( cmd );
					break;
				case 8:
					instance._getAppSignaturesCallbackRecv( cmd );
					break;
				case 10:
					instance._getCallingPackageCallbackRecv( cmd );
					break;
				case 13:
					instance._onIntentReceivedRecv( cmd );
					break;
				case 15:
					instance._getIsServiceRunningCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in IPCEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in IPCEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[349] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onResumeFromOthersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		obj[ "sourceAppID" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "sourceAppID" ] === undefined )
		{
			NgLogE("Could not parse sourceAppID in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_launchFailedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_canLaunchCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		obj[ "canLaunch" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "canLaunch" ] === undefined )
		{
			NgLogE("Could not parse canLaunch in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getAppSignaturesCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		obj[ "signatures" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "signatures" ] === undefined )
		{
			NgLogE("Could not parse signatures in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getCallingPackageCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		obj[ "packageName" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "packageName" ] === undefined )
		{
			NgLogE("Could not parse packageName in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onIntentReceivedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		obj[ "action" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "action" ] === undefined )
		{
			NgLogE("Could not parse action in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		obj[ "extras" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "extras" ] === undefined )
		{
			NgLogE("Could not parse extras in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getIsServiceRunningCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		obj[ "running" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "running" ] === undefined )
		{
			NgLogE("Could not parse running in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x15dffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_canLaunchSendGen: function( url, callbackID )
	{
		Core.Proc.appendToCommandString( 0x15d0002, this, [ Core.Proc.encodeString( url ), +callbackID ] );
	},
	
	/** @private */
	_launchSendGen: function( url, callbackID )
	{
		Core.Proc.appendToCommandString( 0x15d0003, this, [ Core.Proc.encodeString( url ), +callbackID ] );
	},
	
	/** @private */
	_onResumeFromOthersSendGen: function( url, sourceAppID )
	{
		Core.Proc.appendToCommandString( 0x15d0004, this, [ Core.Proc.encodeString( url ), Core.Proc.encodeString( sourceAppID ) ] );
	},
	
	/** @private */
	_getAppSignaturesSendGen: function( packageName, callbackID )
	{
		Core.Proc.appendToCommandString( 0x15d0007, this, [ Core.Proc.encodeString( packageName ), +callbackID ] );
	},
	
	/** @private */
	_getCallingPackageSendGen: function( callbackID )
	{
		Core.Proc.appendToCommandString( 0x15d0009, this, [ +callbackID ] );
	},
	
	/** @private */
	_launchIntentSendGen: function( intent, extras )
	{
		Core.Proc.appendToCommandString( 0x15d000b, this, [ Core.Proc.encodeString( intent ), Core.Proc.encodeString( extras ) ] );
	},
	
	/** @private */
	_launchServiceSendGen: function( intent, extras )
	{
		Core.Proc.appendToCommandString( 0x15d000c, this, [ Core.Proc.encodeString( intent ), Core.Proc.encodeString( extras ) ] );
	},
	
	/** @private */
	_getIsServiceRunningSendGen: function( serviceEnum, callbackID )
	{
		Core.Proc.appendToCommandString( 0x15d000e, this, [ +serviceEnum, +callbackID ] );
	},
	
	/** @private */
	_createShortcutSendGen: function( name, url, icon_path )
	{
		Core.Proc.appendToCommandString( 0x15d0010, this, [ Core.Proc.encodeString( name ), Core.Proc.encodeString( url ), Core.Proc.encodeString( icon_path ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// canLaunch: function( url, callbackID ) {}
	
	// launch: function( url, callbackID ) {}
	
	// _onResumeFromOthersRecv: function( cmd ) {}
	// onResumeFromOthers: function( url, sourceAppID ) {}
	
	// _launchFailedRecv: function( cmd ) {}
	// _canLaunchCallbackRecv: function( cmd ) {}
	// getAppSignatures: function( packageName, callbackID ) {}
	
	// _getAppSignaturesCallbackRecv: function( cmd ) {}
	// getCallingPackage: function( callbackID ) {}
	
	// _getCallingPackageCallbackRecv: function( cmd ) {}
	// launchIntent: function( intent, extras ) {}
	
	// launchService: function( intent, extras ) {}
	
	// _onIntentReceivedRecv: function( cmd ) {}
	// getIsServiceRunning: function( serviceEnum, callbackID ) {}
	
	// _getIsServiceRunningCallbackRecv: function( cmd ) {}
	// createShortcut: function( name, url, icon_path ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LayoutEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LayoutEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LayoutEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/LayoutEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class LayoutEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

var _window = null;

////////////////////////////////////////////////////////////////////////////////

exports.LayoutEmitter = Core.MessageEmitter.singleton(
/** @lends Device.LayoutEmitter.prototype */
{
	classname: 'LayoutEmitter',
	
	/**
	 * @class The <code>LayoutEmitter</code> class constructs a singleton that sends an object to
	 * its listeners when the size of the display's usable portion is changing. The object has
	 * <code>width</code> and <code>height</code> properties representing the width and height, in
	 * logical units, of the display's usable portion. To determine how many pixels the device uses
	 * per logical unit, call <code>{@link Core.Capabilities#getScreenPixelUnits}</code>.
	 * @singleton
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 * @since 1.1.1.2
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_layoutChangedRecv: function( cmd ) 
	{
		var msg = {};
		if(!this._layoutChangedRecvGen(cmd, msg))
			return;

		this.setWidthAndHeight(msg.width, msg.height);
		
 		//NgLogD("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++JS received width as :"+ this._width + " and height as :" + this._height); 
		this.emit(msg);
		this._layoutChangedSendGen(msg.width, msg.height);
	},
	
	/**
	 * Retrieve the width of the usable portion of the display, in logical units, from the last 
	 * known event. To determine how many pixels the device uses per logical unit, call
	 * <code>{@link Core.Capabilities#getScreenPixelUnits}</code>.
	 * @name Device.LayoutEmitter.getWidth
	 * @function
	 * @static
	 * @returns {Number} The width of the usable portion of the display, in logical units.
	 * @since 1.4.1
	 */
	$getWidth: function()
	{
		return this._width;
	},
	
	/**
	 * Retrieve the height of the usable portion of the display, in logical units, from the last
	 * known event. To determine how many pixels the device uses per logical unit, call
	 * <code>{@link Core.Capabilities#getScreenPixelUnits}</code>.
	 * @name Device.LayoutEmitter.getHeight
	 * @function
	 * @static
	 * @returns {Number} The height of the usable portion of the display, in logical units.
	 * @since 1.4.1
	 */
	$getHeight: function()
	{
		return this._height;
	},
	
	$_setWindow: function(UIWindow) {
		_window = UIWindow;
	},
	
	/**
	 * @private
	 */
	setWidthAndHeight: function(width, height) {
		//NgLogD("---------------------------------Setting width and height for LayoutEmitter directly from native ......... width is " + width + " and height is " + height );
		this._width = width;
		this._height = height;
		if (_window) {
			_window._setWidthAndHeight(width, height);
		}
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 352,
	// Method create = -1
	// Method layoutChanged = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._layoutChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LayoutEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LayoutEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[352] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_layoutChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		obj[ "width" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "width" ] === undefined )
		{
			NgLogE("Could not parse width in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		obj[ "height" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "height" ] === undefined )
		{
			NgLogE("Could not parse height in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x160ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_layoutChangedSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( 0x1600002, this, [ +width, +height ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _layoutChangedRecv: function( cmd ) {}
	// layoutChanged: function( width, height ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_LocalNotification'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_LocalNotification'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_LocalNotification'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/_LocalNotification.js';

////////////////////////////////////////////////////////////////////////////////
// Class LocalNotification
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var Core = require ('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.LocalNotification = Core.MessageEmitter.singleton(
/** @lends Device.LocalNotification.prototype */
{
	classname: 'LocalNotification',
	
	/**
	 * @class The Device.LocalNotification object is used to interact with the local notification system of the device.
	 * With this class you can schedule, cancel, listen for notifications, and know if the game was launched from a notification.
	 *  
	 * @constructs The default constructor.
	 * @arguments Core.Class
	 */
	initialize: function()
	{
		this._callbackIndexCounter = 1;
		this._callbacks = [];
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * showLocalNotification is called with JSON options.  Currently, these
	 * JSON options are supported: {
	 * openurl : "mobage-ww-mobageBoot://mobageBoot/1/ServiceUI/Catalog",
	 * aps : {
	 *    alert: "Text to show in notification area"
	 *  }
	 * // optional, Android-only, string tag to control how the notifications
	 * // are stacked in the tray
	 * tag : "tray_tag_1"
	 * }
	 *    
	 * The game cannot invoke this function.
	 *
	 * @param options - json options to describe how to show local notification
	 * @private
	 */
	showLocalNotification: function( options ) {
		this._showLocalNotificationSendGen(options);
	},
	
	/**
	 * Schedule a local notification with JSON options. Currently, these JSON options are supported:
	 * var options = {
	 *   aps : {
	 *    alert: "Text to show in notification area"
	 *   },
	 *   //notification will be scheduled for the next delayTime milliseconds
	 *   delayTime : 10000, 
	 *   // optional, Android-only, string tag to control how the notifications are stacked in the tray
	 *   tag : "tray_tag_1",
	 *   // optional, an id that belongs to the game logic. It can be used to identify the notification.
	 *   gameId: my_game_logic_id
	 * }
	 * @example:
	 * //a notification that will be fired in 15 minutes.
	 * 
	 * var options: {
	 *   aps: {
	 *     alert: "Your blue item is ready!"
	 *   },
	 *   delayTime: 1000*60*15,
	 *   tag: "my_game",
	 *   gameId: "blue_item_" + blueItem.id,
	 * }
	 * Device.LocalNotification.schedule(options,function(notifSysId){
	 *    this._notifications[options.gameId] = id;
	 * }.bind(this));
	 * 
	 * @argument options - json options to describe how to show local notification.
	 * @argument {Function} callback called when the notification is scheduled. The system id of the scheduled notification is passed as an argument. A negative value will be given if the notification couldn't be scheduled.
	 * @status iOS, Android
	 */
	schedule: function( options, callback )
	{
		if (!(callback instanceof Function)) {
			throw new Error('LocalNotification.schedule requires a callback function, given: ' + callback);
		}
		if (!options.delayTime) {
			throw new Error('LocalNotification.schedule requires a delayTime given in options');
		}
			
		if (!options.aps.alert) {
			throw new Error('LocalNotification.schedule requires an aps.alert given in options');
		}
			
		var id = 0;
		if (callback) {
			id = this._callbackIndexCounter++;
			this._callbacks[id] = callback;
		}
		
		this._scheduleSendGen(id, options);
	},
	
	_scheduleCommandCbRecv: function( cmd )
	{
		var msg = {};
		if (!this._scheduleCommandCbRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("_scheduleCommandCbRecv command : No registered callback found, id = " + id);
			return;
		}
		
		delete this._callbacks[id];
		cb(msg.id);
	},
	
	/**
	 * Cancel a previously scheduled notification.
	 * 
	 * @example:
	 * Device.LocalNotification.cancel(31);
	 * 
	 * @argument {Number} id - notification system id to be removed.
	 * @status iOS, Android
	 */
	cancel: function( id ) {
		this._cancelSendGen(id);
	},
	
	/**
	 * Cancel all the scheduled local notifications.
	 * @example: Device.LocalNotification.cancelAll();
	 * @status iOS, Android
	 */
	cancelAll: function() {
		this._cancelAllSendGen();
	},
	
	/**
	 * Returns an object with all the scheduled notifications.
	 * @example:
	 * Device.LocalNotification.getAllScheduled(function(notifications){
	 *   for (var notifId in notifications) {
	 *     console.log("notificationId: " + notifId + ", notificationGameId: " + notifications[notifId]);
	 *   }
	 * }.bind(this));
	 * @argument {Function} callback called with the notifications object as only argument. The object structure is: {sysId1: gameId1, sysId2: gameId2}. An empty object will be given if there is no scheduled notifications.
	 * @status iOS, Android
	 */
	getAllScheduled: function(callback) {
		if (!(callback instanceof Function)) {
			throw new Error('LocalNotification.getAllScheduled requires a callback function, given: ' + callback);
		}
		
		var callbackId = 0;
		if (callback) {
			callbackId = this._callbackIndexCounter++;
			this._callbacks[callbackId] = callback;
		}
		
		this._getAllScheduledSendGen(callbackId);
	},
	
	_getAllScheduledCommandCbRecv: function( cmd )
	{
		var msg = {};
		if (!this._getAllScheduledCommandCbRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("LocalNotificaton._getAllScheduledCommandCbRecv command : No registered callback found, id = " + id);
			return;
		}
		
		delete this._callbacks[id];		
		cb(msg.response);
	},
	
	/**
	 * Retrieves the last notification info that was used to launch or bring to front the game.
	 * @example:
	 * Device.LocalNotification.retrieveLauncherInfo(function(notification){
	 *   if (notification) {
	 *     console.log("Game was launched or brought to front with notification: notificationId: " + notification.id + ", notificationGameId: " + notification.gameId);
	 *   }
	 * }.bind(this));
	 * @argument {Function} callback called with the notification object or null. The object structure is: {id: sysId, gameId: gameId}.
	 */
	retrieveLauncherInfo: function( callback )
	{
		if (!(callback instanceof Function)) {
			throw new Error('LocalNotification.retrieveLauncherInfo requires a callback function, given: ' + callback);
		}
		
		var callbackId = 0;
		if (callback) {
			callbackId = this._callbackIndexCounter++;
			this._callbacks[callbackId] = callback;
		}
		
		this._retrieveLauncherInfoSendGen(callbackId);
	},
	
	_retrieveLauncherInfoCommandCbRecv: function( cmd )
	{
		var msg = {};
		if (!this._retrieveLauncherInfoCommandCbRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;

		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("LocalNotificaton._retrieveLauncherInfoCommandCbRecv command : No registered callback found, id = " + id);
			return;
		}

		delete this._callbacks[id];		
		cb(msg.response);
	},

    _onNotificationEventRecv: function( cmd )
    {
        var msg = {};
        if (!this._onNotificationEventRecvGen(cmd, msg)) {
            return;
        }

        this.emit(msg.info);
    },
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 354,
	// Method create = -1
	// Method destroy = 2
	// Method showLocalNotification = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocalNotification._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocalNotification._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[354] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x162ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1620002, this );
	},
	
	/** @private */
	_showLocalNotificationSendGen: function( options )
	{
		Core.Proc.appendToCommandString( 0x1620003, this, [ Core.Proc.encodeObject( options ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// showLocalNotification: function( options ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_UsageStats'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_UsageStats'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_UsageStats'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/_UsageStats.js';

////////////////////////////////////////////////////////////////////////////////
// Class UsageStats
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.UsageStats = Class.singleton(
/** @lends Device.UsageStats.prototype */
{
	classname: 'UsageStats',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this.requests = {};
		this.cbIdCounter = 1;

		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

	},
	
	getData: function( callback )
	{
		var cbId = this.cbIdCounter++;
		this.requests[cbId] = callback;
		this._getDataSendGen( cbId );
	},
	
	_getDataCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._getDataCbRecvGen( cmd, msg ))
			return;
		
		var cbId = msg.callbackId;
		var data = msg.data;

		if ( !cbId )
		{
			NgLogE ( "UsageStats.getData: No cbId" );
			return;
		}

		var cb = this.requests[ cbId ];

		if ( !cb )
		{
			NgLogE ( "UsageStats.getData:: No registered cb found..cbId is :" + cbId );
			return;
		}

		delete this.requests[ cbId ];
		try
		{
			cb ( JSON.parse(data) );
		}
		catch(e)
		{
			NgLogE( "UsageStats.getData: exception has occured while parsing JSON" );
		}
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 356,
	// Method create = -1
	// Method getData = 2
	// Method getDataCb = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._getDataCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in UsageStats._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in UsageStats._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[356] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_getDataCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in UsageStats.getDataCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in UsageStats.getDataCb from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in UsageStats.getDataCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x164ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_getDataSendGen: function( callbackId )
	{
		Core.Proc.appendToCommandString( 0x1640002, this, [ +callbackId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// getData: function( callbackId ) {}
	
	// _getDataCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/NotificationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/NotificationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/NotificationEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/NotificationEmitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class NotificationEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////
var TAG = "Device.NotificationEmitter";
exports.NotificationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.NotificationEmitter.prototype */
{
	classname: 'NotificationEmitter',
	
	/**
	 * Retrieve a notification that was received before the app started. For example, if the app is
	 * not running, and the user taps a remote notification for your app, the app will launch; your
	 * app must then call <code>getPendingNotification()</code> to retrieve the notification
	 * payload.
	 * <br /><br />
	 * If there is no pending notification, or if the app has already called this method, the method
	 * will return <code>undefined</code>.
	 * <br /><br />
	 * <strong>Important</strong>: Call this method during your app's startup process.
	 * @name Device.NotificationEmitter.getPendingNotification
	 * @function
	 * @static
	 * @returns {Object} The payload for the pending notification, with the same properties as the
	 *		<code>payload</code> parameter to
	 *		<code>{@link Device.NotificationEmitter#scheduleLocal}</code>, or <code>undefined</code>
	 *		if there is no pending notification.
	 * @since 1.7
	 */
	
	$getPendingNotification: function() {
		var notification = Core.Capabilities._getPendingNotification();
		if (notification) {
			notification = this._adjustFormat(notification);
		}
		return notification;
	},
	
	/**
	 * @class <code>Device.NotificationEmitter</code> uses the native notification mechanisms on 
     * Android and iOS to allow scheduling local notifications (ex: scheduling the notification,
     * "Your crops are now ready" for 6 hours in the future) 
     * or to receive application-specific notifications and payload data from local and remote 
     * sources (ex: "John moved Rook to Queen Bishop 4. It's your move!").
     * <br/><br/>
	 * When the app starts, it must call
	 * <code>{@link Device.NotificationEmitter.getPendingNotification}</code>, which retrieves a
	 * notification that was received before the app started. To receive notifications while the app
	 * is running, call <code>{@link Device.NotificationEmitter#addListener}</code> to add a 
	 * listener to the notification emitter.
	 * <br/><br/>
     * In addition, applications can use the method <code>{@link Device.NotificationEmitter#scheduleLocal}</code>
     * to schedule <em>local</em> notifications. For sending remote notifications, 
     * applications should use <code>{@link Social.Common.RemoteNotification.send}.</code><br/><br/>
     *
	 * As you develop your app, keep the following limitations in mind:
	 *
	 * <ul><li>Remote notifications may take a long time to arrive, and there is no guarantee that users
	 * will receive them.</li>
	 * <li>If a user dismisses the notification, rather than tapping on it, the payload will not
	 * be delivered to the app.</li>
	 * <li>If an app sends multiple remote notifications, the user may receive only the most recent
	 * notification.</li></ul>
	 * 
	 *
	 * <strong>Important</strong>: Do not use push notifications to provide features that require reliable
	 * messaging, such as delivery of a virtual item.<br/><br/>
	 *
	 * @constructs The default constructor
	 * @augments Core.MessageEmitter
	 * @singleton
	 * @since 1.7
	 */
	initialize: function()
	{
		this._callbackIndexCounter = 1;
		this._callbacks = {};
		this._payloadKeys = {"message":true,"badge":true,"sound":true,"collapseKey":true,"style":true,"iconUrl":true,"extras":true};
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

    /*
     * //Full Payload
	 * var payload = {
	 *   message: "Your blue item is ready!",
	 *   collapseKey: "my_game",	                // Only supported on Android
	 *   style: "normal",	                        // Only supported on Android
	 *   iconUrl: "internal/path/to/resource.png",	// Only supported on Android
	 *   badge: 3,	                                // Only supported on iOS
	 *   sound: "trumpets.caf",	                // Only supported on iOS
	 *   extras: {itemId: blueItem.id, itemType: "blue_item"}
	 * };    
    */
    	
	/**
	 * Schedule a local notification for some time in the future.<br/><br/>
	 *
	 * If you choose to pass a badge number in your payload, be sure to clear it appropriately
	 * by using {@link Device.NotificationEmitter#setAppBadgeCount}.
     *
	 * @example
	 * // A notification that will be fired in 15 minutes.
	 * 
	 * var payload = {
	 *   message: "Your blue item is ready!",
	 *   collapseKey: "my_game",	                        // Only supported on Android
	 *   style: "normal",	                                // Only supported on Android
	 *   iconUrl: "http://www.domain.com/notification.png",	// Only supported on Android
	 *   badge: 3,	                                        // Only supported on iOS
	 *   sound: "default",
	 *   extras: {itemId: blueItem.id, itemType: "blue_item"}
	 * };
	 * 
	 * var fireTime = (new Date().getTime() / 1000) + 15 * 60;
	 * 
	 * Device.NotificationEmitter.scheduleLocal(payload,fireTime,function(error,notification) {
	 *    if (error) {
	 *       console.log("Couldn't schedule the notification. Error: %s, code: %d", error.description, error.code);
	 *    } else {
	 *       console.log("Notification with message: %s, scheduled with systemId: %d", notification.payload.message, notification.id);
	 *    }
	 *    
	 * });
	 * 
	 * @param {Object} payload json options to describe how to show local notification.
	 * @param {String} payload.message The message that will be displayed to the user upon delivery of the notification. This is displayed by the native OS and delivered in the payload to the application.
	 * @param {String} payload.collapseKey This key is used by Android to group notifications. All notifications with the same collapseKey will be shown in the Notifications Window as one notification.
	 * @param {String} payload.style Determines the size of the icon in the Android Notifications Window. Options are <code>normal</code> and <code>largeIcon</code>.
	 * @param {String} payload.iconUrl A URL to an image file to use as an icon for this notification. This should be a network accessible URL.
	 * @param {Number} payload.badge iOS only. The number to display on the icon badge when viewing the application icon on the iOS home screen.
	 * @param {String} payload.sound Android only. Specifies whether to play a sound with the notification. 
	 * Possible values are <code>""</code> (no sound) or <code>"default"</code>.
	 * @param {Object} payload.extras A user-defined object that can be used to pass proprietary information.
	 * @param {Date or Number} time Time to fire the notification, as a Javascript Date or Unix Timestamp (seconds since the epoch).
	 * @cb {Function} callback called when the notification is scheduled.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {Object} notification Information about the notification that was scheduled.
	 * @cb-param {String} notification.id A unique ID for the notification.
	 * @cb-param {Object} notification.payload The payload for the notification, using the same
	 *		properties as the method's <code>payload</code> parameter.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.7
	 */
	scheduleLocal: function (payload,time,callback) {
		if (typeof callback != "function") {
			throw new Error(TAG + ".scheduleLocal: requires a callback function, given: " + callback);
		}
		if (!payload.message) {
			callback({code:-1,description:TAG + ".scheduleLocal: requires payload.message"});
			return;
		}
		
		if (time instanceof Date) {
			time = time.getTime() / 1000;
		}
			
		var cid = this._callbackIndexCounter++;
		this._callbacks[cid] = callback;
		
		this._scheduleSendGen(payload, ~~time ,cid);
	},
	
	_scheduleCbRecv: function( cmd )
	{
		var msg = {};
		if (!this._scheduleCbRecvGen(cmd, msg)) {
			return;
		}

		var cid = msg.callbackId;
		
		var cb = this._callbacks[cid];
		if (!cb) {
			NgLogE(TAG + "._scheduleCbRecv command : No registered callback found, id = " + cid);
			return;
		}
		
		delete this._callbacks[cid];
		cb(null,msg.notification);
	},
	
	/**
	 * Cancel a previously scheduled notification.
	 * 
	 * @example
	 * Device.NotificationEmitter.cancelScheduled(scheduledNotificationId);
	 * 
	 * @param {String} id An ID returned by a previous NotificationEmitter.schedule call.
	 * @returns {void}
	 * @since 1.7
	 */
	cancelScheduled: function( id ) {
		this._cancelScheduledSendGen(id);
	},
	
	/**
	 * Cancel all the scheduled local notifications.
	 * 
	 * @example
	 * Device.NotificationEmitter.cancelAllScheduled();
	 * @returns {void}
	 * @since 1.7
	 */
	cancelAllScheduled: function() {
		this._cancelAllScheduledSendGen();
	},
	
	/**
	 * Returns an array of all currently scheduled notifications.
	 * @example
	 * // Return format:
	 * {
	 *     "type":0,
	 *     "id":"notificationId", 
	 *     "payload":{ 
	 *         "message":"You did a thing! Claim your prize!"
	 *     }, 
	 *     "time":1332461937 
	 * }, 
	 * {
	 *     "type":0,
	 *     "id":"notificationId", 
	 *     ...
	 * }
	 * 
	 * @example
	 * Device.NotificationEmitter.getAllScheduled(function(notifications){
	 *   for (var i = 0; i < notifications.length; i++) {
	 *     var notification = notifications[i];
	 *     console.log("Notification %s will fire at time %s with payload %s", 
	 *                     notification.id, 
	 *                     notification.time, 
	 *                     JSON.stringify(notification.payload));
	 *   }
	 * });
	 * 
	 * @cb {Function} callback The function to call after retrieving the currently scheduled
	 *		notifications.
	 * @cb-param {Object[]} notifications An array of notifications. An empty array will be returned if no notifications are scheduled.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.7
	 */
	getAllScheduled: function(callback) {
		var cid = this._callbackIndexCounter++;
		this._callbacks[cid] = callback;
		
		this._getAllScheduledSendGen(cid);
	},
	
	_getAllScheduledCbRecv: function( cmd )
	{
		var msg = {};
		if (!this._getAllScheduledCbRecvGen(cmd, msg)) {
			return;
		}

		var cid = msg.callbackId;
		
		var cb = this._callbacks[cid];
		if (!cb) {
			NgLogE(TAG + "._getAllScheduledCbRecvGen command : No registered callback found, id = " + cid);
			return;
		}
		
		delete this._callbacks[cid];		
		cb(msg.notifications);
	},
	
	/**
	 * Adds a listener to receive notifications that arrive when the app is in the foreground. The
	 * listener will receive a <code>notification</code> object with the following properties:
	 * <ul>
	 * <li><code>notification.clicked</code>: Set to <code>true</code> if the user tapped the
	 * notification.</li>
	 * <li><code>notification.payload</code>: An object with the same properties that can be used
	 * in the <code>payload</code> parameter to
	 * <code>{@link Device.NotificationEmitter#scheduleLocal}</code>.</li>
	 * <li><code>notification.type</code>: The type of notification. Contains an enumerated value of
	 * <code>{@link Device.NotificationEmitter#Type}</code>.</li>
	 * </ul>
	 * @example
	 * Device.NotificationEmitter.addListener(new Core.MessageListener(), function(notification) {
	 *   if (notification.type == Device.NotificationEmitter.Type.Local) {
	 *      console.log("Local notification received. Notification message: " + notification.payload.message);
	 *   } else if (notification.type == Device.NotificationEmitter.Type.Remote) {
	 *      console.log("Remote notification received. Notification message: " + notification.payload.message);
	 *   } else {
	 *      console.log("Unknown type: " + notification.type);
	 *      return false;
	 *   }
	 *   return true;
	 * });
	 * @name Device.NotificationEmitter#addListener
	 * @function
	 * @param {Core.MessageListener} listener The <code>{@link Core.MessageListener}</code> object
	 *		that will listen to the emitter.
	 * @cb {Function} callback The function to call when the notification emitter is triggered. See
	 *		See the method description for details about the parameter that the callback will
	 *		receive.
	 * @cb-returns {Boolean} Set to <code>true</code> to halt propagation of the message to other
	 *		listeners or <code>false</code> to allow the message to propagate.
	 * @returns {void}
	 * @since 1.7
	 */

	 /*
	 * 	{notification} All keys defined by the notification spec in @link NotificationEmitter.schedule
	 * 	{notification.type} A Device.NotificationEmitter.Type enum, typically Local or Remote.
	 * 	{notification.clicked} Boolean. True if the system showed the user the notification, and the user decided to take action. If this bit is set, the application must perform the action described by the notification.
	 */
	addListener: function ($super, listener, callback){
		$super(listener,callback);
	},
	
    /**
     * Enumerated values for notification types.
     * @name Type
     * @fieldOf Device.NotificationEmitter#
     */
    
    /**
     * Local notification.
     * @name Type.Local
     * @fieldOf Device.NotificationEmitter#
     * @constant
     */
    
    /**
     * Remote notification.
     * @name Type.Remote
     * @fieldOf Device.NotificationEmitter#
     * @constant
     */


	/**
	 * Retrieves the current app badge count. 
	 * <br/><br/>
	 * This method is supported only on iOS. Calling this method on Android has no effect.
	 * 
	 * @example
	 * Device.NotificationEmitter.getAppBadgeCount( function(error, count) {} );
	 * 
	 * @cb {Function} callback The callback to be called with the current app badge.
	 * @cb-param {Object} error An error, if any.
	 * @cb-param {Number} badgeCount The current application icon badge count.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.7
	 */
	getAppBadgeCount: function(callback) {
		var cid = this._callbackIndexCounter++;
		this._callbacks[cid] = callback;
		
		this._getAppBadgeCountSendGen(cid);
	},
	
	_getAppBadgeCountCbRecv: function (cmd) {
		var msg = {};
		if (!this._getAppBadgeCountCbRecvGen(cmd, msg)) {
			return;
		}
		
		var cid = msg.callbackId;
		
		var cb = this._callbacks[cid];
		if (!cb) {
			NgLogE(TAG + "._getAppBadgeCountCbRecv command : No registered callback found, id = " + cid);
			return;
		}
		
		delete this._callbacks[cid];
		if (msg.error) {
			cb(JSON.parse(msg.error));
		} else {
			cb(null,msg.count);
		}
		
	},
	
	/**
	 * Set the badge count on the application's icon.
	 * <br/><br/>
	 * This method is supported only on iOS. Calling this method on Android has no effect.
	 * 
	 * @example
	 * Device.NotificationEmitter.setAppBadgeCount(1);
	 * 
	 * @param {Number} count The badge count.
	 * @returns {void}
	 * @since 1.7
	 */
	setAppBadgeCount: function(count) {
		this._setAppBadgeCountSendGen(count);
	},
	
	_notificationOccurredRecv: function( cmd )
	{
		var msg = {};
		if (!this._notificationOccurredRecvGen(cmd, msg))
			return;
		
		var notification = this._adjustFormat(JSON.parse(msg.notification));
		
		if(!this.chain(notification)) {
			//No one handled this event. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._notificationOccurredSendGen(msg.notification);
		}
		
	},
	
	_adjustFormat: function (notification) {
		//only remote require_s adjustment
		if (notification.type != Device.NotificationEmitter.Type.Remote) {
			return notification;
		}
		
		if (notification.message) {
			//Android
			return this._adjustC2DM(notification);
		} else if (notification.aps) {
			//iOS
			return this._adjustAPN(notification);
		} else {
			//Don't know, return it as it comes
			return notification;
		}
	},
	
	_adjustC2DM: function (notification) {
		//populate the payload
    	var payload = {};
		for (var key in notification) {
			var opaqueOvalue = notification[key];
			if (key in this._payloadKeys) {
				if (key == "extras" && typeof opaqueOvalue == "string") {
					var value = opaqueOvalue;
					if (value !== "") {
						payload[key] = JSON.parse(decodeURIComponent(value));
					} else {
						payload[key] = null;
					}
				} else {
					payload[key] = opaqueOvalue;
				}
			}
		}
		
		notification.payload = payload;
		return notification;
	},
	
	_adjustAPN: function (notification) {
		var payload = {};
		notification.payload = payload;
		var x = notification.x;
		
		notification.id = x[1];
		notification.senderId = x[2];
		if(typeof x[3] == "string" && x[3] !== "") {
			try {
				payload.extras =  JSON.parse(x[3]);
			} catch(e) {
				NgLogE("Unable to parse payload json: "+e);
				payload.extras = null;
			}
		} else {
			payload.extras = null;
		}
		notification.published = x[4];
		
		//populate the payload
		var aps = notification.aps;
		payload.message = aps.alert;
		payload.badge = aps.badge;
		payload.sound = aps.sound;

		return notification;
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	Type:
	{ 
		Local: 0,
		Remote: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 366,
	// Method create = -1
	// Method schedule = 2
	// Method scheduleCb = 3
	// Method getAllScheduled = 4
	// Method getAllScheduledCb = 5
	// Method cancelScheduled = 6
	// Method cancelAllScheduled = 7
	// Method getAppBadgeCount = 8
	// Method getAppBadgeCountCb = 9
	// Method setAppBadgeCount = 10
	// Method notificationOccurred = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._scheduleCbRecv( cmd );
					break;
				case 5:
					instance._getAllScheduledCbRecv( cmd );
					break;
				case 9:
					instance._getAppBadgeCountCbRecv( cmd );
					break;
				case 11:
					instance._notificationOccurredRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in NotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in NotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[366] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_scheduleCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in NotificationEmitter.scheduleCb from command: " + cmd );
			return false;
		}
		
		obj[ "notification" ] = Core.Proc.parseObject( cmd[ 0 ] );
		if( obj[ "notification" ] === undefined )
		{
			NgLogE("Could not parse notification in NotificationEmitter.scheduleCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in NotificationEmitter.scheduleCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getAllScheduledCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in NotificationEmitter.getAllScheduledCb from command: " + cmd );
			return false;
		}
		
		obj[ "notifications" ] = Core.Proc.parseObject( cmd[ 0 ] );
		if( obj[ "notifications" ] === undefined )
		{
			NgLogE("Could not parse notifications in NotificationEmitter.getAllScheduledCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in NotificationEmitter.getAllScheduledCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getAppBadgeCountCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in NotificationEmitter.getAppBadgeCountCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in NotificationEmitter.getAppBadgeCountCb from command: " + cmd );
			return false;
		}
		
		obj[ "count" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "count" ] === undefined )
		{
			NgLogE("Could not parse count in NotificationEmitter.getAppBadgeCountCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in NotificationEmitter.getAppBadgeCountCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_notificationOccurredRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in NotificationEmitter.notificationOccurred from command: " + cmd );
			return false;
		}
		
		obj[ "notification" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "notification" ] === undefined )
		{
			NgLogE("Could not parse notification in NotificationEmitter.notificationOccurred from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x16effff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_scheduleSendGen: function( payload, time, callbackId )
	{
		Core.Proc.appendToCommandString( 0x16e0002, this, [ Core.Proc.encodeObject( payload ), +time, +callbackId ] );
	},
	
	/** @private */
	_getAllScheduledSendGen: function( callbackId )
	{
		Core.Proc.appendToCommandString( 0x16e0004, this, [ +callbackId ] );
	},
	
	/** @private */
	_cancelScheduledSendGen: function( id )
	{
		Core.Proc.appendToCommandString( 0x16e0006, this, [ Core.Proc.encodeString( id ) ] );
	},
	
	/** @private */
	_cancelAllScheduledSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16e0007, this );
	},
	
	/** @private */
	_getAppBadgeCountSendGen: function( callbackId )
	{
		Core.Proc.appendToCommandString( 0x16e0008, this, [ +callbackId ] );
	},
	
	/** @private */
	_setAppBadgeCountSendGen: function( count )
	{
		Core.Proc.appendToCommandString( 0x16e000a, this, [ +count ] );
	},
	
	/** @private */
	_notificationOccurredSendGen: function( notification )
	{
		Core.Proc.appendToCommandString( 0x16e000b, this, [ Core.Proc.encodeString( notification ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// schedule: function( payload, time, callbackId ) {}
	
	// _scheduleCbRecv: function( cmd ) {}
	// getAllScheduled: function( callbackId ) {}
	
	// _getAllScheduledCbRecv: function( cmd ) {}
	// cancelScheduled: function( id ) {}
	
	// cancelAllScheduled: function(  ) {}
	
	// getAppBadgeCount: function( callbackId ) {}
	
	// _getAppBadgeCountCbRecv: function( cmd ) {}
	// setAppBadgeCount: function( count ) {}
	
	// _notificationOccurredRecv: function( cmd ) {}
	// notificationOccurred: function( notification ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// Device diagnostic emitter; collects info from Device subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

//
// Create and export a DiagnosticEmitter for Device.
//

exports.Diagnostics = Core.DiagnosticEmitter.singleton(
{
	classname: 'Device_Diagnostics',

	/**
	 * @class The <code>Device.Diagnostics</code> class provides detailed diagnostic information
	 * about the device's memory usage, orientation, and screen size. You can use this information
	 * to debug your app and learn more about the app's performance.
	 * <br /><br />
	 * The emitter emits an object of the form:
	 * <br /><br />
	 * <pre>
	 * {
	 *     name: "Device",                          // The emitter's name
	 *     mem_info: {
	 *         totalFreeMemory: {Number},           // Total free memory, in bytes
	 *         virtualSize: {Number},               // Virtual memory size of the process, in bytes
	 *         residentSize: {Number}               // Resident memory size of the process, in bytes
	 *     },
	 *     interface_orientation: {Orientation},    // Current interface orientation
	 *     device_orientation: {Orientation},       // Current device orientation
	 *     layout: {Number[]}                       // The usable screen width and height
	 * }
	 * </pre>
	 * The <code>Orientation</code> type contains one of the following strings:
	 * <br /><br />
	 * <ul>
	 * <li><code>FaceDown</code>: Oriented with the face of the device down. Used only on iOS.</li>
	 * <li><code>FaceUp</code>: Oriented with the face of the device up. Used only on iOS.</li>
	 * <li><code>LandscapeLeft</code>: Landscape orientation with the top of the device to the
	 * left.</li>
	 * <li><code>LandscapeRight</code>: Landscape orientation with the top of the device to the
	 * right. Used only on iOS and on Android 2.3 and later.</li>
	 * <li><code>Portrait</code>: Portrait orientation.</li>
	 * <li><code>PortraitUpsideDown</code>: Portrait orientation, but rotated 180 degrees. Used only
	 * on iOS and on Android 2.3 and later.</li>
	 * <li><code>Unknown</code>: Orientation could not be determined.</li>
	 * </ul>
	 * @name Device.Diagnostics
	 * @constructs
	 * @augments Core.DiagnosticEmitter
	 * @singleton
	 * @since 1.8
	 */
	initialize: function($super)
	{
	$super('Device');
	}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device'] || {}; $MODULE_REGISTRY['NGCore/Client/Device'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Device.js';

/**
 * <p>Classes and objects contained by the Device module.</p>
 * @name Device
 * @namespace Capture a device's location, movement, and user input.
 * @description <p>The Device module is a collection of classes that support the effect of physical movement on a device.
 * Each class instantiates a device singleton that emits when specific device conditions are met:</p>
 *<ul>
 *<li><code>{@link Device.Diagnostics}</code>: A singleton object that provides diagnostic information about the device.</li>
 *<li><code>{@link Device.KeyEmitter}</code>: A singleton object for emitting when the user presses or releases a device hardware key.</li>
 *<li><code>{@link Device.LayoutEmitter}</code>: A singleton object for emitting when the size of the display's usable portion is changing.</li>
 *<li><code>{@link Device.LifecycleEmitter}</code>: A singleton object for emitting when device lifecycle events occur.</li>
 *<li><code>{@link Device.LocationEmitter}</code>: A singleton object for emitting the geographic location of a device.</li>
 *<li><code>{@link Device.MemoryEmitter}</code>: A singleton object for emitting when low-memory states occur on a device.</li>
 *<li><code>{@link Device.MotionEmitter}</code>: A singleton object for emitting objects that collect spatial data from a device.</li>
 *<li><code>{@link Device.NetworkEmitter}</code>: A singleton object for emitting when a change in network status occurs for a device.</li>
 *<li><code>{@link Device.NotificationEmitter}</code>: A singleton object for retrieving notifications and scheduling local notifications.</li>
 *<li><code>{@link Device.OrientationEmitter}</code>: A singleton object for emitting when a change to the physical orientation of the device occurs.</li>
 *<li><code>{@link Device.ShakeEmitter}</code>: A singleton object for emitting when the device detects a shake gesture.</li>
 *</ul>
 */
function DeviceLoader(map) {
	this.add = function(key, toEval) {
		this.__defineGetter__(key, function() {
			delete this[key];
			return this[key] = toEval();
		});
	};
	for (var k in map) {
		if (map.hasOwnProperty(k)) this.add(k, map[k]);
	}
}

exports.Device = new DeviceLoader({
	'LifecycleEmitter': function() { return require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter; },
	'LocationEmitter': function() { return require('NGCore/Client/Device/LocationEmitter').LocationEmitter; },
	'MemoryEmitter': function() { return require('NGCore/Client/Device/MemoryEmitter').MemoryEmitter; },
	'MotionEmitter': function() { return require('NGCore/Client/Device/MotionEmitter').MotionEmitter; },
	'NetworkEmitter': function() { return require('NGCore/Client/Device/NetworkEmitter').NetworkEmitter; },
	'OrientationEmitter': function() { return require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter; },
	'ShakeEmitter': function() { return require('NGCore/Client/Device/ShakeEmitter').ShakeEmitter; },
	'KeyEmitter': function() { return require('NGCore/Client/Device/KeyEmitter').KeyEmitter; },
	'PushNotificationEmitter': function() { return require('NGCore/Client/Device/_PushNotificationEmitter').PushNotificationEmitter; },
	'InAppPurchaseEmitter': function() { return require('NGCore/Client/Device/_InAppPurchaseEmitter').InAppPurchaseEmitter; },
	'InAppPurchase': function() { return require('NGCore/Client/Device/_InAppPurchase').InAppPurchase; },
	'IPCEmitter': function() { return require('NGCore/Client/Device/IPCEmitter').IPCEmitter; },
	'LayoutEmitter': function() { return require('NGCore/Client/Device/LayoutEmitter').LayoutEmitter; },
	'LocalNotification': function() { return require('NGCore/Client/Device/_LocalNotification').LocalNotification; },
	'UsageStats': function() { return require('NGCore/Client/Device/_UsageStats').UsageStats; },
	'NotificationEmitter': function() { return require('NGCore/Client/Device/NotificationEmitter').NotificationEmitter; }
});
exports.Device.__defineGetter__("NotificationEmitter", function() {
	delete this.UsageStats;
	return this.UsageStats= require('NGCore/Client/Device/NotificationEmitter').NotificationEmitter;
});
exports.Device.__defineGetter__("Diagnostics", function() {
	delete this.Diagnostics;
	return this.Diagnostics = require('NGCore/Client/Device/Diagnostics').Diagnostics;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Game'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Game'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Game'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/Game.js';

var Core		= require("NGCore/Client/Core").Core;
var Device		= require("NGCore/Client/Device").Device;

var DataModelR	= require("NGCore/Client/Social/US/Models/DataModel");
var OrderedList	= require("NGCore/Client/Social/US/Models/OrderedList").OrderedList;
var Dispatcher	= require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
 * <code>Game</code> objects identify a game and its properties.
 * Game properties include: 
 * <ul>
 * <li><code>name</code></li>
 * <li><code>publisher</code></li>
 * <li><code>category</code></li>
 * <li><code>featured</code></li>
 * <li><code>numberOfLeaderboards</code></li> 
 * <li><code>numberOfAchievements</code></li>
 * <li><code>masterProductID</code></li>
 * <li><code>iconURL</code></li>
 * <li><code>AppStoreURL</code></li>
 * <li><code>feedURL</code></li>
 * <li><code>catalogURL</code></li>
 * </ul>
 * <code>Game</code> objects provide static functions to return all games in a catalog or games associated to a user profile.
 * 
 * @class 
 * @name Social.US.Game
 * @augments Social.US.DataModel
 */
var Game = exports.Game = DataModelR.DataModel.subclass({
	classname: "Game",
	
	
	 //Game is a subclass of data model, and the getter/setter methods are generated by defineSetterCallbacks. The following
	 //comments document the generated methods.
	 /**
	 * The game name. Read-only.
	 * @name Social.US.Game.name
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The publisher name. Read-only.
	 * @name Social.US.Game.publisher
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The game category name. Read-only.
	 * @name Social.US.Game.category
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Whether the game is featured. Read-only.
	 * @name Social.US.Game.featured
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The number of leaderboards for the game. Read-only.
	 * @name Social.US.Game.numberOfLeaderboards
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The number of achievements. Read-only.
	 * @name Social.US.Game.numberOfAchievements
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The master product ID. Read-only.
	 * @name Social.US.Game.masterProductID
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the icon for a game. Read-only.
	 * @name Social.US.Game.iconURL
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the store or marketplace for a game. Read-only.
	 * @name Social.US.Game.appStoreURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the RSS feed for a game. Read-only.
	 * @name Social.US.Game.feedURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Sets a catalog URL for the catalog of game items. Read-only.
	 * @name Social.US.Game.catalogURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	properties: [
		// public
		"name",
		"publisher",
		"category",
		"numberOfLeaderboards",
		"iconURL",
		
		// private
		"numberOfAchievements",
		"featured",
		"masterProductID",
		"appStoreURL",
		"feedURL",
		"catalogURL",
		"description",
		"phone_screenshot_urls",
		"ngcore_url",
		"androidMarketIntentURL"
	],
	
	/**
	 * @public
	 * Sends the user to the app store for this Game
	 */
	goToAppStore: function() {
		if (Core.Capabilities.getPlatformOS().toLowerCase() === "iphone os") {
			Device.IPCEmitter.launch(this.appStoreURL);
		} else {
			Device.IPCEmitter.launchIntent(this.androidMarketIntentURL);
		}
	}
});

/**
 * Returns an ordered list interface to the Mobage game catalog.
 * 
 * @name Social.US.Game.getAllGamesList
 * @function
 * @private 
 * @static
 *
 * @returns {Social.US.OrderedList} An ordered list interface to the catalog of games.
 * @see Social.US.OrderedList
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Game.getAllGamesList = function(){
		
	return OrderedList.getClassPublicInterface(Game, "getAllGamesList", "_allGamesInterface");
};

/**
 * Returns the current game. 
 *
 * @name Social.US.Game.getCurrentGame
 * @function
 * @static
 *
 * @cb {Function} cb The function to call after retrieving the current game.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} [error.description] A description of the error.
 * @cb-param {String} [error.errorCode] A code identifying the error type.
 * @cb-param {String} game An identifier for the game.
 * @cb-returns {void}
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Game.getCurrentGame = function(cb){
	Dispatcher.callClassMethodOnRemoteObject(Game, "getCurrentGame", [cb]);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/FullGamercard'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/FullGamercard'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/FullGamercard'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/FullGamercard.js';


var DataModelR  = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher  = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
 * @class {FullGamercard} Full gamercard.
 */
var FullGamercard = exports.FullGamercard = DataModelR.DataModel.subclass({
	classname: "FullGamercard",
	 /**
	 * The show state of the gamercard. Read-only.
	 * @name visible
	 */
	properties: [
		// public
		"visible"
	],
	
	/**
	 * Show the gamercard.
	 * 
	 * An exception will be thrown if no valid user is set when attempting
	 * to show the gamercard.
	 */
	show: function() {
		Dispatcher.callMethodOnRemoteObject(this, "show");
	},
	
	/**
	 * Hide the gamercard.
	 */
	hide: function() {
		Dispatcher.callMethodOnRemoteObject(this, "hide");
	},
	
	/**
	 * Set gamercard data.
	 * 
	 * This may be called on-the-fly to update the gamercard after it has been
	 * displayed.
	 * 
	 * Set the <code>gameModule</code> entry to <code>null</code> to remove/disable it.
	 * 
	 * Up to two buttons can be set on the game module. Click events for these buttons
	 * will come into <code>actionCB</code> with <code>action.buttonClick</code>. The
	 * presence of the <code>buttonClick</code> block indicates the click occurred and
	 * its contents provides more context: the <code>id</code> of the button in question.
	 * (Note that if the button doesn't have an ID, the index into the button array is
	 * used instead.)
	 * 
	 * @example
	 *    card.set(
	 *       {
	 *          user: 'gahtje3',
	 *          gameModule: {
	 *             basic: {
	 *                text: 'blah blah blah',
	 *                icon: 'http://ngmoco.com/we-rule/wp-content/themes/werule/images/game/logo-small.png'
	 *             },
	 *             buttons: [
	 *                { id: 'foo', label: 'Foo' },
	 *                { id: 'bar', label: 'Bar' }
	 *             ]
	 *          }
	 *       },
	 *       function(err) {
	 *          if(err) {
	 *             NgLogD("Something went horribly, horribly wrong: " + err);
	 *          }
	 *          else {
	 *             card.show();			// show once complete, after user has been loaded
	 *          }
	 *       },
	 *       function(action) {
	 *          if(action.hasOwnProperty('buttonClick')) {
	 *             NgLogD("Clicked button with ID '" + action.buttonClick.id + "'");
	 *          }
	 *       }
	 *    );
	 * 
	 * @example
	 *    card.set(
	 *       {
	 *          user: 'gahtje7',
	 *          gameModule: {
	 *             dynamicImage: {
	 *                image: 'http://media.tumblr.com/tumblr_lok12fhmJi1qhmqze.jpg?size={width}x{height}',
	 *                placeholder: {
	 *                   width: "{width}",
	 *                   height: "{height}"
	 *                }
	 *             }
	 *          }
	 *       },
	 *       null, null
	 *    );
	 * 
	 * @param conf Data to configure.
	 * @config {String|User} [user] User object or gamertag.
	 * @config [gameModule] Game module data. Adding this will cause the game module
	 *                      to be added to the gamercard automatically.
	 * @param {Function} [completeCB] Completion callback, with <code>error</code> parameters (<code>null</code> if no error).
	 * @param {Function} [actionCB] Action callback, with <code>data</code> parameter.
	 */
	set: function(conf, completeCB, actionCB) {
		Dispatcher.callMethodOnRemoteObject(this, "set", [conf, completeCB, actionCB]);
	}
});

/**
 * Gets the full gamercard.
 * 
 * Only one full gamercard is maintained and its settings can be changed on-the-fly
 * with calls to {@link FullGamercard#set}.
 * 
 * @function
 * @static
 * @example
 *    Gamercard.getFullGamercard(function(card) {
 *       card.set({
 *          user: 'gahtje3'
 *       });
 *       card.show();
 *    });
 * 
 * @param {Function} cb Callback. This function will be passed the gamercard.
 */
FullGamercard.getFullGamercard = function(cb) {
	Dispatcher.callClassMethodOnRemoteObject(FullGamercard, "getFullGamercard", [cb]);
};

/**
 * Gets the full gamercard and sets the user.
 * 
 * @function
 * @static
 * @example
 *    Gamercard.getFullGamercardAndSetUser('gahtje3', function(err, card) {
 *       if(!err) {
 *          card.show();
 *       }
 *    });
 * 
 * @param {String|User} userOrGamertag User object or gamertag of user.
 * @param {Function} cb Callback. This function will be passed arguments: error string
 *                   (<code>null<</code> on success) and the gamercard (if no error).
 */
FullGamercard.getFullGamercardAndSetUser = function(userOrGamertag, cb) {
	Dispatcher.callClassMethodOnRemoteObject(FullGamercard, "getFullGamercardAndSetUser", [userOrGamertag, cb]);
};

/**
 * Gets the full gamercard and sets the user as the currently logged-in user.
 * 
 * @function
 * @static
 * @example
 *    Gamercard.getFullGamercardAndSetCurrentUser(function(err, card) {
 *       if(!err) {
 *          card.show();
 *       }
 *    });
 * 
 * @param {Function} cb Callback. This function will be passed arguments: error string
 *                   (<code>null</code> on success) and the gamercard (if no error).
 */
FullGamercard.getFullGamercardAndSetCurrentUser = function(cb) {
	Dispatcher.callClassMethodOnRemoteObject(FullGamercard, "getFullGamercardAndSetCurrentUser", [cb]);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/Leaderboard.js';

var DataModelR = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;
var OrderedList = require("NGCore/Client/Social/US/Models/OrderedList").OrderedList;

/**
 * <code>Leaderboard</code> objects enable the current user to get friend scores, top scores, and submit a score.
 * To return a leaderboard, you must set up at least one leaderboard for your game in the Mobage Sandbox or Production environment.
 * @class 
 * @name Social.US.Leaderboard
 * @augments Social.US.DataModel
 */
var Leaderboard = exports.Leaderboard = DataModelR.DataModel.subclass({

	 
	classname: "Leaderboard",
	properties: [
	"level",
	"title",
	"game",
	"iconURL"
	],

	
	/** 
	 * @constructs Constructs a <code>Leaderboard</code> object identified by the record ID. 
	 * @private
	 *
	 * @param {Type} $super A reference to the DataModel superclass.
	 * @param {String} recordId The record ID of the object.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	initialize: function($super, recordID){
		$super(recordID);
		NgLogD("Leaderboard Public! " + recordID + " " + this.recordID);
	},
	
	
	/**
	 * Submits a score to the leaderboard.
	 *
	 * @name Social.US.Leaderboard.submitScore
	 * @function
	 *
	 * @param {Numeric} points The score points. If <code>null</code> or <code>undefined</code>, the callback error is "No score."
	 * @cb {Function} cb The function to call after submitting a score to the leaderboard.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Number} score The score.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	submitScore: function(points, cb){
		Dispatcher.callMethodOnRemoteObject(this, "submitScoreWithPoints", [points, cb]);
	},	
	
	/**
	 * Returns an <code>OrderedList</code> with the user's score and the highest scores.
	 * 
	 * @name Social.US.Leaderboard.getTopScoresList
	 * @function
	 *
	 * @returns {Social.US.OrderedList} The list of highest scores.
	 * @see Social.US.OrderedList
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	getTopScoresList: function(){
		return OrderedList.getObjectPublicInterface(this, "getTopScoresList", "_leaderboardTopScoresInterface");
	},
	
	/**
	 * Returns an <code>OrderedList</code> of scores for the user's friends.
	 * 
	 * @name Social.US.Leaderboard.getFriendsScoresList
	 * @function
	 *
	 * @returns {Social.US.OrderedList} The list of scores for the user's friends.
	 * @see Social.US.OrderedList
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	getFriendsScoresList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFriendsScoresList", "_leaderboardFriendsScoresInterface");
	}

	 /**
	  * The user's level in the game. Read-only.
	  * @name Social.US.Leaderboard.level
	  * @field
	  * @status iOS, Android, Test, iOSTested, AndroidTested
	  */
	 
	 /**
	  * The leaderboard title. Read-only.
	  * @name Social.US.Leaderboard.title
	  * @field
	  * @status iOS, Android, Test, iOSTested, AndroidTested
	  */

	 /**
	  * The game name. Read-only.
	  * @name Social.US.Leaderboard.game
	  * @field
	  * @status iOS, Android, Test, iOSTested, AndroidTested
	  */
	 
	 /**
	  * A URL to the leaderboard icon. Read-only.
	  * @name Social.US.Leaderboard.iconURL
	  * @field
	  * @status iOS, Android, Test, iOSTested, AndroidTested
	  */
		 
});

/**
 * Returns the leaderboard(s) for the current game.
 * To return a leaderboard, you must set up at least one leaderboard for your game in the Mobage Sandbox or Production environment.
 *
 * @name Social.US.Leaderboard.getLeaderboards
 * @function
 * @static
 *
 * @cb {Function} cb The function to call after retrieving the leaderboard(s) for the current game.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} error.description A description of the error.
 * @cb-param {String} error.errorCode A code identifying the error type.
 * @cb-param {Social.US.Leaderboard[]} leaderboards An array of leaderboards for the current game.
 * @cb-returns {void}
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Leaderboard.getLeaderboards = function(cb){
	Dispatcher.callClassMethodOnRemoteObject(Leaderboard, "getLeaderboards", [cb]);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Achievement'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Achievement'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Achievement'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/Achievement.js';

var GSGlobals 	= require("NGCore/Client/Social/_Internal/GSGlobals");
var DataModelR  = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher  = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
	// MAX: TODO: DOCUMENT 
 */

var Achievement = exports.Achievement = DataModelR.DataModel.subclass({
		
	classname: "Achievement",

	properties: [
		"description",
		"points",
		"category",
		"unlocked",
		"name",
		"index",
		"icon_url"
	],
	
	initialize: function($super, recordID){

		$super(recordID);
	},

	// cb signature: function(data, err), err is null if no error
	// data will have success: true, and points:___ with some # of points
	unlockAchievement: function(cb) {
		Dispatcher.callMethodOnRemoteObject(this, "unlockAchievement", [cb]);
	}

});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Score'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Score'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Score'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/Score.js';

var DataModel 	  = require("NGCore/Client/Social/US/Models/DataModel").DataModel;

/**
 * <code>Score</code> constructs objects that reflect a user's score for the current game.
 * @class 
 * @name Social.US.Score
 * @augments Social.US.DataModel
 */
var Score = exports.Score = DataModel.subclass({
	
    classname: "Score",
    	
	 /**
	 * A user's score. Read-only.
	 * @name Social.US.Score.score
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The score as formatted for display. Read-only.
	 * @name Social.US.Score.displayScore
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	
	 /**
	 * The user's rank. Read-only.
	 * @name Social.US.Score.rank
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	
	 /**
	 * The user's level in the current game. Read-only.
	 * @name Social.US.Score.level
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
    
	 /**
	 * A <code>Social.US.User</code> reference to the user associated to the score. Read-only.
	 * @name Social.US.Score.user
	 * @field
	 * @public
     * @see Social.US.User
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */    
	 
    properties: [
	"points",
	"displayScore",
	"rank",
	"level",
	"user"
	]
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/AppData'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/AppData'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/AppData'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Models';
var __filename = 'NGCore/Client/Social/US/Models/AppData.js';

var DataModelReq = require("NGCore/Client/Social/US/Models/DataModel");
var Dispatcher = require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher;

/**
 * <code>AppData</code> constructs objects that get and set a user's properties, 
 * and provides permissions for sharing the user's properties with other users.
 * <br /><br />
 * To use the <code>AppData</code> API, you must indicate on the Mobage Developer Portal that your
 * application uses this API. To do this, follow these steps:
 * <ol>
 * <li>Log into the Developer Portal at
 * <a href="https://developer-sandbox.mobage.com/en/portal/dashboard">https://developer-sandbox.mobage.com/en/portal/dashboard</a>.</li>
 * <li>Click the Apps tab at the top of the page, then click the name of your application.</li>
 * <li>Scroll to the bottom of the page and click Edit Product Details, then scroll
 * to the bottom of the page and ensure that the "Use userdata api" box is selected.</li>
 * <li>Click Save to save your changes.</li>
 * </ol>
 * <br /><br />
 * <strong>Note</strong>: You can also use ngCore's <code>{@link Storage.KeyValue}</code> and
 * <code>{@link Storage.FileSystem}</code> classes to store application data on the user's device.
 * @class 
 * @name Social.US.AppData
 * @see Social.Common.Appdata
 * @see Storage.KeyValue
 * @see Storage.FileSystem
 */
var AppData = exports.AppData = DataModelReq.DataModel.subclass({
/** @lends Social.US.AppData.prototype */
		
	classname: "AppData",
	properties: [
		"data",
		"key",
		"user",
		"permissions"
	],
	
	/**
	 * The application data for the user. Limited to 1024 bytes.
	 * 
	 * @name data
	 * @fieldOf Social.US.AppData#
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	/**
	 * The key describing the application data. Limited to 32 bytes.
	 * 
	 * @name key
	 * @fieldOf Social.US.AppData#
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	/**
	 * The name of the user who owns the data.
	 * 
	 * @name name
	 * @fieldOf Social.US.AppData#
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	/**
	 * The permissions for the application data.
	 * 
	 * @name permissions
	 * @fieldOf Social.US.AppData#
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
    /**
     * The default constructor.
     * @constructs 
     * @name Social.US.AppData.initialize
     * @private
     *
     * @param recordID A unique ID for the <code>AppData</code> object.
     *
     * @augments Social.US.DataModel
     * @status iOS, Android, Test, iOSTested, AndroidTested
     */	
    initialize: function($super, recordID) {
        $super(recordID);
    }
});

/**
 * Takes a user reference and returns key/value pairs of the user for the current game.
 * @name Social.US.AppData.getKeysForUser
 * @function
 * @static
 *
 * @param {Social.US.User} user A reference to the user.
 * @cb {Function} cb The function to call after retrieving key/value pairs.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} error.description A description of the error.
 * @cb-param {String} error.errorCode A code identifying the error type.
 * @cb-param {Object} entries The key/value pairs for the user. The properties of the object
 *		represent keys. The value of each property represents the value of the corresponding key.
 * @cb-returns {void}
 * @example
 * var user = Social.US.Session.getCurrentSession().user();
 * var AppData = Social.US.AppData;
 * var retrievedEntries = null;
 * AppData.getKeysForUser(user, function(error, entries){
 *     retrievedEntries = entries;
 * });
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
AppData.getKeysForUser = function(user, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "getKeysForUser", [user, cb]);
};

/**
 * Takes a user, a key (the name of the key for a name/value pair) and returns the key/value pair
 * for the user for the current game.
 * @name Social.US.AppData.getDataForUserWithKey
 * @function
 * @static
 *
 * @param {Social.US.User} user A reference to the user.
 * @param {String} key The name of the key.
 * @cb {Function} cb The function to call after retrieving the specified value.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} error.description A description of the error.
 * @cb-param {String} error.errorCode A code identifying the error type.
 * @cb-param {Object} response Information about the key.
 * @cb-param {String} response.data The value of the key.
 * @cb-returns {void}
 * @example
 * var user = Social.US.Session.getCurrentSession().user();
 * var AData = Social.US.AppData;
 * var errorCode = null;
 * var errorDesc = null;
 * var fetchedData = null;
 * AData.getDataForUserWithKey( user, 
 *                              key, 
 *                              function(error, response){
 *                                   errorCode = error.errorCode;
 *                                   errorDesc = error.description;
 *                                   fetchedData = response.data;
 *                              }
 *                            );
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
AppData.getDataForUserWithKey = function(user, key, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "getDataForUserWithKey", [user, key, cb]);
};


/**
 * Takes data, a user, a key (the name of the key for a name/value pair) and permissions for the
 * data and sets the application data for the user.
 * <b>Note:</b> Limited to 30 key/value pairs per user, per game. 
 * Maximum key name limited to 32 bytes. Maximum value limited to 1,024 bytes.
 * To use key/value pairs without the foregoing constraints, use ngCore's
 * <code>{@link Storage.KeyValue}</code> class.
 * @name Social.US.AppData.setDataForUserWithKeyAndPermissions
 * @function
 * @static 
 *
 * @param {String} data The data to set.
 * @param {Social.US.User} user A reference to the user.
 * @param {String} key The name of the key.
 * @param {Social.US.AppData.Permissions} permission The permissions for the data.
 * @cb {Function} cb The function to call after setting the value.
 * @cb-param {Object} error Information about the error, if any.
 * @cb-param {String} error.description A description of the error.
 * @cb-param {String} error.errorCode A code identifying the error type.
 * @cb-returns {void}
 * @example
 * var user = Social.US.Session.getCurrentSession().user();
 * var data = "some data";
 * var key = "some key";
 * var errorCode = null;
 * var errorDesc = null;
 * var result = null; 
 *
 * var AData = Social.US.AppData;
 * 
 * AData.setDataForUserWithKeyAndPermissions(data, 
 *                                           user, 
 *                                           key, 
 *                                           AppData.Permissions.Private, 
 *                                           function(error, response){
 *                                             errorCode = error.errorCode;
 *                                             errorDesc = error.description;
 *                                             result = response;
 *                                           }
 *                                         );
 * @returns {void}
 * @status iOS, Android, Test, iOSTested, AndroidTested
 * @see Social.US.AppData.Permissions
 * @see Social.Common.Appdata
 * @see Storage.KeyValue
 * @see Storage.FileSystem
 */
AppData.setDataForUserWithKeyAndPermissions = function(data, user, key, permissions, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "setDataForUserWithKeyAndPermissions", [data, user, key, permissions, cb]);
};



/**
 * Enumeration to define permissions for viewing user data.
 * @name Permissions
 * @fieldOf Social.US.AppData#
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */

/**
 * Only the user can read and write the user data.
 * @name Permissions.Private
 * @fieldOf Social.US.AppData#
 * @constant
 */

/**
 * Friends can read the user data but cannot write it.
 * @name Permissions.FriendsReadOnly
 * @fieldOf Social.US.AppData#
 * @constant
 */

/**
 * All users can read the user data but cannot write it.
 * @name Permissions.PublicReadOnly
 * @fieldOf Social.US.AppData#
 * @constant
 */

/** @ignore */
AppData.Permissions = {
	Private: 0,
	FriendsReadOnly: 1,
	PublicReadOnly: 2
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/GameLaunchPayload.js';

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

var MessageEmitter = require("NGCore/Client/Core/MessageEmitter").MessageEmitter;

/**
* Provides an interface for retrieving a game's last payload from the game service. The game
* payload is returned as a string.
* @name Social.US.Service.GameLaunchPayload
*/

var GameLaunchPayload = exports.GameLaunchPayload = {


	/**
	 * @name Social.US.Service.GameLaunchPayload.getLastPayload
	 * @function
	 * @public
	 * 
	 * @param {Function} callback Retrieves the last payload generated by the game client from the game service 
     * as a string (e.g., JSON) and/or any error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, payload){
     *      if(error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     *      } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var pl = payload;     
     *      }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	getLastPayload:function(callback)
	{
        if(callback != undefined && typeof callback == "function")
		{
			var cmd = {
				apiURL:"US.Service.GameLaunchPayload.getLastPayload"
			};

            cmd["callbackFunc"] = callback;

			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
		}
	},
	
	// MAX: NEEDS DOCUMENTATION!
	// use this to reference the emitter so that you can get push events as they are acted on by the user
	// Example usage code:
	
	//	listen for game push
	//	var GamePayloadListener = Core.MessageListener.subclass({
	//		_onNewGamePayload:function(payload) {
	//			TODO: act on game payload somehow :)
	//		},
	//
	//		destroy:function() {
	// 			Social.US.Service.GameLaunchPayload.getNewPayloadEmitter().removeListener(this);
	// 		}
	//	});
	//	var gamePayloadListenerInstance = new GamePayloadListener();
	//	Social.US.Service.GameLaunchPayload.getNewPayloadEmitter().addListener(gamePayloadListenerInstance,gamePayloadListenerInstance._onNewGamePayload);
	
	
	getNewPayloadEmitter:function() {
		if(!GameLaunchPayload.newGamePayloadEmitter) {
			NgLogD("Creating new payload emitter...");
			
			GameLaunchPayload.newGamePayloadEmitter = new MessageEmitter();
		}
		
		return GameLaunchPayload.newGamePayloadEmitter;
	},
	
	// private, automatically called when new payload arrives. Do not call.
	onGameLaunchPayload:function(event)
	{
		GameLaunchPayload.getNewPayloadEmitter().emit(event.data.payload);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Achievements'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Achievements'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Achievements'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/Achievements.js';

var RouterInited = require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals = require("NGCore/Client/Social/_Internal/GSGlobals");

exports.Achievements = {

	showAchievementsScreen: function() {
		NgLogD("Public - showAchievementsScreen");
		
		var cmd = {
			apiURL:"US.Service.Achievements.showAchievementsScreen"
		};

		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Bank'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Bank'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Bank'] = exports; 
var __dirname = 'NGCore/Client/Social/US/Service';
var __filename = 'NGCore/Client/Social/US/Service/Bank.js';

// Bank Public Interface
var RouterInited 	= require("NGCore/Client/Social/_Internal/RouterInit");
var GSGlobals 		= require("NGCore/Client/Social/_Internal/GSGlobals");

/**
* @ignore
* @private
*/
exports.Bank = {
};


/**
 * @class
 * @name Bank.Debit
 * @description
 * Bank.Debit is an interface for in-game item purchasing. A transaction begins with a call to <code>createTransaction()</code>, which presents
 * a user interface to the user. If the user follows through with a purchase, the <code>transaction.state</code> property changes from 
 * <code>new</code> to <code>authorized</code>. Once <code>createTransaction()</code> executes its callback, the game may call 
 * <code>openTransaction()</code>, which changes the state from <code>authorized</code> to <code>open</code> and puts funds into escrow. 
 * At this point, the game/game server should deliver the purchased items. Once the items have been delivered, the game should call   
 * <code>closeTransaction()</code>. If there is a problem at any point in the transaction lifecycle, call <code>cancelTransaction()</code>,
 * which sets the <code>transactionState</code> property to <code>canceled</code> and restores funds from escrow back to the user.
 * <br /><br />
 * The value of a single transaction cannot exceed 100,000 MobaCoins.
 * <br /><br />
 * Please use <code>toLowerCase</code> when checking the state of the transaction to make sure the compatability across Japan and US platform.
 * <code>
 *   if(txnState.toLowerCase() == "open") {
 *    ...
 *   }
 * </code>
 */
exports.Bank.Debit = {
/** @lends Bank.Debit.prototype */
	
		
	/**
	 * Creates a transaction. Initially, it sets the <code>transaction.state</code> to <code>new</code>.
     * Mobage presents a dialog that prompts the user to confirm the transaction. 
	 * If the user decides not to proceed with the transaction, the callback error returns as "usercanceled."
	 * In the client-only flow, this call checks inventory and sets the state to <code>authorized</code>.
	 * <br /><br />
	 * The value of a single transaction cannot exceed 100,000 MobaCoins.
	 * 
	 * @name Bank.Debit.createTransaction
	 * @function
	 * 
	 * @param {Array} billingItems The billing items for the transaction. <br/><b>Note:</b> The array is limited to one item for this release.
	 * @param {String} comment A comment about the transaction.
	 * @cb {Function} callback The function to call after creating the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
     * var billingItems = [{
     *     "item": {
     *           "id": "iceCastle",
     *          },
     *     "quantity": 1
     *    }
     * ];
     * 
     * var createTxCallback = function (error, transaction) {
	 *     if (error === 'usercanceled') {
     *         var userCanceledDlg = new UI.AlertDialog();
     *         userCanceledDlg.setTitle("Transaction Cancelled");
     *         userCanceledDlg.setText("The transaction has been cancelled.");
     *         userCanceledDlg.setChoices([('OK')]);
     *         userCanceledDlg.show();
     *     } else if(error) {
     *         var errorCode = error.errorCode;
     *         var errorDesc = error.description;
     *         Bank.Debit.cancelTransaction(transaction.id);
     *     } else {
     *         txId = transaction.id;
     *         Bank.Debit.openTransaction(txId, openTxCallback)
     * };
     *
     * Bank.Debit.createTransaction(billingItems, "Sample transaction", createTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
    createTransaction: function(billingItems, comment, callback) {
		NgLogD("Public call createTransaction");
		
		
	var data = {
	    billingItems: billingItems,
	    comment: comment
	};
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.createTransaction",
			data: data
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}    
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Places funds into escrow and begins processing the transaction. 
	 * Indicates the game server needs to deliver the purchased item.
	 * The <code>transaction.state</code> transitions from <code>authorized</code> to <code>open</code>.
	 *
	 * @name Bank.Debit.openTransaction
	 * @function
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @cb {Function} callback The function to call after opening the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
	 * var openTxCallback = function (error, transaction) {
	 *      if (error) {
	 *          var errorCode = error.errorCode;
     *          var errorDesc = error.errorDescription;
     *          Bank.Debit.cancelTransaction(transaction.id, cancelTxCallback );
     *      } else {
     *          var txId = transaction.id;
     *          var txState = transaction.state;
     *          var txComment = transaction.comment;
     *          // Deliver items to the client
     *          MyGameTxClass.deliverItems(transaction.items);
     *          // You must close the transaction in order to be paid
     *          Bank.Debit.closeTransaction(transaction.id, closeTxCallback );
     *      }	
     * };
     *
     * Bank.Debit.openTransaction(myTxId, openTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	openTransaction: function(transactionId, callback) {
		NgLogD("Public call openTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.openTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Continues processing a transaction.
	 * Checks the inventory to verify the item is valid, available, and so on. After verification, the <code>transaction.state</code> chranges from <code>new</code> to <code>authorized</code>,
	 * and funds are placed in escrow. The <code>transaction.state</code> transitions from <code>authorized</code> to <code>open</code>, which 
	 * indicates the game server needs to deliver the purchased item. 
	 * 	 
	 *
	 * @name Bank.Debit.continueTransaction
	 * @function
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @cb {Function} callback The function to call after continuing to process the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
	 * var continueTxCallback = function (error, transaction) {
     *      if (error) {
	 *           var errorCode = error.errorCode;
	 *           var errorDesc = error.description;
     *           Bank.Debit.cancelTransaction(transaction.id, cancelTxCallback );
     *      } else {
     *           var tx = transaction;
     *           Bank.Debit.openTransaction(transaction.id, openTxCallback );
     *      }
	 * };
	 * 
	 * Bank.Debit.continueTransaction(myTxId, continueTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    continueTransaction: function(transactionId, callback) {
		NgLogD("Public call continueTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.continueTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	

    /**
     * Cancels the transaction. The transaction was canceled or the purchased item was not delivered and the game
     * needs to return the user's funds. The <code>transaction.state</code> transitions to <code>canceled</code>.
     *
     * @name Bank.Debit.cancelTransaction
     * @function
     * 
     * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @cb {Function} callback The function to call after continuing to process the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
	 * var cancelTxCallback = function (error, transaction) {
     *     if (error) {
     *        var errorCode = error.errorCode;
     *        var errorDesc = error.errorDescription;
     *        console.log("An error occurred while canceling a transaction: " + error.errorCode +
     *            error.errorDescription);
     *     } else {
     *        var txId = transaction.id;
     *        var txState = transaction.state;
     *        var txComment = transaction.comment;
	 *     }	
     * };
     * 
     * Bank.Debit.cancelTransaction(myTxId, cancelTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
    cancelTransaction: function(transactionId, callback) {
		NgLogD("Public call cancelTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.cancelTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
    },


	/**
	 * Closes the transaction. The virtual item was delivered.
	 * The <code>transaction.state</code> transitions from <code>open</code> to <code>closed</code>.
	 *
	 * @name Bank.Debit.closeTransaction
	 * @function
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @cb {Function} callback The function to call after continuing to process the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
	 * var closeTxCallback = function (error, transaction) {
     *     if (error) {
     *          var errorCode = error.errorCode;
     *          var errorDesc = error.errorDescription;
     *          Bank.Debit.cancelTransaction(transaction.id, cancelTxCallback);
	 *     } else {
     *          var txId = transaction.id;
     *          var txState = transaction.state;
     *          var txComment = transaction.comment;
     *     }	
     * };
     *
     * Bank.Debit.closeTransaction(myTxId, closeTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	closeTransaction: function(transactionId, callback) {
		NgLogD("Public call closeTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.closeTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Retrieves the transaction corresponding to the given transaction ID parameter.
	 *
	 * @name Bank.Debit.getTransaction
	 * @function
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @cb {Function} callback The function to call after continuing to process the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} transaction Information about the transaction.
	 * @cb-param {String} transaction.comment A comment about the transaction.
	 * @cb-param {String} transaction.id The transaction ID.
	 * @cb-param {String} transaction.state The current state of the transaction.
	 * @cb-returns {void}
	 * @example
	 * var getTxCallback = function(error, transaction) {
     *      if (error) {
	 *            var errorCode = error.errorCode;
	 *            var errorDesc = error.description;
     *      } else {
     *            var tx = transaction;     
     *      }
	 * };
	 *
	 * Bank.Debit.getTransaction(myTxId, getTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getTransaction: function(transactionId, callback) {
		NgLogD("Public call getTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.getTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Retrieves the user's transactions where the state is <code>new</code>, <code>authorized</code> or <code>open</code>.
     * See the <a href="https://developer.mobage.com/en/resources/bank_economy">Bank and Economy
     * section</a> of the <a href="https://developer.mobage.com/">Mobage Developer Portal</a> for
     * details.
     * <br /><br />
     * <strong>Note</strong>: This method is not available on the Japan platform.
	 *
	 * @name Bank.Debit.getPendingTransactions
	 * @function
	 * 
	 * @cb {Function} callback The function to call after continuing to process the transaction.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object[]} transactions Information about the transactions.
	 * @cb-param {String} transactions[] transaction ID
	 * @cb-returns {void}
	 * @example
	 * var getPendingTxCallback = function(error, transaction) {
     *      if (error) {
	 *         var errorCode = error.errorCode;
	 *         var errorDesc = error.description;
     *      } else {
     *         var tx = transaction;     
     *      }
	 * };
	 *
	 * Bank.Debit.getPendingTransactions(getPendingTxCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getPendingTransactions: function(callback) {
		NgLogD("Public call getPendingTransactions");

		var cmd = {
			apiURL:"US.Service.Banking.Purchase.getPendingTransactions",
			data:{}
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = function(err, data) {
				callback(err.error, data.openTransactions);
			};
		}

	    GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	_getCallBackFunc : function(callback) {
			return function(err, data) {
				if(err) {
					callback(err, undefined);
				} else {
					callback(err, data.transaction);					
				}
			};
	}
};

/**
 * @class 
 * @name Bank.Inventory
 * @description
 * Provides an interface to retrieve items from inventory. The Mobage platform
 * server is responsible for managing item inventory in games.
 */
exports.Bank.Inventory = {


	/**
	 * Retrieves the item identified by its product ID from inventory on the Mobage platform server.
	 *
	 * @name Bank.Inventory.getItem
	 * @function
	 * 
	 * @param {Number} itemId The product ID for the item.
	 * @cb {Function} callback The function to call after retrieving the item.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} item Information about the item.
	 * @cb-param {String} item.description A description of the item.
	 * @cb-param {String} item.id The item ID.
	 * @cb-param {String} item.imageUrl The URL for an image of the item.
	 * @cb-param {String} item.name The name of the item.
	 * @cb-param {Number} item.price The price of the item.
	 * @cb-returns {void}
	 * @example
	 * var getItemCallback = function(error, item) {
     *      if (error) {
	 *         var errorCode = error.errorCode;
	 *         var errorDesc = error.description;
     *      } else {
     *         var itemData = item;
     *      }
	 * };
	 *
	 * Bank.Inventory.getItem(myItemId, getItemCallback);
	 * @returns {void}
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */    
    getItem: function(itemId,callback) {
	    NgLogD("Public call Inventory getItem");

	    var data = {
	        itemId: itemId
	    };

	    var cmd = {
	        apiURL:"US.Service.Banking.Purchase.getItem",
	        data:data
	    };

	    if (callback != undefined && typeof callback == "function") {
	        cmd["callbackFunc"] =  function(err, data) {
		        if(err) {
		            callback(err, undefined);
		        } else {
		            callback(err, data.item);					
		        }
	        };
	    }

	    GSGlobals.getRouterInstance().sendCommandToGameService(cmd);

    },

	/**
	 * Retrieves the IAP items pricing information by IAP product IDs.
	 *
     * Note that the current implementation is not synchronized. If you do the following,
     * you will only get one callback:
     *
     * Bank.Inventory.getIAPItems(itemListA, cb);
     * Bank.Inventory.getIAPItems(itemListB, cb);
     * 
     * Here are the workarounds:
     * 1. Put all the item in one list and just call getIAPItems once.
     * 2. Chain the two call like :
     * Bank.Inventory.getIAPItems(itemListA, function(err, data){
     *     Bank.Inventory.getIAPItems(itemListB, function(err, data){
     *   });
     * });
     *
	 * @name Bank.Inventory.getIAPItems
	 * @function
	 * 
	 * @param {Array} items The product ID array.
	 * @cb {Function} callback The function to call after retrieving the items.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {String} [error.errorCode] A code identifying the error type.
	 * @cb-param {Object} data IAP product information
	 * @cb-returns {void}
     *
	 * @example
     * var items = new Array();
     * items.push("com_mobage_Dreamtopia_iOS_PLANET75");
     * items.push("com_mobage_Dreamtopia_iOS_SOLARSYSTEM165");
     * items.push("com_mobage_Dreamtopia_iOS_CONSTELLATION300");
     *     
     * Bank.Inventory.getIAPItems(items, function(err, data) {
     *     if(!err && data) {
     *          NgLogD("data = " + JSON.stringify(data));
     *     }
     * });
	 *
     * data = {"currency":"USD","items":[{"price":"29.990000","sku":"com_mobage_Dreamtopia_iOS_CONSTELLATION300","formatted":"$29.99"},{"price":"9.990000","sku":"com_mobage_Dreamtopia_iOS_PLANET75","formatted":"$9.99"},{"price":"19.990000","sku":"com_mobage_Dreamtopia_iOS_SOLARSYSTEM165","formatted":"$19.99"}]}
     *
     *
	 * Bank.Inventory.getIAPItems(items, cb);
	 * @returns {void}
	 * @status iOS
	 */    
    getIAPItems: function(items,callback) {
	    NgLogD("Public call Inventory getIAPItems");

	    var data = {
	        itemId: items
	    };

	    var cmd = {
	        apiURL:"US.Service.Banking.Purchase.getIAPItems",
	        data:data
	    };

	    if (callback != undefined && typeof callback == "function") {
	        cmd["callbackFunc"] =  function(err, data) {
		        if(err) {
		            callback(err, undefined);
		        } else {
		            callback(err, data.item);					
		        }
	        };
	    }

	    GSGlobals.getRouterInstance().sendCommandToGameService(cmd);

    }


};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social'] || {}; $MODULE_REGISTRY['NGCore/Client/Social'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Social.js';

/**
 * Public API for GameService
 * 
 * Access this file as NGCore/Client/Social.js
 */

// Note the proper require_ path for our public interface files is: "./Social/US/[filename]"

/**
 * @namespace Manage user data, connect to friends, and more.
 * @name Social
 * @description
 * The <code>Social</code> namespace provides interfaces for the Mobage Social APIs.
 */
exports.Social = {
};

/**
 * @namespace
 * @name Social.Common
 * @description
 * The <code>Social.Common</code> namespace provides APIs for functionality that is shared by the
 * Japan (JP) and United States/worldwide (US) submodules. The features provided by this namespace
 * include Auth, People, Appdata, Blacklist, Profanity and Service.<br /><br />
 * <strong>Important</strong>: You are strongly encouraged to use the <code>Social.Common</code> 
 * APIs wherever possible. If your application uses the <code>Social.US</code> APIs, you must
 * rewrite portions of your application in order to release it in Japan. The same issue applies to
 * the <code>Social.JP<code> APIs.
 */
exports.Social.Common = new (require("NGCore/Client/Social/US/_Internal/_RequireLoader").RequireLoader)({
	"Appdata": function() { return require("NGCore/Client/Social/US/Common/Appdata").Appdata; },
	"Auth": function() { return require("NGCore/Client/Social/US/Common/Auth").Auth; },
	"Blacklist": function() { return require("NGCore/Client/Social/US/Common/Blacklist").Blacklist; },
	"Config": function() { return require("NGCore/Client/Social/US/Common/Config").Config; },
	"People": function() { return require("NGCore/Client/Social/US/Common/People").People; },
	"Profanity": function() { return require("NGCore/Client/Social/US/Common/Profanity").Profanity; },
	"Request": function() { return require("NGCore/Client/Social/US/Common/Request").Request; },
	"RemoteNotification": function() { return require("NGCore/Client/Social/US/Common/RemoteNotification").RemoteNotification; },
	"Service": function() { return require("NGCore/Client/Social/US/Common/Service").Service; },
	"Analytics": function() { return require("NGCore/Client/Social/US/Common/Analytics").Analytics; },
	"Leaderboard": function() { return require("NGCore/Client/Social/US/Common/Leaderboard").Leaderboard; }
});

/**
 * @namespace
 * @name Social.US
 * @description
 * The <code>Social.US</code> namespace provides APIs for the United States (US) submodule. The
 * features provided by this namespace include User, Game, Leaderboard, Score, Ordered List, and
 * AppData.<br /><br />
 * <strong>Important</strong>: You are strongly encouraged to use the <code>Social.Common</code>
 * APIs wherever possible. If your application uses the <code>Social.US</code> APIs, you must
 * rewrite portions of your application in order to release it in Japan.
 */
exports.Social.US = new (require("NGCore/Client/Social/US/_Internal/_RequireLoader").RequireLoader)({
	// Data Models
	"DataModel": function() { return require("NGCore/Client/Social/US/Models/DataModel").DataModel; },
	"User": function() { return require("NGCore/Client/Social/US/Models/User").User; },
	"Game": function() { return require("NGCore/Client/Social/US/Models/Game").Game; },
	"FullGamercard": function() { return require("NGCore/Client/Social/US/Models/FullGamercard").FullGamercard; },
	"Leaderboard": function() { return require("NGCore/Client/Social/US/Models/Leaderboard").Leaderboard; },
	"Achievement": function() { return require("NGCore/Client/Social/US/Models/Achievement").Achievement; },
	"Score": function() { return require("NGCore/Client/Social/US/Models/Score").Score; },
	
	"AppData": function() { return require("NGCore/Client/Social/US/Models/AppData").AppData; },
	
	// Data Cache
	"Cache": function() { return require("NGCore/Client/Social/US/Models/Cache").Cache; },

	// Data APIs
	"Session": function() { return require("NGCore/Client/Social/US/Data/Session").Session; },
	"Dispatcher": function() { return require("NGCore/Client/Social/US/Data/Dispatcher").Dispatcher; }
});

/**
 * @namespace
 * @name Social.US.Service
 * @description
 * Service APIs include the Community button, the Balance button, the Friend Picker, the User Finder, and the User Profile.
 */
exports.Social.US.Service = new (require("NGCore/Client/Social/US/_Internal/_RequireLoader").RequireLoader)({
	"Leaderboards": function() { return require("NGCore/Client/Social/US/Service/Leaderboards").Leaderboards; },
	"Friends": function() { return require("NGCore/Client/Social/US/Service/Friends").Friends; },
	"Profile": function() { return require("NGCore/Client/Social/US/Service/Profile").Profile; },
	"ButtonOverlays": function() { return require("NGCore/Client/Social/US/Service/ButtonOverlays").ButtonOverlays; },
	"GameLaunchPayload": function() { return require("NGCore/Client/Social/US/Service/GameLaunchPayload").GameLaunchPayload; },
	"Achievements": function() { return require("NGCore/Client/Social/US/Service/Achievements").Achievements; }
});

/**
 * @namespace Enable in-game purchasing using MobaCoin on Android or your own in-game currency on iOS.
 * @name Bank
 * @description
 * The <code>Bank</code> namespace provides interfaces for the Mobage Bank APIs.
 */
exports.Bank = require("NGCore/Client/Social/US/Service/Bank").Bank;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/NgPipe'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/NgPipe'] || {}; $MODULE_REGISTRY['NGCore/Shared/NgPipe'] = exports; 
var __dirname = 'NGCore/Shared';
var __filename = 'NGCore/Shared/NgPipe.js';

var Class = require("NGCore/Shared/Class").Class;
var NgPipesRemote = require('NGCore/Shared/NgPipesRemote').NgPipesRemote;
var hex_sha1 = require('NGCore/Shared/Lib/sha1').hex_sha1;
var __hasProp = Object.prototype.hasOwnProperty;
var CapabilitiesReq = require('NGCore/Client/Core/Capabilities');
var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;

/*
The NgPipes object
*/

var NgPipe = Class.subclass({
    classname: "NgPipe",
    initialize: function(options) {
        options = options || {};
		var Capabilities = CapabilitiesReq.Capabilities;
		/*
		 * Note that this require statement cannot be put at the top level
		 * because it will cause code to fail to execute.  It's an intricacy
		 * in our require system.
		 */
		this._socAnalytics = require('NGCore/Client/Social').Social.Common.Analytics;
        this._meta = options.meta || {};
        this._queue = null;
        this._isSendQueued = false;
        this._sendDelay = options.sendDelay || 1000;
		this.UTCoffset = options.offset || 0;
		this.timeQueue = []; // Queue to hold items not yet ready for send. holds {msg:message,time:deviceTime} objects.
        this._meta = options.meta || {};
        this._seqStart = options.seqStart || new Date().getTime();
        this._playerState = options.playerState || null;
        this._seqNumber = options.seqNumber || 0;
        this._allowedLargeValue = {
            msg: 1024 * 5,
            err: 1024 * 5,
            sid: 64,
            udid: 64
        };

		this._waitForUTC = Capabilities.meetsBinaryVersion && Capabilities.meetsBinaryVersion("1.3.5.8");

        this._sendToRemote = true;
        this._globalKey = '__PipeKey';
        var self = this;
        var cb = function(error,value, key) {
            var new_queue = [];
            if (!error) {
                try {
                    new_queue = JSON.parse(value);
                } catch(e) {
                    new_queue = [];
                }
            }

            if (self._queue) {
                new_queue = self._queue.concat(new_queue);
            }

            self._setQueue(new_queue);
            if (self._queue.length > 0 ){
                self._drainQueue();
            }
        };
        this._locListener = null;
        this._location = null;
        KeyValueCache.global(this._globalKey).getItem(this._globalKey, {}, cb);
        var starting_queue = [].concat(options.queue || []);
        this._queue = starting_queue;
        this._sessionEnded = false;
        this._capAlphaNumStringKeys = ['afam', 'asku', 'srcty', 'evcl', 'evid', 'pltfmsku','carr','srv'];
        this.sessionStartEvent();
        this._tagQa();
        this._hookLifetime();
        this._hookGeo();
        return true;
    },

    close: function() {
        this._drainQueue();
        return true;
    },

    enable: function() {
        this._sendToRemote = true;
    },

    disable: function() {
        this._sendToRemote = false;
    },

    setRemoteUrl: function(url) {
        NgPipesRemote.setUrl(url);
    },

    playerEvent: function(eventId, evcl, change, playerState) {
        var e;
        evcl || (evcl = "PLST");
        e = {
            change: change,
            srcty: 'GC',
            evid: eventId,
            evcl: evcl,
            plst: this._getPlayerStateDiff(playerState || this._playerState)
        };
        this._queueMessage(e);
        this._setCurrentPlayerState(playerState);
        return e;
    },
    gameEvent: function(eventId, payload, playerState) {
        var e;
        e = {
            evid: eventId,
            evpl: payload,
            srcty: 'GC',
            evcl: 'GAME'
        };

        if (playerState) {
          e.plst = this._getPlayerStateDiff(playerState || this._playerState);
        }
        this._queueMessage(e);
        return e;
    },
    gameOpsEvent: function(eventId, payload) {
        var e;
        e = {
            evid: eventId,
            evpl: payload,
            srcty: 'GC',
            evcl: 'GAMEOPS'
        };
        this._queueMessage(e);
        return e;
    },
    revenueEvent: function(eventId, payload) {
        var e;
        e = {
            evcl: 'REV',
            evid: eventId,
            srcty: 'PC',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    uiEvent: function(eventId, payload) {
        var e;
        e = {
            evcl: 'UI',
            srcty: 'GC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    funnelEvent: function(eventId, payload, playerState) {
        var e;
        e = {
            evcl: 'FUNNEL',
            srcty: 'GC',
            evid: eventId,
            evpl: payload
        };

        if (playerState) {
          e.plst = this._getPlayerStateDiff(playerState || this._playerState);
          this._setCurrentPlayerState(playerState);
        }
        this._queueMessage(e);
        return e;
    },
    plusEvent: function(eventId, payload, forThis)
	{
        var e;
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e, forThis);
        return e;
    },
    plusUIEvent: function(eventId, payload) {
        var e = {
            evcl: 'PLUSUI',
            srcty: 'PC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    navigationEvent: function(fromScreen, toScreen, buttonID){
        var payload = {};
        payload.fro = fromScreen;
        payload.to  = toScreen;
        if(buttonID){
            payload.btnid = buttonID;
        }

        return this.plusUIEvent("NAV", payload);
    },
	_setUTC: function(time)
	{
		this.UTCoffset = time ? time - new Date().getTime() : 0;	// Default to phone time if we don't get something valid
		this.UTCready = true;
		var i = this.timeQueue.length;
		while (i--)
		{
			var x = this.timeQueue[i];
			x.msg.evts = x.time + this.UTCoffset;
			this._queueMessage(x.msg);
		}
	},
    sessionEndEvent: function() {
		if (!this.UTCready)
		{
			// Exiting before we got the right timestamp, we still need to send messages!
			this.UTCready = true;
			var i = this.timeQueue.length;
			while (i--)
			{
				var x = this.timeQueue[i];
				x.msg.evts = x.time;
				this._queueMessage(x.msg);
			}
		}
        if (!(this._sessionEnded)) {
            var e;
            var Capabilities = CapabilitiesReq.Capabilities;

            e = {
                evid:  'SFN',
                evcl:  'PLUS',
                srcty: 'PC',
                hwty:  Capabilities.getDeviceName(), // cat ro.product.manufacturer, ro.product.brandh, ro.product.model
                hwrev: Capabilities.getPlatformHW(), // cat ro.revision + ro.build.date.utc
                osrev: ""+  Capabilities.getPlatformOS() + " " + Capabilities.getPlatformOSVersion(), // ro.build.fingerprint
                lang: Capabilities.getLanguage()
            };

            e = this._queueMessage(e);
            this._sessionEnded = true;
            return e;
        }
        return null;
    },
    sessionStartEvent: function() {
        var e;
        var Capabilities = CapabilitiesReq.Capabilities;

        e = {
            evid:  'SST',
            evcl:  'PLUS',
            srcty: 'PC',
            hwty:  Capabilities.getDeviceName(), // cat ro.product.manufacturer, ro.product.brandh, ro.product.model
            hwrev: Capabilities.getPlatformHW(), // cat ro.revision + ro.build.date.utc
            osrev: ""+  Capabilities.getPlatformOS() + " " + Capabilities.getPlatformOSVersion(), // ro.build.fingerprint
            lang: Capabilities.getLanguage()
        };



        e = this._queueMessage(e);
        this._drainQueue();
        return e;
    },
    socialEvent: function(eventId, friendId,  payload) {
        var e;
        e = {
            evcl: 'SOCL',
            srcty: 'GC',
            frid: friendId,
            evid: eventId,
            evpl: payload
        };
        return this._queueMessage(e);
    },
    initPlayerState: function(inState) {
        this._setCurrentPlayerState(inState);
        return true;
    },

    updatePlayerState: function(newState) {
        this._setCurrentPlayerState(newState);
        return true;
    },

    //params for internal IAP events:

    //promo campaign unique identifier
    //promoid (String)

    //price of virtual good
    //price (Float)

    //currency used. Defaults to USD
    //cur (String)

    //user's moba balance after purchase
    //mobabalance (Integer)

    //unique identifier for purchase
    //orderid (String)

    //a string identifier for an item, e.g. "IceCastle"
    //sku (String)

    //the value of the item in moba
    //mobaprice (Float)

    //the quantity of item being purchased
    //itemamt (Float)

    //a text description of the item.
    //desc (String)

    //a message displayed to the user when the debit or credit occurs
    //dispmsg (String)

    //the name of the item, as displayed to the user
    //dispname (String)

    //the Mobage ID for the product.
    //productid (Integer)

    //dynamic data accepts a custom object with any params not included above
    //dynamicdata (Object)

    reportAdShow : function(adid) {
        return this.revenueEvent('ADSHOW',{'adid':adid});      
    },

    reportAdClick : function(adid) {
        return this.revenueEvent('ADCLCK',{'adid':adid});    
    },

    reportPromoShow : function(promoid) {
        return this.revenueEvent('PROMOSHOW',{'promoid':promoid});    
    },

    reportPromoClick : function(promoid) {
        return this.revenueEvent('PROMOCLCK',{'promoid':promoid});    
    },

    reportPromoRedeem : function(promoid) {
        return this.revenueEvent('PROMOREDM',{'promoid':promoid});    
    },

    //user clicks on money sku
    reportMoneyIAPIntent : function(sku,item_amt,price,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPINTENT', evpl);
    },

    //user cancels a money sku transaction
    reportMoneyIAPCancel : function(sku,item_amt,price,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPCANCEL', evpl);
    },

    //money sku transaction is successful; orderid require_d
    reportMoneyIAPSuccess : function(sku,item_amt,price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            orderid : orderid,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPSUCCESS',evpl);
    },

    //money iap purchase fails after being authorized by user; orderid optional if available, pass in null otherwise
    reportMoneyIAPFail : function(sku,item_amt,price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        orderid ? evpl.orderid = orderid : "";
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPFAIL', evpl);
    },

    //user opens money IAP store
    reportMoneyIAPShow : function() {
        return this.revenueEvent('IAPSHOW',{});
    },

    //user opens moba IAP store
    reportMobaIAPShow : function() {
        return this.revenueEvent('MOBAIAPSHOW',{});
    },

    //user clicks on a moba sku
    reportMobaIAPIntent : function(sku,moba_price,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPINTENT', evpl);
    },

    //user cancels moba sku transaction
    reportMobaIAPCancel : function(sku,moba_price,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPCANCEL', evpl);
    },

    //moba sku transaction is successful. orderid require_d. 
    reportMobaIAPSuccess : function(sku,moba_price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            orderid : orderid,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPSUCCESS', evpl);
    },

    //moba sku purchase fails after being authorized by user. orderid optional if available, pass in null otherwise
    reportMobaIAPFail : function(sku,moba_price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        orderid ? evpl.orderid = orderid : '';
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPFAIL', evpl);
    },

    /**
    * Report us scraping a facebook user's profile - ext_id is the user's facebook ID.
    *
    * @since 1.1.1.2
    */
    reportFacebookScrape : function(ext_id, dynamicdata) {
        var e;
        var evpl={};
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            extid: ext_id,
            evid: 'FBSCRAPE',
            evpl: evpl
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report us scraping a user's contact list - ext_id is the user's facebook ID.
    *
    * @since 1.1.1.2
    */
    reportContactScrape : function(dynamicdata) {
        var e;
        var evpl={};
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: 'CONTACTSCRAPE',
            evpl: evpl
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report a user posting to another user's wall.
    *
    * @since 1.1.1.2
    */
    reportWallPost : function(friendId, payload) {
        var e;
        e = {
            evcl: 'SOCL',
            srcty: 'PC',
            frid: friendId,
            evid: 'WALLPOST',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report a user downloading a game from a specific section in the store.
    * @param {String} game is the asku for the game being downloaded.
    * @param {String} section is the name of the section that the user downloaded from:
    *   AllGames, FeaturedGames, MyProfile, FriendsLastPlayedGame, FriendsPlayingGame
    * @param {String} slot is the order of the game in the section (if applicable)
    * @since 1.1.1.2
    */
    reportDownload : function(game, section, slot) {
        var payload = {};
        payload.game = game;
        payload.section = section;
        payload.slot = slot;
        var e;
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: 'DOWNLOAD',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * add internal tag to a user.
    * @since 1.1.1.2
    */
    addTag : function(tagName) {
        var payload = {};
        payload.tag = tagName;
        var e;
        e = {
            evcl: 'PLUS',
            evid: 'TAG', 
            srcty: 'PC',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    getSeqNumber: function() {
        this._seqNumber += 1;
        return this._seqNumber;
    },

    getQueueCount: function() {
        return this._queue.length;
    },

    getSendDelay: function() {
        return this._sendDelay;
    },

    setSendDelay: function(val) {
        return (this._sendDelay = val);
    },

    setMeta: function(key, value) {
        if (!value) {
            value = key;
            return (this._meta = value);
        } else {
            return (this._meta[key] = value);
        }
    },

    getMeta: function(key) {
        if (key) {
            return this._meta[key];
        } else {
            return this._meta;
        }
    },

    _queueMessage: function(msg, forThis) {
        if (!msg) {
            return false;
        }

		if (this._waitForUTC && !this.UTCready)
		{
			this.timeQueue.unshift({msg:msg, time:new Date().getTime()});
			return true;
		}

        var self = this;

        //This sets metas that don't change often
        this._setUnsetMetaKeys();

		// evts = UTC time. Makes sense, no?
		msg.evts = msg.evts || this._getUTCTime();

        // The rest of these function set properties that 
        msg = this._mergeMeta(msg);
        msg = this._addSeqDetails(msg);
        msg = this._addGeo(msg);
        msg = this._addGameSku(msg, forThis);
        msg = this._addGameRel(msg);
        msg = this._addCarrier(msg);
        msg = this._addService(msg);
        msg = this._addPlatformVersion(msg);
        msg = this._addUserId(msg);
        msg = this._addUserName(msg);
        msg = this._normalizeValues(msg);
        var queue = this._getQueue();
        queue.push(msg);
        this._setQueue(queue);

        if (!this._isSendQueued) {
            setTimeout(function() {
                self._isSendQueued = false;
                return self._drainQueue();
            }, self._sendDelay);
        }
        return msg;
    },
    _tagQa: function() {
        var fs = require('NGCore/Client/Storage/FileSystem').FileSystem;
        var self = this;
        fs.readFile('QA', {}, function(err, data) {
            if (!err) {
                self.addTag("NGMOCOQA");
            }
        });
    },
    _hookGeo: function() {
        var Social = require('NGCore/Client/Social').Social;
        if(Social.US){
            var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
            var Device = require('NGCore/Client/Device').Device, self = this;
            var LocationListener = MessageListener.subclass({
                initialize: function() {
                    Device.LocationEmitter.addListener(this, this.onUpdate, false);
                },
                onUpdate: function(location) {
                    self._location = location;
                    Device.LocationEmitter.removeListener(this);
                    self._locListener = null;
                }
            });
            this._locListener = new LocationListener();
        }
    },
    _hookLifetime: function() {
        var self = this;
        var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
        var Device = require('NGCore/Client/Device').Device;
        var ListenerClass =  MessageListener.subclass({
            initialize: function() {
                Device.LifecycleEmitter.addListener(this, this.onLifecycleUpdate);
            },
            onLifecycleUpdate: function(event) {
                switch (event) {
                case Device.LifecycleEmitter.Event.Suspend:
                case Device.LifecycleEmitter.Event.Terminate:
                    self.sessionEndEvent();
					self._drainQueue();
                    break;
                }
            }
        });
        if (!this._listener) {
            this._listener = new ListenerClass();
        }
    },
    /**
    * Change the Social Analytic object to be used.  Please see MOBWEST-2300
	* for details
	*
    * @private
    */
	_setSocialAnalytics: function(obj) {
		this._socAnalytics = obj;
	},
    _setUnsetMetaKeys: function() {
        var Capabilities = CapabilitiesReq.Capabilities, udid;
        if ((!this.getMeta('udid')) && (udid = Capabilities.getUniqueId() )) {
            this.setMeta('udid', udid);
        }

        if (!this.getMeta('sid')) {
            var sid = ''+ hex_sha1(this._seqStart+ (this.getMeta('udid')|| "UNKNOWN"));
            this.setMeta('sid', sid);
        }

        if (!this.getMeta('pltfmsku')) {
            var platRegex = /android/;

            var plat = Capabilities.getPlatformOS();
            if (plat) {
                plat = plat.toLowerCase();
                if (plat.match(platRegex) ) {
                    plat = "android";
                } else if ("flash" === plat ) {
                    plat = "flash";
                } else {
                    plat = "ios";
                }
                this.setMeta( 'pltfmsku', plat);
            }
        }

        if (!this.getMeta('apiver')) {
            this.setMeta('apiver', 5);
        }
        return true;
    },

    _getPlayerStateDiff: function(newState) {
        var delta_sign, delta_value, diff, key, value;
        diff = {};
        if (!this._playerState) {
            this._setCurrentPlayerState(newState);
        }
        for (key in newState) {
            if (!__hasProp.call(newState, key)) continue;
            value = newState[key];
            if (typeof value === 'number') {
                delta_value = (value - this._playerState[key]) || 0;
                if (delta_value < 0) {
                    delta_sign = '-';
                }
                if (delta_value >= 0) {
                    delta_sign = '+';
                }
                diff[key] = "" + delta_sign + "," + Math.abs(delta_value) + "," + (this._playerState[key]);
            } else if (typeof value === 'string') {
                diff[key] = value;
            }
        }
        return diff;
    },

    _setCurrentPlayerState: function(pst) {
        var key, value;
        this._playerState = {};
        for (key in pst) {
            if (!__hasProp.call(pst, key)) continue;
            value = pst[key];
            this._playerState[key] = value;
        }
        return true;
    },
	_getUTCTime: function()
	{
		return new Date().getTime() + this.UTCoffset;
	},
    _addGeo: function(msg) {
        var loc_point;

        if (this._location && (loc_point = this._location.getPosition())  && !isNaN(loc_point.getX()) && !isNaN(loc_point.getY())) {
            msg.geo = "" + loc_point.getX() + "," + loc_point.getY();
        }
        return msg;
    },
    _addCarrier: function(msg) {
        var Capabilities = CapabilitiesReq.Capabilities;
        var carr = Capabilities.getCarrier();
        if (carr) {
            msg.carr = carr;
        }
        return msg;
    },
    _addService: function(msg) {
        var Analytics = this._socAnalytics;
        msg.srvc = Analytics.getServiceId();
        return msg;
    },
    _addPlatformVersion: function(msg) {
        var Analytics = this._socAnalytics;
        msg.pver = Analytics.getPlatformVersion();
        return msg;

    },
    _addSeqDetails: function(msg) {
        this._seqNum += 1;
        msg.seq = this.getSeqNumber();
		// This is the length of the session. No need to offset on the real UTC, it's all relative.
        msg.seqdt = new Date().getTime() - this._seqStart;
        return msg;
    },
    _addUserId: function(msg) {
      var Analytics = this._socAnalytics;
      var uid = Analytics.getUserId();
      if (uid) {
        msg.uid = uid;
      }
      return msg;
    },
    _addUserName: function(msg) {
      var Analytics = this._socAnalytics;
      var un = Analytics.getUsername();
      if (un) {
        msg.plus = un;
      }
      return msg;
    },
    _addGameSku: function(msg, forThis) {
        var app_key = forThis || (Capabilities.getConfigs() || {} )["appId"];
        if ( app_key ) {
            msg.asku = app_key;
        }
        return msg;
    },
    _addGameRel: function(msg) {
        var arel = Capabilities.getAppReleaseVersion();
        if (arel) {
          msg.arel = arel;
        }
        return msg;
    },
    _normalizeValues: function(msg) {
        var key, value;
        for (key in msg) {
            if (!__hasProp.call(msg, key)) continue;
            value = msg[key];
            if (typeof value === 'string') {
                value = this._normalizeString(key, value);
            } else if (typeof value === 'object') {
                value = this._normalizeValues(value);
            }
            msg[key] = value;
        }
        return msg;
    },

    _normalizeString: function(key, value) {
        value = value.substring(0, this._allowedLargeValue[key] || 32);
        if (-1 !== this._capAlphaNumStringKeys.indexOf(key)) {
            value = value.toUpperCase().replace(/[^\w]+/g, "").replace("_", "");
        }
        return value;
    },

    _mergeMeta: function(msg) {
        var _ref, _ref2, key, new_msg, value;
        new_msg = {};
        for (key in msg) {
            if (!__hasProp.call(msg, key)) continue;
            value = msg[key];
            new_msg[key] = value;
        }
		ref = this._meta;
        for (key in _ref)
		{
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            (_ref2 = new_msg[key]) ? _ref2 : new_msg[key] = value;
        }
        return new_msg;
    },

    _drainQueue: function() {
        var cb, self, toDrain;
        toDrain = this._getQueue();
        this._setQueue([]);
        self = this;

        if (! this._sendToRemote)
            return true;

        cb = function(state, not_sent) {
            if (state === NgPipesRemote.possibleStates.error) {
                self._queueMany(not_sent);
				self._storeQueue();
                self._sendDelay = self._sendDelay * 2;
            } else if (state === NgPipesRemote.possibleStates.finished ) {
                self._sendDelay = 1000;
            }
            return true;
        };
        NgPipesRemote.clearQueue(toDrain, cb);
        toDrain = null; // explicit clear to keep memory down
        return true;
    },

	_exitingApp: function()
	{
		// called by LifecycleEmitter when we are about to exit the application
		this.sessionEndEvent();
		this._drainQueue();
	},

    _queueMany: function(msg_arr) {
        var _i, _len, msg, self = this;
        this._setQueue( (this._getQueue() || [] ).concat(msg_arr) );
        if (this._isSendQueued) {
          this._isSendQueued = true;
          setTimeout(function() {
              self._isSendQueued = false;
              return self._drainQueue();
          }, self._sendDelay);
        }

        return true;
    },
    _setQueue: function(new_queue) {
        this._queue = new_queue;
        return true;
    },
	_storeQueue: function()
	{
		KeyValueCache.global(this._globalKey).setItem(this._globalKey, {}, JSON.stringify(this._queue));
    },
    _getQueue: function() {
        return this._queue;

    }
});

exports.NgPipe = NgPipe;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Analytics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Analytics'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Analytics'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Analytics.js';

var Class = require('NGCore/Client/Core/Class').Class,
NgPipe = require('NGCore/Shared/NgPipe').NgPipe,
NgPipesRemote = require('NGCore/Shared/NgPipesRemote').NgPipesRemote;

var Analytics = Class.singleton(
/** @lends Core.Analytics.prototype */
{
    classname: 'Analytics',

    /**
     * @class The <code>Analytics</code> class serves as the custom messaging channel to the ngCore platform. 
     * The <code>Analytics</code> class provides developers with a way to keep track of game-specific items that require analysis and counting.
     * Use this class when you need your games to send custom elements that require in-game analytics support. 
     * @constructs The default constructor.
     * @augments Core.Class
     * @since 1.0
     */
    initialize: function() {
        if (!this._pipe) {
          this._pipe = new NgPipe();
        }
    },

	/** @private */
	updateGLEXT: function()
	{
		try
		{
			var caps = require("NGCore/Client/Core/Capabilities").Capabilities;
			var ext = caps.getOglExtensions();
			if (ext.length > 2)	// > 2 means we got some actual data, not our fake string
			{
				// We need to rip out just one of the four tex compressions we want.
				var list = [];
				var goodies =
				[
					"GL_IMG_texture_compression_pvrtc",
					"GL_AMD_compressed_ATC_texture",
					"GL_OES_compressed_ETC1_RGB8_texture",
					"GL_AMD_compressed_3DC_texture"
				];
				for (var i in goodies)
				{
					var item = goodies[i];
					for (var j in ext)
					{
						if (ext[j] ===  item)
						{
							var rep = {};
							rep[caps.getDeviceName()] = item;
							list.push(rep);
						}
					}
				}

				for (i in list)
				{
					Analytics.reportGameEvent("openglexts", list[i]);
				}
			}
		}
		catch (e)
		{
			NgLogException(e);
		}
	},

    /** @private */
    enable: function() {
        this._pipe.enable();
    },

    /** @private */
    disable: function() {
        this._pipe.disable();
    },

    /** @private */
    setUrl: function(url) {
        this._pipe.setRemoteUrl(url);
    },

    /**
    * Report a navigation event that occurs when users navigate between application pages. 
    * Calling this function will alert the analytics platform that a user has generated a navigation event.
    * This information is used to plot how users move through the game, how long they spend on a page, and what page they navigate to next.
    * @param {String} from The name of the page from which navigation originates. 
    * @param {String} to An analytics name for the destination page.
    * @param {String} btnid The ID of the button that triggered the navigation.
    * @returns {Boolean} Set to <code>false</code> if the <code>from</code> or <code>to</code>
    *		parameter is omitted. Set to <code>true</code> in all other cases.
    * @since 1.0
    */
    reportNavigation : function(from, to, btnid) {
        if (!(from && to)) {
            return false;
        }
        this._pipe.uiEvent('NAV', {to: to, fro: from, btnid: btnid} );
        return true;
    },
    /**
    * Report a custom game event. Call <code>reportGameEvent</code> to record events that do not alter a user's core game statistics.<br /><br />
    * <b>Note:</b> This function serves as a catch-all. Call <code>reportGameEvent</code> to count or analyze events that do not fit into any 
    * other category.
    * @param {String} eventId The ID for the custom event.
    * @param {Object} payload A hash of extra information.
    * @param {Object} playerState A hash of important player states.
    * @returns {Boolean} Set to <code>false</code> if the <code>eventId</code> parameter is omitted.
    *		Set to <code>true</code> in all other cases.
    * @since 1.0
    */
    reportGameEvent : function(eventId, payload, playerState ) {
        if (!eventId) {
            return false;
        }

        this._pipe.gameEvent(eventId, payload, playerState);

        return true;
    },
    /**
    * Report a change to a playerstate. A playerstate is the object representation of the player's core stats. 
    * For example, if a player purchased an in-game item, you would call this to let the analytics system know what happened and how much gold was spent.
    * Everything in the player state is counted and recorded. Make sure to only pass in things for which you want to see the change 
    * (gold, mojo, grow, level, xp, health, lives, and so on).<br /><br />
    * <b>Note:</b> This is only for game state and should not include information that is unique to a user. For example, the user game tag or the user ID.
    * @param {String} action The product ID of a purchased product. This essentially points out when an action is performed.
    * @param {Object} change A hash of currencies spent and/or gained. For example {mojo: 100, gold:-10}
    * @param {Object} playerState A hash of important player states after the purchase.
    * @returns {Boolean} Set to <code>false</code> if the <code>action</code> parameter is omitted.
    *		Set to <code>true</code> in all other cases.
    * @since 1.0
    */
    reportPlayerStateChange : function(action, change,  playerState) {
        if (action) {
            this._pipe.playerEvent(action, 'PLSTCHANGE', change, playerState);
            return true;
        } else {
            return false;
        }
    },

    /**
    * Report when a user reaches a new stage of a funnel. Funnel refers to a set of pages or requirements a user is required to engage in before proceeding. 
    * You can use this call to keep track of progress for all users. For example, keeping track of various stages users engage in for game registration.
    * Funnel stages are ordered by numeric ID. The funnel <code>stageName</code> is used for display. You do not need to define funnels ahead of time.
    * Funnel stages start at 0 and increase as the user proceeds further.<br /><br />
    * <b>Note:</b> Calling <code>reportFunnelStage()</code> multiple times for a single user generates an incorrect count.
    * @param {String} funnelName The name of the funnel that the user has progressed to.
    * @param {Number} funnelStage The integer value of the stage that the user reached.
    * @param {String} stageName The name of the stage that the user reached.
    * @param {Object} playerState A hash of important player states after a funnel stage.
    * @private
    */
    reportFunnelStage : function(funnelName, funnelStage, stageName, playerState) {
        var payload =  {};

        if (!(funnelName)) {
            return false;
        }
        if (funnelStage !== null && funnelStage !== undefined) {
            payload.stage = funnelStage;
        } else {
            return false;
        }

        if (stageName) {
            payload.stageName = stageName;
        }
        this._pipe.funnelEvent(funnelName, payload, playerState);

        return true;
    },
    /**
     * Report an interaction between two users.
     * @param {String} actionId The action that the user is performing to interact with the other user
     * @param {String} friendGamerTag The other user with whom the current user is interacting.
     * @param {Object} payload A hash of extra information.
     * @returns {Boolean} Set to <code>false</code> if the <code>actionId</code> or
     *		<code>friendGamerTag</code> parameter is omitted. Set to <code>true</code> in all other
     *		cases.
     * @since 1.0
     */
    reportSocialEvent: function(actionId, friendGamerTag, payload) {
        if (actionId && actionId.length && friendGamerTag && friendGamerTag.length ) {
            this._pipe.socialEvent(actionId, friendGamerTag, payload);
            return true;
        }
        return false;
    },
    /**
    * Report an error to analytics.
    * @param {String} error_msg The error message to log.
    * @returns {Boolean} Set to <code>false</code> if the <code>error_msg</code> parameter is
    *		omitted. Set to <code>true</code> in all other cases.
    * @since 1.0
    */
    reportError : function(error_msg) {
        if (!error_msg) {
            return false;
        }
        this._pipe.gameOpsEvent("ERR", {err: error_msg } );
        return true;
    },
    /**
     * @private
     */
    addTag: function(tag) {
        if (tag) {
            var evpl = {tag:tag};
            this._pipe.gameEvent('tag', evpl);
            return true;
        }
        return false;
    },
    /** @private */
    _getPipe: function() {
        return this._pipe;
    },
    /**
    * Change the Social Analytic object to be used.  Please see MOBWEST-2300
	* for details
	*
    * @private
    */
	_setNgPipeSocialAnalytics: function(socialAnalyticObj) {
		if (this._pipe) {
			this._pipe._setSocialAnalytics(socialAnalyticObj);
		}
	}
});
exports.Analytics = Analytics;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] = exports; 
var __dirname = 'NGCore/Client/Device';
var __filename = 'NGCore/Client/Device/LifecycleEmitter.js';

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;

exports.LifecycleEmitter = MessageEmitter.singleton(
/** @lends Device.LifecycleEmitter.prototype */
{
	classname: 'LifecycleEmitter',
		
	/**
	 * @class The <code>LifecycleEmitter</code> class constructs a singleton object that sends its
	 * listeners a unique value when a lifecycle event occurs (for example, when the application is
	 * being suspended). The value corresponds to an enumerated value of
	 * <code>{@link Device.LifecycleEmitter#Event}</code>. Apps can respond to these events by
	 * notifying external sources, saving their current state, or taking another action. For
	 * example, an app can respond to a <code>Terminate</code> event by sending an analytics message
	 * using <code>{@link Core.Analytics}</code>.
	 * <br /><br />
	 * In addition, an app can exit immediately and shut down its process by calling the static
	 * method <code>{@link Device.LifecycleEmitter.exitProcess}</code>.
	 * @singleton
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		/** @private */
		this.identificationCache = {};
		this.numEngineRequests = 0;
	},
	
	_lifecycleEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._lifecycleEventRecvGen(cmd, msg))
			return;
			
		this.emit(msg.event);
		//Cascade the original message back out to native for forwarding
		//	to the next interpreter in the chain.
		this._lifecycleEventSendGen(msg.event);
	},

	/**
	 * Exit the app immediately, and shut down the app's process.
	 * @name Device.LifecycleEmitter.exitProcess
	 * @function
	 * @static
	 * @returns {void}
	 * @since 1.8
	 */
	
	$exitProcess: function()
	{
		// We need to notify analytics in case it wants to start sending events
		var pipe = require('NGCore/Client/Core/Analytics').Analytics._getPipe();
		pipe._exitingApp();

		this._exitProcessSendGen();
	},
	
	/** @private */
	$_bgMe: function()
	{
		this.__bgMeSendGen();
	},

	/** @private */
	$pauseGame: function()
	{
		NgLogD("+++++++++++++++++++++++++++++++++++++++++Pausing Game");
		this._pauseGameSendGen();
		var _lgl = require("NGCore/Client/Core/_LocalGameList")._LocalGameList;
		_lgl._pausingGame();
	},

	/** @private */
	$resumeGame: function()
	{
		NgLogD("+++++++++++++++++++++++++++++++++++++++++Resuming Game");
		this._resumeGameSendGen();
		var _lgl = require("NGCore/Client/Core/_LocalGameList")._LocalGameList;
		_lgl._resumingGame();
	},

	requestEngineKeepAlive: function(obj)
	{
		var key = obj;
		if (obj.identification_key !== undefined)
		{
			key = obj.identification_key;
		}

			//Store identification key and increment request to engine
			this.identificationCache[key] = true;
			++this.numEngineRequests;
			this.incrementEngineAlive();
	},
	
	cancelEngineKeepAlive: function(obj)
	{
		var key = obj;
		if (obj.identification_key !== undefined)
		{
			key = obj.identification_key;
		}

			if (this.identificationCache[key])
			{
				//Store identification key and increment request to engine
				delete this.identificationCache[key];
				--this.numEngineRequests;
				this.decrementEngineAlive();
			}else{
				NgLogW("LifecycleEmitter.cancelEngineKeepAlive() Identification Key not found");
			}
	},

	incrementEngineAlive: function()
	{
		this._incrementEngineAliveSendGen();
	},
	
	decrementEngineAlive: function()
	{
		this._decrementEngineAliveSendGen();
	},
	
	cancelAllEngineRequests: function()
	{
		this._cancelAllEngineRequestsSendGen();
	},

	_killGameProc: function( )
	{
		this.__killGameProcSendGen();
	},
	
	/** 
	 * Enumeration values for lifecycle events.
	 * @name Event
	 * @fieldOf Device.LifecycleEmitter#
	 */

	/**
	 * Application is being suspended.
	 * @name Event.Suspend
	 * @fieldOf Device.LifecycleEmitter#
	 * @constant
	 */

	/**
	 * Application is being resumed.
	 * @name Event.Resume
	 * @fieldOf Device.LifecycleEmitter#
	 * @constant
	 */
	 
	/**
	 * Application is being terminated.
	 * @name Event.Terminate
	 * @fieldOf Device.LifecycleEmitter#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Event:
	{ 
		Suspend: 0,
		Resume: 1,
		Terminate: 2,
		KeepAliveWillTerminate: 3
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 334,
	// Method create = -1
	// Method lifecycleEvent = 2
	// Method exitProcess = -3
	// Method pauseGame = -4
	// Method resumeGame = -5
	// Method incrementEngineAlive = 6
	// Method decrementEngineAlive = 7
	// Method cancelAllEngineRequests = 8
	// Method _killGameProc = -9
	// Method _bgMe = -10
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._lifecycleEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LifecycleEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LifecycleEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[334] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_lifecycleEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in LifecycleEmitter.lifecycleEvent from command: " + cmd );
			return false;
		}
		
		obj[ "event" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "event" ] === undefined )
		{
			NgLogE("Could not parse event in LifecycleEmitter.lifecycleEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x14effff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_lifecycleEventSendGen: function( event )
	{
		Core.Proc.appendToCommandString( 0x14e0002, this, [ +event ] );
	},
	
	/** @private */
	$_exitProcessSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14efffd );
	},
	
	/** @private */
	$_pauseGameSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14efffc );
	},
	
	/** @private */
	$_resumeGameSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14efffb );
	},
	
	/** @private */
	_incrementEngineAliveSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14e0006, this );
	},
	
	/** @private */
	_decrementEngineAliveSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14e0007, this );
	},
	
	/** @private */
	_cancelAllEngineRequestsSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14e0008, this );
	},
	
	/** @private */
	$__killGameProcSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14efff7 );
	},
	
	/** @private */
	$__bgMeSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x14efff6 );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _lifecycleEventRecv: function( cmd ) {}
	// lifecycleEvent: function( event ) {}
	
	// $exitProcess: function(  ) {}
	
	// $pauseGame: function(  ) {}
	
	// $resumeGame: function(  ) {}
	
	// incrementEngineAlive: function(  ) {}
	
	// decrementEngineAlive: function(  ) {}
	
	// cancelAllEngineRequests: function(  ) {}
	
	// $_killGameProc: function(  ) {}
	
	// $_bgMe: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Time'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Time'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Time'] = exports; 
var __dirname = 'NGCore/Client/Core';
var __filename = 'NGCore/Client/Core/Time.js';

////////////////////////////////////////////////////////////////////////////////
// Class Time
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

var callbacks = {};
var cbKey = 0;
callbacks.add = function(fn) {
	if (typeof fn != 'function') return undefined;
	this[++cbKey] = fn;
	return cbKey;
};

var Time = Class.singleton(
/** @lends Core.Time.prototype */
{
	classname: 'Time',
	mFrameTime: 0,
	mFrameDelta: 0,

	/**
	 * @class the <code>Time</code> class constructs objects that provide access to the system clock and system timings for a device.
	 * @status iOS, Android, Flash
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		
		var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
		var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
		var ListenerClass =  MessageListener.subclass({
			initialize: function(mainTime)
			{
				LifecycleEmitter.addListener(this, this.onLifecycleUpdate);
				this.mTime = mainTime;
			},
			onLifecycleUpdate: function(event)
			{
				switch (event)
				{
//					case LifecycleEmitter.Event.Suspend: 	// If MOB-3366 is reopened, this may need to be uncommented
					case LifecycleEmitter.Event.Resume:		//MOB-3366 Reset frame time when we pause/resume. Suspend doesn't work, so use Resume
						this.mTime.mFrameTime = 0;
					break;
				}
			}
		});
		this.mLifeListener = new ListenerClass(this);
	},

	/**
	 * Return the timestamp for the current time frame (expressed in milliseconds).
	 * @returns {Number} The timestamp for the current time frame.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFrameTime: function()
	{
		return this.mFrameTime;
	},

	/**
	 * Return the delta time in milliseconds since the last time frame.
	 * @returns {Number} The delta time since the last time frame.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFrameDelta: function()
	{
		return this.mFrameDelta;
	},

	/**
	 * Return the real-time clock in milliseconds. 
	 * <b>Note:</b> This differs from the time frame timestamp, which is constant for the entire time frame.
	 * @returns {Number} The real-time clock.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getRealTime: function()
	{
		return (new Date()).getTime();
	},

	$_frameTimeRecv: function( cmd )
	{
		var o = {};
		this._frameTimeRecvGen(cmd, o);

		this.mFrameDelta = this.mFrameTime ? o.time - this.mFrameTime : 1;
		this.mFrameTime = o.time;
	},
	
	setTimeout: function( fn, delta ) {
		var cbId = callbacks.add(fn);
		if (cbId) {
			this._setTimeoutSendGen( cbId, delta );
		}
		return cbId;
	},
	
	setInterval: function( fn, interval ) {
		var cbId = callbacks.add(fn);
		if (cbId) {
			this._setIntervalSendGen( cbId, interval );
		}
		return cbId;
	},
	
	clearTimeout: function( token ) {
		delete callbacks[token];
		this._clearSendGen( token );
	},
	
	clearInterval: function( token ) {
		delete callbacks[token];
		this._clearSendGen( token );
	},
	
	_fireTimerRecv: function( cmd ) {
		var msg = {};
		if(!this._fireTimerRecvGen(cmd, msg))
			return;
		
		var fn = callbacks[msg.cbId];
		if (typeof fn == 'function') {
			fn();
		} else console.log("Could not find closure for " + msg.cbId);
		if (cmd.remove) delete callbacks[cmd.cbId];
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 351,
	// Method frameTime = -1
	// Method create = -2
	// Method setTimeout = 3
	// Method setInterval = 4
	// Method clear = 5
	// Method fireTimer = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._fireTimerRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Time._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -1:
					Time._frameTimeRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Time._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[351] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$_frameTimeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Time.frameTime from command: " + cmd );
			return false;
		}
		
		obj[ "time" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "time" ] === undefined )
		{
			NgLogE("Could not parse time in Time.frameTime from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_fireTimerRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Time.fireTimer from command: " + cmd );
			return false;
		}
		
		obj[ "cbId" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "cbId" ] === undefined )
		{
			NgLogE("Could not parse cbId in Time.fireTimer from command: " + cmd );
			return false;
		}
		
		obj[ "remove" ] = Proc.parseBool( cmd[ 1 ] );
		if( obj[ "remove" ] === undefined )
		{
			NgLogE("Could not parse remove in Time.fireTimer from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( 0x15ffffe, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_setTimeoutSendGen: function( cbId, delta )
	{
		Proc.appendToCommandString( 0x15f0003, this, [ +cbId, +delta ] );
	},
	
	/** @private */
	_setIntervalSendGen: function( cbId, interval )
	{
		Proc.appendToCommandString( 0x15f0004, this, [ +cbId, +interval ] );
	},
	
	/** @private */
	_clearSendGen: function( cbId )
	{
		Proc.appendToCommandString( 0x15f0005, this, [ +cbId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $_frameTimeRecv: function( cmd ) {}
	// $create: function( __objectRegistryId ) {}
	
	// setTimeout: function( cbId, delta ) {}
	
	// setInterval: function( cbId, interval ) {}
	
	// clear: function( cbId ) {}
	
	// _fireTimerRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});

exports.Time = Time;

/** Timeout Support. Shameface. Intentionally leak to the global scope. */
var env = typeof $_GETENGINEENV !== "undefined" ? $_GETENGINEENV() : undefined;

if ( typeof env == 'object' && env.useCoreTimeout ) {
	
	setTimeout = function( fn, delay ) { return Time.setTimeout(fn, delay); };
	setInterval = function( fn, interval ) { return Time.setInterval(fn, interval); };
	clearTimeout = function( token ) { Time.clearTimeout(token); };
	clearInterval = function( token ) { Time.clearInterval(token); };
	
	exports.NGSetTimeoutRunTimers = function() {};
	
} else {
	exports.NGSetTimeoutRunTimers = require("NGCore/Client/UI/NGJSEnvironmentSupport").NGSetTimeoutRunTimers;
	
	Time.setTimeout = setTimeout;
	Time.setInterval = setInterval;
	Time.clearTimeout = clearTimeout;
	Time.clearInterval = clearInterval;
	
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/Util'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/Util'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/Util'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/Util.js';

////////////////////////////////////////////////////////////////////////////////
// Utilities for Network
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Caps = require("NGCore/Client/Core/Capabilities").Capabilities;
var Time = require("NGCore/Client/Core/Time").Time;
var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
var AlertDialog = require("NGCore/Client/UI/AlertDialog").AlertDialog;

////////////////////////////////////////////////////////////////////////////////

var urlPathServerSplit = /^(https?:\/\/)?([^\/]*)(.*[^\/])?.?/i;

var Util = exports.Util =
{
    /*
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	NormalizeUrl: function(url, keepTrailingSlash)
	{
		url = Util.buildRelativeUrl(url);

		// Now split it into parts and make server bits lower case
		var parsed = url.match(urlPathServerSplit);
		if (parsed && parsed[1])
		{
			// absolute path!
			url = parsed[1].toLowerCase() + parsed[2].toLowerCase() + (parsed[3] ? parsed[3] : "");
		}
		else
		{
			// Direct server, no path
			url = url.toLowerCase();
		}
		return url;
	},

	/*
	 * For a given game url, this returns the directory of that url on the SD card.
	 */
	GetMD5HashDirectoryFromUrl: function(url)
	{
		var name;
		if (url === Capabilities._getBootServer() + "/" + Capabilities._getBoot())
			name = Capabilities.getBootDir();
		else
			name = require('NGCore/Shared/Lib/md5').toMD5(url);

		return name;
	},

	buildRelativeUrl: function(url)
	{
		if (!url.match(/^(https?:\/\/)/))
		{
			// If the path is relative, then we append our server to the beginning of it
			if (url.charAt(0) == '/' || !url.length)
			{
				url = Caps.getServer() + url;
			}
			else
			{
				url = Caps.getServer() + "/" + Caps.getGame() + "/" + url;
			}
		}

		return url;
	},

	RetrySchedule: function(initialRetry, maxDuration)
	{
		var count = Math.floor(Math.log(maxDuration / initialRetry));
		var schedule = [initialRetry];
		for(var i=0; i < count + 1; ++i)
		{
			initialRetry *= 2;
			schedule.push(initialRetry);
		}
		return schedule;
	},
	
	OperationWithRetries: function(operationCb, failureCb, failEarly)
	{
		var abortAttempts;
		var abortTime;
		var abortTimeAttempts;
		
		if(failEarly)
		{
			abortAttempts = 3;
			abortTime = 10000;
			abortTimeAttempts = 1;
		}
		else
		{
			abortAttempts = Infinity;
			abortTime = 30000;
			abortTimeAttempts = 6;
		}
		
		// console.log('retry config abortAttempts:', abortAttempts, 'abortTime', abortTime, 'abortTimeAttempts', abortTimeAttempts);
		
		abortTime = Core.Time.getRealTime() + abortTime;
		var timeout = 250;
		var attemptCount = 1;
		
		var failed = false;
		var armed = true;
		
		var failureParam = function()
		{
			if(failed) return;
			
			if(!armed)
			{
				console.log('OperationWithRetries: failureParam called when not armed');
				return;
			}
			armed = false;
			
			if(attemptCount >= abortAttempts)
			{
				console.log('OperationWithRetries: too many retry attempts');
				failed = true;
				failureCb();
				return;
			}
			
			if(Core.Time.getRealTime() >= abortTime && attemptCount >= abortTimeAttempts)
			{
				console.log('OperationWithRetries: retries took too long');
				console.log('OperationWithRetries: abortTime:', abortTime, 'realTime:', Core.Time.getRealTime());
				console.log('OperationWithRetries: attemptCount:', attemptCount, 'abortTimeAttempts:', abortTimeAttempts);
				failed = true;
				failureCb();
				return;
			}
			
			console.log('OperationWithRetries: Failure, will retry in ' + timeout + 'ms');
			setTimeout(function()
			{
				if(failed) return;
				armed = true;
				operationCb(failureParam, abortParam);
			}, timeout);
			
			attemptCount += 1;
			timeout *= 2;
		};
		
		var abortParam = function()
		{
			var failed = true;
			failureCb();
		};
		
		operationCb(failureParam, abortParam);
		
		return abortParam;
	},
	
	showFatalErrorDialog: function(status)
	{
		// Set up info dialog
		var myAlert = new AlertDialog();
		myAlert.setTitle(Core.Localization.getString("Network failure"));
		myAlert.setChoices([Core.Localization.getString("Exit")]);

		myAlert.onchoice =
		function(ret)
		{
			myAlert.hide();
			LifecycleEmitter.exitProcess();
		};
		
		// TODO: Move this list somewhere localizable
		var commonErrors = {
			'302': "File location has changed (302)",
			'400': "Bad request to server (400)",
			'401': "Authorization failed (401)",
			'403': "Server permissions error (403)",
			'404': "Resource not found (404)",
			'408': "Request timed out (408)",
			'500': "Internal server error (500)",
			'501': "Cannot process request (501)",
			'502': "Bad Gateway (502)",
			'503': "Service overloaded / down for maintenance (503)",
			'504': "Timeout at intervening gateway (504)"
		};
		myAlert.setText( Core.Localization.getString( commonErrors[status] || "This application requires a working data connection." ) );
		myAlert.show();
	},

	showSimpleNetworkError: function(status)
	{
		// Set up info dialog
		var myAlert = new AlertDialog();
		myAlert.setTitle(Core.Localization.getString("Network failure"));
		myAlert.setChoices([Core.Localization.getString("OK")]);

		myAlert.onchoice =
		function(ret)
		{
			myAlert.hide();
		};

		// TODO: Move this list somewhere localizable
		var commonErrors = {
			'302': " File location has changed (302)",
			'400': " Bad request to server (400)",
			'401': " Authorization failed (401)",
			'403': " Server permissions error (403)",
			'404': " Resource not found (404)",
			'408': " Request timed out (408)",
			'500': " Internal server error (500)",
			'501': " Cannot process request (501)",
			'502': " Bad Gateway (502)",
			'503': " Service overloaded / down for maintenance (503)",
			'504': " Timeout at intervening gateway (504)"
		};
		var message = "Cannot download game without network connection.";
		if (commonErrors[status])
		{
			message += commonErrors[status];
		}
		myAlert.setText( Core.Localization.getString( message ) );
		myAlert.show();
	},
	
	getCacheBustingString: function()
	{
		return '?t=' + (new Date()).getTime();
	},

	/*
	 * Ad
	 */
	Ad: {
		Tapjoy: {
			sendActionComplete: function(actionId) {
				var _int_Util = require('NGCore/Client/Network/_int_Util')._int_Util;
				_int_Util.adTapjoySendActionComplete(actionId);
			}
		}
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/XHR'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/XHR'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/XHR'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/XHR.js';

////////////////////////////////////////////////////////////////////////////////
// Class XHR
// XMLHttpRequest implementation
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Util = require('NGCore/Client/Network/Util').Util;
var Caps = require('NGCore/Client/Core/Capabilities').Capabilities;

////////////////////////////////////////////////////////////////////////////////

var Header = function (item, content)
{
	this.item = item;
	this.content = content;
};
var headerEx = /(.*?): (.*)/;

// Constants
var State =
{
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
};

// ///////////// Begin HTTP req'd methods of testing! //////
var methods =
[
	"OPTIONS",
	"GET",
	"HEAD",
	"POST",
	"PUT",
	"DELETE",
	"TRACE",
	"CONNECT"
];

var unsecureMethods = ["CONNECT", "TRACE", "TRACK"];

var checkMethod = function(method)
{
	if(!method) return "GET";

	method = method.toString();

	if (method in unsecureMethods)
	{
		throw "SECURITY_ERROR " + method + " not allowed.";
	}
	if (method.toUpperCase() in methods)
	{
		return method.toUpperCase();
	}
	return method;
};

// ////////////////////////// End! /////////////////////

////////////////////////////////////////////////////////////////////////////////

exports.XHR = Class.subclass(
/** @lends Network.XHR.prototype */
{
	classname: 'XHR',
	
	/**
	 * @class The `XHR` class constructs `XmlHttpRequest` objects. Applications can use these
	 * objects to send HTTP or HTTPS requests directly to a web server and load the server response
	 * data directly back into a script. For additional details, see the [W3C XmlHttpRequest
	 * specification](http://www.w3.org/TR/XMLHttpRequest/).
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		this.respHeaders = {};

		this.settings = {};
		this.headers = [];

		// State-associated flags
		this.sendFlag = false;
		this.errorFlag = false;
		
		// Status & response
		this.readyState = State.UNSENT;
		this.responseText = null;
		this.responseXML = null;
		this.status = 0;
		this.statusText = "";
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 340,
	// Method create = -1
	// Method destroy = 2
	// Method sendStatus = 3
	// Method sendHeaders = 4
	// Method sendData = 5
	// Method onFinish = 6
	// Method start = 7
	// Method header = 8
	// Method setComposition = 9
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._sendStatusRecv( cmd );
					break;
				case 4:
					instance._sendHeadersRecv( cmd );
					break;
				case 5:
					instance._sendDataRecv( cmd );
					break;
				case 6:
					instance._onFinishRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in XHR._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in XHR._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[340] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_sendStatusRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		obj[ "statNum" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "statNum" ] === undefined )
		{
			NgLogE("Could not parse statNum in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		obj[ "statStr" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "statStr" ] === undefined )
		{
			NgLogE("Could not parse statStr in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_sendHeadersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendHeaders from command: " + cmd );
			return false;
		}
		
		obj[ "headers" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "headers" ] === undefined )
		{
			NgLogE("Could not parse headers in XHR.sendHeaders from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_sendDataRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendData from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in XHR.sendData from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onFinishRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.onFinish from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in XHR.onFinish from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x154ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1540002, this );
	},
	
	/** @private */
	_startSendGen: function( method, url, data, headers )
	{
		Core.Proc.appendToCommandString( 0x1540007, this, [ Core.Proc.encodeString( method ), Core.Proc.encodeString( url ), Core.Proc.encodeString( data ), +headers ] );
	},
	
	/** @private */
	_headerSendGen: function( item, content )
	{
		Core.Proc.appendSubcommandToCommandString( [ Core.Proc.encodeString( item ), Core.Proc.encodeString( content ) ] );
	},
	
	/** @private */
	_setCompositionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1540009, this );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// _sendStatusRecv: function( cmd ) {}
	// _sendHeadersRecv: function( cmd ) {}
	// _sendDataRecv: function( cmd ) {}
	// _onFinishRecv: function( cmd ) {}
	// start: function( method, url, data, headers ) {}
	
	// header: function( item, content ) {}
	
	// setComposition: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,
// API
	/**
	 * Initialize a request for this `XHR`.
	 *
	 * **Note**: Calling `open()` will wipe all request headers. You must set them after making this
	 * call.
	 * @param {String} method The request method (`GET`, `POST`, `OPTIONS`, `HEAD`, `PUT`, `DELETE`,
	 *		`TRACE`, `CONNECT`).
	 * @param {String} url The request URL.
	 * @param {Boolean} [async=true] Set to `true` if the request is synchronous. Set to `false` in
	 *		all other cases. **Note**: Currently not implemented.
	 * @param {String} [user] Username for basic authentication. **Note**: Currently not
	 *		implemented.
	 * @param {String} [password] Password for basic authentication.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	open: function(method, url, async, user, password)
	{
		url = url.split(' ').join('%20');
		this.settings =
		{
			"method": checkMethod(method),
			"url": Util.buildRelativeUrl(url),
			"async": async,
			"user": user,
			"password": password
		};

		this.reset();
		this.setState(State.OPENED);
	},

	/**
	 * @private
	 * Send a request initialized by the `open()` method. 
	 * @param {Array} [composition] Array of strings and file names to be composed into the body.
	 * **Note**: This parameter is ignored if `readyState` is set as `GET` or `HEAD`.
	 * @throws {INVALID_STATE_ERR} If `readyState` is set as anything other than `OPENED` or if the `send()` flag is true.
	 * @see Network.XHR#open
	 * @returns {void}
	 * @status iOS, Android, Flash
	 * @since 1.1.6
	 */
	sendComposition: function(comp)
	{
		// ex: [{"str":"string to send"},{"file":"path/to/file.bin"},{"str":"more goods"}]
		this.composing = true;
		this.send(JSON.stringify(comp));
	},

	/**
	 * Send a request initialized by the `open()` method.
	 * @param {String} [data] The request entity body. **Note**: This parameter is ignored if
	 *		`readyState` is set as `GET` or `HEAD`.
	 * @throws {INVALID_STATE_ERR} If `readyState` is set as anything other than `OPENED` or if the
	 *		`send()` flag is true.
	 * @see Network.XHR#open
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	send: function(data)
	{
		if (this.readyState != State.OPENED || this.sendFlag)
		{
			throw "INVALID_STATE_ERR: " + (this.sendFlag ? "Already sending" : "in state " + this.readyState);
		}
		this.sendFlag = true;

		/* Skip unused code.
		if (data && this.settings.method != "GET" && this.settings.method != "HEAD")
		{
			// TODO http://www.w3.org/TR/XMLHttpRequest/#the-send-method step 3
		}
		*/

		this.errorFlag = false;

	        var i;

		// Set content length header
		if (this.settings.method == "GET" || this.settings.method == "HEAD")
		{
			data = null;
		}
		else if (data)
		{
			var bFound = false;
			for (i in this.headers)
			{
				if (this.headers[i].item == "Content-Type")
				{
					bFound = true;
					break;
				}
			}
			if (!bFound)
			{
				this.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
			}
		}

		this.responseText = "";

		// Send data to the server
		if (!data)
		{
			data = "";
		}

		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		if (this.composing)
			this._setCompositionSendGen();

		this._startSendGen(this.settings.method, this.settings.url, data, this.headers.length);
		for (i in this.headers)
		{
			var obj = this.headers[i];
			this._headerSendGen(obj.item, obj.content);
		}
	}, // this.send() 

	/**
	 * Cancel any existing or pending network activity for this `XHR`. 
	 * This method is invoked using the
	 * [specification outlined by W3C for `abort()`](http://www.w3.org/TR/XMLHttpRequest/#the-abort-method).
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	abort: function()
	{
		this.responseText = null;
		this.errorFlag = true;
		this.headers = [];

		if (this.sendFlag)
		{
			if (this.readyState != State.DONE)
			{
				this.sendFlag = false;
				this.setState(State.DONE);
			}
		}
		this.readyState = State.UNSENT;
	},

	/**
	 * Retrieve a header from the server response.
	 * @param {String} header Name of header to retrieve.
	 * @returns {String} Text of the header or `null` if text does not exist.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getResponseHeader: function(header)
	{
		if (this.readyState > State.OPENED)
		{
			return this.respHeaders[header.toLowerCase()];
		}
		return null;
	},

	/**
	 * Nonstandard: Retrieve the key-value map of all response headers.
	 * @return {Object} A key-value map as an object.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getUnflattenedResponseHeaders: function()
	{
		return this.respHeaders;
	},

	/**
	 * Retrieve all the response headers from a request. This method is invoked using the
	 * [specification outlined by W3C for `getAllResponseHeaders()`](http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method).
	 * @return {String} All the response headers from a request.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAllResponseHeaders: function()
	{
		if (this.readyState < State.HEADERS_RECEIVED || this.errorFlag)
		{
			return "";
		}

		var result = "";
		for (var i in this.respHeaders)
		{
			result += i + ": " + this.respHeaders[i] + "\r\n";
		}
		return result.substr(0, result.length - 2);
	},

	/**
	 * Set a header for the request.
	 * @param {String} header The name of the header.
	 * @param {String} value The value of the header.
	 * @see Network.XHR#getRequestHeader
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setRequestHeader: function(header, value)
	{
		this.headers.push(new Header(header, value));
	},

	/**
	 * Retrieve a header from the request.
	 * @param {String} header The name of the header.
	 * @return {String} The value of the header.
	 * @see Network.XHR#setRequestHeader
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getRequestHeader: function(header)
	{
		var ret = null;
		for (var i in this.headers)
		{
			if (this.headers[i].item == header)
			{
				ret = this.headers[i].content;
				break;
			}
		}
		return ret;
	},

// Receivers
    /*
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	onStatus: function ( num, str)
	{
		this.status = num;
		this.statusText = str;
	},

	_sendStatusRecv: function( cmd )
	{
		var obj = {};
		this._sendStatusRecvGen(cmd, obj);
		this.onStatus(obj.statNum, obj.statStr);
	},
    /*
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	onHeaders: function(str)
	{
		var lines = str.split('\n');
		lines.pop();
		for (var i in lines)
		{
			var match = headerEx.exec(lines[i]);
			if (match)
				this.respHeaders[match[1].toLowerCase()] = match[2];
		}
		this.setState(State.HEADERS_RECEIVED);
	},

	_sendHeadersRecv: function( cmd )
	{
		var obj = {};
		this._sendHeadersRecvGen(cmd, obj);
		this.onHeaders(obj.headers);
	},
    /*
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	onData: function(data)
	{
		this.responseText += data;
		this.setState(State.LOADING);
	},

	_sendDataRecv: function( cmd )
	{
		var obj = {};
		this._sendDataRecvGen(cmd, obj);
		this.onData(obj.data);
	},
    /*
     * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	onFinish: function (err)
	{
		this.sendFlag = false;
		if (err)
		{
			this.responseText = null;
			this.error = "Network Error";
			this.errorFlag = true;
			this.status = 0;
		}
		this.setState(State.DONE);
	},

	_onFinishRecv: function( cmd )
	{
		var obj = {};
		this._onFinishRecvGen(cmd, obj);
		this.onFinish(obj.error);
	},

// Internal methods
	/**
	 * Reset all fields from a request. This call sets `readyState` to `UNSENT` and the response
	 * properties to `null`.
	 * @ignore
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	reset: function()
	{
		this.headers = [];
		this.readyState = State.UNSENT;
		this.responseText = null;
		this.responseXML = null;
		this.composing = false;
	},
	/**
	 * Change the value of `readyState` and call `onreadystatechange()`.
	 * @param {Number} state The new value for `readyState`
	 * @ignore
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 */
	setState: function(state)
	{
		this.readyState = state;
		if (state == State.DONE)
		{
			this._destroySendGen();
			ObjectRegistry.unregister(this);
		}
		if (typeof this.onreadystatechange != 'undefined')
		{
			try
			{
				this.onreadystatechange();
			}
			catch (e)
			{
				NgLogException(e);
			}
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/DownloadManifest'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/DownloadManifest'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/DownloadManifest'] = exports; 
var __dirname = 'NGCore/Client/Network';
var __filename = 'NGCore/Client/Network/DownloadManifest.js';

////////////////////////////////////////////////////////////////////////////////
// Class XHR
// XMLHttpRequest implementation
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var XHR = require('NGCore/Client/Network/XHR').XHR;
var Util = require('NGCore/Client/Network/Util').Util;
var DownloadFile = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;
var LocalGameList = require('NGCore/Client/Core/LocalGameList').LocalGameList;

// JMarr temporary hack to supress archive downloads on flash.
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

////////////////////////////////////////////////////////////////////////////////

var Manifest = Class.subclass(
/**
 * @private
 */
{
	classname: 'Manifest',

	/**
	 * @private
	 */
	initialize: function()
	{
    this.mNumAdded = 0;
    this.mNumRemoved = 0;
	},

	/**
	 * @private
	 */
	reset: function ()
	{
		this.mJson = null;
		this.mArchives = null;
	},

	/**
	 * @private
	 */
	initWithJsonText: function ( text, emptyOnFail)
	{
		try
		{
			this.mJson = JSON.parse ( text );
			if (!this.mJson)
			{
				this.mJson = {};
			}
		}
		catch (e)
		{
			this.mJson = {};
		}

		if('__archives' in this.mJson)
		{
			this.mArchives = this.mJson['__archives'].files;
			delete this.mJson['__archives'];
		}
		else
		{
			this.mArchives = [];
		}
	},

	//cb: function ( itemKey, dstList, srcList ), which is compareItems
	//cb returns ! null, then dst[ item ] = cb return value.
	//cb returns null, then delete dst[ item ].
	/**
	 * @private
	 */
	foreach: function ( other, cb )
	{
		var dst = this.mJson;
		var src = other.mJson;
	        var key;
		// Handle all things in src.
		for ( key in src )
		{
			this.handleItem ( key, dst, src, cb );
		}
		// Build up list of all things not in src.
		for ( key in dst )
		{
			// Handle all things not in src.
			if ( ! (key in src) )
			{
				this.handleItem ( key, dst, src, cb );
			}
		}
	},

	/**
	 * @private
	 */
	handleItem: function ( key, dst, src, cb )
	{
		var ret = cb ( key, dst, src );
		if(ret)
		{
      if(ret < 0) {
        this.mNumRemoved++;
        delete dst[ key ];
      } else {
        this.mNumAdded++;
      }
		}
	},

  isModified: function()
  {
    return (this.mNumAdded > 0 || this.mNumRemoved > 0);
  },

	/**
	 * @private
	 */
	write: function ( fname, callback )
	{
		var cb = function (err)
		{
			if (err)
			{
				console.log('Error writing manifest! ' + err);
			}
			if(callback)
			{
				callback();
			}
		};

		if (this.mJson)
		{
			var out = JSON.stringify(this.mJson);
			FileSystem.writeFile(fname, out, {}, cb);
		}
		else
		{
			callback();
		}
	}
});

////////////////////////////////////////////////////////////////////////////////

exports.DownloadManifest = MessageListener.subclass(
/** @lends Network.DownloadManifest.prototype */
{
	classname: 'DownloadManifest',

	/**
	 * @class The `DownloadManifest` class constructs objects that initiate the handling of a
	 * manifest file. This ensures a set of files are kept up-to-date in the specified directory
	 * from the specified URL.
	 * @constructs The default constructor. 
	 * @augments Core.MessageListener
	 * @since 1.0
	 */
	initialize: function()
	{
		this.reset();
	},

	_clearConnections: function()
	{
		for (var i in this.mConnections)
		{
			if(!this.mConnections.hasOwnProperty(i)) continue;
			
			this.mConnections[i].abort();
		}
		this.mConnections = [];
	},

	/**
	 * @private
	 */
	reset: function ()
	{
		this.mConcurrentRequests = 6;

		this.mManifest = null;

		this.mRemoteUrl = null;
		this.mLocalPath = null;
		this.mLocalRoot = null;

		this.mLocalText = null;
		this.mRemoteText = null;
		/** @inner */
		this.mProgressCb = function() {};
		/** @inner */
		this.mDoneCb = function() {};

		this.mPaused = false;
		this.mValid = false;

		this._clearConnections();
		this.mPendingItems = [];
		this.mCompleteBytes = 0;
		this.mTotalBytes = 0;
		
		this.mSpaceNeeded = 0;
		
		this.mNumRemoteManifestFiles = 0;
		this.mNumRemoteManifestBytes = 0;
		
		this.mDownloadArchives = true;
		this.mActiveRequests = [];

		this.mLocalGameList = LocalGameList;

		this.mNewJS = false;
		this.mAppObserver = null;

		this.mRetrySchedule = Util.RetrySchedule(50, 2000);
		this.mManifestRetrySchedule = this.mRetrySchedule.slice(0);

		if(this._statusListener)
		{
			this._statusListener.destroy();
			this._statusListener = null;
		}
		this.mCheckUpdateOnly = false;
		this.mCheckUpdateCallback = null;
		this.mDecompCtxId = 0;
	},

	_ensureTrailingSlashes: function(remoteUrl, localPath, secureContentUrl)
	{
		// Check for trailing slashes
		this.mRemoteUrl = remoteUrl.match(/.*\/$/) ? remoteUrl : remoteUrl + '/';
		// If the local path is nothing, do not alter the filename. Otherwise, ensure trailing slash
		this.mLocalRoot = (localPath.match(/.*\/$/) || (!localPath)) ? localPath : localPath + '/';
		this._secureContentUrl = ((!secureContentUrl) || secureContentUrl.match(/.*\/$/)) ? secureContentUrl : secureContentUrl + '/';
	},

	_readLocalManifest: function()
	{
		FileSystem.readFile ( this.mLocalPath, {}, this._onReadLocalManifest.bind(this) );
	},

	_setRemotePath: function(manifestName)
	{
		if (this._secureContentUrl)
		{
			this.mRemotePath = this._secureContentUrl + manifestName;
		}
		else
		{
			this.mRemotePath = this.mRemoteUrl + manifestName;
		}
	},

	_parseManNames: function (man)
	{
		if (typeof man === 'string')
		{
			var obj = {};
			obj[man] = man;
			man = obj;
		}
		return man;
	},

	/**
	 * @private
	 */
	isUpdated: function(remoteUrl, localPath, manifest, doneCB, errorCB)
	{
		this.mCheckUpdateOnly = true;
		this.mCheckUpdateCallback = doneCB;

		this.mDoneCb = (typeof errorCB == 'function') ? errorCB : function() {};
		this.mProgressCb = function(done, left) {};
		var httpStatusCode = 0;
		var fullUrl = remoteUrl + "/configuration.json" + Util.getCacheBustingString();
		Util.OperationWithRetries(
			(function(failCall, abortCall)
			{
				// Start remote manifest download.
				var req = new XHR();
				/** @inner */
				req.onreadystatechange = (function()
				{
					if( req.readyState == 4 && this.mValid )	// done && not cancelled
					{
						this.mManifest = new Manifest ();
						var manifestUrl = null;
						// Only parse if we got a good response back
						if (req.status == 200 && req.responseText)
						{
							var config = JSON.parse(req.responseText);
							manifestUrl = config.contentUrl;
							if (!manifest)
							{
								manifest =
								{
									"webgame.ngmanifest":
									require('NGCore/Client/Core/_int_LGL')._int_LGL.getManifestName(config)
								};
							}

							// If config didn't have contentUrl or we never parsed(local testing), use the base URL
							if (!manifestUrl)
								manifestUrl = remoteUrl;

							manifest = this._parseManNames(manifest);
							var manifestSourceName;
							var manifestName;
							for (var key in manifest)
							{
								manifestSourceName = manifest[key];
								manifestName = key;
								break;
							}

							this._ensureTrailingSlashes(manifestUrl, localPath);
							this.mLocalPath = this.mLocalRoot + manifestName;
							this._setRemotePath(manifestSourceName);
							this._readLocalManifest();
						}
						else if (req.status == 404)
						{
							this._processError('404! Failed to download configuration at '+ fullUrl, false);
						}
						else
						{
							httpStatusCode = req.status;
							failCall();
						}
					}
				}).bind(this);

				req.open ( 'GET', fullUrl, true );
				req.send ();
			}).bind(this),
			(function()
			{
				console.log('Exceeded maximum number of manifest download retires, failing');
				this._processError('Failed to download manifest (' + httpStatusCode + ') at ' + fullUrl, false);
			}).bind(this),
			this.mFailEarly
		);

		this.mValid = true;
	},

	// progressCb: function ( completedRequests, totalRequests )
	// doneCb: function ( err, manifest )
	// throws if url/path arguments are null or empty.
	// TODO: Allow headers argument.  Currently null.
	// TODO: Allow HTTP method argument.  Currently GET.
    /**
	 * Start a download of a remote manifest file at `[remoteUrl + manifestName]` and read a local
	 * manifest at `[localPath + manifestName]`.
	 * 
	 * + If the local manifest does not exist, all files specified by the remote manifest are
	 * downloaded.
	 * + If the local manifest does exist, this method will update the file system at `[localPath]`
	 * to match the files specified in the remote manifest.
	 * 
	 * Each file download will trigger a callback function that returns the number of items
	 * downloaded and the total number of items to download. When all downloads are complete, a
	 * second callback function is triggered that returns an error (if any) and the contents of
	 * `[localPath + manifestName]`. If an error does not occur, this function returns `undefined`.
	 *
	 * **Note**: The contents of `[localPath + manifestName]` are saved whether an error occurs or
	 * not.
	 * 
	 * **Important**: It is currently not supported for multiple manifests to refer to the same 
	 * file.  If a file exists in several different manifests this may cause a race condition 
	 * when downloading multiple manifests that will lead to difficult to debug asset issues.
	 * 
	 * @param {String} remoteUrl The URL to a manifest file.
	 * @param {String} localPath The directory path to a manifest file.
	 * @param {String} manifestName The manifest filename. 
	 * @cb {Function} progressCb The function to call when a file has downloaded.
	 * @cb-param {Number} completedRequests The number of completed downloads.
	 * @cb-param {Number} totalRequests The total number of items being downloaded. Includes items 
	 *		that have already been downloaded.
	 * @cb-returns {void}
	 * @cb {Function} doneCb The function to call when all downloads are complete.
	 * @cb-param {String} err The error message, if any.
	 * @cb-param {String[]} manifest The contents of `[localPath + manifestName]`.
	 * @cb-returns {void}
	 * @param {Boolean} disableArchives Set to `true` to disable downloading files using archives.
	 * @param {Boolean} failEarly Set to `true` to reduce the number of times to attempt to download
	 *		files and the timeout length for each request.
	 * @throws {Error} The URL or directory path to the manifest file was empty or missing.
	 * @example
	 * Network.DownloadManifest.start(this._URL, './', this._manifestName,
	 *   progressCb, doneCallback);
	 * @function
	 * @returns {void}
     * @status iOS, Android
	 * @since 1.0
	 */
	start: function ( remoteUrl, localPath, manifest, progressCb, doneCb, disableArchives, failEarly )
	{
		this.mCheckUpdateOnly = false;
		
		// Allow manifestName to be a hash with {manifestDestName: manifestSourceName}
		manifest = this._parseManNames(manifest);
		var manifestSourceName;
		var manifestName;
		for (var key in manifest)
		{
			manifestSourceName = manifest[key];
			manifestName = key;
			break;
		}

		console.log('DownloadManifest.start(', remoteUrl, localPath, manifestSourceName, ')');
		if ( ! remoteUrl || ! localPath || remoteUrl === '' || localPath === '' )
		{
			throw new Error ( 'invalid arguments: ' + JSON.stringify ( arguments ) );
		}

		// Set up instance state for this request.
		this.mManifest = new Manifest ();
		if(disableArchives)
			this.mDownloadArchives = false;
		
		// JMarr temporary hack to disable archive downloads on flash.
		if(Capabilities.getPlatformOS() == 'flash')
		{
			console.log('Flash does not yet support archive downloads');
			this.mDownloadArchives = false;
		}

		this._ensureTrailingSlashes(remoteUrl, localPath, this._secureContentUrl);
		this._setRemotePath(manifestSourceName);
		this.mLocalPath = this.mLocalRoot + manifestName;
		this.mFailEarly = failEarly;

		// try these to prevent a failed update due to bad code
		/** @inner */
		this.mProgressCb = function (done, left)
		{
			try
			{
				progressCb(done, left);
			}
			catch (ex)
			{
				NgLogException(ex);
			}
		};

		var that = this;
		/** @inner */
		this.mDoneCb = function (err, man, hadCache)
		{
			try
			{
				// touch the .nomedia file (MOB-1355)
				FileSystem.writeFile(that.mLocalRoot + '/.nomedia', '', {});

				/** @inner */
				this.mProgressCb = function() {};
				/** @inner */
				this.mDoneCb = function() {};
				this._setLifecycleListening(false);
				doneCb(err, man, hadCache);
			}
			catch (ex)
			{
				NgLogException(ex);
			}
		};

		this._readLocalManifest();
		this._setLifecycleListening(true);
		this.mValid = true;
	},

	/**
	 * Reinitialize a `Network.DownloadManifest` object.
	 * @returns {void}
	 * @since 1.4.1
	 */
	abort: function()
	{
		this.reset();
	},

	/**
	 * Pause downloading of a download manifest.
	 * @returns {void}
	 * @since 1.4.1
	 */
	pause: function()
	{
		// Cancel downloads
		this._clearConnections();

		// move active requests back to pending
		this.mPendingItems = this.mPendingItems.concat(this.mActiveRequests);
		this.mActiveRequests = [];

		// Invalidate current unzip operations.
		this.mDecompCtxId++;

		this.mPaused = true;
	},

	/**
	 * Resume downloading of a download manifest.
	 * @returns {void}
	 * @since 1.4.1
	 */
	resume: function()
	{
		if (this.mPaused)
		{
			this.mPaused = false;
			this._downloadPendingItems();
		}
	},

	_setLifecycleListening: function(toListen)
	{
		if (toListen && !this.lifeListening)
		{
			Device.LifecycleEmitter.addListener(this,
				function (event)
				{
					switch (event)
					{
						case Device.LifecycleEmitter.Event.Suspend:
						case Device.LifecycleEmitter.Event.Terminate:
							this._writeManifest();
						break;
					}
				}
			);
			this.lifeListening = true;
		}
		else if (this.lifeListening)
		{
			Device.LifecycleEmitter.removeListener(this);
			this.lifeListening = false;
		}
	},

	_theQuestion: function (toBe)
	{
		return toBe | !toBe;
	},

	_setConfig: function (cfg)
	{
		// For saving after completion
		this._Config = cfg;
		// for skipping JS download
		this._noJS = cfg.omitJsUpdate;
		// For using separate content URL
		this._secureContentUrl = cfg.secureContentUrl;
	},

	// Callback for read of local manifest file in start method.

	_onReadLocalManifest: function ( err, data )
	{
		if (this.mValid)
		{
			try	// always start try block in async callbacks
			{
				if ( ! err )
				{
					this.mLocalText = data;
				}
				else
				{
					this.mLocalText = '{}';	// Empty string is ! null.  It's ok for the read to fail.
				}
				this._downloadManifest();
			}
			catch ( ex )
			{
				NgLogException ( ex );
				this._processError ( 'Error reading local manifest err: ' + err , false );
			}
		}
	},

	// Called to start the manifest download.
	_downloadManifest: function()
	{
		var httpStatusCode = 0;
		Util.OperationWithRetries(
			(function(failCall, abortCall)
			{
				// Start remote manifest download.
				var req = new XHR();
				var id = this.mConnections.push(req) - 1;
				/** @inner */
				req.onreadystatechange = (function()
				{
					if( req.readyState == 4 && this.mValid )	// done && not cancelled
					{
						delete this.mConnections[id];
						httpStatusCode = req.status;
						if ( httpStatusCode == 200 )
						{
							this.mRemoteText = req.responseText;
							this._checkItems();

							if (this.mCheckUpdateOnly)
								this._checkUpdate();
							else
								this._evalManifests ();
						}
						else
						{
							console.log( 'Download of manifest at ' + this.mRemotePath
								+Util.getCacheBustingString() + ' failed: ' + httpStatusCode + ' '
								+ req.responseText);
							if (httpStatusCode == 404)
							{
								abortCall();
							}
							else
							{
								failCall();
							}
						}
					}
				}).bind(this);

				req.open ( 'GET', this.mRemotePath + Util.getCacheBustingString(), true );
				req.send ();
			}).bind(this),
			(function()
			{
				this._processError('Failed to download manifest (' + httpStatusCode + ')', false);
			}).bind(this),
			this.mFailEarly
		);
	},

	// Can be called at any time.

	_processError: function ( message , writeManifest)
	{
		if (writeManifest && this.mManifest)
		{
			this._writeManifest();
		}

		// Don't call the doneCB without checking local text
		if (this.mValid)
		{
			this.mDoneCb ( message, null,  this.mLocalText ? this.mLocalText.length > 2 : false );
			this.reset ();
		}
	},

	_checkItems: function()
	{
		// Init source and destination manifests.
		this.mManifest.initWithJsonText ( this.mLocalText , true );
		var other = new Manifest ();
		other.initWithJsonText ( this.mRemoteText );

		// Build list of pending local items.
		this.mManifest.foreach ( other, this._compareItems.bind(this));
	},

	_checkUpdate: function()
	{
		this.mPendingItems = [];
		this.mCheckUpdateCallback(this.mTotalBytes > 0, this.mTotalBytes);
	},

	_evalManifests: function ()
	{
		try
		{
			// JMarr always download with zips if they are available.
			// If we only need to download less than 33% of files and less than 33% of bytes, then don't use an archive.
			// Additinoally, we must be on wifi, or else carriers might tamper with our files.
			/*var NetworkEmitter = require('NGCore/Client/Device/NetworkEmitter').NetworkEmitter;
			if(this.mPendingItems.length < this.mNumRemoteManifestFiles * 0.33
				&& this.mTotalBytes < this.mNumRemoteManifestBytes * 0.33
				&& NetworkEmitter.getLastStatus() == NetworkEmitter.Status.Wifi)
			{
				this.mDownloadArchives = false;
			}*/
			
			// Cache total bytes into separate variable. Archive download might increase
			// space needed, but not total bytes.
			this.mSpaceNeeded = this.mTotalBytes;

			var other = new Manifest ();
			other.initWithJsonText ( this.mRemoteText );
			// If there is no archive in the manifest, don't download an archive.
			if(!other.mArchives)
				this.mDownloadArchives = false;

			// Prepare for archive downloads. If mDownloadArchives is true,
			// then all files will be downloaded through an archive. Otherwise,
			// only files that are makred as force archive will be downloaded
			// through archive.
			this._prepareForArchiveDownload(other.mArchives, !this.mDownloadArchives);
			
			// Trigger progress callback.
			this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );

			this.mLocalGameList.freeSpace(this.mSpaceNeeded, (function (err)
			{
				if (err)
				{
					this._processError(err, false);
					return;
				}
				var num = this.mPendingItems.length;
				if (num)
				{
					console.log("Going to download %d items.", num);
					if (num < 10)
					{
						console.log("Items: " + JSON.stringify(this.mPendingItems));
					}
				}
				// Download anything that got into pending list
				this._downloadPendingItems ();
			}).bind(this));
		}
		catch (e)
		{
			NgLogException ( e );
			this.mDoneCb ( 'Failed processing manifests!', null );
		}
	},
	
	// Decides which archives need to be downloaded to ensure that all of the pending files are downloaded.
	_prepareForArchiveDownload: function(archives, onlyForcedFiles)
	{
		console.log('DownloadManfiest._prepareForArchiveDownload onlyForcedFiles:', onlyForcedFiles);
		// Iterate over files that need to be covered and make sure they are included.
		var neededFiles = [];
		var includedArcns = {};
		var includedExpSize = 0;
		var includedArcSize = 0;
		var filesToCover = this.mPendingItems;
		var nonForcedFiles = [];
	        var f;
		for(var i=0; i < filesToCover.length; ++i)
		{
			// If this file isn't an archive, just download the file.
			f = filesToCover[i];
			if(!f.arcn)
			{
				//console.log('NonForced: including arnc-less %s', f.name);
				neededFiles.push(f);
				includedExpSize += f.size;
				continue;
			}
			
			// Record that this archive provides this file.
			var arcn = f.arcn;
			var a = archives[arcn];
			if(!a.files)
				a.files = [f];
			else
				a.files.push(f);
			
			// Is this archive already incldued?
			if(includedArcns[arcn])
				continue;
			
			// If we are only including forced files, remember that this
			// is a non forced file that we need to download. If after evaluating
			// all of the forced files and these files are not included, they will
			// be explicitly included.
			if(onlyForcedFiles && !f.arcForce)
			{
				nonForcedFiles.push(f);
				//console.log('NonForced: delaying decision about %s in arcn %d', f.name, f.arcn);
				continue;
			}
			
			//console.log('Forced: including %s from arcn %d', f.name, f.arcn);
			
			// Include the archive associated with this arcn.
			neededFiles.push(a);
			includedArcns[arcn] = true;
			includedExpSize += a.expSize;
			includedArcSize += a.arcSize;
		}
		
		// If only downloading forced archives, examine all of the queued
		// files that are not forced. If their archive is not included, then 
		// directly include the file.
		for(i=0; i < nonForcedFiles.length; ++i)
		{
			// Is the archive for this file already incldued?
			// This will happen if a forced file (like a .js) 
			// forced the archive to be included.
			f = nonForcedFiles[i];
			if(includedArcns[f.arcn])
			{
				//console.log('NonForced: skipping %s because it is already in arcn %d', f.name, f.arcn);
				continue;
			}
			
			//console.log('NonForced: including %s from arch %d', f.name, f.arcn);
			
			// Otherwise, include this file.
			neededFiles.push(f);
			includedExpSize += f.size;
		}
		
		// Tell the rest of the world about our choices.
		this.mPendingItems = neededFiles;
		this.mTotalBytes = includedExpSize;
		this.mSpaceNeeded = includedExpSize + includedArcSize;
	},

	// Callback from Manifest.foreach.

	_compareItems: function ( key, dst, src )
	{
		var ditem = dst[key];
		var sitem = src[key];

		// Early out for removed file.  Always delete.
		if ( ! sitem )
		{
			var fname = this.mLocalRoot + key;
			var cb = function(err)
			{
				if (err)
				{
					console.log('Error deleting ' + fname + ' error: ' + err);
				}
			};
			FileSystem.deleteFile(fname, {}, cb);

			// If the item was pending, delete the temporary file it was downloading
			if ('pending' in ditem )
			{
				fname = fname + '.tmp';
				FileSystem.deleteFile(fname, {}, cb);
			}
			return -1; // removed
		}

		var isJS = this._extensionMatch ( key, 'js' );

		// Don't download the html or the js with noJS.
		if (this._noJS && (isJS || key == "index.html"))
		{
			// Don't download JS!! keep it in the local manifest, but don't push it to download
			return 0; // no change
		}

		sitem.name = key;
		this.mNumRemoteManifestFiles += 1;
		this.mNumRemoteManifestBytes += sitem.size;

		// No local version or version mismatch, must download.
		if ( ! ditem || ditem.hash != sitem.hash)
		{
			if ( isJS )
			{
				this.mNewJS = true;
			}

			// Tally the space we need for downloading new items
			this.mTotalBytes += sitem.size;

			// Add to the pending queue.
			this.mPendingItems.push ( sitem );

      return 1; // added
		}
		
		return 0; // no chage
	},

	// Utility method to check for case-insensitive match for file extension.
	
	_extensionMatch: function ( fname, ext )
	{
		var pattern = new RegExp ( '^.*\\.(' + ext + ')$', 'i' );
		var ret = fname.match ( pattern );
		return ret;
	},

	// Once in download state, this method is called to start downloading 
	// assets from manifest.  When each asset successfully completes, this method
	// will also be called to start the next download.  This method institutes
	// the logic for having a limited number of concurrent downloads from
	// the mCurrentRequests and mConcurrentRequests members.

	_downloadPendingItems: function ()
	{
		if (this.mValid && !this.mPaused)
		{
			// Are we done?
			if ( this.mPendingItems.length === 0 && this.mActiveRequests.length === 0)
			{
				var cb = function()
				{
					this._writeConfig(function()
					{
						// Trigger done callback and reset.
						this.mDoneCb ( null, this.mManifest );
						this.reset ();
					}.bind(this));
				}.bind(this);

				//if (this.mTotalBytes > 0)
				if(this.mManifest && this.mManifest.isModified())
				{
					this._writeManifest ( cb );
				}
				else
				{
					FileSystem.registerManifest ( this.mLocalPath );
					cb();
				}
				return;
			}

			// Not done, pop more pending items and start their downloads.
			while ( this.mPendingItems.length && this.mActiveRequests.length < this.mConcurrentRequests )
			{
				// Download the next pending file.
				var item = this.mPendingItems.pop ();
				item.retrySchedule = this.mRetrySchedule.slice(0);
				this._downloadItem(item);
			}
		}
	},
	
	_downloadItem: function(item)
	{
		this.mActiveRequests.push(item);
		var remoteUrl = this.mRemoteUrl + item.name;
		if(item.mangled)
		{
			var i = remoteUrl.lastIndexOf('.');
			remoteUrl = remoteUrl.substr(0, i) + '-' + remoteUrl.substr(i+1) + '.bin';
		}

		Util.OperationWithRetries((function(failCb)
		{
			// Start the download.
			var dlFile = new DownloadFile();
			var id = this.mConnections.push(dlFile) - 1;
			dlFile.start(this.mLocalRoot + item.name,
				'GET',
				remoteUrl + Util.getCacheBustingString(),
				[],
				this._onDownloadItemComplete.bind(this, item, failCb, id));
		}).bind(this), (function()
		{
			console.log('Manifest download failed. Too many failed download attempts for ' + item.name );
			this._processError ( 'Could not download file ' + item.name , true);
		}).bind(this), this.mFailEarly);
	},

	_removeActiveRequest: function (item)
	{
		for (var i in this.mActiveRequests)
		{
			if (item == this.mActiveRequests[i])
			{
				this.mActiveRequests.splice(i, 1);
			}
		}
	},

	// Callback for completion of download started in downloadItem method.
	// Will throw if item does not have pending member set.

	_onDownloadItemComplete: function ( item, failCb, id, status, hash )
	{
		var decompCtxId = this.mDecompCtxId;
		try
		{
			delete this.mConnections[id];
			// Was there an error or bad download?
			if(status != 200 || item.hash != hash)
			{
				// Try to download the item again.
				console.log('Download failed.  Retrying ' + item.name );
				console.log('Status: ' + status + ' manifest hash: ' + JSON.stringify(item.hash) + ' actual hash: ' + JSON.stringify(hash));
				failCb();
				return;
			}
			
			// Is this an archive?
			if(item.files)
			{
				// Temporarially increase the max number of connections while we decompress the archive.
				++this.mConcurrentRequests;
				this._downloadPendingItems();
				
				FileSystem.decompressFile(this.mLocalRoot + item.name, this.mLocalRoot, { returnFiles:false }, (function(err, files)
				{
					// Restore max connections to original value.
					--this.mConcurrentRequests;
					
					if(decompCtxId !== this.mDecompCtxId) {
						return;
					}

					// Delete the zip file.
					FileSystem.deleteFile(this.mLocalRoot + '/' + item.name, {});

					if(err)
					{
						// Try to download the item again.
						console.log('Decompress failed.  Retrying ' + item.name );
						failCb();
					}
					else
					{
						for(var i=0; i < item.files.length; ++i)
						{
							var f = item.files[i];
							this.mManifest.mJson[f.name] = {size: f.size, hash: f.hash};
							if (typeof f.encryption != "undefined")
								this.mManifest.mJson[f.name].encryption = f.encryption;
							if (typeof f.is_code != "undefined")
								this.mManifest.mJson[f.name].is_code = f.is_code;
						}

						this._removeActiveRequest(item);
						this.mCompleteBytes += Number(item.expSize);
						this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );
						this._downloadPendingItems ();
					}
				}).bind(this));
			}
			else
			{
				// Update our working manifest.
				this.mManifest.mJson[item.name] = {size: item.size, hash: item.hash};
			    if (typeof item.encryption != "undefined")
					this.mManifest.mJson[item.name].encryption = item.encryption;
				if (typeof item.is_code != "undefined")
					this.mManifest.mJson[item.name].is_code = item.is_code;

				// Make callbacks (like a boss).
				this._removeActiveRequest(item);
				this.mCompleteBytes += Number(item.size);
				this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );
				this._downloadPendingItems ();
			}
		}
		catch ( ex )
		{
			// Unlikely, but safety
			NgLogException ( ex );
			this._processError ( 'Error after finishing the download of item ' + item 
				+ '. status is ' + status , true );
		}
	},

	// Flush changes to locally cached manifest file.

	_writeManifest: function ( callback )
	{
		console.log("DM Complete!");
		try
		{
			if (this.mManifest) {
				var onComplete = function () {
					FileSystem.registerManifest ( this.mLocalPath );
					if (callback)
						callback.apply(this, arguments);
				};
				this.mManifest.write ( this.mLocalPath, onComplete.bind(this) );
			}
		}
		catch (ex)
		{
			NgLogException(ex);
		}
	},

	_writeConfig: function ( callback )
	{
		try
		{
			if (this._Config)
			{
				// console.log("writing |%s| to %s", JSON.stringify(this._Config), this.mLocalRoot + Capabilities._getConfigFile());
				FileSystem.writeFile(this.mLocalRoot + Capabilities._getConfigFile(),
					JSON.stringify(this._Config), {}, function(err) {
						console.log(err);
						if(callback)
						{
							callback();
						}
					} );
			}
			else
			{
				if(callback)
				{
					callback();
				}
			}
		}
		catch (ex)
		{
			NgLogException(ex);
		}
	}
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/View'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/View'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/View'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/View.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Window = require('NGCore/Client/UI/Window').Window;

var ViewParent = require('NGCore/Client/UI/ViewParent').ViewParent;

var View = exports.View = AbstractView.subclass(
/** @lends UI.View.prototype */
{
	'type':'view',

	/**	 
	 * @class The `UI.View` class constructs objects that represent a view in a user interface.
	 * A view can encompass an entire screen in the user interface or a smaller component of a
	 * screen. This enables you to organize UI components into groups, then show and hide them as
	 * needed.
	 * 
	 * This class also serves as a base class for the following derived classes:
	 *
	 * + `{@link UI.ScrollView}`
	 * + `{@link UI.Toast}`
	 *
	 * A `UI.View` object's appearance can change automatically when its view state changes. For
	 * example, the view's image border can change automatically when the view gains focus or is
	 * selected. To implement this feature, your application can call a `UI.View` setter method more
	 * than once, passing a different value in the `flags` parameter each time. In addition, your 
	 * application can include properties for multiple view states in the constructor. See the 
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.View#setImageFit}` to specify how images
	 * will be resized to fit within the view, the fit mode you specify will apply in all view
	 * states.
	 * @name UI.View
	 * @constructs Create a view.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a UI.View object without setting any of its properties.
	 * var view = new UI.View();
	 * @example
	 * // Create a UI.View object, and set images that are specified in the
	 * // "image" property to use a dark gray border.
	 * var border = {
	 *     outerLine: "FF5F5F5F 1.0"
	 * };
	 * var View = new UI.View({
	 *     imageBorder: border
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.View`
	 *		object.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (View._init) View._init();
		ViewParent.initialize.call(this);
		return $super(properties);
	},
	/**
	 * Add a child node to the view at the specified index. The child node must be an object
	 * created by a class that is derived from `{@link UI.AbstractView}`. Objects with a higher
	 * index are drawn on top of objects with a lower index.
	 * 
	 * If a child node already exists at the specified index, the existing child node is not
	 * removed. Instead, the index is incremented for all existing child nodes that have a higher
	 * index than the new child node.
	 * @function
	 * @example
	 * // Create a new view, then add a button to the view.
	 * var mainView = new UI.View();
	 * var button = new UI.Button();
	 * mainView.addChild(button);
	 * @param {Object} childNode The child node to add.
	 * @param {Number} [index] The index at which to add the child node. If the index is not
	 *		provided, the child node will be added as the last child node in the view.
	 * @returns {this}
	 * @see UI.View#removeChild
	 * @status iOS, Android, Flash, Test
	 */
	addChild: ViewParent.addChild,
	
	/**
	 * Remove the specified child node from the view.
	 *
	 * **Note**: Removing a child node from a view does not destroy the child node. You must 
	 * explicitly call `destroy()` when you no longer need to use the child node.
	 * @function
	 * @example
	 * // Create a new view, then add a button to the view.
	 * var mainView = new UI.View();
	 * var button = new UI.Button();
	 * mainView.addChild(button);
	 * // Remove the button when necessary.
	 * mainView.removeChild(button);
	 * @param {Object} childNode The child node to remove.
	 * @returns {Object} The child node that was removed.
	 * @see UI.View#addChild
	 * @status iOS, Android, Flash, Test
 	 */    
	removeChild: ViewParent.removeChild,


	/**
	 * Retrieve the number of child nodes attached to the view.
	 * @function
	 * @returns {Number} The current number of child nodes.
	 * @status Javascript, iOS, Android, Flash
	 */
	getChildCount: ViewParent.getChildCount,

	/**
	 * Retrieve the child nodes that are attached to the view.
	 * @function
	 * @returns {Object[]} An array of child nodes that are attached to the view.
	 * @status Javascript, iOS, Android, Flash
	 */
	getChildren: ViewParent.getChildren,

	/**
	 * Provide custom layout code that runs before the view is displayed. For example, an
	 * application could programmatically adjust the positioning of the view's child nodes based on
	 * the dimensions of the view's frame.
	 *
	 * To use this method, create a custom subclass of `UI.View` that overrides this method, then
	 * specify your own layout code in the subclass' version of the method. 
	 * @function
	 * @returns {void}
	 * @since 1.0
	 */
	layoutSubviews: function() {
		//Override this for custom view subclass layout code
	},
	
	/**
	 * @protected
	 * @function
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	_setVisible: function($super, makeVisible) {
		var wasVisible = this._visible;
		$super(makeVisible);
		if (this._visible != wasVisible) {
			var l = this._children.length;
			for (var i = 0; i < l; i++) {
				this._children[i]._setVisible(makeVisible);
			}
		}
	}
});

// Properties
View._init = function() {
	delete View._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * Set the `image` property, which links to an image that the view will display in a specified
	 * view state.
	 * @name UI.View#setImage
	 * @function 
	 * @example
	 * var view = new UI.View();
	 * view.setImage("./Content/background.png");
	 * @param {String} image The path to the new image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image. To specify an image for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
 	 * @see UI.View#getImage
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `image` property, which links to an image that the view will
	 * display in a specified view state.
	 * @name UI.View#getImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The path to the current image for the specified view state.
	 * @see UI.View#setImage
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	View.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * Set the `imageBorder` property, which defines a border for the image in a specified view 
	 * state. See `{@link UI.Style#setGradient}` for information about this property.
	 * @name UI.View#setImageBorder
	 * @function
	 * @example
	 * var view = new UI.View();
	 * var border = {
	 *     outerLine: "FF5F5F5F 1.0"
	 * };
	 * view.setImageBorder(border);
	 * @param {Object} imageBorder The new image border.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image border. To specify an image border for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.View#getImageBorder
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageBorder` property, which defines a border for the image in a
	 * specified view state.
	 * @name UI.View#getImageBorder
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current image border.
	 * @see UI.View#setImageBorder
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	View.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * Set the `imageGravity` property, which defines how the image is positioned within the
	 * viewable area. The default image gravity is `[0.5, 0.5]`, which horizontally and vertically
	 * centers the image within the view.
	 * 
	 * See `{@link UI.Style#setImageGravity}` for more information about this property.
	 * @name UI.View#setImageGravity
	 * @function
	 * @example
	 * // Set the image gravity so that the image is horizontally centered and
	 * // vertically adjacent to the view's top edge.
	 * var view = new UI.View();
	 * view.setImageGravity([0.5, 0.0]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} imageGravity The new image gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
 	 * @returns {void}
	 * @see UI.View#getImageGravity
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageGravity` property, which defines how the image is positioned
	 * within the viewable area.
	 * @name UI.View#getImageGravity
	 * @function
	 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.View#setImageGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	View.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	/**
	 * Set the `imageFit` property, which defines how images will be scaled relative to the view.
	 * @name UI.View#setImageFit
	 * @function
	 * @example
	 * var view = new UI.View();
	 * view.setImageFit(UI.Commands.FitMode.None);
	 * @param {UI.Commands#FitMode} imageFit The scaling option that will be used to scale images 
	 * 		relative to the view.
	 * @status Flash
	 * @returns {void}
	 * @see UI.View#getImageFit
	 */
	/**
	 * Retrieve the value of the `imageFit` property, which defines how images will be scaled
	 * relative to the view.
	 * @name UI.View#getImageFit
	 * @function
	 * @example
	 * var view = new UI.View();
	 * view.setImageFit(UI.Commands.FitMode.AspectWidth);
	 * // More code here.
	 * // Later, the application takes different actions based on the
	 * // image's fit mode:
	 * var imageFitMode = view.getImageFit();
	 * switch (imageFitMode) {
	 *     case UI.Commands.FitMode.AspectHeight:
	 *         // Your code here
	 *         break;
	 *     case UI.Commands.FitMode.AspectWidth:
	 *         // Your code here
	 *         break;
	 *     // Continue through each enumerated value that you want to test
	 *     default:
	 *         // Your code here
	 *         break;
	 * }
	 * @returns {Number} The current scaling option that will be used to scale images relative to 
	 * 		the view. The returned value corresponds to an enumerated value of
	 *		`{@link UI.Commands#FitMode}`.
	 * @see UI.View#setImageFit
 	 * @status Flash
	 */
	View.synthesizeProperty('imageFit', Commands.setImageFitMode);

	View.synthesizeProperty('visibleInOrientations', Commands.setVisibleInOrientations);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Label'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Label'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Label'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Label.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Label = exports.Label = AbstractView.subclass(
/** @lends UI.Label.prototype */
{
	'type':'label',
	/**
	 * @class The `UI.Label` class creates text labels in a user interface.
	 * 
	 * A `UI.Label` object's appearance can change automatically when its view state changes. For
	 * example, the label's text shadow can change automatically when the label is disabled. To
	 * implement this feature, your application can call a `UI.Label` setter method more than once,
	 * passing a different value in the `flags` parameter each time. In addition, your application
	 * can include properties for multiple view states in the constructor. See the `{@link UI}`
	 * module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Label#setTextGravity}` to control a label's
	 * position within its view, the text gravity you specify will apply in all view states.
	 * @name UI.Label
	 * @constructs Create a new label.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.Label object without setting any of its properties.
	 * var label = new UI.Label();
	 * @example
	 * // Create a new UI.Label object, setting its text and text color.
	 * var labelText = "First Name";
	 * var labelTextColor = "5A7F95";
	 * var label = new UI.Label({
	 *     text: labelText,
	 *     textColor: labelTextColor
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.Label`
	 *		object.
	 * @see UI.Commands#State
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (Label._init) Label._init();
		$super(properties);
	}
});

Label._init = function() {
	delete Label._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * Set the `text` property, which defines text for the label in a specified view state.
	 * @name UI.Label#setText
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * label.setText("First Name");
	 * @param {String} text The new text for the label.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Label#getText
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `text` property, which defines text for the label in a specified
	 * view state.
	 * @name UI.Label#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current label text for the specified view state.
	 * @see UI.Label#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizePropertyWithState('text', Commands.setText);	
	/**
	 * Set the `textFont` property, which defines the font that is used for the label text in a
	 * specified view state.
	 * @name UI.Label#setTextFont
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * label.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this font. To specify a font for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Label#getTextFont
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * label text in a specified view state.
	 * @name UI.Label#getTextFont
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The name of the current font for the specified view state.
	 * @see UI.Label#setTextFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizePropertyWithState('textFont', Commands.setTextFont);
	/**
	 * Set the `textColor` property, which defines the text color for the label in a specified view
	 * state.
	 * @name UI.Label#setTextColor
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * label.setTextColor("5A7F95");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Label#getTextColor
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the label in
	 * a specified view state.
	 * @name UI.Label#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
	 *		format.
	 * @see UI.Label#setTextColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the label text
	 * in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0, -1.0}"`)
	 * that contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.Label#setTextShadow
	 * @function
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
	 * var label = new UI.Label();
	 * label.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified above.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @see UI.Label#getTextShadow
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the label text in a specified view state.
	 * @name UI.Label#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.Label#setTextShadow
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * Set the `textGravity` property, which defines how the label text is positioned within the
	 * viewable area. The text gravity is defined as two floats, one for the X (horizontal) axis and
	 * one for the Y (vertical) axis. Each float represents a percentage of the whitespace 
	 * surrounding the text.
	 * 
	 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
	 * text, with the remainder placed to the right of the text. For the Y axis, the specified 
	 * percentage of whitespace will be placed above the text, with the remainder placed below the
	 * text.
	 * 
	 * By default, the text gravity is set to `[0.5, 0.5]`, which centers the text within the
	 * label's area.
	 * @name UI.Label#setTextGravity
	 * @function
	 * @example
	 * // Set the text to be near the left side of the label and
	 * // vertically centered
	 * var label = new UI.Label();
	 * label.setTextGravity([0.1, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @see UI.Label#getTextGravity
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textGravity` property, which defines how the label text is
	 * positioned within the viewable area.
	 * @name UI.Label#getTextGravity
	 * @function
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.Label#setTextGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the label text.
	 * @name UI.Label#setTextSize
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * var textSize = 24;
	 * label.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the label text.
	 * @see UI.Label#getTextSize
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * label text.
	 * @name UI.Label#getTextSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the label text.
	 * @see UI.Label#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizeProperty('textSize', Commands.setTextSize);

	/**
	 * Set the `textInsets` property, which contains insets that are used to clip the edges of the
	 * label text. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the button.
	 * @name UI.Label#setTextInsets
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * var insetLeft = 10;
	 * label.setTextInsets([0, 0, 0, insetLeft]);
	 * @param {Number[]} textInsets The new text insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the label.
	 * @returns {void}
	 * @see UI.Label#getTextInsets
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textInsets` property, which contains insets that are used to clip
	 * the edges of the label text.
	 * @name UI.Label#getTextInsets
	 * @function
	 * @returns {Number[]} The current text insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the label.
	 * @see UI.Label#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Label.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);

	/**
	 * Set the `lineHeight` property, which specifies the line height, in pixels, for the label
	 * text. The line height will affect the label's layout if the text wraps onto multiple lines.
	 * @name UI.Label#setLineHeight
	 * @function
	 * @example
	 * var label = new UI.Label();
	 * label.setLineHeight(24);
	 * @param {Number} lineHeight The new line height, in pixels, for the label.
	 * @returns {void}
	 * @see UI.Label#getLineHeight
	 * @status iOS, Android, Test
	 * @since 1.6
	 */
	/**
	 * Retrieve the value of the `lineHeight` property, which specifies the line height, in pixels, 
	 * for the label text.
	 * @name UI.Label#getLineHeight
	 * @function
	 * @returns {Number} The current line height, in pixels, for the label.
	 * @see UI.Label#setLineHeight
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.6
	 */
	Label.synthesizeProperty('lineHeight', Commands.setLineHeight);

};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Image'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Image'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Image'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Image.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Image = exports.Image = AbstractView.subclass(
/** @lends UI.Image.prototype */
{
	/**
	 * @class The `UI.Image` class creates images in a user interface. The methods in this class
	 * control how images are displayed and positioned.
	 * 
	 * A `UI.Image` object's appearance can change automatically when its view state changes. For
	 * example, the border around an image can change automatically when the image gains focus or is
	 * selected. To implement this feature, your application can call a `UI.Image` setter method
	 * more than once, passing a different value in the `flags` parameter each time. In addition,
	 * your application can include properties for multiple view states in the constructor. See the
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Image#setImageGravity}` to control an
	 * image's position within its view, the image gravity you specify will apply in all view
	 * states.
	 * @name UI.Image
	 * @constructs Create a new image.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.Image object without setting any of its properties.
	 * var splashGraphic = new UI.Image();
	 * @example
	 * // Create a new UI.Image object, setting its image gravity.
	 * var splashGraphic = new UI.Image({
	 *     imageGravity: [0.25, 0.5]
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.Image` object.
	 * @see UI.Commands#State
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (Image._init) Image._init();
		$super(properties);
	},
	
	'type':'image'
});


// Properties
Image._init = function() {
	delete Image._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * Set the `image` property, which contains the path to an image that will be displayed for a 
	 * specified view state.
	 * @name UI.Image#setImage
	 * @function 
	 * @example
	 * var splashGraphic = new UI.Image();
	 * splashGraphic.setImage("./Content/splash.png");
	 * @param {String} imageURL The new image URL.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image. To specify an image for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Image#getImage
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve a path to the image for a specified view state.
	 * @name UI.Image#getImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The path to the image for the specified view state.
	 * @see UI.Image#setImage
	 * @status iOS, Android, Flash, Test
	 */
	Image.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * Set the `imageBorder` property, which defines a border for images in a specified view state.
	 * See `{@link UI.Style#setGradient}` for information about this property.
	 * @name UI.Image#setImageBorder
	 * @function
	 * @example
	 * // Specify a one-pixel dark gray border.
	 * var image = new UI.Image();
	 * image.setImageBorder({
	 *     outerLine: "FF5F5F5F 1.0"
	 * });
	 * @param {Object} imageBorder The new image border.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this border. To specify a border for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Style#setGradient
	 * @see UI.Image#getImageBorder
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the `imageBorder` property, which defines a border for images in a specified view
	 * state.
	 * @name UI.Image#getImageBorder
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current image border.
	 * @see UI.Image#setImageBorder
	 * @status iOS, Android, Flash, Test
	 */
	Image.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * Set the `imageGravity` property, which defines how the image is positioned within the
	 * viewable area. The image gravity is defined as two floats, one for the X (horizontal)
	 * axis and one for the Y (vertical) axis. Each float represents a percentage of the
	 * whitespace surrounding the button image.
	 * 
	 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
	 * image, with the remainder placed to the right of the image. For the Y axis, the specified 
	 * percentage of whitespace will be placed above the image, with the remainder placed below the
	 * image.
	 * 
	 * By default, the image gravity is set to `[0.5, 0.5]`, which centers the image within the
	 * viewable area.
	 * @name UI.Image#setImageGravity
	 * @function
	 * @example
	 * // Set the image gravity so that images are vertically centered
	 * // and horizontally placed near the left edge.
	 * var splashGraphic = new UI.Image();
	 * splashGraphic.setImageGravity([0.25, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} imageGravity The new image gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @returns {void}
	 * @see UI.Image#getImageGravity
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageGravity` property, which defines how the image is positioned
	 * within the viewable area.
	 * @name UI.Image#getImageGravity
	 * @function
	 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.Image#setImageGravity
	 * @status iOS, Android, Flash, Test
	 */
	Image.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	 /**
	  * Set the `imageTransform` property, which defines an affine transformation of the image. An
	  * affine transformation makes it possible to move, scale, or skew an image while ensuring that
	  * straight lines remain straight and parallel lines remain parallel. You can also use an
	  * affine transformation to rotate an image.
	  * 
	  * The parameters to this method represent a 2 x 3 matrix that contains the following values:
	  * 
	  *     --      --    a = X scale    tx = X reposition
	  *     | a    b |    b = Y skew     ty = Y reposition
	  *     | c    d |    c = X skew
	  *     | tx  ty |    d = Y scale
	  *     --      --
	  * @name UI.Image#setImageTransform
	  * @function
	  * @example
	  * // Increase an image's size by 20 units along the X axis, and move it
	  * // down 5 units along the Y axis.
	  * var splashGraphic = new UI.Image();
	  * var scaleX = 20;
	  * var moveY = 5;
	  * splashGraphic.setImageTransform([scaleX, 0, 0, 0, 0, moveY]);
	  * @example
	  * // Rotate an image 30 degrees to the left.
	  * function degreesToRadians(degrees) {
	  *     return degrees * (Math.PI / 180);
	  * }
	  *
	  * var splashGraphic = new UI.Image();
	  * var angle = degreesToRadians(30);
	  * splashGraphic.setImageTransform([Math.cos(angle), Math.sin(angle),
	  *     -Math.sin(angle), Math.cos(angle), 0, 0]);
	  * @example
	  * // Skew the bottom of an image to the right by 10 units along the x axis.
	  * var splashGraphic = new UI.Image();
	  * var skewX = 10;
	  * splashGraphic.setImageTransform([0, 0, skewX, 0, 0, 0]);
	  * @param {Number[]} imageTransform The new affine transformation to use. Specified as an array 
	  *		of six floats: `[a, b, c, d, tx, ty]`.
	  * @returns {void}
	  * @see UI.Image#getImageTransform
	  */
	 /**
	  * Retrieve the value of the `imageTransform` property, which defines an affine transformation
	  * of the image.
	  * @name UI.Image#getImageTransform
	  * @function
	  * @returns {Number[]} The current affine transformation. Specified as an array of six floats:
	  *		 `[a, b, c, d, tx, ty]`.
	  * @see UI.Image#setImageTransform
	  */
	 Image.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * Set the `imageFit` property, which defines how images will be scaled relative to the view.
	 * @name UI.Image#setImageFit
	 * @function
	 * @example
	 * var splashGraphic = new UI.Image();
	 * splashGraphic.setImageFit(UI.Commands.FitMode.None);
	 * @param {UI.Commands#FitMode} imageFit The scaling option that will be used to scale images 
	 * 		relative to the button.
	 * @returns {void}
	 * @see UI.Image#getImageFit
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageFit` property, which defines how images will be scaled
	 * relative to the view.
	 * @name UI.Image#getImageFit
	 * @function
	 * @example
	 * var splashGraphic = new UI.Image();
	 * splashGraphic.setImageFit(UI.Commands.FitMode.AspectWidth);
	 * // More code here.
	 * // Later, the application takes an action based on the image's
	 * // fit mode:
	 * var imageFitMode = splashGraphic.getImageFit();
	 * switch (imageFitMode) {
	 *     case UI.Commands.FitMode.AspectHeight:
	 *         // Your code here
	 *         break;
	 *     case UI.Commands.FitMode.AspectWidth:
	 *         // Your code here
	 *         break;
	 *     // Continue through each enumerated value that you want to test
	 *     default:
	 *         // Your code here
	 *         break;
	 * }
	 * @returns {Number} The current scaling option that will be used to scale images relative to 
	 * 		the view. The returned value corresponds to an enumerated value of
	 *		`{@link UI.Commands#FitMode}`.
	 * @see UI.Image#setImageFit
 	 * @status iOS, Android, Flash, Test
	 */
	Image.synthesizeProperty('imageFit', Commands.setImageFitMode);
	
	/**
	 * Set a function to call when an `imageLoaded` event occurs. This event occurs when the
	 * image specified by the `image` property finishes loading.
	 * @name UI.Image#setOnImageLoaded
	 * @event
	 * @example
	 * var image = new UI.Image();
	 * image.setOnImageLoaded(function(event) {
	 *     if (event.error) {
	 *         console.log("Unable to load image: " + event.error + ": " +
	 *             event.message);
	 *     } else {
	 *         console.log("Loaded an image with width=" + event.width + 
	 *         " and height=" + event.height);
	 *     }
	 * });
	 * @cb {Function} imageLoadedCallback The function to call when an `imageLoaded` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} [event.error] A code identifying the error, if any.
	 * @cb-param {Number} [event.height] The height of the image that was loaded.
	 * @cb-param {String} [event.message] A message describing the error, if any.
	 * @cb-param {Number} [event.width] The width of the image that was loaded.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.Image#event:getOnImageLoaded
	 * @since 1.6
	 * @status Flash
	 */
	/**
	 * Retrieve the function to call when an `imageLoaded` event occurs.
	 * @name UI.Image#getOnImageLoaded
	 * @event
	 * @returns {Function} The current function to call when an `imageLoaded` event occurs.
	 * @see UI.Image#event:setOnImageLoaded
	 * @since 1.6
	 * @status Flash
	 */
	Image.registerEventType('imageLoaded');
	
	/**
	 * Set a function to call when an `imageLoadFailed` event occurs. This event occurs when the
	 * image specified by the `image` property cannot be loaded.
	 * @name UI.Image#setOnImageLoadFailed
	 * @event
	 * @example
	 * var image = new UI.Image();
	 * image.setOnImageLoadFailed(function(event) {
	 *     console.log("An error occurred when loading " + event.url + 
	 *         ": " + event.error + ": " + event.message);
	 * });
	 * @cb {Function} imageLoadFailedCallback The function to call when an `imageLoadFailed` event
	 *		occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} event.error A code identifying the error.
	 * @cb-param {String} event.url The URL for the image.
	 * @cb-param {String} event.message A message describing the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.Image#event:getOnImageLoadFailed
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoadFailed` event occurs.
	 * @name UI.Image#getOnImageLoadFailed
	 * @event
	 * @returns {Function} The current function to call when an `imageLoadFailed` event occurs.
	 * @see UI.Image#event:setOnImageLoadFailed
	 * @since 1.6
	 */
	Image.registerEventType('imageLoadFailed');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Button'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Button'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Button'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Button.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Button = exports.Button = AbstractView.subclass(
/** @lends UI.Button.prototype */
{
	/**
	 * @class The `UI.Button` class provides buttons in a user interface. The methods in this class
	 * control how buttons are displayed and positioned.
	 * 
	 * A `UI.Button` object's appearance can change automatically when the button's view state 
	 * changes. For example, the button's fill color can change automatically when the button gains 
	 * focus or is selected. To implement this feature, your application can call a `UI.Button`
	 * setter method more than once, passing a different value in the `flags` parameter each time.
	 * In addition, your application can include properties for multiple view states in the
	 * constructor. See the `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Button#setImageGravity}` to control an
	 * image's position within the button, the image gravity you specify will apply in all view
	 * states.
	 * @name UI.Button
	 * @constructs Create a button.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.Button object without setting any of its properties.
	 * var button = new UI.Button();
	 * @example
	 * // Create a new UI.Button object, setting its text gravity.
	 * var button = new UI.Button({
	 *     textGravity: [0.25, 0.5]
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.Button`
	 *		object.
	 */
	'type':'button',

	'Layout':Commands.ButtonLayout,
	
	/** @ignore */
	initialize: function($super, properties) {
		if (Button._init) Button._init();
		$super(properties);
	}
});

// Properties
Button._init = function() {
	delete Button._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * Set the `image` property, which links to an image that represents the button for a
	 * specified view state.
	 * @name UI.Button#setImage
	 * @function 
	 * @example
	 * var backButton = new UI.Button();        
	 * backButton.setImage("./Content/backButton.png", UI.Commands.State.Normal |
	 *     UI.Commands.State.Focused);
	 * @param {String} image The path to the new image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image. To specify an image for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Button#getImage
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `image` property, which defines a path to the button image for a
	 * specified view state.
	 * @name UI.Button#getImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The path to the button image for the specified view state.
	 * @see UI.Button#setImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('image', Commands.setImage);
	
	/**
	 * Set a function to call when an `imageLoaded` event occurs. This event occurs when an image
	 * finishes loading.
	 * @name UI.Button#setOnImageLoaded
	 * @event
	 * @example
	 * // Create an array of objects representing images to load, and update an
	 * // image's state when it has been loaded.
	 * var infoButton = new UI.Button();
	 * var images = [
	 *     {
	 *         url: "http://www.example.com/image1.png",
	 *         loaded: false,
	 *         width: 0,
	 *         height: 0
	 *     },
	 *     {
	 *         url: "http://www.example.com/image2.png",
	 *         loaded: false,
	 *         width: 0,
	 *         height: 0
	 *     }
	 * ];
	 * infoButton.setOnImageLoaded(function(event) {
	 *     if (event.error) {
	 *         console.log("An error occurred when loading " + event.imageURL + 
	 *             ": " + event.error + ": " + event.message);
	 *     } else {
	 *         for (var i = 0, l = images.length; i < l; i++) {
	 *             if (images[i].url == event.imageUrl) {
	 *                 images[i].loaded = true;
	 *                 images[i].height = event.height;
	 *                 images[i].width = event.width;
	 *             }
	 *         }
	 *     }
	 * });
	 * @cb {Function} imageLoadedCallback The function to call when an `imageLoaded` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} [event.error] A code identifying the error, if any.
	 * @cb-param {Number} [event.height] The height of the image, in pixels.
	 * @cb-param {String} event.imageUrl The URL for the image.
	 * @cb-param {String} [event.message] A message describing the error, if any.
	 * @cb-param {Number} [event.width] The width of the image, in pixels.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.Button#event:getOnImageLoaded
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoaded` event occurs.
	 * @name UI.Button#getOnImageLoaded
	 * @event
	 * @returns {Function} The function to call when an `imageLoaded` event occurs.
	 * @see UI.Button#event:setOnImageLoaded
	 * @since 1.6
	 */
	Button.registerEventType('imageLoaded');
	
	/**
	 * Set a function to call when an `imageLoadFailed` event occurs. This event occurs when an
	 * image cannot be loaded.
	 * @name UI.Button#setOnImageLoadFailed
	 * @event
	 * @example
	 * var infoButton = new UI.Button();
	 * infoButton.setOnImageLoadFailed(function(event) {
	 *     console.log("An error occurred when loading " + event.url + 
	 *         ": " + event.error + ": " + event.message);
	 * });
	 * @cb {Function} imageLoadFailedCallback The function to call when an `imageLoadFailed` event
	 *		occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} event.error A code identifying the error.
	 * @cb-param {String} event.url The URL for the image.
	 * @cb-param {String} event.message A message describing the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.Button#event:getOnImageLoadFailed
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoadFailed` event occurs.
	 * @name UI.Button#getOnImageLoadFailed
	 * @event
	 * @returns {Function} The function to call when an `imageLoadFailed` event occurs.
	 * @see UI.Button#event:setOnImageLoadFailed
	 * @since 1.6
	 */
	Button.registerEventType('imageLoadFailed');
		
	/**
	 * Set the `imageInsets` property, which contains insets that are used to clip the edges of the
	 * button image. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the button.
	 * @name UI.Button#setImageInsets
	 * @function
	 * @example
	 * var backButton = new UI.Button();
	 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
	 * // a left inset of 5.
	 * backButton.setImageInsets([10, 20, 15, 5]);
	 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the button.
	 * @returns {void}
	 * @see UI.Button#getImageInsets
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `imageInsets` property, which contains insets that are used to clip
	 * the edges of the button image.
	 * @name UI.Button#getImageInsets
	 * @function
	 * @returns {Number[]} The current image insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the button.
	 * @see UI.Button#setImageInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
	/**
	 * Set the `imageFit` property, which defines how images will be scaled relative to the button.
	 * @name UI.Button#setImageFit
	 * @function
	 * @example
	 * var backButton = new UI.Button();
	 * backButton.setImageFit(UI.Commands.FitMode.None);
	 * @param {UI.Commands#FitMode} imageFit The scaling option that will be used to scale images 
	 * 		relative to the button.
	 * @returns {void}
	 * @see UI.Button#getImageFit
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `imageFit` property, which defines how images will be scaled
	 * relative to the button.
	 * @name UI.Button#getImageFit
	 * @function
	 * @example
	 * var backButton = new UI.Button();
	 * backButton.setImageFit(UI.Commands.FitMode.AspectWidth);
	 * // More code here.
	 * // Later, the application takes different actions based on the
	 * // image's fit mode:
	 * var imageFitMode = backButton.getImageFit();
	 * switch (imageFitMode) {
	 *     case UI.Commands.FitMode.AspectHeight:
	 *         // Your code here
	 *         break;
	 *     case UI.Commands.FitMode.AspectWidth:
	 *         // Your code here
	 *         break;
	 *     // Continue through each enumerated value that you want to test
	 *     default:
	 *         // Your code here
	 *         break;
	 * }
	 * @returns {Number} The current scaling option that will be used to scale images relative to 
	 * 		the button. The returned value corresponds to an enumerated value of
	 *		`{@link UI.Commands#FitMode}`.
	 * @see UI.Button#setImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeProperty('imageFit', Commands.setImageFitMode);
	/**
	 * Set the `imageGravity` property, which defines how the button image is positioned within the
	 * viewable area. By default, the image gravity is set to `[0.5, 0.5]`, which centers the image
	 * within the viewable area.
	 * 
	 * See `{@link UI.Image#setImageGravity}` for more information about this property.
	 * @name UI.Button#setImageGravity
	 * @function
	 * @example
	 * // Position the image horizontally towards the left edge of the button and
	 * // vertically centered.
	 * var backButton = new UI.Button();
	 * backButton.setImageGravity([0.25, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} imageGravity The new image gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @returns {void}
	 * @see UI.Button#getImageGravity
	 * @see UI.Image#setImageGravity
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `imageGravity` property, which defines how the button image is
	 * positioned within the viewable area.
	 * @name UI.Button#getImageGravity
	 * @function
	 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.Button#setImageGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	/**
	 * Set the `imageTransform` property, which defines an affine transformation of the button
	 * image. See `{@link UI.Image#setImageTransform}` for more information about affine
	 * transformations.
	 * @name UI.Button#setImageTransform
	 * @function
	 * @example
	 * // Increase an image's size by 20 units along the X axis, and move it
	 * // down 5 units along the Y axis.
	 * var button = new UI.Button();
	 * var scaleX = 20;
	 * var moveY = 5;
	 * button.setImageTransform([scaleX, 0, 0, 0, 0, moveY]);
	 * @example
	 * // Rotate an image 30 degrees to the left.
	 * function degreesToRadians(degrees) {
	 *     return degrees * (Math.PI / 180);
	 * }
	 *
	 * var button = new UI.Button();
	 * var angle = degreesToRadians(30);
	 * button.setImageTransform([Math.cos(angle), Math.sin(angle),
	 *     -Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @example
	 * // Skew the bottom of an image to the right by 10 units along the x axis.
	 * var button = new UI.Button();
	 * var skewX = 10;
	 * button.setImageTransform([0, 0, skewX, 0, 0, 0]);
	 * @param {Number[]} imageTransform The new affine transformation. Specified as an array
	 *		of six floats: `[a, b, c, d, tx, ty]`.
	 * @returns {void}
	 * @see UI.Button#getImageTransform
	 * @see UI.Image#setImageTransform
 	 * @status iOS, Android
	 */
	/**
	 * Retrieve the value of the `imageTransform` property, which defines an affine transformation
	 * of the button image.
	 * @name UI.Button#getImageTransform
	 * @function
	 * @returns {Number[]} The current affine transformation. Specified as an array of six floats:
	 *		 `[a, b, c, d, tx, ty]`.
	 * @see UI.Button#setImageTransform
 	 * @status Javascript, iOS, Android, Flash
	 */
	Button.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * Set the `imageBorder` property, which defines a border for images in a specified view state.
	 * See `{@link UI.Style#setGradient}` for information about this property.
	 * @name UI.Button#setImageBorder
	 * @function
	 * @example
	 * // Use a dark gray border for the image.
	 * var infoButton = new UI.Button();
	 * var border = {
	 *     outerLine: "FF5F5F5F 1.0"
	 * }; 
	 * infoButton.setImageBorder(border);
	 * @param {Object} imageBorder The new image border.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this border. To specify a border for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Style#setGradient
	 * @see UI.Button#getImageBorder
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageBorder` property, which defines a border for images in a
	 * specified view state.
	 * @name UI.Button#getImageBorder
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current image border for the specified view state.
	 * @see UI.Button#setImageBorder
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	
	/**
	 * Set the `text` property, which defines text for the button in a specified view state.
	 * @name UI.Button#setText
	 * @function
	 * @example
	 * var infoButton = new UI.Button();
	 * infoButton.setText("More information");
	 * @param {String} text The new text for the button.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Button#getText
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `text` property, which defines text for the button in a specified
	 * view state.
	 * @name UI.Button#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current button text for the specified view state.
	 * @see UI.Button#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * Set the `textColor` property, which defines the text color for the button in a specified view
	 * state.
	 * @name UI.Button#setTextColor
	 * @function 
	 * @example
	 * var infoButton = new UI.Button();
	 * infoButton.setTextColor("FFFFFF");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Button#getTextColor
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the button
	 * in a specified view state.
	 * @name UI.Button#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
	 *		format.
	 * @see UI.Button#setTextColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * Set the `textFont` property, which defines the font that is used for the button text in a
	 * specified view state.
	 * @name UI.Button#setTextFont
	 * @function
	 * @example
	 * var infoButton = new UI.Button();
	 * infoButton.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this font. To specify a font for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Button#getTextFont
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * button text in a specified view state.
	 * @name UI.Button#getTextFont
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The name of the current font for the specified view state.
	 * @see UI.Button#setTextFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('textFont', Commands.setTextFont);
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the button text
	 * in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0, -1.0}"`)
	 * that contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.Button#setTextShadow
	 * @function
	 * @example
	 * // Specify a white text shadow with a two-pixel blur, shifted up one pixel
	 * // along the Y axis.
	 * var infoButton = new UI.Button();
	 * infoButton.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified above.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Button#getTextShadow
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the button text in a specified view state.
	 * @name UI.Button#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.Button#setTextShadow
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	/**
	 * Set the `textGravity` property, which defines how the button text is positioned within the
	 * viewable area. The text gravity is defined as two floats, one for the X (horizontal) axis and
	 * one for the Y (vertical) axis. Each float represents a percentage of the whitespace 
	 * surrounding the text.
	 * 
	 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
	 * text, with the remainder placed to the right of the text. For the Y axis, the specified 
	 * percentage of whitespace will be placed above the text, with the remainder placed below the
	 * text.
	 * 
	 * By default, the text gravity is set to `[0.5, 0.5]`, which centers the text horizontally and
	 * vertically within the viewable area.
	 * @name UI.Button#setTextGravity
	 * @function
	 * @example
	 * // Position the text horizontally towards the left side of the button and
	 * // vertically centered.
	 * var infoButton = new UI.Button();
	 * infoButton.setTextGravity([0.1, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @returns {void}
	 * @see UI.Button#getTextGravity
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `textGravity` property, which defines how the button text is
	 * positioned within the viewable area.
	 * @name UI.Button#getTextGravity
	 * @function
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.Button#setTextGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the button text.
	 * @name UI.Button#setTextSize
	 * @function
	 * @example
	 * var infoButton = new UI.Button();
	 * var textSize = 24;
	 * infoButton.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the button text.
	 * @returns {void}
	 * @see UI.Button#getTextSize
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * button text.
	 * @name UI.Button#getTextSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the button text.
	 * @see UI.Button#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * Set the `textInsets` property, which contains insets that are used to clip the edges of the
	 * button text. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the button.
	 * @name UI.Button#setTextInsets
	 * @function
	 * @example
	 * var infoButton = new UI.Button();
	 * var insetLeft = 10;
	 * infoButton.setTextInsets([0, 0, 0, insetLeft]);
	 * @param {Number[]} textInsets The new text insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the button.
	 * @returns {void}
	 * @see UI.Button#getTextInsets
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `textInsets` property, which contains insets that are used to clip
	 * the edges of the button text.
	 * @name UI.Button#getTextInsets
	 * @function
	 * @returns {Number[]} The current text insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the button.
	 * @see UI.Button#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/GLView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/GLView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/GLView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/GLView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var GLView = exports.GLView = AbstractView.subclass(
/** @lends UI.GLView.prototype */
{
	'type':'glview',
	/**
	 * @class The `UI.GLView` class provides applications with access to OpenGL. Before an
	 * application instantiates objects in the `{@link GL2}` module, it must do the following:
	 *
	 * 1. Instantiate a `UI.GLView` object.
	 * 2. Call the `setFrame()` method, inherited from `{@link UI.AbstractView}`, to set the view's
	 * frame. You will normally set the frame so that it encompasses the device's entire screen.
	 * **Note**: When calling `{@link UI.AbstractView#setFrame}` on a `UI.GLView` object, you must
	 * set the `x` and `y` parameters to `0`. Using other values will result in undefined behavior.
	 * 3. Call the `setOnLoad()` method, inherited from `{@link UI.Element}`, to define a callback
	 * function that will run after the `UI.GLView` object has loaded. **Important**: You must wait
	 * for the callback to run before you add `GL2` objects to the OpenGL view.
	 * 4. Set the `active` property of the `UI.GLView` object to `true`.
	 * @name UI.GLView
	 * @augments UI.AbstractView	
 	 * @example
	 * // Create a new UI.GLView object without setting any of its properties,
	 * // then prepare the object for use.
	 * var glView = new UI.GLView();
     * glView.setFrame(0, 0, Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight());
	 * glView.setOnLoad(function() {
	 *     // Add code to create GL2 objects and add them as children of the
	 *     // GL2.Root singleton.
	 * });
	 * glView.setActive(true);
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.GLView` object.
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (GLView._init) GLView._init();
		$super(properties);
	}
});

GLView._init = function() {
	delete GLView._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * Set the value of the `active` property, which indicates whether the `UI.GLView` will be
	 * displayed.
	 * @name UI.GLView#setActive
	 * @function
	 * @example
	 * var glView = new UI.GLView();
     * glView.setFrame(0, 0, Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight());
 	 * glView.setOnLoad(function() {
	 *     // Add code to create GL2 objects and add them as children of the
	 *     // GL2.Root singleton.
	 * });
	 * glView.setActive(true);
	 * @param {Boolean} active Set to `true` if the `UI.GLView` object is active.
	 * @returns {void}
	 * @see UI.GLView#getActive
	 * @status iOS, Flash, Test
	 */
	/**
	 * Retrieve the value of the `active` property, which indicates whether the `UI.GLView` will be
	 * displayed.
	 * @name UI.GLView#getActive
	 * @function
	 * @returns {Boolean} Set to `true` if the `UI.GLView` object is active.
	 * @see UI.GLView#setActive
	 * @status iOS, Android, Flash, Test
	 */
	GLView.synthesizeProperty('active', Commands.setActive);
	
	/**
	 * Retrieve an array that lists all of the OpenGL extensions that are supported in the current
	 * view. You can use this information to control how your application displays content. For
	 * example, some Android devices do not include hardware extensions for certain texture-mapping
	 * effects. This can result in low frame rates when an application requires these effects. On
	 * devices that lack the extensions, you could improve the application's frame rate by turning
	 * off the effect and displaying a different set of textures that simulates the effect. 
	 * 
	 * For more information about OpenGL extensions, see the
	 * [OpenGL website](http://www.opengl.org/resources/features/OGLextensions/).
	 * 
	 * **Note**: The return value of this method may be incorrect if the view is not active.
	 * @name UI.GLView#getOGLExtensions
	 * @returns {String[]} An array of OpenGL extensions that the device supports.
	 * @status Android
	 * @function
	 */
	GLView.registerAccessors('OGLExtensions', function() {return this['_OGLExtensions'];}, function() {} );
	
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/NavController'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/NavController'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/NavController'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/NavController.js';

var MessageListener = require("NGCore/Client/Core/MessageListener").MessageListener;
var KeyEmitter = require("NGCore/Client/Device/KeyEmitter").KeyEmitter;
var Window = require("NGCore/Client/UI/Window").Window;
var Capabilities = require("NGCore/Client/Core/Capabilities").Capabilities;
var Element = require("NGCore/Client/UI/Element").Element;
var View = require("NGCore/Client/UI/View").View;
var Commands = require("NGCore/Client/UI/Commands").Commands;

var NavKeyListener = MessageListener.subclass({
	classname: "UI_NavController_KeyListener"
});

var NavController = exports.NavController = View.subclass(
/** @lends UI.NavController.prototype */
{
	/**
	 * @class The `UI.NavController` class enables your application to navigate between multiple
	 * views in a navigation stack.
	 * @name UI.NavController
	 * @constructs Create a navigation controller.
	 * @augments UI.View
	 * @example
	 * // Create a new UI.NavController object without setting any of its properties.
	 * var navController = new UI.NavController();
	 * @example
	 * // Create a new UI.NavController object, setting its view frame to the entire screen.
	 * var navController = new UI.NavController({
	 *     frame: UI.Window.getFrame()
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new 
	 *		`UI.NavController` object. See `{@link UI.AbstractView}` for information about the
	 *		properties that are supported.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (NavController._init) NavController._init();
		
	    this.navStack = [];
		var onAndroid = Capabilities.getPlatformOS() == 'Android';
	    this._useBackButton = !onAndroid;
	
		this.keyListener = new NavKeyListener();
		KeyEmitter.addListener(this.keyListener, this.onKeyPressed.bind(this));
		$super(properties);
	},
	
	/**
	 * Display a Back button on the screen. Applications that will run on iOS should always provide
	 * an on-screen Back button and call `{@link UI.NavController#back}` when it is pressed. On
	 * Android devices, which have a hardware Back button, this method has no effect.
	 * @function
	 * @example
	 * var navController = new UI.NavController();
	 * navController.setUseBackButton(true);
	 * @param {Boolean} toUse Set to `true` to enable the on-screen Back button.
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	setUseBackButton: function(toUse) {
		this._useBackButton = toUse;
		if (toUse) {
			this._createBackButton();
		} else if (this.backButton) {
			this.backButton.removeFromParent();
		}
	},
    
	// don't document the unused fromButton parameter, per jyopp
	/**
	 * Reset the navigation stack, removing all views from the stack.
	 * @name UI.NavController#clear
	 * @function
	 * @example
	 * var navController = new UI.NavController();
	 * var page = new UI.View();
	 * navController.forwardToView(page);
	 * // When the application is finished with the navigation stack:
	 * navController.clear();
	 * @returns {Object[]} The views that were removed, or an empty array if no views were removed.
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	
	clear: function(fromButton) {
		return this.backToView(undefined);
	},
	
	/**
	 * Retrieve the top view from the navigation stack.
	 * @returns {Object} The top view in the navigation stack, or `undefined` if the navigation
	 *		stack does not contain any views.
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 * @since 1.0
	 */
	getTopView: function() {
		return (this.navStack.length > 0) ? this.navStack[ (this.navStack.length - 1) ] : undefined;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	navStackDepth: function() {
		return this.navStack.length;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	depthOfView: function(targetView) {
		var targetIndex = this.navStack.indexOf(targetView);
		if(targetIndex == -1){return -1;}
		
		return this.navStack.length - targetIndex - 1;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	viewAtDepth: function(targetDepth) {
		if(targetDepth >= this.navStack.length){
			return null;
		}
		return this.navStack[this.navStack.length - targetDepth - 1];
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	removeDeepView:function(targetView) {
		var targetIndex = this.navStack.indexOf(targetView);
		if(targetIndex == -1){
			NgLogE("NavController: trying to remove a nonexistent view from the nav stack!");
			return;
		}
		this.navStack.splice(targetIndex,1);
	},
    
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 * @since 1.0
	 */
	_viewTransition: function(fromView, toView, back) {
		//The views transition within the container (which is 'this')
		var myFrame = this.getFrame();
		var w = myFrame[2];
		var h = myFrame[3];
		
		//TODO: animate this (below) transition.
		if (toView) {
			toView.setFrame( (back ? -w : w), 0, w, h);
			this.addChild(toView);
		}
		
		Commands.animate(function() {
			if (fromView) fromView.setFrame( (back ? w : -w), 0, w, h);
			if (toView) toView.setFrame(0, 0, w, h);
		}, 400, function() {
			if (fromView) fromView.removeFromParent();
		});
		
		this._createBackButton();
	},

	// don't document the unused fromButton parameter
	/**
	 * Add the specified view to the navigation stack, and move forward to the view.
	 * @name UI.NavController#forwardToView
	 * @function
	 * @example
	 * var navController = new UI.NavController();
	 * var page = new UI.View();
	 * navController.forwardToView(page);
	 * @param {Object} destView The view to display.
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash
	 * @see UI.NavController#backToView
	 * @since 1.0
	 */
	
	forwardToView: function(destView, fromButton) {
		var currentView = this.getTopView();
		if (destView && 
			(!this._delegate 
				|| (this._delegate 
					&& typeof this._delegate.navControllerShouldPush == "function" 
					&& this._delegate.navControllerShouldPush(this,destView))
			)) {
			
			destView.performEventCallback({eventType:"push",navController:this});
			
			this.navStack.push(destView);
			this._viewTransition(currentView, destView, false, fromButton);
		}
	},
    
	/**
	 * Go back to the previous view.
	 * @returns {Object} The view that was removed, or `null` if no view was removed.
	 * @status Javascript, iOS, Android, Flash
	 * @see UI.NavController#forward	
	 * @since 1.0
	 */
	back: function() {
		var removed = this.navStack.pop();
		
		if (removed && 
			(!this._delegate 
				|| (this._delegate 
					&& typeof this._delegate.navControllerShouldPop == "function" 
					&& this._delegate.navControllerShouldPop(this,removed))
			)) {
			removed.performEventCallback({eventType:"pop",navController:this});
		} else {
			return null;
		}
		this._viewTransition(removed, this.getTopView(), true);
		return removed;
	},

	// don't document the unused fromButton parameter
	/**
	 * Navigate back to the specified view, returning any views that were removed from the
	 * navigation stack in the order they were removed.
	 * @name UI.NavController#backToView
	 * @function
	 * @example
	 * var navController = new UI.NavController();
	 * var page1 = new UI.View(),
	 *     page2 = new UI.View(),
	 *     page3 = new UI.View();
	 * navController.forwardToView(page1);
	 * navController.forwardToView(page2);
	 * navController.forwardToView(page3);
	 * // removedViews will contain page3, followed by page2
	 * var removedViews = navController.backToView(page1);
	 * @param {Object} destView The view to display.
	 * @returns {Object[]} The views that were removed, or an empty array if no views were removed.
	 * @see UI.NavController#forwardToView
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */

	backToView: function(destView, fromButton) {
		var removedSet = [];
		var removed = this.navStack.pop();
		var originalView = removed;
		if (removed) {
			do {
				if (removed && 
					(!this._delegate 
						|| (this._delegate 
							&& typeof this._delegate.navControllerShouldPop == "function" 
							&& this._delegate.navControllerShouldPop(this,removed))
					)) {
					removedSet.push(removed);
					removed.performEventCallback({eventType:"pop",navController:this});
				}
				else {
					//There was nothing to remove, or the this._delegate said "don't remove".
					break;
				}
				
				if (this.getTopView() == destView){break;}
			} while ((removed = this.navStack.pop()));
		}
		if(removedSet.length > 0) {
			this._viewTransition(originalView, this.getTopView(), true, fromButton);
		}
		return removedSet;
	},

	/**
	 * Set the navigation controller to launch the application when activated.
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */    
	loadApp: function() {		
	},
    
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */    
	onBackPressed: function() {
		if (this.navStack.length > 1) {
		//	NgLogD("Handle back on nav stack. Number of views on stack=" + this.navStack.length);
			this.back();
			return true;
		}
		return false;
	},
	
	onKeyPressed: function(event) {
		if ((event.code === KeyEmitter.Keycode.back) && (this.navStack.length > 1)) {
			this.back();
			return true;
		}
		return false;
	},
	
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 */
	_delegate:null,
	/**
	 * @description Set subscribers to the `NavController` behavior. Subscribers can modify what happens. 
	 * NavControllerDelegateProtocol:
	 *	@optional - (BOOL)navControllerShouldPop(NavController,View)
	 *	@optional - (BOOL)navControllerShouldPush(NavController,View)
	 * @param {String} navDelegate A `NavController` subscriber.
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	setDelegate:function( /*NavControllerDelegate*/ navDelegate){
		this._delegate = navDelegate;
	},
	
	delegate:function(){return this._delegate;},
	
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 * @since 1.0
	 */
	_createBackButton: function() {
		// Do nothing if this device does not require_ an onscreen button.
		if (!this._useBackButton) return;
		
		if (!this.backButton) {
			this.backButton = new UI.Button({
				normalText: 'Back',
				textSize: 13.0,
				normalTextColor: "FF",
				normalTextShadow: "00 1.5 {0,-1}",
				frame: [-2, 20, Window.outerWidth / 5, Window.outerHeight / 12],
				normalGradient: {
					corners: "0 8 8 0",
					outerLine: "00 1.5",
					innerShadow: "99FF 2.0 {0,-1}",
					gradient: [
						"FFCC 0.0",
						"FF80 1.0"
					]
				},
				highlightedGradient: {
					corners: "0 8 8 0",
					outerLine: "00 1.5",
					innerLine: "FF00 15 {0,-1}",
					gradient: [
						"FF50 0.0",
						"FF80 1.0"
					]
				}
			});
			this.backButton.onclick = this.bind(this.onBackPressed);
		}
		
		if (this.navStack.length > 1) {
			if (!this.backButton.getParent()) Window.document.addChild(this.backButton);
		} else if ( this.backButton.getParent() ) {
			this.backButton.removeFromParent();
		}
	}
});

NavController._init = function() {
	delete NavController._init;
	if (View._init) View._init();
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/WebView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/WebView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/WebView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/WebView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var WebView = exports.WebView = AbstractView.subclass(
/** @lends UI.WebView.prototype */
{
	'type':'webview',

	/**
	 * @class The `UI.WebView` class provides web views for loading HTML documents, either from
	 * local files or from remote servers. It also provides methods for navigating back and forward
	 * in the web view's history.
	 * 
	 * On Android devices, email addresses and telephone numbers in a web view are automatically
	 * turned into active links. Web addresses in a web view are not autodetected.
	 * 
	 * On iOS devices, by default, web addresses in a web view are automatically turned into active 
	 * links. You can use the `{@link UI.WebView#setAutodetection}` method to control this behavior. 
	 * Email addresses and phone numbers are not autodetected.
	 *
	 * **Note**: If your app uses the `UI.WebView` class to display a web-based game, avoid adding
	 * listeners to the `{@link Core.UpdateEmitter}` class when possible. Attaching a listener to
	 * `Core.UpdateEmitter` can limit the performance of web-based games.
	 * @name UI.WebView
	 * @constructs Create a web view.
	 * @augments UI.AbstractView
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.WebView`
	 *		object.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (WebView._init) WebView._init();
		this._canGoBack = false;
		this._canGoForward = false;
		return $super(properties);
	},
	
	/** @private */
	_onShouldLoad: function(event) {
		NgLogD("Should Load " + event.url + " ???????");
		var fn = this.getOnShouldload();
		if (typeof fn == 'function') {
			// If we SHOULDN'T load the url, bail.
			if (!Boolean(fn.call(this, event))) return;
		}
		// The default (if the function was missing or not a function) is to load the url.
		this.loadUrl(event.url);
	},
	
	/** @private */
	performEventCallback: function($super, event) {
		try {
			if (event.eventType == 'shouldload') {
				// We need to call the onShouldLoad function in a way that captures the return value.
				this._onShouldLoad(event);
				return;
			}
			if (event.eventType == 'pageload') {
				// Do not touch this parsing code. Everything else is wrong, extensive testing was done.
				this._canGoBack = event.canGoBack = Boolean(JSON.parse(event.canGoBack));
				this._canGoForward = event.canGoForward = Boolean(JSON.parse(event.canGoForward));
			}
			$super(event);
		} catch(e) {
			NgHandleException(e);
		}
	},
	// invoke doesn't return a value. to get response, use onpageevent
	/**
	 * Execute the JavaScript code specified in the `script` parameter. To return a value, your code
	 * must do the following:
	 *
	 * 1. Convert the return value to a string.
	 * 2. Turn the string into a URL by adding `ngcore://` to the beginning of the string.
	 * 3. Attempt to load the `ngcore://` URL. This fires a `pageevent` event, and the return value
	 * is passed to the callback function that was set through
	 * `{@link UI.WebView#event:setOnPageevent}`.
	 * @function
	 * @example
	 * // Log the text "Hello World" to the console.
	 * var js = "var message = 'Hello World'; " + 
	 *     "window.location.href = 'ngcore://' + message;";
	 * var webView = new UI.WebView();
	 * webView.setOnPageevent(function(event) {
	 *     console.log(event.eventStream);
	 * });
	 * webView.invoke(js);
	 * @param {String} script The JavaScript code to execute.
	 * @returns {void}
 	 * @see UI.WebView#event:setOnPageevent
	 * @status iOS, Android, Flash
	 */
	invoke: Commands.invoke,
	/**
	 * Request a file from the specified URL using the HTTP `GET` method. You can specify an
	 * `http://` or `https://` URL.
	 * @example
	 * // Load a webpage from a remote server.
	 * var webView = new UI.WebView();
	 * webView.loadUrl("http://www.example.com/testpage/");
	 * @param {String} url The URL to request.
	 * @param {String} [headers] A JSON object containing key-value pairs to include in the HTTP 
	 *		request headers. Supported only on iOS.
	 * @param {Number} [timeout] The timeout length for the request, in seconds.
	 * @returns {void}
 	 * @see UI.WebView#loadDocument
	 * @see UI.WebView#postUrl
	 * @status iOS, Android, Flash, Test, FlashTested
	 * @since 1.0
	 */
	loadUrl: function(url, headers, timeout) {
		Commands.loadURL.call(this, url, headers || null, +(timeout || 0));
	},
	/**
	 * Load a document from the specified local path.
	 * @example
	 * // Load a local file.
	 * var webView = new UI.WebView();
	 * webView.loadDocument("./html/page.html");
	 * @param {String} relativePath The local path from which to load a document.
	 * @returns {void}
	 * @see UI.WebView#loadUrl
	 * @see UI.WebView#postUrl
	 * @status iOS, Android, Flash, Test, FlashTested
	 * @since 1.0
	 */
	loadDocument: Commands.setSourceDocument,
	/**
	 * Post data to the specified URL using the HTTP `POST` method.
	 * @example
	 * // Post data using a string that contains the raw body of the `POST` request.
	 * var webView = new UI.WebView();
	 * var postData = "catalog=Fall;retrieve=titles";
	 * webView.postUrl("http://www.example.com/getCatalogInfo", postData);
	 * @example
	 * // Post data using an object that contains key-value pairs.
	 * var webView = new UI.WebView();
	 * var postData = {
	 *     catalog: "Fall",
	 *     retrieve: "titles"
	 * };
	 * webView.postUrl("http://www.example.com/getCatalogInfo", postData);
	 * @param {String} url The URL that will be used to post data.
	 * @param {String|Object} data A string that contains the raw body of the `POST` request, or an
	 *		object whose properties will be converted into key-value pairs for the request, using
	 *		`www/form-data` encoding.
	 * @see UI.WebView#loadUrl
	 * @see UI.WebView#loadDocument
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.0
	 */
	postUrl: function(url, data){
		var dataStr;
		if(typeof data == "object"){
			var params = [];
			for(var key in data){
				params.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
			}
			dataStr = params.join('&');
		}else{
			dataStr = data;
		}
		Commands.postURL.call(this, url, dataStr);
	},
	/**
     * Stop loading a document. 
	 * @function
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	stopLoading: Commands.stopLoading,
	/**
	 * Reload a document that was requested with `{@link UI.WebView#loadDocument}` or
	 * `{@link UI.WebView#loadUrl}`.
	 * @function
	 * @returns {void}
	 * @see UI.WebView#loadDocument
	 * @see UI.WebView#loadUrl
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	reload: Commands.reload,
	/**
	 * Go back one page in the web view's history.
	 * @function
	 * @returns {void}
	 * @see UI.WebView#goForward
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	goBack: Commands.goBack,
	/**
	 * Go forward one page in the web view's history.
	 * @function
	 * @returns {void}
	 * @see UI.WebView#goBack
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	goForward: Commands.goForward,
	/**
	 * Determine whether the web view can go back a page in the web view's history.
	 * @returns {Boolean} Set to `true` if the web view can go back a page in the web view's
	 *		history.
	 * @see UI.WebView#canGoForward
	 * @status iOS, Flash, Test, FlashTested
	 * @since 1.0
	 */
	canGoBack: function(){
		return this._canGoBack;
	},
	/**
	 * Determine whether the web view can go forward a page in the web view's history.
	 * @returns {Boolean} Set to `true` if the web view can go forward a page in the web view's
	 *		history.
	 * @see UI.WebView#canGoBack
	 * @status iOS, Flash, Test, FlashTested
	 * @since 1.0
	 */
	canGoForward: function(){
		return this._canGoForward;
	},
	/**
	 * Set the authentication credentials for this web view, including the username, the password,
	 * the authentication host, and the security realm. This method supports HTTP Basic Access
	 * Authentication.
	 *
	 * For more information about using the `host` and `realm` parameters, see
	 * [RFC 2617](http://www.ietf.org/rfc/rfc2617.txt), which provides the specification for Basic
	 * Access Authentication.
	 * @param {String} host The authentication host.
	 * @param {String} realm The security realm.
	 * @param {String} username The username for the session.
	 * @param {String} password The password for the session.
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.0
	 */
	setBasicAuthCredential: function(host, realm, username, password){
		Commands.setBasicAuthCredentials.call(this, {'host':host, 'realm':realm, 'username':username, 'password':password});
	},
    /**
     * Set whether the web view should honor an HTML document's `viewport` meta tags. These meta
 	 * tags are honored by default.
	 *
	 * For example, if this property is set to `true`, the following meta tags would cause the page
	 * content to be scaled to fill the viewport:
	 *
     *     <meta name="viewport" content="initial-scale=1.0" />
     *     <meta name="viewport" content="user-scalable=false" />
     * @param {Boolean} enabled Set to `true` if the web view should honor the page's `viewport`
	 *		meta tags.
     * @returns {void}
     * @since 1.4.1
     */
	setViewportEnabled: Commands.setViewportEnabled,

	/**
	 * Set whether to autodetect phone numbers in this web view. By default, phone numbers are not
	 * autodetected. Call this method before calling `{@link UI.WebView#loadDocument}` or
	 * `{@link UI.WebView#loadUrl}`. Supported only on iOS.
	 * @param {UI.Commands#Autodetect} type Set to `UI.Commands.Autodetect.Phone` to enable
	 *		autodetection of phone numbers.
	 * @returns {void}
	 * @see UI.WebView#loadDocument
	 * @see UI.WebView#loadUrl
	 * @status iOS
	 * @since 1.4.1
	 */
	setAutodetection: function(type) {
		Commands.setAutodetection.call(this, type);
	}
});

WebView._init = function() {
	delete WebView._init;
	if (AbstractView._init) AbstractView._init();
	
	WebView.synthesizeProperty('scrollable', Commands.setScrollable);
	WebView.synthesizeProperty('pluginsEnabled', Commands.setPluginsEnabled);
	
	/**
	 * Set a function to call when a `startload` event occurs. This event occurs when a document
	 * starts loading.
	 * @name UI.WebView#setOnStartload
	 * @event
	 * @example
	 * var webView = new UI.WebView();
	 * webView.setOnStartload(function(event) {
	 *     console.log("Started loading the following URL: " + event.url);
	 * });
	 * @cb {Function} startloadCallback The function to call when a `startload` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.url The URL of the page being loaded.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.WebView#event:getOnStartload
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the function to call when a `startload` event occurs.
	 * @name UI.WebView#getOnStartload
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnStartload
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	WebView.registerEventType('startload');
	/**
	 * Set a function to call when a `pageload` event occurs. This event occurs when a document
	 * finishes loading.
	 * @name UI.WebView#setOnPageload
	 * @event
	 * @example
	 * var backOK = false;
	 * var forwardOK = false;
	 * var webView = new UI.WebView();
	 * webView.setOnPageload(function(event) {
	 *     console.log("Finished loading the following URL: " + event.url);
	 *     backOK = event.canGoBack;
	 *     forwardOK = event.canGoForward;
	 * });
	 * @cb {Function} pageloadCallback The function to call when a `pageload` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Boolean} event.canGoBack Set to `true` if the web view can go back a page in the
	 *		web view's history.
	 * @cb-param {Boolean} event.canGoForward Set to `true` if the web view can go forward a page in
	 *		the web view's history.
	 * @cb-param {String} event.url The URL of the page that loaded.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.WebView#event:getOnPageload
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the function to call when a `pageload` event occurs.
	 * @name UI.WebView#getOnPageload
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnPageload
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	WebView.registerEventType('pageload');
	/**
	 * Set a function to call when an `error` event occurs. This event occurs when a document cannot
	 * be loaded.
	 * @name UI.WebView#setOnError
	 * @event
	 * @example
	 * var webView = new UI.WebView();
	 * webView.setOnError(function(error) {
	 *     console.log("The document could not be loaded: " + event.code + ": " +
	 *         event.description);
	 * });
	 * @cb {Function} errorCallback The function to call when an `error` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Number} event.code The HTTP error code for the error.
	 * @cb-param {String} [event.description] A description of the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.WebView#event:getOnError
	 * @status iOS, Android
	 */
	/**
	 * Retrieve the function to call when an `error` event occurs.
	 * @name UI.WebView#getOnError
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnError
	 * @status iOS, Android
	 */
	WebView.registerEventType('error');
	/**
	 * Set a function to call when a `pageevent` event occurs. This event occurs when the
	 * application executes JavaScript code by calling `{@link UI.WebView#invoke}`, and the
	 * JavaScript code attempts to load a URL that begins with `ngcore://`. The text of the URL,
	 * excluding the `ngcore://` prefix, is passed to the callback function.
	 * @name UI.WebView#setOnPageevent
	 * @event
	 * @cb {Function} pageeventCallback The function to call when a `pageevent` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.eventStream The text of the URL, excluding the `ngcore://` prefix.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.WebView#event:getOnPageevent
	 * @status iOS, Android, Flash
	 */
	/**
	 * Retrieve the function to call when a `pageevent` event occurs.
	 * @name UI.WebView#getOnPageevent
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnPageevent
	 * @status iOS, Android, Flash
	 */
	WebView.registerEventType('pageevent');	
	/**
	 * Set a function to call when a `shouldload` event occurs. When a callback function is
	 * specified, a `shouldload` event occurs each time a document is requested via the HTTP `GET`
	 * method. The callback function returns a boolean to indicate whether the URL should be loaded.
	 * @name UI.WebView#setOnShouldload
	 * @event
	 * @example
	 * // Only load http:// and https:// links. Ignore other types of links, such
	 * // as links that will open external applications.
	 * var webView = new UI.WebView();
	 * webView.setOnShouldload(function(event) {
	 *     if (event.url.match(/^http[s?]:\/\//)) {
	 *         return true;
	 *     } else {
	 *         console.log("Attempted to load the external link " + event.url);
	 *         return false;
	 *     }
	 * });
	 * @cb {function} shouldloadCallback The function to call when a `shouldload` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.navigation The type of navigation event that occurred. Contains one
	 *		of the following values:
	 * 
	 * + `click`: The user clicked a link.
	 * + `other`: The user performed an unspecified action.
	 * + `reload`: The user reloaded the page.
	 * + `resubmit`: The user resubmitted a form.
	 * + `submit`: The user submitted a form.
	 * @cb-param {String} event.url The URL to be loaded.
	 * @cb-returns {Boolean} Set to `true` if the document should be loaded.
	 * @see UI.WebView#event:getOnShouldload
	 * @returns {void}
	 */
	/**
	 * Retrieve the function to call when a `shouldload` event occurs.
	 * @name UI.WebView#getOnShouldload
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnShouldload
	 * @event
	 */
	WebView.registerEventType('shouldload');
	
	/**
	 * Set a function to call when an `externalLink` event occurs, indicating that a link will be
	 * opened in an external application.
	 * @name UI.WebView#setOnExternalLink
	 * @event
	 * @example
	 * var webView = new UI.WebView();
	 * webView.setOnExternalLink(function(event) {
	 *     console.log("Opened the external link " + event.url);
	 * });
	 * @cb {function} externalLinkCallback The function to call when an `externalLink` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.url The URL to be loaded.
	 * @cb-returns {Boolean} Set to `true` if the URL should be opened.
	 * @returns {void}
	 * @see UI.WebView#event:getOnExternalLink
	 */
	/**
	 * Retrieve the function to call when an `externalLink` event occurs.
	 * @name UI.WebView#getOnExternalLink
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnExternalLink
	 */
	WebView.registerEventType('externalLink');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ScrollView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ScrollView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ScrollView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ScrollView.js';

var View = require('NGCore/Client/UI/View').View;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var Commands = require('NGCore/Client/UI/Commands').Commands;

var ScrollView = exports.ScrollView = View.subclass(
/** @lends UI.ScrollView.prototype */
{
	'type':'scrollview',
	/**
	 * @class The `UI.ScrollView` class constructs objects that handle views in a small scroll area.
	 * A scroll area can be scrolled horizontally, vertically, or in both directions. Android
	 * devices can scroll in only one direction at a time.
	 *
	 * If you need to create a scrolling list that uses a table-like layout, or that contains a
	 * large number of very similar views, consider using the `{@link UI.ListView}` class instead of
	 * `UI.ScrollView`.
	 * @name UI.ScrollView
	 * @constructs Create a scroll area.
	 * @augments UI.View
	 * @example
	 * // Create a new UI.ScrollView object without setting any of its properties.
	 * var scrollArea = new UI.ScrollView();
	 * @example
	 * // Create a new UI.ScrollView object, and hide its scrollbars.
	 * var scrollArea = new UI.ScrollView({
	 *     scrollIndicatorsVisible: false
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.ScrollView` object.
	 * @see UI.ListView
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (ScrollView._init) ScrollView._init();
		this._scrollPosition = [0, 0];
		return $super(properties);
	},
	
	/**
	 * @private
	 */    
	updateScrollPosition: function(newVal) {
		this._scrollPosition = newVal;
	},
	
	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		if (e.eventType == 'scroll') this.updateScrollPosition(e.scrollPosition);
		$super(e);
	},

	getFrameOffset: function() {
		var frame = this._frame;
		if (frame) {
			return [-this._scrollPosition[0], -this._scrollPosition[1]];
		} else {
			return undefined;
		}
	}
});

// Properties
ScrollView._init = function() {
	delete ScrollView._init;
	if (View._init) View._init();

	/**
	 * Set the `contentSize` property, which defines the scroll area's width and height in pixels.
	 * @name UI.ScrollView#setContentSize
	 * @function
	 * @example
	 * var width = Device.LayoutEmitter.getWidth();
	 * var scrollArea = new UI.ScrollView();
	 * scrollArea.setContentSize([width / 2, 200]);
	 * @param {Number[]|Number} w An array of two integers, where the first item contains the scroll
	 *		area's width in pixels and the second item contains the scroll area's height in pixels;
	 *		or a number representing the width, in pixels, of the scroll area.
	 * @param {Number} [h] A number representing the height, in pixels, of the scroll area. If
	 *		the `w` parameter contains an array, do not use the `h` parameter.
	 * @returns {void}
 	 * @see UI.ScrollView#getContentSize
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `contentSize` property, which defines the scroll area's width and
	 * height in pixels.
	 * @name UI.ScrollView#getContentSize
	 * @function
	 * @returns {Number[]} An array of two integers, where the first item contains the scroll area's
	 *		width in pixels and the second item contains the scroll area's height in pixels.
	 * @see UI.ScrollView#setContentSize
	 * @status iOS, Android, Flash, Test
	 */
	ScrollView.synthesizeCompoundProperty('contentSize', Commands.setScrollableSize);
	/**
	 * Set the `scrollPosition` property, which indicates where the scrollbar should be positioned
	 * and, as a result, what part of the scroll area should be displayed. This property contains
	 * two integers, which indicate the positions, in pixels, of the horizontal and vertical
	 * scrollbars.
	 * @name UI.ScrollView#setScrollPosition
	 * @function
	 * @example
	 * // Scroll to the origin of the scroll area.
	 * var scrollArea = new UI.ScrollView();
	 * scrollArea.setScrollPosition([0, 0]);
	 * @param {Number[]|Number} x An array of two integers, where the first item contains the 
	 *		position of the horizontal scrollbar, in pixels, and the second item contains the 
	 *		position of the vertical scrollbar, in pixels; or a single integer representing the 
	 *		position of the horizontal scrollbar, in pixels.
	 * @param {Number} [y] An integer representing the position of the vertical scrollbar, in
	 *		pixels. If the `x` parameter contains an array, do not use the `y` parameter.
	 * @see UI.ScrollView#getScrollPosition
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `scrollPosition` property, which indicates where the scrollbar
	 * should be positioned and, as a result, what part of the scroll area should be displayed.
	 *
	 * **Note**: The `scrollPosition` property is not updated when the user scrolls the view. See
	 * `{@link UI.ScrollView#event:setOnScroll}` for information about how to monitor the current
	 * position of the scroll area. If the application has not called
	 * `{@link UI.ScrollView#setScrollPosition}`, this method will return the value `[0, 0]`,
	 * regardless of whether the view has been scrolled.
	 * @name UI.ScrollView#getScrollPosition
	 * @function
	 * @returns {Number[]} An array of two integers, where the first item contains the position of the
	 *		horizontal scrollbar, in pixels, and the second item contains the position of the
	 *		vertical scrollbar, in pixels.
	 * @see UI.ScrollView#setScrollPosition
	 * @status iOS, Android, Flash, Test
	 */
	ScrollView.synthesizeCompoundProperty('scrollPosition', Commands.setScrollPosition);
	
	/**
	 * Set the `scrollIndicatorsVisible` property, which indicates whether the scroll area's 
	 * scrollbars should be visible.
	 * @name UI.ScrollView#setScrollIndicatorsVisible
	 * @function
	 * @example
	 * // Hide the scroll area's scrollbars.
	 * var scrollArea = new UI.ScrollView();
	 * scrollArea.setScrollIndicatorsVisible(false);
	 * @param {Boolean} enabled Set to `true` if the scroll area's scrollbars should be visible.
	 * @returns {void}
	 * @see UI.ScrollView#getScrollIndicatorsVisible
	 * @status iOS, Android, Test
	 */
	/**
	 * Retrieve the value of the `scrollIndicatorsVisible` property, which indicates whether the
	 * scroll area's scrollbars should be visible.
	 * @name UI.ScrollView#getScrollIndicatorsVisible
	 * @function
	 * @returns {Boolean} Set to `true` if the scroll area's scrollbars should be visible.
	 * @see UI.ScrollView#setScrollIndicatorsVisible
	 * @status iOS, Android, Test
	 */
	ScrollView.synthesizeCompoundProperty('scrollIndicatorsVisible', Commands.setScrollIndicatorsVisible);
	
	View.synthesizeProperty('visibleInOrientations', Commands.setVisibleInOrientations);

	/**
	 * Set a function to call when a `scroll` event occurs. This event occurs when the user scrolls
	 * the scroll area.
	 * @name UI.ScrollView#setOnScroll
	 * @event
	 * @example
	 * var scrollArea = new UI.ScrollView();
	 * scrollArea.setOnScroll(function(event) {
	 *     console.log("X position: " + event.scrollPosition[0] +
	 *         ", Y position:" + event.scrollPosition[1]);
	 * });
	 * @cb {Function} scrollCallback The function to call when a `scroll` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Number[]} event.scrollPosition An array of two integers, where the first item
	 *		represents the number of pixels by which the scroll area has been scrolled along the X
	 *		axis and the second item represents the number of pixels by which the scroll area has
	 *		been scrolled along the Y axis.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.ScrollView#event:getOnScroll
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the function to call when a `scroll` event occurs.
	 * @name UI.ScrollView#getOnScroll
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.ScrollView#event:setOnScroll
	 * @status iOS, Android, Flash, Test
	 */
	ScrollView.registerEventType('scroll');
	
	ScrollView.registerEventType('scrollEnded');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ListView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var ScrollView = require('NGCore/Client/UI/ScrollView').ScrollView;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var Commands = require('NGCore/Client/UI/Commands').Commands;

var ListView = exports.ListView = ScrollView.subclass(
/** @lends UI.ListView.prototype */
{
	'type':'listview',
	/**
	 * @class The `UI.ListView` class creates scrolling lists in an application. A `UI.ListView`
	 * object can contain one or more sections, which are represented by `UI.ListViewSection` 
	 * objects. In turn, each section can contain one or more items, which are represented by
	 * `UI.ListViewItem` objects.
	 *
	 * To improve performance for long lists, `UI.ListView` objects use a pool of reusable views.
	 * When a list item scrolls off the top or bottom of the screen, its view is added to the view
	 * pool. See `{@link UI.ListViewItem}` for more information about managing view pools.
	 *
	 * In a typical list, most or all of the list items' views are displayed with the same general 
	 * appearance. When a list item's view is given a unique appearance--for example, if it is
	 * highlighted with a unique background color--its appearance must be reset when it scrolls off
	 * screen. If the appearance is not reset, the view's unique appearance will persist when the
	 * view is recycled. See `{@link UI.ListViewItem}` for more information.
	 * 
	 * Use this class for scrolling lists that use a table-like layout, or that contain a large
	 * number of very similar views.  For other types of scrolling lists, use the
	 * `{@link UI.ScrollView}` class instead.
	 *
	 * **Note**: Destroying a `UI.ListView` object also destroys all of the
	 * `{@link UI.ListViewItem}` objects that are associated with the scrolling list.
	 * @name UI.ListView
	 * @constructs Create a list view.
	 * @augments UI.ScrollView
	 * @example
	 * // Create a new UI.ListView object without setting any of its properties.
	 * var listView = new UI.ListView();
	 * @example
	 * // Create a new UI.ListView object, setting its header.
	 * var listHeader = "Latest News";
	 * var listView = new UI.ListView({
	 *     header: listHeader
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.ListView` object.
	 * @see UI.ListViewItem
	 * @see UI.ListViewSection
	 * @see UI.ScrollView
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize:function($super, properties) {
		if (ListView._init) ListView._init();
		$super(properties);
		
		this._sections = [];
		this._scrollPosition = [0,0];
		this.enableEvent('scroll', true);
		
		this._ownedViews = [];
		this._queuedViews = {};
		
		this._cellDivider = 0;
		
		return this;
	},
	
	destroy: function($super) {
		var l = this._ownedViews.length;
		for (var i = 0; i < l; i++) {
			this._ownedViews[i].release();
		}
		this._ownedViews = null;
		$super();
	},
	
	addChild: function($super, child, index) {
		if (index == "cell") {
			index = this._cellDivider++;
		} else if ((index || -1) >= 0) {
			index += this._cellDivider;
		}
		$super(child, index);
	},
	
	_viewForItem: function(lvItem) {
		if (lvItem._currentView instanceof AbstractView) return lvItem._currentView;
		
		var rID = lvItem._reuseId;
		var queue = this._queuedViews[rID];
		
		var view = null;
		while (queue && queue.length > 0) {
			if ((view = queue.pop()) instanceof AbstractView) break;
		}
		
		if (!(view instanceof AbstractView)) {
			view = lvItem._onCreateView(lvItem);
			if (view instanceof AbstractView) {
				this._ownedViews.push(view.retain());
				this.addChild(view, "cell");
			} else {
				console.log("Error creating view for list item with reuse id " + rID);
			}
		}
	//	console.log("_viewForItem: " + lvItem + " = " + view);
		return view;
	},
	
	_queueViewForItem: function(lvItem) {
		if(!lvItem){
			NgLogE("ListView::_queueViewForItem called with undefined item");
			return;
		}
		var viewToQueue = lvItem._currentView;
		if (viewToQueue instanceof AbstractView) {
			var rId = lvItem._reuseId;
			var queue = this._queuedViews[rId] || (this._queuedViews[rId] = []);
			queue.push(viewToQueue);
		}
		lvItem._setCurrentView();
	},
	
	_removeQueuedViews: function() {
		for (var q in this._queuedViews) {
			if (!this._queuedViews.hasOwnProperty(q)) continue;
			
			q = this._queuedViews[q];
			for (var i = 0, l = q.length; i < l; i++) {
				q[i].removeFromParent();
			}
		}
		this._cellDivider = 0;
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	flushSections: function() {
		for (var i in this._sections) {
			if(!this._sections.hasOwnProperty(i)) { continue; }
				
			var section = this._sections[i];
			// Cause every section to completely queue out its item views.
			section.flush();
			section.calculateItemPositions();
		}
		this._removeQueuedViews();
	},
	
	/**
	 * Reload all of the list's sections, and update the layout of each list item's view. Calling
	 * this method ensures that the list reflects any changes to its list items.
	 * 
	 * You do not normally need to call this method. In most cases, the list is automatically 
	 * redrawn as necessary when its list items change.
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	reloadData: function() {
		this.flushSections();
		this.calculateSectionPositions();
		this.updateScrollPosition(this._scrollPosition);
	},
	
	/**
	 * Retrieve the sections that the list contains.
	 * @returns {UI.ListViewSection[]} An array of sections that the list contains.
	 * @see UI.ListView#setSections
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	getSections: function() {
		return this._sections;
	},
	
	/**
	 * Remove all sections from the list, and set a new list of sections that the list contains.
	 * @example
	 * var sections = [];
	 * var sectionHeaders = ["News", "Updates", "Announcements"];
	 * for (var i = 0, l = sectionHeaders.length; i < l; i++) {
	 *     var section = new UI.ListViewSection({
	 *         titleView: sectionHeaders[i]
	 *     });
	 *     // Additional code to populate the section with items.
	 *     // Then add the section to the list:
	 *     sections.push(section);
	 * }
	 * var listView = new UI.ListView();
	 * listView.setFrame([0, 0, Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight()]);
	 * listView.setSections(sections);
	 * @param {UI.ListViewSection[]} newSections An array of sections to add to the list.
	 * @see UI.ListView#getSections
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	setSections: function(newSections) {
		this.flushSections();
	        var i;
		for (i in this._sections) {
			if(this._sections.hasOwnProperty(i)) {
				this._sections[i].setListView(null);
			}
		}
		this._sections = newSections;
		var idArray = [];
		for (i in newSections) {
			if(newSections.hasOwnProperty(i)) {
				idArray.push(0+(newSections[i].__objectRegistryId || 0));
			}
		}
		Commands.setSections.call(this, idArray);
		this.reloadData();
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	calculateSectionPositions: function() {
		if(!this.getFrame()){
			console.log("UI.ListView Warning: You probably called setSections before you actually set a frame.");
			return;
		}
		this._stackedSections = {};
		var topY = 0;
		// Should account for header here.
		var l = this._sections.length;
		for (var i = 0; i < l; i++) {
		//	NgLogD("Calculating height for Section " + i + " / " + l + " from yPos " + topY);
			var section = this._sections[i];
			this._stackedSections[topY] = section;
			section.setListView(this);
			section.setYPosition(topY);
			var relTopY = this._scrollPosition[1/*y*/] - topY;
			section.updateVisibleRange(relTopY, relTopY + this._frame[3/*h*/]);
			var h = section._measureHeight();
			// Set the section's frame...
			section._setFrame(0, topY, this._frame[2], h);
			topY += h;
		}
		// Should account for footer here.
		this.setContentSize([this._frame[2], topY]);
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	updateScrollPosition:function(newVal) {
		if (this._scrollPosition[1] === newVal[1]) return;
		this._scrollPosition = newVal;
		
		var myHeight = this._frame[3];
		for (var yPos in this._stackedSections) {
			if(this._stackedSections.hasOwnProperty(yPos)) {
				var section = this._stackedSections[yPos];
				var relTopY = newVal[1] - yPos;
				section.updateVisibleRange(relTopY, relTopY + myHeight);
			}
		}
	},
	
	/**
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	'_onScroll': function() {},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	enableEvent: function($super, eventName, enable) {
		// Don't allow scrolling events to be turned off!
		if ( (eventName == 'scroll') && !enable ) return;
		$super(eventName, enable);
	}
});

ListView._init = function() {
	delete ListView._init;
	if (ScrollView._init) ScrollView._init();

	/**
	 * Set the `header` property, which contains header text for the list.
	 * @name UI.ListView#setHeader
	 * @function
	 * @example 
	 * var listView = new UI.ListView();
	 * listView.setHeader("Friends");
	 * @param {String} header The new header text for the list.
	 * @see UI.ListView#getHeader
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `header` property, which contains header text for the list.
	 * @name UI.ListView#getHeader
	 * @function
	 * @returns {String} The current header text for the list.
	 * @see UI.ListView#setHeader
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	ListView.synthesizeProperty('header');
	/**
	 * Set the `footer` property, which contains footer text for the list.
	 * @name UI.ListView#setFooter
	 * @function
	 * @example
	 * var listView = new UI.ListView();
	 * listView.setFooter("Powered by Mobage");
	 * @param {String} footer The new footer text for the list.
	 * @returns {void}
	 * @see UI.ListView#getFooter
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `footer` property, which contains footer text for the list.
	 * @name UI.ListView#getFooter
	 * @function
	 * @returns {String} The current footer text for the list.
	 * @see UI.ListView#setFooter
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	ListView.synthesizeProperty('footer');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListViewItem'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListViewItem'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListViewItem'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ListViewItem.js';

/* This class does not have a physical view representation, and is just a holder for closures / a bag for data...
	We still fully map and register it so that sections can be persisted independently of tables. */
var Class = require("NGCore/Client/Core/Class").Class;

var ListViewItem = exports.ListViewItem = Class.subclass(
/** @lends UI.ListViewItem.prototype */
{	
	/**
	 * @class The `UI.ListViewItem` class creates individual items in a scrolling list. When a list
	 * item is about to be displayed, it is assigned a view, such as a `{@link UI.CellView}` object,
	 * that represents the list item's contents. The view is taken from a pool of reusable views,
	 * which are managed by the `UI.ListView` object. When a list item scrolls off the top or bottom
	 * of the screen, its view is added to the view pool.
	 *
	 * **Note**: Your application can also create more than one view pool, which is useful if your 
	 * list items will use different types of views. For example, some of your list's items might 
	 * use a cell view created by `{@link UI.CellView}`, while others might use a text label created 
	 * by `{@link UI.Label}`. To specify the view pool for a list item, include a name for the view
	 * pool in the constructor's `reuseId` parameter. You can use this view pool for any list item
	 * that uses the same type of view.
	 *
	 * When an application creates a `UI.ListViewItem` object, the application does not immediately
	 * populate the object with a view. Instead, the application assigns callback functions to the
	 * object, which are triggered as follows:
	 *
	 * +   **When the list's view pool is not full**: The `createView` event fires, telling the 
	 * application that it must create a new view for the view pool. This event triggers the 
	 * callback function specified by `{@link UI.ListViewItem#event:setOnCreateView}`. The callback 
	 * function returns a new view, such as a `{@link UI.CellView}` object, which is added to the 
	 * list's view pool. The callback function also sets the view's default appearance. For example,
	 * the function could call the view's `setGradient()` method to specify the fill color.
	 *
	 * +   **When a view is assigned to a list item**: The `setView` event fires, telling the 
	 * application that it needs to set up the view's unique attributes, such as the text and images
	 * that it displays. This event triggers the callback function specified by
	 * `{@link UI.ListViewItem#event:setOnSetView}`. The callback function assigns text and images
	 * to the view and changes its default appearance as necessary.
	 *
	 *     In some cases, the callback function will _always_ set a certain attribute, such as the
	 * view's text. The application does not need to clean up these attributes when the view is
	 * released.
	 *
	 *     In other cases, the callback function will _only sometimes_ set a certain attribute. For
	 * example, the callback function might use a unique fill color for certain views based on the
	 * views' content. **When the view is released, the application must restore these attributes to
	 * their default settings.**
	 *
	 * +   **When a view is released from a list item**: The `releaseView` event fires, telling the
	 * application that it needs to clean up the view's unique attributes as necessary. This event
	 * triggers the callback function specified by `{@link UI.ListViewItem#event:setOnReleaseView}`. 
	 * 
	 *     As described above, the callback function does not need to clean up attributes that are 
	 * _always_ set when the `setView` event fires. For attributes that are _only sometimes_ set, 
	 * **the callback function must restore these attributes to their default settings**. If the 
	 * callback function does not do this, the unique attributes will persist when the view is
	 * reused, and the view will not have the appropriate appearance.
	 * @name UI.ListViewItem
	 * @constructs Create a new list item.
	 * @augments Core.Class
	 * @example
	 * var listItem = new UI.ListViewItem();
	 * var defaultGradient = ["FFCBCBCB 1.0"];
	 *
	 * listItem.setOnCreateView(function() {
	 *     // Return a UI.CellView object that can be added to the view pool.
	 *     // Set the view to have a light gray background.
	 *     var cell = new UI.CellView({
	 *         gradient: {
	 *             gradient: defaultGradient
	 *         }
	 *     });
	 *
	 *     return cell;
	 * });
	 *
	 * listItem.setOnSetView(function(newView) {
	 *     // Set the text for the UI.CellView object to display. In this
	 *     // example, the text is chosen at random from an array.
	 *     var textOptions = ["Choose an Item", "Update Settings", "View High
	 *         Scores"];
	 *     newView.setText(textOptions[Math.floor(Math.random() * 
	 *         textOptions.length)];
	 *
	 *     // If the text contains a specific string, change the view's
	 *     // background color. Because the callback function only updates
	 *     // the background color in some cases, the application must restore
	 *     // the default background color when the releaseView event fires.
	 *     var cellText = newView.getText();
	 *     if (cellText.match(/Settings/)) {
	 *         newView.setGradient({
	 *             gradient: ["FF91CBC6 1.0"]
	 *         });
	 *     }
	 * });
	 * 
	 * listItem.setOnReleaseView(function(oldView) {
	 *     // Restore the view's background color to the default. The view's
	 *     // text does not need to be restored to a default setting, because
	 *     // the setView event's callback function will always set the correct
	 *     // text for the view.
	 *     oldView.setGradient({
	 *         gradient: defaultGradient
	 *     });
	 * });
	 * @param {String} [reuseId] The name of the view pool that this list item should use. Use this
	 *		parameter if your list items do not all display the same type of view. If you do not
	 *		include this parameter, the list item will use the default view pool. See the [overview 
	 *		of this class](#) for additional details.
	 * @see UI.ListView
	 * @see UI.ListViewSection
	 */
	
	'type':'listview-item',
	
	_reuseId: "__default__",
	/** @protected */
	_currentView: null,
	
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	_onCreateView: function() {},
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	_onReleaseView: function(oldView) {},
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	_onSetView: function(newView) {},
	
	/**
	 * Set a function to call when a `createView` event occurs. This event occurs when the
	 * `{@link UI.ListView}` object needs an additional view that can be assigned to list items
	 * when they are displayed. The callback function returns a new view, such as a
	 * `{@link UI.CellView}` object, which will be added to the view pool. The callback function
	 * also sets the view's default appearance.
	 *
	 * For additional details, see the [overview of this class](#).
	 * @event
	 * @cb {Function} newFn The function to call when a `createView` event occurs.
	 * @cb-returns {Object} A view that can be assigned to a list item.
	 * @returns {void}
	 * @since 1.0
	 */
	setOnCreateView: function(newFn)	{this._onCreateView = newFn},
	/**
	 * Set a function to call when a `releaseView` event occurs. This event occurs when a view is
	 * released from a list item.
	 * 
	 * **Important**: The function must clean up any unique attributes of the view, such as a unique
	 * background color, that are not automatically reset by the `setView` event's callback
	 * function. If the function does not do this, the unique attributes will persist when the view
	 * is reused, and the view will not have the appropriate appearance.
	 *
	 * For additional details, see the [overview of this class](#).
	 * @event
	 * @cb {Function} newFn The function to call when a `releaseView` event occurs.
	 * @cb-param {Object} oldView The view that is being released from the list item.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.0
	 */
	setOnReleaseView: function(newFn)	{this._onReleaseView = newFn},
	/**
	 * Set a function to call when a `setView` event occurs. This event occurs when a view is being
	 * added to a list item. The function assigns text and images to the view and changes its
	 * default appearance as necessary. In some cases, it is necessary to clean up the view after it
	 * is released from the list item, so that the view has the correct appearance when it is
	 * reused.
	 *
	 * For additional details, see the [overview of this class](#).
	 * @event
	 * @cb {Function} newFn The function to call when a `setView` event occurs.
	 * @cb-param {Object} newView The view that is being added to a list item.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.0
	 */
	setOnSetView: function(newFn)		{this._onSetView = newFn},
	
	/**
	 * Set the height, in pixels, of the list item. This value is used only when the list item is in
	 * a list section that uses variable row heights. Call this method before the list item is
	 * visible to the user (for example, when a `setView` event occurs).
	 * @param {Number} h The height, in pixels, of the list item.
	 * @returns {void}
	 * @see UI.ListViewSection#setRowHeight
	 * @since 1.1.1.2
	 */
	setHeight: function(h) {
		this._height = h;
	},
	
	/**
	 * Get the height, in pixels, of the list item.
	 * @returns {Number} The height, in pixels, of the list item.
	 * @since 1.1.1.2
	 */
	getHeight: function() {
		return this._height;
	},
	
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	_setCurrentView: function(newView) {
		if (newView instanceof Class) {
			this._onSetView(newView);
		} else {
			this._onReleaseView(this._currentView);
		}
		this._currentView = newView;
		return this;
	},
	
	/**
 	 * Retrieve the view that is currently attached to the list item.
	 * @returns {Object} The list item's current view, or `null` if no view is assigned.
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
 	 */
	getCurrentView: function(){
		return this._currentView;
	},
		
	initialize: function(reuseId) {
		if (reuseId) this._reuseId = reuseId;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListViewSection'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListViewSection'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListViewSection'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ListViewSection.js';

var Element = require('NGCore/Client/UI/Element').Element;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Core = require('NGCore/Client/Core').Core;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var ListViewItem = require('NGCore/Client/UI/ListViewItem').ListViewItem;

var _padTopRows = 5;
var _padBottomRows = 5;

if ( Core.Capabilities.getPlatformOS() === "iPhone OS" ) {
	// iOS's UI refresh mechanisms are much more tightly coupled. Save some memory...
	_padTopRows = 1;
	_padBottomRows = 2;
}

/* This class does not have a physical view representation.
	We still fully map and register it so that sections can be persisted independently of tables. */

var ListViewSection = exports.ListViewSection = Element.subclass(
/** @lends UI.ListViewSection.prototype */
{
	'type':'listview-section',
	/**
	 * @class The `UI.ListViewSection` class creates sections of a scrolling list. Each section 
	 * contains one or more `{@link UI.ListViewItem}` objects, which represent the list's individual
	 * items.
	 *
	 * A `UI.ListViewSection` object's appearance can change automatically when its view state 
	 * changes. For example, the section's title can change automatically when the section gains 
	 * focus or is selected. To implement this feature, your application can call a
	 * `UI.ListViewSection` setter method more than once, passing a different value in the `flags`
	 * parameter each time. In addition, your application can include properties for multiple view
	 * states in the constructor. See the `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.ListViewSection#setRowHeight}` to control
	 * the fheight of the section's rows, the height you specify will apply in all view states.
	 * @name UI.ListViewSection
	 * @constructs Create a list section.
	 * @augments UI.Element
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.ListViewSection object without setting any of its properties.
	 * var listSection = new UI.ListViewSection();
	 * @example
	 * // Create a new UI.ListViewSection object, setting its title.
	 * var sectionTitle = "Latest Updates";
	 * var listSection = new UI.ListViewSection({
	 *     titleView: sectionTitle
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.ListViewSection` object.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize:function($super, properties) {
		if (ListViewSection._init) ListViewSection._init();
		
		this._visibleRange = [0,0];
		this._headerHeight = 0;
		this._titleHeight = 0;
		
		delete this._measuredHeight;
		this._needsLayout = false;
		
		$super(properties);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	addItemToVisible: function(lvItem, index) {
		if (!(lvItem instanceof ListViewItem)) return;
		if (lvItem._currentView instanceof Element) return;
		
		var useView = this._listView._viewForItem(lvItem);
		var w = this._listView.getFrame()[2];
		
		if (this._rowHeight > 0) {
			useView.setFrame(0, this._yPosition + this._titleHeight + index * this._rowHeight, w, this._rowHeight);
		} else {
			useView.setFrame(0, this._yPosition + this._cellPositions[index], w, lvItem._height);
		}
		
		lvItem._setCurrentView(useView);
		if (!useView.getParent()) this._listView.addChild(useView, "cell");
	},
	
	_setFrame: function(l, t, w, h) {
		Commands.setFrame.call(this, l, t, w, h);
		if (this._titleView) {
			var f = this._titleView.getFrame();
			this._titleView.setFrame(l, t, w, f[3]);
		}
	},
	
	/**
	 * Reset the indices of the first and last visible list items within the section. Call this
	 * method when you change the list items in a way that the `{@link UI.ListView}` object cannot
	 * automatically detect. For example, if you pass an array to
	 * `{@link UI.ListViewSection#setItems}`, then modify the array, calling `flush()` will redraw
	 * the list based on the current items in the array.
	 * @function
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash
	 * @since 1.0
	 */
	flush: function() {
		for (var i = this._visibleRange[0], l = this._visibleRange[1]; i < l && i < this._items.length; i++) {
            this._listView._queueViewForItem(this._items[i]);
		}
		this._visibleRange = [0,0];
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	updateVisibleRange: function(topY, bottomY) {
		var totalH = this._getMeasuredHeight();
		
		// Expand the view window. This is really only necessary for Android...
		var l = this._items.length;
		var rowH = this._rowHeight > 0 ? this._rowHeight : totalH / l;
		topY -= rowH * _padTopRows;
		bottomY += rowH * _padBottomRows;
		
		var oldStartIndex = this._visibleRange[0];
		var oldEndIndex = this._visibleRange[1];
		var startIndex = l > 0 ? Math.max(0, Math.floor(topY / rowH)) : 0;
		var endIndex = l > 0 ? Math.min(l, startIndex + Math.floor((bottomY - topY) / rowH)) : 0;
		
		if (this._cellPositions) {
			// We should have a good guess into the array from the above code,
			// so now it just needs to be adjusted until accurate.
			while (startIndex < l && this._cellPositions[startIndex] < topY) startIndex++;
			while (startIndex > 0 && this._cellPositions[startIndex] > topY) startIndex--;
			if (startIndex >= l) startIndex = Math.max(0, l - 1);
			
			while (endIndex < l && this._cellPositions[endIndex] < bottomY) endIndex++;
			while (endIndex > startIndex && this._cellPositions[endIndex] > bottomY) endIndex--;
		
			topY = this._cellPositions[startIndex];
			// EndIndex is one past the last element...
			bottomY = endIndex === 0 ? topY : (this._cellPositions[endIndex-1] + this._items[endIndex-1]._height );
		}
		if (bottomY < 0 || topY > totalH) {
			for (var i = this._visibleRange[0]; i < this._visibleRange[1] && i < this._items.length; i++) {
				this._listView._queueViewForItem(this._items[i]);
			}
			this._visibleRange = [0,0];
			return;
		}
		
		if (oldStartIndex == startIndex && oldEndIndex == endIndex) return;
		
//		NgLogD("(" + oldStartIndex + "," + oldEndIndex + ") -> (" + startIndex + "," + endIndex + ")");
		
		if (oldStartIndex == oldEndIndex) {
			for (i = startIndex; i < endIndex; i++) {
				this.addItemToVisible(this._items[i], i);
			}
		} else {
			// Dequeue and requeue from both ends.
			if (oldStartIndex < startIndex) {
				do {
					this._listView._queueViewForItem(this._items[oldStartIndex]);
				} while (++oldStartIndex < startIndex);
			}
			if (oldEndIndex > endIndex) {
				while (oldEndIndex-- > endIndex) {
					this._listView._queueViewForItem(this._items[oldEndIndex]);
				}
				oldEndIndex = endIndex;	// Keep later codepath from triggering
			}
		
			if (oldStartIndex > startIndex) {
				while (oldStartIndex-- > startIndex) {
					this.addItemToVisible(this._items[oldStartIndex], oldStartIndex);
				}
				oldStartIndex = startIndex;
			} 
			if (oldEndIndex < endIndex) {
				do {
					this.addItemToVisible(this._items[oldEndIndex], oldEndIndex);
				} while (++oldEndIndex < endIndex);
			}
		
		}
		this._visibleRange = [startIndex, endIndex];
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	setListView : function(listView) {
		this._listView = listView;
		delete this._measuredHeight;
		return this;
	},
	
	_getMeasuredHeight : function() {
		return this._measuredHeight || this._measureHeight();
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	_measureHeight : function() {
		// Sum the heights of the rows.  No variable-heights yet!!!
		if (this._rowHeight < 0) {
			// Variable Height Trigger
			var totalHeight = this._titleHeight + this._headerHeight;
			var runningHeights = [];
			var l = this._items.length;
			for (var i = 0; i < l; i++) {
				runningHeights.push(totalHeight);
				totalHeight += this._items[i]._height;
			}
			this._cellPositions = runningHeights;
			return this._measuredHeight = totalHeight;
		}
		
		delete this._cellPositions;
		return this._measuredHeight = this._titleHeight + this._headerHeight + this._rowHeight * this._items.length;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	calculateItemPositions: function() {
		// Not used?.
	}
});

ListViewSection._init = function() {
	delete ListViewSection._init;
	if (Element._init) Element._init();

	// We don't have a set pattern for sending the id of a view we want to assign by reference...
	var boundTitleFunction = function() {
		if (this.listViewMonitor) this.listViewMonitor.setTitleView(this);
		boundTitleFunction._superfunc.apply(this, Array.prototype.slice.call(arguments));
	};
	var setTitleView = function(titleView) {
		if (this._titleView && this._titleView.listViewMonitor == this) {
			delete this._titleView.listViewMonitor;
		}
		this._titleView = titleView;
		
		if (titleView.listViewMonitor != this) {
			titleView.listViewMonitor = this;
			if (!boundTitleFunction._superfunc) {
				boundTitleFunction._superfunc = titleView.setFrame;
			}
			if (titleView.setFrame != boundTitleFunction) {
				titleView.registerAccessors('frame', null, boundTitleFunction);
			}
		}
		
		this._titleHeight = titleView.getFrame()[3];
		delete this._measuredHeight;
		Commands.setTitleView.call(this, ObjectRegistry.objectToId(titleView));
		return this;
	};
	var getTitleView = function() {
		return this._titleView;
	};
	/**
	 * Set the `titleView` property, which contains the list section's title.
	 * @name UI.ListViewSection#setTitleView
	 * @function
	 * @example
	 * var listSection = new UI.ListViewSection();
	 * listSection.setTitleView("Latest Updates");
	 * @param {String} title The new section title.
	 * @returns {void}
	 * @see UI.ListViewSection#getTitleView
	 */
	/**
	 * Retrieve the value of the `titleView` property, which contains the list section's title.
	 * @name UI.ListViewSection#getTitleView
	 * @function
	 * @returns {String} The current section title.
	 * @see UI.ListViewSection#setTitleView
	 */
	ListViewSection.registerAccessors('titleView', getTitleView, setTitleView);
	
	// Other properties
	/**
	 * Set the `rowHeight` property, which contains the height, in pixels, of each row in the list
	 * section. If the section's rows will have variable heights, set the value of `rowHeight` to
	 * `-1`, and call the `{@link UI.ListViewItem#setHeight}` method to set the height of each list
	 * item in the section.
	 * @name UI.ListViewSection#setRowHeight
	 * @function
	 * @example
	 * // Set a fixed row height.
	 * var listSection = new UI.ListViewSection();
	 * listSection.setRowHeight(80);
	 * @param {Number} rowHeight The height, in pixels, of each row in the list section. To use
	 *		variable row heights, set the value to `-1`.
	 * @returns {void}
	 * @see UI.ListViewItem#setHeight
	 * @see UI.ListViewSection#getRowHeight
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `rowHeight` property, which contains the height, in pixels, of each
	 * row in the list section.
	 * @name UI.ListViewSection#getRowHeight
	 * @function
	 * @returns {Number} The height, in pixels, of each row in the list section. Set to `-1` if the
	 *		row uses variable heights.
	 * @see UI.ListViewSection#setRowHeight
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	ListViewSection.synthesizeProperty('rowHeight');
	/**
	 * Set the `items` property, which specifies a list of the `{@link UI.ListViewItem}` objects
	 * that the section contains. The new list of items will completely replace the existing list of
	 * items. If the section is visible, it will be redrawn to show the new items.
	 * @name UI.ListViewSection#setItems
	 * @function
	 * @example
	 * var listItem1 = new UI.ListViewItem(),
	 *     listItem2 = new UI.ListViewItem(),
	 *     listItem3 = new UI.ListViewItem();
	 * var listSection = new UI.ListViewSection();
	 * listSection.setItems[listItem1, listItem2, listItem3];
	 * @param {UI.ListViewItem|UI.ListViewItem[]} newItems A single `{@link UI.ListViewItem}`
	 *		object, or an array of objects, that the list section will contain.
	 * @returns {void}
	 * @see UI.ListViewSection#getItems
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	var setItems = function(newItems) {
		newItems = (newItems instanceof Array) ? newItems : Array.prototype.slice.call(arguments);
		
		this.flush();
		this._items = newItems;
		
		delete this._measuredHeight;
		if (!this._listView) return;
		this._listView.reloadData();
	};
	/**
	 * Retrieve the value of the `items` property, which specifies a list of the
	 * `{@link UI.ListViewItem}` objects that the section contains.
	 * @name UI.ListViewSection#getItems
	 * @function
	 * @returns {UI.ListViewItem[]} An array of objects that the list section currently contains.
	 * @see UI.ListViewSection#setItems
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	var getItems = function() {
		return this._items;
	};
	ListViewSection.registerAccessors('items', getItems, setItems);

	// private
	ListViewSection.synthesizeProperty('yPosition');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CellView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CellView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CellView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/CellView.js';

var View = require('NGCore/Client/UI/View').View;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var CellView = exports.CellView = View.subclass(
/** @lends UI.CellView.prototype */
{
	'type':'cell',
	/**
	 * @class The `UI.CellView` class provides cell views in an application, such as cells in a
	 * scrolling list. A `UI.CellView` object can display an image, such as an arrow, on the right
	 * side. The object also provides two vertically stacked areas that can contain a title and
	 * other text.
	 * 
	 * A `UI.CellView` object's appearance can change automatically when the cell's view state 
	 * changes. For example, the cell's fill color can change automatically when the cell is
	 * selected. To implement this feature, your application can call a `UI.CellView` setter method 
	 * more than once, passing a different value in the `flags` parameter each time. In addition, 
	 * your application can include properties for multiple view states in the constructor. See the
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.CellView#setImageGravity}` to control an
	 * image's position within the cell, the image gravity you specify will apply in all view
	 * states.
	 * @name UI.CellView
	 * @constructs Create a cell view.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.CellView object without setting any of its properties.
	 * var cell = new UI.CellView();
	 * @example
	 * // Create a new UI.CellView object, setting its title and text.
	 * var cellTitle = "Options";
	 * var cellText = "Configure the application."
	 * var cell = new UI.CellView({
	 *     title: cellTitle,
	 *     text: cellText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.CellView` object.
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (CellView._init) CellView._init();
		$super(properties);
	}
});

// Properties
CellView._init = function() {
	delete CellView._init;
	if (View._init) View._init();
	
	/**
	 * Set the `image` property, which links to an image that is displayed in the cell for a
	 * specified view state.
	 * @name UI.CellView#setImage
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setImage("./Content/cell-bg.png", UI.Commands.State.Normal |
	 *     UI.Commands.State.Focused);
	 * @param {String} image The path to the new image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image. To specify an image for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getImage
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `image` property for a specified view state.
	 * @name UI.CellView#getImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The path to the image for the specified view state.
	 * @see UI.CellView#setImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * Set the value of the `imageBorder` property, which defines a border for images in a
	 * specified view state. See `{@link UI.Style#setGradient}` for information about this
	 * property.
	 * @name UI.CellView#setImageBorder
	 * @function
	 * @example
	 * // Use a dark gray border for the image.
	 * var cell = new UI.CellView();
	 * var border = {
	 *     outerLine: "FF5F5F5F 1.0"
	 * };
	 * cell.setImageBorder(border);
	 * @param {Object} imageBorder The new image border.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this border. To specify a border for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getImageBorder
	 * @see UI.Style#setGradient
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageBorder` property, which defines a border for images in a
	 * specified view state.
	 * @name UI.CellView#getImageBorder
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current image border.
	 * @see UI.CellView#setImageBorder
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * Set the `imageInsets` property, which contains insets that are used to clip the edges of the
	 * image.
	 * @name UI.CellView#setImageInsets
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
	 * // a left inset of 5.
	 * cell.setImageInsets([10, 20, 15, 5]);
	 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the button.
	 * @returns {void}
	 * @see UI.CellView#getImageInsets
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageInsets` property, which contains insets that are used to clip
	 * the edges of the image.
	 * @name UI.CellView#getImageInsets
	 * @function
	 * @returns {Number[]} The current image insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the button.
	 * @see UI.CellView#setImageInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
	/**
	 * Set the `imageFit` property, which defines how images will be scaled relative to the cell.
	 * @name UI.CellView#setImageFit
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setImageFit(UI.Commands.FitMode.None);
	 * @param {UI.Commands#FitMode} imageFit The method that will be used to scale images relative
	 * 		to the cell.
	 * @returns {void}
	 * @see UI.CellView#getImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `imageFit` property, which defines how images will be scaled
	 * relative to the cell.
	 * @name UI.CellView#getImageFit
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setImageFit(UI.Commands.FitMode.AspectWidth);
	 * // More code here.
	 * // Later, the application takes different actions based on the
	 * // image's fit mode:
	 * var imageFitMode = cell.getImageFit();
	 * switch (imageFitMode) {
	 *     case UI.Commands.FitMode.AspectHeight:
	 *         // Your code here
	 *         break;
	 *     case UI.Commands.FitMode.AspectWidth:
	 *         // Your code here
	 *         break;
	 *     // Continue through each enumerated value that you want to test
	 *     default:
	 *         // Your code here
	 *         break;
	 * }
	 * @returns {Number} The current scaling option that will be used to scale images relative to 
	 * 		the cell. The returned value corresponds to an enumerated value of
	 *		`{@link UI.Commands#FitMode}`.
	 * @see UI.CellView#setImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizeProperty('imageFit', Commands.setImageFitMode);
	/**
	 * Set the `imageGravity` property, which defines how the image is positioned within the
	 * viewable area. By default, the image gravity is set to `[0.5, 0.5]`, which centers the image
	 * within the viewable area.
	 * 
	 * See `{@link UI.Image#setImageGravity}` for more information about this property.
	 * @name UI.CellView#setImageGravity
	 * @function
	 * @example
	 * // Position the image towards the left side of the cell and vertically centered.
	 * var cell = new UI.CellView();
	 * cell.setImageGravity([0.25, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} imageGravity The new image gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @returns {void}
	 * @see UI.CellView#getImageGravity
	 * @see UI.Image#setImageGravity
 	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#getImageGravity
	 * @function
	 * @description Retrieve the value of the `imageGravity` property.
	 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.CellView#setImageGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	 /**
	 * Set the `imageTransform` property, which defines an affine transformation of the image. See
	 * `{@link UI.Image#setImageTransform}` for more information about affine transformations.
	 * @name UI.CellView#setImageTransform
	 * @function
	 * @example
	 * // Increase an image's size by 20 units along the X axis, and move it
	 * // down 5 units along the Y axis.
	 * var cell = new UI.CellView();
	 * var scaleX = 20;
	 * var moveY = 5;
	 * cell.setImageTransform([scaleX, 0, 0, 0, 0, moveY]);
	 * @example
	 * // Rotate an image 30 degrees to the left.
	 * function degreesToRadians(degrees) {
	 *     return degrees * (Math.PI / 180);
	 * }
	 *
	 * var cell = new UI.CellView();
	 * var angle = degreesToRadians(30);
	 * cell.setImageTransform([Math.cos(angle), Math.sin(angle),
	 *     -Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @example
	 * // Skew the bottom of an image to the right by 10 units along the x axis.
	 * var cell = new UI.CellView();
	 * var skewX = 10;
	 * cell.setImageTransform([0, 0, skewX, 0, 0, 0]);
	 * @param {Number[]} imageTransform The new affine transformation. Specified as an array of
	 *		four floats: `[a, b, c, d, tx, ty]`.
	 * @returns {void}
	 * @see UI.CellView#getImageTransform
	 * @see UI.Image#setImageTransform
 	 * @status iOS, Android, Test
	 */
	/**
	 * Retrieve the value of the `imageTransform` property, which defines an affine transformation
	 * of the image.
	 * @name UI.CellView#getImageTransform
	 * @function
	 * @returns {Number[]} The current affine transformation. Specified as an array of six floats:
	 *		 `[a, b, c, d, tx, ty]`.
	 * @see UI.CellView#setImageTransform
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	 CellView.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * Retrieve the value of the `rightImage` property, which defines a path to an image to display
	 * on the right side of the cell for a specified view state.
	 * @name UI.CellView#getRightImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current path to the image that will be displayed on the right side of
	 *		the cell.
	 * @see UI.CellView#setRightImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImage` property, which defines a path to an image to display on the right side
	 * of the cell for a specified view state. For example, your application could display a right
	 * arrow, indicating that the user will proceed to a new view by touching the cell.
	 * @name UI.CellView#setRightImage
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setRightImage("./Content/right-arrow.png",
	 *     UI.Commands.State.Focused);
	 * @param {String} rightImage The path to the new image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this right image. To specify a right image for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getRightImage
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('rightImage', Commands.setRightImage);
	/**
	 * Retrieve the value of the `rightImageBorder` property, which defines a border for the image
	 * that is specified by the `rightImage` property for a specified view state.
	 * @name UI.CellView#getRightImageBorder
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The current image border for the right image.
	 * @see UI.CellView#setRightImage
	 * @see UI.CellView#setRightImageBorder
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImageBorder` property, which defines a border for the image that is specified 
	 * by the `rightImage` property for a specified view state. See `{@link UI.Style#setGradient}`
	 * for information about the `rightImageBorder` property.
	 * @name UI.CellView#setRightImageBorder
	 * @function
	 * @example
	 * // Use a dark gray border for the right image.
	 * var cell = new UI.CellView();
	 * var border = {
	 *     outerLine: "FF5F5F5F 1.0"
	 * };
	 * cell.setRightImageBorder(border);
	 * @param {Object} rightImageBorder The new image border for the right image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this right image border. To specify a right image for a view that is in multiple states,
	 * 		you can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#setRightImage
	 * @see UI.CellView#getRightImageBorder
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('rightImageBorder', Commands.setRightImageBorder);
	/**
	 * Retrieve the value of the `rightImageInsets` property, which contains insets that are used to
	 * clip the edges of the right image.
	 * @name UI.CellView#getRightImageInsets
	 * @function
	 * @returns {Number[]} The current image insets. Specified as an array of four floats, starting 
	 *		with the top inset and going clockwise around the cell.
	 * @see UI.CellView#setRightImageInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImageInsets` property, which contains insets that are used to clip the edges of
	 * the right image. The inset is specified as an array of floats, starting with the top inset
	 * and going clockwise around the cell.
	 * @name UI.CellView#setRightImageInsets
	 * @function
	 * @example
	 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
	 * // a left inset of 5.
	 * var cell = new UI.CellView();
	 * cell.setRightImageInsets([10, 20, 15, 5]);
	 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the cell.
	 * @returns {void}
	 * @see UI.CellView#getRightImageInsets
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('rightImageInsets', Commands.setRightImageInsets);
	/**
	 * Retrieve the value of the `rightImageFit` property, which defines how the right image will be
	 * scaled relative to the view.
	 * @name UI.CellView#getRightImageFit
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setRightImageFit(UI.Commands.FitMode.AspectWidth);
	 * // More code here.
	 * // Later, the application takes an action based on the image's
	 * // fit mode:
	 * var imageFitMode = cell.getImageFit();
	 * switch (imageFitMode) {
	 *     case UI.Commands.FitMode.AspectHeight:
	 *         // Your code here
	 *         break;
	 *     case UI.Commands.FitMode.AspectWidth:
	 *         // Your code here
	 *         break;
	 *     // Continue through each enumerated value that you want to test
	 *     default:
	 *         // Your code here
	 *         break;
	 * }
	 * @returns {Number} The current scaling option that will be used to scale the right image 
	 * 		relative to the view. The returned value corresponds to an enumerated value of
	 *		`{@link UI.Commands#FitMode}`.
	 * @see UI.CellView#setRightImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImageFit` property, which defines how the right image will be scaled relative
	 * to the view.
	 * @name UI.CellView#setRightImageFit
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setRightImageFit(UI.Commands.FitMode.None);
	 * @param {UI.Commands#FitMode} rightImageFit The scaling option that will be used to scale 
	 * 		the right image relative to the cell.
	 * @returns {void}
	 * @see UI.CellView#getRightImageFit
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeProperty('rightImageFit', Commands.setRightImageFitMode);
	/**
	 * Retrieve the value of the `rightImageGravity` property, which defines how the right image is
	 * positioned within the viewable area.
	 * @name UI.CellView#getRightImageGravity
	 * @function
	 * @returns {Number[]} The current image gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.CellView#setRightImageGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImageGravity` property, which defines how the right image is positioned within 
	 * the viewable area. See `{@link UI.Image#setImageGravity}` for information about this
	 * property.
	 * @name UI.CellView#setRightImageGravity
	 * @function
	 * @example
	 * // Position the right image so that it is horizontally centered and vertically
	 * // adjacent to the top edge of the cell.
	 * var cell = new UI.CellView();
	 * cell.setRightImageGravity([0.5, 0.0]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} rightImageGravity The new image gravity. Specified
	 *		as an array of two floats, where the first represents the X axis and the second
	 *		represents the Y axis. You can also specify an enumerated value of
	 *		`{@link UI.ViewGeometry#Gravity}` in place of the array.
	 * @returns {void}
	 * @see UI.CellView#getRightImageGravity
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('rightImageGravity', Commands.setRightImageGravity);
	/**
	 * Retrieve the current value of the `rightImageTransform` property, which defines an affine
	 * transformation of the right image.
	 * @name UI.CellView#getRightImageTransform
	 * @function
	 * @returns {Number[]} The current affine transformation. Specified as an array of six floats:
	 *		`[a, b, c, d, tx, ty]`.
	 * @see UI.CellView#setRightImageTransform
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `rightImageTransform` property, which defines an affine transformation of the right 
	 * image. See `{@link UI.Image#setImageTransform}` for information about this property.
	 * @name UI.CellView#setRightImageTransform
	 * @function
	 * @example 
	 * // Increase the right image's size by 20 units along the X axis, and 
	 * // move it down 5 units along the Y axis.
	 * var cell = new UI.CellView();
	 * var scaleX = 20;
	 * var moveY = 5;
	 * cell.setRightImageTransform([scaleX, 0, 0, 0, 0, moveY]);
	 * @param {Number[]} imageTransform The new affine transformation. Specified as an array of six
	 *		floats: `[a, b, c, d, tx, ty]`.
	 * @returns {void}
	 * @see UI.CellView#getRightImageTransform
	 * @see UI.Image#setImageTransform
 	 * @status iOS, Android, Test
	 */
	CellView.synthesizeCompoundProperty('rightImageTransform', Commands.setRightImageTransform);
	
	/**
	 * Set the function to call when an `imageLoaded` event occurs. This event occurs when an image
	 * that is specified for a `UI.CellView` finishes loading.
	 * @name UI.CellView#setOnImageLoaded
	 * @event
	 * @example
	 * var cellView = new UI.CellView();
	 * cellView.setOnImageLoaded(function(event) {
	 *     if (event.error) {
	 *         console.log("Unable to load image: " + e.error + " " + e.message);
	 *     } else {
	 *         console.log("Loaded the image " + event.imageUrl);
	 *         console.log("Width: " + event.width + ", height: " + event.height);
	 *     }
	 * });
	 * @cb {Function} imageLoadedCallback The function to call when an `imageLoaded` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} [event.error] A code identifying the error, if any.
	 * @cb-param {Number} [event.height] The height of the image that was loaded.
	 * @cb-param {String} event.imageUrl The URL of the image that was loaded, or that failed to
	 *		load.
	 * @cb-param {String} [event.message] A description of the error, if any.
	 * @cb-param {Number} [event.width] The width of the image that was loaded.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.CellView#event:getOnImageLoaded
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoaded` event occurs.
	 * @name UI.CellView#getOnImageLoaded
	 * @event
	 * @returns {Function} The function to call when an `imageLoad` event occurs.
	 * @see UI.CellView#event:setOnImageLoaded
	 * @since 1.6
	 */
	 CellView.registerEventType('imageLoaded'); 
		
	/**
	 * Set a function to call when an `imageLoadFailed` event occurs. This event occurs when an
	 * image that is specified for a `UI.CellView` cannot be loaded.
	 * @name UI.CellView#setOnImageLoadFailed
	 * @event
	 * @example
	 * var cellView = new UI.CellView();
	 * cellView.setOnImageLoadFailed(function(event) {
	 *     console.log("An error occurred when loading " + event.url + 
	 *         ": " + event.error + ": " + event.message);
	 * });
	 * @cb {Function} imageLoadFailedCallback The function to call when an `imageLoadFailed` event
	 *		occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} event.error A code identifying the error.
	 * @cb-param {String} event.url The URL for the image.
	 * @cb-param {String} event.message A message describing the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.CellView#event:getOnImageLoadFailed
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoadFailed` event occurs.
	 * @name UI.CellView#getOnImageLoadFailed
	 * @event
	 * @returns {Function} The current function to call when an `imageLoadFailed` event occurs.
	 * @see UI.CellView#event:setOnImageLoadFailed
	 * @since 1.6
	 */
	CellView.registerEventType('imageLoadFailed');
	
	/**
	 * Retrieve the current value of the `title` property, which defines a title for the cell in a
	 * specified view state.
	 * @name UI.CellView#getTitle
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current cell title.
	 * @see UI.CellView#setTitle
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `title` property, which defines a title for the cell in a specified view state.
	 * @name UI.CellView#setTitle
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * var cellTitle = "Configure Application";
	 * cell.setTitle(cellTitle);
	 * @param {String} title The new cell title.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this title. To specify a title for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTitle
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * Retrieve the value of the `titleColor` property, which defines the text color for the title
	 * in a specified view state.
	 * @name UI.CellView#getTitleColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current title text color, in hexidecimal RGB format.
	 * @see UI.CellView#setTitleColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleColor` property, which defines the text color for the title in a specified view
	 * state.
	 * @name UI.CellView#setTitleColor
	 * @function 
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setTitleColor("FFFFFF");
	 * @param {String} titleColor The new title text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTitleColor
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('titleColor', Commands.setTitleColor);
	/**
	 * Retrieve the value of the `titleFont` property, which defines the font that is used for the 
	 * title text in a specified view state.
	 * @name UI.CellView#getTitleFont	 
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current title text font.
	 * @see UI.CellView#setTitleFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleFont` property, which defines the font that is used for the title text in a
	 * specified view state.
	 * @name UI.CellView#setTitleFont
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setTitleFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this font. To specify a font for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTitleFont
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('titleFont', Commands.setTitleFont);
	/**
	 * Retrieve the value of the `titleShadow` property, which defines the color and size of shadows
	 * on the title text in a specified view state.
	 * @name UI.CellView#getTitleShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current title text shadow.
	 * @see UI.CellView#setTitleShadow
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleShadow` property, which defines the color and size of shadows on the title text
	 * in a specified view state. See `{@link UI.Style#setTextShadow}` for information about this
	 * property.
	 * @name UI.CellView#setTitleShadow
	 * @function
	 * @example
	 * // Set a light gray text shadow with a two-pixel blur, shifted up by one
	 * // pixel along the Y axis.
	 * var cell = new UI.CellView();
	 * cell.setTitleShadow("FFCCCCFF 2.0 {0.0, -1.0}");
	 * @param {String} titleShadow The new title text shadow, in the format specified by 
	 *		`{@link UI.Button#setTextShadow}`.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you 
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTitleShadow
	 * @see UI.Style#setTextShadow
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('titleShadow', Commands.setTitleShadow);

	/**
	 * Retrieve the value of the `titleGravity` property, which defines how the title text is
	 * positioned within the viewable area.
	 * @name UI.CellView#getTitleGravity
	 * @function
	 * @returns {Number[]} The current title text gravity. Specified as an array of two floats,
	 *		where the first represents the X axis and the second represents the Y axis.
	 * @see UI.CellView#setTitleGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleGravity` property, which defines how the title text is positioned within the
	 * viewable area. See `{@link UI.Style#setTextGravity}` for information about this property.
	 * @name UI.CellView#setTitleGravity
	 * @function
	 * @example
	 * // Position the title text so that it is horizontally centered and vertically
	 * // adjacent to the top of the cell.
	 * var cell = new UI.CellView();
	 * cell.setTitleGravity([0.5, 0.0]);	 
	 * @param {Number[]|UI.ViewGeometry#Gravity} titleGravity The new title text gravity. Specified
	 *		as an array of two floats, where the first represents the X axis and the second
	 *		represents the Y axis. You can also specify an enumerated value of
	 *		`{@link UI.ViewGeometry#Gravity}` in place of the array.
	 * @returns {void}
	 * @see UI.CellView#getTitleGravity
	 * @see UI.Style#setTextGravity
	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('titleGravity', Commands.setTitleGravity);

	/**
	 * Retrieve the value of the `titleSize` property, which specifies the size, in pixels, of the
	 * title text.
	 * @name UI.CellView#getTitleSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the title text.
	 * @see UI.CellView#setTitleSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleSize` property, which specifies the size, in pixels, of the title text.
	 * @name UI.CellView#setTitleSize
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * var textSize = 24;
	 * cell.setTitleSize(textSize);
	 * @param {Number} titleSize The new size, in pixels, of the title text.
	 * @returns {void}
	 * @see UI.CellView#getTitleSize
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeProperty('titleSize', Commands.setTitleSize);
	/**
	 * Retrieve the value of the `titleInsets` property, which contains insets that are used to clip
	 * the edges of the title text.
	 * @name UI.CellView#getTitleInsets
	 * @function
	 * @returns {Number[]} The current title text insets. Specified as an array of four floats, 
	 *		representing pixels, starting with the top inset and going clockwise around the text.
	 * @see UI.CellView#setTitleInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `titleInsets` property, which contains insets that are used to clip the edges of the
	 * title text. The inset is specified as an array of floats, representing pixels, starting with 
	 * the top inset and going clockwise around the text.
	 * @name UI.CellView#setTitleInsets
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * var insetLeft = 10;
	 * cell.setTitleInsets([0, 0, 0, insetLeft]);
	 * @param {Number[]} titleInsets The new title text insets. Specified as an array of four 
	 *		floats, representing pixels, starting with the top inset and going clockwise around the 
	 *		text.
	 * @returns {void}
	 * @see UI.CellView#getTitleInsets
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('titleInsets', Commands.setTitleInsets);
	
	/**
	 * Retrieve the value of the `text` property, which defines text for the cell in a specified
	 * view state.
	 * @name UI.CellView#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text for the cell.
	 * @see UI.CellView#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `text` property, which defines text for the cell in a specified view state.
	 * @name UI.CellView#setText
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * var cellText = "Change your configuration settings.";
	 * cell.setText(cellText);
	 * @param {String} text The new text for the cell.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getText
 	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	CellView.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the cell in
	 * a specified view state.
	 * @name UI.CellView#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color, in hexidecimal RGB format.
	 * @see UI.CellView#setTextColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textColor` property, which defines the text color for the cell in a specified view
	 * state.
	 * @name UI.CellView#setTextColor
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setTextColor("FFFFFF");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTextColor
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the button text in a specified view state.
	 * @name UI.CellView#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.CellView#setTextShadow	
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the cell text
	 * in a specified view state. See `{@link UI.Style#setTextShadow}` for information about this
	 * property.
	 * @name UI.CellView#setTextShadow
	 * @function
	 * @example
	 * // Set a white text shadow with a two-pixel blur, shifted up one pixel
	 * // along the Y axis.
	 * var cell = new UI.CellView();
	 * cell.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified by
	 *		`{@link UI.Button#setTextShadow}`.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you 
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTextShadow
	 * @see UI.Style#setTextShadow
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * cell text in a specified view state.
	 * @name UI.CellView#getTextFont
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The name of the current font.
	 * @see UI.CellView#setTextFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textFont` property, which defines the font that is used for the cell text in a
	 * specified view state.
	 * @name UI.CellView#setTextFont
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * cell.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this font. To specify a font for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CellView#getTextFont
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	/**
	 * Retrieve the value of the `textGravity` property, which defines how the cell text is
	 * positioned within the viewable area.
	 * @name UI.CellView#getTextGravity
	 * @function
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.CellView#setTextGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textGravity` property, which defines how the cell text is positioned within the
	 * viewable area. See `{@link UI.Style#setTextGravity}` for information about this property.
	 * @name UI.CellView#setTextGravity	 
	 * @function
	 * @example
	 * // Position the cell text so it is horizontally pushed towards the left edge
	 * // of the cell and vertically centered.
	 * var cell = new UI.CellView();
	 * cell.setTextGravity([0.1, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @returns {void}
	 * @see UI.CellView#getTextGravity
	 * @see UI.Style#setTextGravity
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * cell text.
	 * @name UI.CellView#getTextSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the cell text.
	 * @see UI.CellView#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the cell text.
	 * @name UI.CellView#setTextSize
	 * @function
	 * @example
	 * var cell = new UI.CellView();
	 * var textSize = 24;
	 * cell.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the cell text.
	 * @returns {void}
	 * @see UI.CellView#getTextSize
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * Retrieve the value of the `textInsets` property, which contains insets that are used to clip
	 * the edges of the cell text.
	 * @name UI.CellView#getTextInsets
	 * @function
	 * @returns {Number[]} The current text insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the button.
	 * @see UI.CellView#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textInsets` property, which contains insets that are used to clip the edges of the
	 * cell text. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the text.
	 * @name UI.CellView#setTextInsets
	 * @function
	 * @example
	 * // Add a two-pixel inset to the left and right sides of the text.
	 * var cell = new UI.CellView();
	 * cell.setTextInsets([0.0, 2.0, 0.0, 2.0]);
	 * @param {Number[]} textInsets The new text insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the button.
	 * @returns {void}
	 * @see UI.CellView#getTextInsets
 	 * @status iOS, Android, Flash, Test
	 */
	CellView.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CheckBox'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CheckBox'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CheckBox'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/CheckBox.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var WindowR = require('NGCore/Client/UI/Window');

var gradients = {
	'normal': {
		"gradient": ["FFED 0.000", "FFA4 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "FF51 2.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	},
	'pressed': {
		"innerShadow": "FF00 6.0 {0.0,-1.0}",
		"gradient": ["FF80 0.000", "FF80 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "FF51 2.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	},
	'checked': {"innerLine":"FF27A227 2.0","corners":"3.0 3.0 3.0 3.0","insets":"{4.0,4.0,4.0,4.0}","gradient":["FF2CFF2B 0.000","FF179117 1.000"],"outerShadow":"0000 0.0 {0.0,0.0}","outerLine":"FF51 3.0","innerShadow":"FF97FE97 1.0 {0.0,0.0}"},
	'checkedpressed': {"innerShadow":"FF0F610F 5.0 {0.0,-1.0}","gradient":["FF179117 0.000","FF179117 1.000"],"insets":"{4.0,4.0,4.0,4.0}","outerLine":"FF2B512B 3.0","outerShadow":"0000 0.0 {0.0,0.0}","corners":"3.0 3.0 3.0 3.0"},
	'disabled': {
		"innerShadow": "0000 0.0 {0.0,0.0}",
		"gradient": ["66B6 0.000", "66CA 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "7FE0 3.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	}
};

var CheckBox = exports.CheckBox = AbstractView.subclass(
/** @lends UI.CheckBox.prototype */
{
	'type':'checkbox',

	/**
	 * @class The `UI.CheckBox` class provides checkboxes in a user interface. The methods in this
	 * class control how checkboxes are displayed and positioned, and they provide access to the
	 * checkbox's current state.
	 * 
	 * A `UI.CheckBox` object's appearance can change automatically when the cell's view state 
	 * changes. For example, the border around a checkbox can change automatically when the checkbox
	 * gains focus or is selected. To implement this feature, your application can call a
	 * `UI.CheckBox` setter method more than once, passing a different value in the `flags`
	 * parameter each time. In addition, your application can include properties for multiple view
	 * states in the constructor. See the `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Checkbox#setImageInsets}` to control an
	 * image's insets within the checkbox, the insets you specify will apply in all view states.
	 * @name UI.CheckBox
	 * @constructs Create a checkbox.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.CheckBox object without setting any of its properties.
	 * var checkBox = new UI.CheckBox();
	 * @example
	 * // Create a new UI.CheckBox object, setting its label text.
	 * var checkBox = new UI.CheckBox({
	 *     text: "Expert Mode"
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.CheckBox` object.
	 * @since 1.0
	 */

	/** @ignore */
	initialize: function($super, properties) {
		if (CheckBox._init) CheckBox._init();
        this._checked = false;
        $super();
		this.setGradient(gradients['normal'], Commands.State.Normal);
		this.setGradient(gradients['pressed'], Commands.State.Pressed);
		this.setGradient(gradients['checked'], Commands.State.Checked);
		this.setGradient(gradients['checkedpressed'], Commands.State.Checked | Commands.State.Pressed);
		this.setGradient(gradients['disabled'], Commands.State.Disabled);
		this.setImageInsets([4,4,4,4]);
		this.setAttributes(properties);
    },
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
    performEventCallback: function($super, event) {
		if (event.eventType == 'click') {
        	this._checked = event.checked;
			if (this._checked) {
				this._state = this._state | Commands.State.Checked;
			} else {
				this._state = this._state & ~Commands.State.Checked;
			}
		}
		$super(event);
    }
});

CheckBox._init = function() {
	delete CheckBox._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * Retrieve the value of the `image` property, which links to an image that represents the 
	 * checkbox for a specified view state.
	 * @name UI.CheckBox#getImage
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The path to the checkbox image for the specified view state.
	 * @see UI.CheckBox#setImage
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `image` property, which links to an image that represents the checkbox for a
	 * specified view state.
	 * @name UI.CheckBox#setImage
	 * @example
	 * var checkBox = new UI.CheckBox();        
	 * checkBox.setImage("./Content/checkBox.png");
	 * @see UI.CheckBox#getImage
	 * @param {String} imageURL The path to the new image.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this image. To specify an image for a view that is in multiple states, you can use the 
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 * @function 
	 */
	CheckBox.synthesizePropertyWithState('image', Commands.setImage);
	CheckBox.bindPropertyState('image', 'checked', Commands.State.Checked);
	/**
	 * Retrieve the value of the `imageInsets` property, which contains insets that are used to clip
	 * the edges of the checkbox image.
	 * @name UI.CheckBox#getImageInsets
	 * @function
	 * @returns {Number[]} The current image insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the checkbox.
	 * @see UI.CheckBox#setImageInsets
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `imageInsets` property, which contains insets that are used to clip the edges of the
	 * checkbox image. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the checkbox.
	 * @name UI.CheckBox#setImageInsets
	 * @function
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * // Use a top inset of 10, a right inset of 20, a bottom inset of 15, and
	 * // a left inset of 5.
	 * checkBox.setImageInsets([10, 20, 15, 5]);
	 * @param {Number[]} imageInsets The new image insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the checkbox.
	 * @returns {void}
	 * @see UI.CheckBox#getImageInsets
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);

	/**
	 * Set the function to call when an `imageLoaded` event occurs. This event occurs when an image
	 * that is specified for a `UI.CheckBox` finishes loading.
	 * @name UI.CheckBox#setOnImageLoaded
	 * @event
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setOnImageLoaded(function(event) {
	 *     if (event.error) {
	 *         console.log("Unable to load image: " + event.error + ": " +
	 *             event.message);
	 *     } else {
	 *         console.log("Loaded an image with width=" + event.width + 
	 *         " and height=" + event.height);
	 *     }
	 * });
	 * @cb {Function} imageLoadedCallback The function to call when an `imageLoaded` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} [event.error] A code identifying the error, if any.
	 * @cb-param {Number} [event.height] The height of the image that was loaded.
	 * @cb-param {String} [event.message] A message describing the error, if any.
	 * @cb-param {Number} [event.width] The width of the image that was loaded.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.CheckBox#event:getOnImageLoaded
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoaded` event occurs.
	 * @name UI.CheckBox#getOnImageLoaded
	 * @event
	 * @returns {Function} The current function to call when an `imageLoaded` event occurs.
	 * @see UI.CheckBox#event:setOnImageLoaded
	 * @since 1.6
	 */
	CheckBox.registerEventType('imageLoaded');
	
	/**
	 * Set a function to call when an `imageLoadFailed` event occurs. This event occurs when an
	 * image that is specified for a `UI.CheckBox` cannot be loaded.
	 * @name UI.CheckBox#setOnImageLoadFailed
	 * @event
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setOnImageLoadFailed(function(event) {
	 *     console.log("An error occurred when loading " + event.url + 
	 *         ": " + event.error + ": " + event.message);
	 * });
	 * @cb {Function} imageLoadFailedCallback The function to call when an `imageLoadFailed` event
	 *		occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {UI.Commands#ResourceError} event.error A code identifying the error.
	 * @cb-param {String} event.url The URL for the image.
	 * @cb-param {String} event.message A message describing the error.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.CheckBox#event:getOnImageLoadFailed
	 * @since 1.6
	 */
	/**
	 * Retrieve the function to call when an `imageLoadFailed` event occurs.
	 * @name UI.CheckBox#getOnImageLoadFailed
	 * @event
	 * @returns {Function} The current function to call when an `imageLoadFailed` event occurs.
	 * @see UI.CheckBox#event:setOnImageLoadFailed
	 * @since 1.6
	 */
	CheckBox.registerEventType('imageLoadFailed');
	
	
	/**
	 * Retrieve the value of the `text` property, which defines text for the checkbox's label in a 
	 * specified view state.
	 * @name UI.CheckBox#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text for the checkbox's label for the specified view state.
	 * @see UI.CheckBox#setText
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `text` property, which defines text for the checkbox's label in a specified view 
	 * state.
	 * @name UI.CheckBox#setText
	 * @function
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setText("Flip screen");
	 * @param {String} text The new text for the checkbox's label.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @see UI.CheckBox#getText
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizePropertyWithState('text', Commands.setText);
	CheckBox.bindPropertyState('text', 'checked', Commands.State.Checked);
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the 
	 * checkbox's label in a specified view state.
	 * @name UI.CheckBox#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
	 *		format.
	 * @see UI.CheckBox#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textColor` property, which defines the text color for the checkbox's label in a 
	 * specified view state.
	 * @name UI.CheckBox#setTextColor
	 * @function 
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setTextColor("FFFFFF");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CheckBox#getTextColor
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizePropertyWithState('textColor', Commands.setTextColor);
	CheckBox.bindPropertyState('textColor', 'checked', Commands.State.Checked);
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the checkbox's label in a specified view state.
	 * @name UI.CheckBox#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.CheckBox#setTextShadow	
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the checkbox's 
	 * label in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0, 
	 * -1.0}"`) that contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.CheckBox#setTextShadow
	 * @function
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel
	 * // along the Y axis.
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified above.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.CheckBox#getTextShadow
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	CheckBox.bindPropertyState('textShadow', 'checked', Commands.State.Checked);
	/**
	 * Retrieve the value of the `textGravity` property, which defines how the checkbox's label is
	 * positioned within the viewable area.
	 * @name UI.CheckBox#getTextGravity
	 * @function
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.CheckBox#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textGravity` property, which defines how the checkbox label is positioned within the
	 * viewable area. The text gravity is defined as two floats, one for the X (horizontal) axis and
	 * one for the Y (vertical) axis. Each float represents a percentage of the whitespace 
	 * surrounding the text.
	 * 
	 * By default, the image gravity is set to `[0.5, 0.5]`, which centers the text within the
	 * viewable area.
	 * @name UI.CheckBox#setTextGravity
	 * @function
	 * @example
	 * // Position the checkbox label so it is horizontally pushed towards the
	 * // left side of the viewable area and vertically centered.
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setTextGravity([0.1, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @see UI.CheckBox#getTextGravity
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * checkbox label.
	 * @name UI.CheckBox#getTextSize
	 * @returns {Number} The current size, in pixels, of the checkbox label.
	 * @see UI.CheckBox#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the checkbox label.
	 * @name UI.CheckBox#setTextSize
	 * @function
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * var textSize = 12;
	 * checkBox.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the checkbox label.
	 * @see UI.CheckBox#getTextSize
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * checkbox label in a specified view state.
	 * @name UI.CheckBox#getTextFont
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The name of the current font for the specified view state.
	 * @see UI.CheckBox#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textFont` property, which defines the font that is used for the checkbox label in a
	 * specified view state.
	 * @name UI.CheckBox#setTextFont
	 * @function
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this font. To specify a font for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @see UI.CheckBox#getTextFont
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizePropertyWithState('textFont', Commands.setTextFont);
	CheckBox.bindPropertyState('textFont', 'checked', Commands.State.Checked);
	/**
	 * Retrieve the value of the `textInsets` property, which contains insets that are used to clip
	 * the edges of the checkbox label.
	 * @name UI.CheckBox#getTextInsets
	 * @function
	 * @returns {Number[]} The current text insets. Specified as an array of four floats, starting
	 *		with the top inset and going clockwise around the checkbox label.
	 * @see UI.CheckBox#setTextInsets
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textInsets` property, which contains insets that are used to clip the edges of the
	 * checkbox label. The inset is specified as an array of floats, starting with the top inset and
	 * going clockwise around the checkbox label.
	 * @name UI.CheckBox#setTextInsets
	 * @function
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * var insetLeft = 10;
	 * checkBox.setTextInsets([0, 0, 0, insetLeft]);
	 * @param {Number[]} textInsets The new text insets. Specified as an array of four floats, 
	 *		starting with the top inset and going clockwise around the button.
	 * @see UI.CheckBox#getTextInsets
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */
	CheckBox.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
	
	// Corresponding event is onClick
	/**
	 * Retrieve the value of the `checked` property, which indicates whether the checkbox is
	 * currently checked.
	 * @name UI.CheckBox#getChecked
	 * @function
	 * @returns {Boolean} Set to `true` if the checkbox is currently checked.
	 * @see UI.CheckBox#setChecked
	 * @status Javascript, iOS, Android, Flash
	 */
	/**
	 * Set the `checked` property, which indicates whether the checkbox is currently checked.
	 * @name UI.CheckBox#setChecked
	 * @function 
	 * @example
	 * var checkBox = new UI.CheckBox();
	 * checkBox.setChecked(true);
	 * @param {Boolean} checked Set to `true` if the checkbox is currently checked.
	 * @returns {void}
	 * @see UI.CheckBox#getChecked
	 * @status iOS, Android, Flash
	 */
	CheckBox.synthesizeProperty('checked', Commands.setChecked);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/EditText'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/EditText'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/EditText'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/EditText.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var EditText = exports.EditText = AbstractView.subclass(
/** @lends UI.EditText.prototype */
{
	'type':'edittext',
	/**
	 * @class The `UI.EditText` class creates single-line text fields in a user interface. The 
	 * methods in this class control how text fields are displayed and positioned, and they provide
	 * access to the user's input.
	 *
	 * A `UI.EditText` object's appearance can change automatically when its view state changes. For
	 * example, the field's text color can change automatically when the field gains focus or is
	 * selected. To implement this feature, your application can call a `UI.EditText` setter method 
	 * more than once, passing a different value in the `flags` parameter each time. In addition, 
	 * your application can include properties for multiple view states in the constructor. See the
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.EditText#setPlaceholder}` to control a
	 * field's placeholder text, the placeholder text you specify will apply in all view states.
	 *
	 * **Note**: As of version 1.6, `UI.EditText` objects no longer fire `click` events, and calling
	 * `UI.EditText.setOnClick()` will have no effect.
	 * @name UI.EditText
	 * @constructs Create a text field.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.EditText object without setting any of its properties.
	 * var textField = new UI.EditText();
	 * @example
	 * // Create a new UI.EditText object, setting its placeholder text.
	 * var placeholderText = "Email address";
	 * var textField = new UI.EditText({
	 *     placeholder: placeholderText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.EditText` object.
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (EditText._init) EditText._init();
		$super(properties);
		this.setOnClick = this.setOnClickCancel = function() {
			NgLogE("WARNING: Click and ClickCancel events do not work on EditText objects.");
		};
	},
	
	
	'InputTypes': Commands.InputType,
	'EnterKeyTypes': Commands.EnterKeyType,
	
	
	performEventCallback: function($super, event) {
		try {
			switch (event.eventType) {
				case 'change':
					this._text = event.text;
					/* falls through */
				default: $super(event);
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	
	// Adapt API to the single-state model for "text" on editable text.
	/**
	 * Retrieve the value of the `text` property, which contains the user's text input.
	 * @function
	 * @returns {String} The current text input.
	 * @see UI.EditText#setText
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */	
	getText: function() {
		return this._text || "";
	},
	
	/**
	 * Set the `text` property, which contains the user's text input. You can use this method to
	 * fill in fields whose value is already known, such as a user's name.
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * var firstName = "John";
	 * textField.setText(firstName);
	 * @param {String} text The text that the user can edit.
	 * @returns {void}
	 * @see UI.EditText#getText
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	setText: function(text) {
		this._text = text;
		Commands.setText.call(this, 0, text);
	},

	focus: function() {
		Commands.setFocus.call(this, true);
	},

	blur: function() {
		Commands.setFocus.call(this, false);
	},
	
	setFocus: function(focus) {
		try {
			throw new Error("EditText.setFocus is deprecated and should not be used. Please use .focus() and .blur().");
		} catch (e) {
			NgHandleException(e);
		}
		Commands.setFocus.call(this, focus);
	}
});

EditText._init = function() {
	delete EditText._init;
	if (AbstractView._init) AbstractView._init();
	
	// ==== Content
	// API defines state for the text property, but we ONLY support one state for this control.
	
	EditText.registerAccessors('text', EditText.prototype.getText, EditText.prototype.setText);
	
	/**
	 * Retrieve the value of the `placeholder` property, which defines text that will be displayed
	 * as a placeholder before the user types in the text field.
	 * @name UI.EditText#getPlaceholder
	 * @function
	 * @returns {String} The current placeholder text.
	 * @see UI.EditText#setPlaceholder
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `placeholder` property, which defines text that will be displayed as a placeholder
	 * before the user types in the text field.
	 * @name UI.EditText#setPlaceholder
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * var placeholderText = "Email address";
	 * textField.setPlaceholder(placeholderText);
	 * @param {String} placeholder The new placeholder text.
	 * @returns {void}
	 * @see UI.EditText#getPlaceholder
	 */
	EditText.synthesizeProperty('placeholder', Commands.setPlaceholderText);
	/**
	 * Retrieve the value of the `placeholderColor` property, which defines the text color for the
	 * placeholder text.
	 * @name UI.EditText#getPlaceholderColor
	 * @function
	 * @returns {String} The current placeholder text color, in hexidecimal RGB format.
	 * @see UI.EditText#setPlaceholderColor
	 * @status Javascript, iOS, Android, Flash, Test
	 */	
	/**
	 * Set the `placeholderColor` property, which defines the text color for the placeholder text.
	 * @name UI.EditText#setPlaceholderColor
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setPlaceholderColor("666666");
	 * @param {String} placeholderColor The new placeholder text color, in hexidecimal RGB format.
	 * @see UI.EditText#getPlaceholderColor
	 * @returns {void}
	 */
	EditText.synthesizeProperty('placeholderColor', Commands.setPlaceholderTextColor);
	/**
	 * Retrieve the value of the `placeholderShadow` property, which defines the color and size of
	 * shadows on the placeholder text.
	 * @name UI.EditText#getPlaceholderShadow
	 * @function
	 * @returns {String} The current placeholder text shadow.
	 * @see UI.EditText#setPlaceholderShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `placeholderShadow` property, which defines the color and size of shadows on the
	 * placeholder text. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0, -1.0}"`) that
	 * contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.EditText#setPlaceholderShadow
	 * @function
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
	 * var textField = new UI.EditText();
	 * textField.setPlaceholderShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} placeholderShadow The new placeholder text shadow.
	 * @see UI.EditText#getPlaceholderShadow
	 * @returns {void}
	 */
	 EditText.synthesizeProperty('placeholderShadow', Commands.setPlaceholderTextShadow);
	
	// ==== Behavior
	/**
	 * Retrieve the value of the `inputType` property, which defines the type of text input that
	 * the field will contain.
	 * @name UI.EditText#getInputType
	 * @function
	 * @returns {UI.Commands#InputType} The current input type.
	 * @see UI.EditText#setInputType
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `inputType` property, which defines the type of text input that the field will
	 * contain. For devices that have soft keyboards, the device uses this value and the value of
	 * the `enterKeyType` property to control which keyboard is displayed to the user.
	 * @name UI.EditText#setInputType
	 * @param {UI.Commands#InputType} inputType The new input type.
	 * @see UI.Commands#InputType
	 * @see UI.EditText#getInputType
	 * @function
	 * @returns {void}
	 */	
	 EditText.synthesizeProperty('inputType', Commands.setInputType);
	/**
	 * Retrieve the value of the `enterKeyType` property, which defines the Enter key's behavior for
	 * the field.
	 * @name UI.EditText#getEnterKeyType
	 * @function
	 * @returns {UI.Commands#EnterKeyType} The current behavior of the Enter key.
	 * @see UI.EditText#setEnterKeyType
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `enterKeyType` property, which defines the Enter key's behavior for the field. For 
	 * devices that have soft keyboards, the device uses this value and the value of the 
	 * `inputType` property to control which keyboard is displayed to the user.
	 * @name UI.EditText#setEnterKeyType
	 * @function
	 * @param {UI.Commands#EnterKeyType} enterKeyType The new behavior of the Enter key.
	 * @see UI.Commands#EnterKeyType
	 * @see UI.EditText#getEnterKeyType
	 * @returns {void}
	 */
	EditText.synthesizeProperty('enterKeyType', Commands.setEnterKeyType);
	
	// ==== Appearance
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the field
	 * in a specified view state.
	 * @name UI.EditText#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
	 *		format.
	 * @see UI.EditText#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textColor` property, which defines the text color for the button in a specified view
	 * state.
	 * @name UI.EditText#setTextColor
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setTextColor("FFFFFF");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @see UI.EditText#getTextColor
	 * @returns {void}
	 * @status iOS, Flash, Test
	 */
	EditText.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the user's text input in a specified view state.
	 * @name UI.EditText#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.EditText#setTextShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the user's text
	 * input in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0,
	 * -1.0}"`) that contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.EditText#setTextShadow
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
	 * var textField = new UI.EditText();
	 * textField.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified above.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @see UI.EditText#getTextShadow
	 * @returns {void}
	 * @status iOS, Flash, Test
	 * @function
	 */
	EditText.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * Retrieve the value of the `textGravity` property, which defines how text is positioned within
	 * the field.
	 * @name UI.EditText#getTextGravity
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.EditText#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * Set the `textGravity` property, which defines how text is positioned within the field. The
	 * text gravity is defined as two floats, one for the X (horizontal) axis and one for the Y
	 * (vertical) axis. Each float represents a percentage of the whitespace surrounding the text.
	 * 
	 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
	 * text, with the remainder placed to the right of the text. For the Y axis, the specified 
	 * percentage of whitespace will be placed above the text, with the remainder placed below the
	 * text.
	 * 
	 * By default, the text gravity is set to `[0.0, 0.5]`, which positions the text adjacent to
	 * the left side of the field and vertically centers the text.
	 * @name UI.EditText#setTextGravity
	 * @example
	 * // Set the text to be horizontally and vertically centered
	 * var textField = new UI.EditText();
	 * textField.setTextGravity([0.5, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @see UI.EditText#getTextGravity
     * @status Flash
	 * @function
	 * @returns {void}
	 */
	EditText.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * field's text.
	 * @name UI.EditText#getTextSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the field's text.
	 * @see UI.EditText#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the field's text.
	 * @name UI.EditText#setTextSize
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * var textSize = 12;
	 * textField.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the field's text.
	 * @returns {void}
	 * @see UI.EditText#getTextSize
	 * @status iOS, Flash, Test
	 */
	EditText.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * field's text.
	 * @name UI.EditText#getTextFont
	 * @function
	 * @returns {String} The name of the current font.
	 * @see UI.EditText#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textFont` property, which defines the font that is used for the field's text.
	 * @name UI.EditText#setTextFont
	 * @function
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @see UI.EditText#getTextFont
	 * @returns {void}
	 * @status iOS, Flash, Test
	 */
	EditText.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	// ==== Events
	/**
	 * Retrieve the function to call when a `change` event occurs. This event occurs when the user
	 * changes the value of the text field.
	 * @name UI.EditText#getOnChange
	 * @event
	 * @returns {Function} The current function to call when a `change` event occurs.
	 * @see UI.EditText#event:setOnChange
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set a function to call when a `change` event occurs. This event occurs when the user changes
	 * the value of the text field.
	 * @name UI.EditText#setOnChange
	 * @event
	 * @example
	 * var textField = new UI.EditText();
	 * var text = "";
	 * textField.setOnChange(function(event) { 
	 *     text = event.text;
	 * });
	 * @cb {Function} changeCallback The function to call when a `change` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.text The new value of the text field.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.EditText#event:getOnChange
	 * @status iOS, Flash
	 */
	EditText.registerEventType('change');
	/**
	 * Retrieve the function to call when a `focus` event occurs. This event occurs when the text
	 * field gains focus.
	 * @name UI.EditText#getOnFocus 
	 * @event	 
	 * @returns {Function} The current function to call when a `focus` event occurs.
	 * @see UI.EditText#event:setOnFocus
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the function to call when a `focus` event occurs. This event occurs when the text
	 * field gains focus.
	 * @name UI.EditText#setOnFocus
	 * @event
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setOnFocus(function() {
	 *     textField.addState(UI.Commands.State.Focused);
	 * });
	 * @cb {Function} focusCallback The function to call when a `focus` event occurs.
	 * @cb-returns {void}
	 * @see UI.EditText#event:getOnFocus
	 * @status Flash
	 * @returns {void}
	 */
	EditText.registerEventType('focus');
	/**
	 * Retrieve the function to call when a `blur` event occurs. This event occurs when the text
	 * field loses focus.
	 *
	 * **Note**: This event is not guaranteed to occur on Android devices.
	 * @name UI.EditText#getOnBlur
	 * @event
	 * @returns {Function} The current function to call when a `blur` event occurs.
	 * @see UI.EditText#event:setOnBlur
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the function to call when a `blur` event occurs. This event occurs when the text field
	 * loses focus.
	 *
	 * **Note**: This event is not guaranteed to occur on Android devices.
	 * @name UI.EditText#setOnBlur
	 * @event
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setOnBlur(function() {
	 *     textField.clearState(UI.Commands.State.Focused);
	 * });
	 * @cb {Function} blurCallback The current function to call when a `blur` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.EditText#event:getOnBlur
	 */
	EditText.registerEventType('blur');

	/**
	 * Retrieve the function to call when an `action` event occurs. This event occurs when the user
	 * presses the Return or Enter key.
	 * 
	 * **Note**: This event is not guaranteed to occur on Android devices.
	 * @name UI.EditText#getOnAction
	 * @event
	 * @returns {Function} The current function to call when an `action` event occurs.
	 * @see UI.EditText#event:setOnAction
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the function to call when an `action` event occurs. This event occurs when the user
	 * presses the Return or Enter key.
	 * 
	 * **Note**: This event is not guaranteed to occur on Android devices.
	 * @name UI.EditText#setOnAction
	 * @event
	 * @example
	 * var textField = new UI.EditText();
	 * textField.setOnAction(function() {
	 *     console.log("The user pressed the Return key.");
	 * });
	 * @cb {Function} actionCallback The function to call when an `action` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.EditText#event:getOnAction
	 * @since 1.1.6
	 */
	EditText.registerEventType('action');
	
	

};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/EditTextArea'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/EditTextArea'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/EditTextArea'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/EditTextArea.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var EditTextArea = exports.EditTextArea = AbstractView.subclass(
/** @lends UI.EditTextArea.prototype */
{
	'type':'edittextarea',
	/**
	 * @class The `UI.EditTextArea` class provides multi-line text areas in a user interface. The 
	 * methods in this class control how text areas are displayed and positioned, and they provide
	 * access to the user's input.
	 * 
	 * A `UI.EditTextArea` object's appearance can change automatically when its view state changes. 
	 * For example, the border around a text area can change automatically when the text area gains 
	 * focus or is selected. To implement this feature, your application can call a
	 * `UI.EditTextArea` setter method more than once, passing a different value in the `flags`
	 * parameter each time. In addition, your application can include properties for multiple view
	 * states in the constructor. See the `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.EditTextArea#setPlaceholder}` to set the
	 * text area's placeholder text, the placeholder text you specify will apply in all view states.
	 * @name UI.EditTextArea
	 * @constructs Create a text area.
	 * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.EditTextArea object without setting any of its properties.
	 * var textArea = new UI.EditTextArea();
	 * @example
	 * // Create a new UI.EditTextArea object, setting its placeholder text.
	 * var placeholderText = "Write your message here";
	 * var textArea = new UI.EditTextArea({
	 *     placeholder: placeholderText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.EditTextArea` object.
	 * @since 1.1.1.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (EditTextArea._init) EditTextArea._init();
		$super(properties);
	},
	
	
	performEventCallback: function($super, event) {
		try {
			switch (event.eventType) {
				case 'change':
					this._text = event.text;
					$super(event);
					break;
				case 'focus':
				case 'blur':
					$super(event);
					break;
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	
	// Adapt API to the single-state model for "text" on editable text.
	/**
	 * Retrieve the value of the `text` property, which contains the user's text input.
	 * @function
	 * @returns {String} The current text input.
	 * @see UI.EditTextArea#setText
	 * @status Javascript, iOS, Flash
	 * @since 1.1.1.2
	 */	
	getText: function() {
		return this._text || "";
	},
	
	/**
	 * Set the `text` property, which contains the user's text input. You can use this method to
	 * fill in a text area when its value is already known. For example, you can call this method
	 * when a user is updating previously entered text.
	 * @function
	 * @example
	 * var previousText = "This game is my favorite!";
	 * var textArea = new UI.EditTextArea();
	 * textArea.setText(previousText);
	 * @param {String} text The text that the user can edit.
	 * @returns {void}
	 * @see UI.EditTextArea#getText
	 * @status Javascript, iOS, Flash
	 * @since 1.1.1.2
	 */
	setText: function(text) {
		this._text = text;
		Commands.setText.call(this, 0, text);
	},

	focus: function() {
		Commands.setFocus.call(this, true);
	},

	blur: function() {
		Commands.setFocus.call(this, false);
	}
});

EditTextArea._init = function() {
	delete EditTextArea._init;
	if (AbstractView._init) AbstractView._init();
	
	// ==== Content
	// API defines state for the text property, but we ONLY support one state for this control.
	
	EditTextArea.registerAccessors('text', EditTextArea.prototype.getText, EditTextArea.prototype.setText);
	
	/**
	 * Retrieve the value of the `placeholder` property, which defines text that will be displayed
	 * as a placeholder before the user types in the text area.
	 * @name UI.EditTextArea#getPlaceholder
	 * @function
	 * @returns {String} The current placeholder text.
	 * @see UI.EditTextArea#setPlaceholder
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `placeholder` property, which defines text that will be displayed as a placeholder
	 * before the user types in the text area.
	 * @name UI.EditTextArea#setPlaceholder
	 * @function
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setPlaceholder("Write your message here");
	 * @param {String} placeholder The new placeholder text.
	 * @see UI.EditTextArea#getPlaceholder
	 * @returns {void}
	 */
	EditTextArea.synthesizeProperty('placeholder', Commands.setPlaceholderText);
	/**
	 * Retrieve the value of the `placeholderColor` property, which defines the text color for the
	 * placeholder text.
	 * @name UI.EditTextArea#getPlaceholderColor
	 * @function
	 * @returns {String} The current placeholder text color, in hexidecimal RGB format.
	 * @see UI.EditTextArea#setPlaceholderColor
	 * @status Javascript, iOS, Android, Flash, Test
	 */	
	/**
	 * Set the `placeholderColor` property, which defines the text color for the placeholder text.
	 * @name UI.EditTextArea#setPlaceholderColor
	 * @function
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setPlaceholderColor("666666");
	 * @param {String} placeholderColor The new placeholder text color, in hexidecimal RGB format.
	 * @see UI.EditTextArea#getPlaceholderColor
	 * @returns {void}
	 */
	EditTextArea.synthesizeProperty('placeholderColor', Commands.setPlaceholderTextColor);
	/**
	 * Retrieve the value of the `placeholderShadow` property, which defines the color and size of
	 * shadows on the placeholder text.
	 * @name UI.EditTextArea#getPlaceholderShadow
	 * @function
	 * @returns {String} The current placeholder text shadow.
	 * @see UI.EditTextArea#setPlaceholderShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `placeholderShadow` property, which defines the color and size of shadows on the
	 * placeholder text. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0, -1.0}"`) that
	 * contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.EditTextArea#setPlaceholderShadow
	 * @function
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
	 * var textArea = new UI.EditTextArea();
	 * textArea.setPlaceholderShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} placeholderShadow The new placeholder text shadow.
	 * @see UI.EditTextArea#getPlaceholderShadow
	 * @returns {void}
	 */
	 EditTextArea.synthesizeProperty('placeholderShadow', Commands.setPlaceholderTextShadow);
	
	
	// ==== Appearance
	/**
	 * Retrieve the value of the `textColor` property, which defines the text color for the text
	 * area in a specified view state.
	 * @name UI.EditTextArea#getTextColor
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text color for the specified view state, in hexidecimal RGB
	 *		format.
	 * @see UI.EditTextArea#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textColor` property, which defines the text color for the text area in a specified
	 * view state.
	 * @name UI.EditTextArea#setTextColor
	 * @function
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setTextColor("FFFFFF");
	 * @param {String} textColor The new text color, in hexidecimal RGB format.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text color. To specify a text color for a view that is in multiple states, you can 
	 * 		use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.EditTextArea#getTextColor
	 * @status iOS, Flash, Test
	 */
	EditTextArea.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * Retrieve the value of the `textShadow` property, which defines the color and size of shadows
	 * on the user's text input in a specified view state.
	 * @name UI.EditTextArea#getTextShadow
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text shadow.
	 * @see UI.EditTextArea#setTextShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textShadow` property, which defines the color and size of shadows on the user's text
	 * input in a specified view state. Specified as a string (for example, `"FFFFFFFF 2.0 {0.0,
	 * -1.0}"`) that contains three values separated by spaces:
	 * 
	 * 1. A color in hexidecimal ARGB format (the alpha value followed by the RGB color).
	 * 2. The width, in pixels, to blur the edges of the shadow.
	 * 3. Two comma-separated floats enclosed in brackets:
	 *     1. The shadow's X offset from the left, in pixels.
	 *     2. The shadow's Y offset from the top, in pixels.
	 * @name UI.EditTextArea#setTextShadow
	 * @function
	 * @example
	 * // Use a white text shadow with a two-pixel blur, shifted up one pixel.
	 * var textArea = new UI.EditTextArea();
	 * textArea.setTextShadow("FFFFFFFF 2.0 {0.0, -1.0}");
	 * @param {String} textShadow The new text shadow, in the format specified above.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text shadow. To specify a text shadow for a view that is in multiple states, you  
	 * 		can use the `|` operator to combine multiple flags.
	 * @see UI.EditTextArea#getTextShadow
	 * @status iOS, Flash, Test
	 */
	EditTextArea.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * Retrieve the value of the `textGravity` property, which defines how text is positioned within
	 * the text area.
	 * @name UI.EditTextArea#getTextGravity
	 * @function
	 * @returns {Number[]} The current text gravity. Specified as an array of two floats, where the
	 *		first represents the X axis and the second represents the Y axis.
	 * @see UI.EditTextArea#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textGravity` property, which defines how text is positioned within the text area. 
	 * The text gravity is defined as two floats, one for the X (horizontal) axis and one for the Y
	 * (vertical) axis. Each float represents a percentage of the whitespace surrounding the text.
	 * 
	 * For the X axis, the specified percentage of whitespace will be placed to the left of the 
	 * text, with the remainder placed to the right of the text. For the Y axis, the specified 
	 * percentage of whitespace will be placed above the text, with the remainder placed below the
	 * text.
	 * 
	 * By default, the text gravity is set to `[0.0, 0.0]`, which positions the text at the top
	 * left corner of the text area.
	 * @name UI.EditTextArea#setTextGravity
	 * @function
	 * @example
	 * // Set the text to be centered within the text area.
	 * var textArea = new UI.EditTextArea();
	 * textArea.setTextGravity([0.5, 0.5]);
	 * @param {Number[]|UI.ViewGeometry#Gravity} textGravity The new text gravity. Specified as an 
	 *		array of two floats, where the first represents the X axis and the second represents the
	 *		Y axis. You can also specify an enumerated value of `{@link UI.ViewGeometry#Gravity}` in
	 *		place of the array.
	 * @see UI.EditTextArea#getTextGravity
	 * @returns {void}
     * @status Flash
	 */
	EditTextArea.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * Retrieve the value of the `textSize` property, which specifies the size, in pixels, of the
	 * text area's text.
	 * @name UI.EditTextArea#getTextSize
	 * @function
	 * @returns {Number} The current size, in pixels, of the text area's text.
	 * @see UI.EditTextArea#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textSize` property, which specifies the size, in pixels, of the field's text.
	 * @name UI.EditTextArea#setTextSize
	 * @function
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * var textSize = 12;
	 * textArea.setTextSize(textSize);
	 * @param {Number} textSize The new size, in pixels, of the text area's text.
	 * @returns {void}
	 * @see UI.EditTextArea#getTextSize
	 * @status iOS, Flash, Test
	 */
	EditTextArea.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * Retrieve the value of the `textFont` property, which defines the font that is used for the
	 * text area's text.
	 * @name UI.EditTextArea#getTextFont
	 * @function
	 * @returns {String} The name of the current font.
	 * @see UI.EditTextArea#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the `textFont` property, which defines the font that is used for the text area's text.
	 * @name UI.EditTextArea#setTextFont
	 * @function
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setTextFont("DroidSans");
	 * @param {String} textFont The name of the new font.
	 * @returns {void}
	 * @see UI.EditTextArea#getTextFont
	 * @status iOS, Flash, Test
	 */
	EditTextArea.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	// ==== Events
	/**
	 * Retrieve the function to call when a `change` event occurs. This event occurs when the user
	 * changes the value of the text area.
	 * @name UI.EditTextArea#getOnChange
	 * @event
	 * @returns {Function} The current function to call when a `change` event occurs.
	 * @see UI.EditTextArea#event:setOnChange
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set a function to call when a `change` event occurs. This event occurs when the user changes
	 * the value of the text area.
	 * @name UI.EditTextArea#setOnChange
	 * @event
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setOnChange(function(event) { 
	 *     console.log(event.text);
	 * });
	 * @cb {Function} changeCallback The function to call when a `change` event occurs.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {String} event.text The new value of the text area.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.EditTextArea#event:getOnChange
	 * @status iOS, Flash
	 */
	EditTextArea.registerEventType('change');
	/**
	 * Retrieve the function to call when a `focus` event occurs. This event occurs when the text
	 * area gains focus.
	 * @name UI.EditTextArea#getOnFocus 
	 * @event	 
	 * @returns {Function} The current function to call when a `focus` event occurs.
	 * @see UI.EditTextArea#event:setOnFocus
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the function to call when a `focus` event occurs. This event occurs when the text
	 * area gains focus.
	 * @name UI.EditTextArea#setOnFocus
	 * @event
	 * @example
	 * var textArea = new UI.EditText();
	 * textArea.setOnFocus(function() {
	 *     textArea.addState(UI.Commands.State.Focused);
	 * });
	 * @cb {Function} focusCallback The function to call when a `focus` event occurs.
	 * @cb-returns {void}
	 * @status Flash
	 * @returns {void}
	 * @see UI.EditTextArea#event:getOnFocus
	 */
	EditTextArea.registerEventType('focus');
	/**
	 * Retrieve the function to call when a `blur` event occurs. This event occurs when the text
	 * area loses focus.
	 * @name UI.EditTextArea#getOnBlur
	 * @event
	 * @returns {Function} The current function to call when a `blur` event occurs.
	 * @see UI.EditTextArea#event:setOnBlur
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Set the function to call when a `blur` event occurs. This event occurs when the text area
	 * loses focus.
	 * @name UI.EditTextArea#setOnBlur
	 * @event
	 * @example
	 * var textArea = new UI.EditTextArea();
	 * textArea.setOnBlur(function() {
	 *     textArea.clearState(UI.Commands.State.Focused);
	 * });
	 * @cb {Function} blurCallback The current function to call when a `blur` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.EditTextArea#event:getOnBlur
	 */
	EditTextArea.registerEventType('blur');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/DateField'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/DateField'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/DateField'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/DateField.js';

var EditText = require('NGCore/Client/UI/EditText').EditText;

function isValidDate(d) {
	if ( !d || !d.getTime )
		return false; 
		
	return !isNaN(d.getTime());
}

/*
 Date Parser code to handle WebKit's lack of following the implementation.
 http://stackoverflow.com/questions/3085937/safari-js-cannot-parse-yyyy-mm-dd-date-format/3085993#3085993
 */
function parseDate(input, format) {
  format = format || 'yyyy-mm-dd'; // default format
  var parts = input.match(/(\d+)/g), 
      i = 0, fmt = {};
  if (parts === null) { //Don't throw exceptions if the input isn't parsable
	return null;
  }
  // extract date-part indexes from the format
  format.replace(/(yyyy|dd|mm)/g, function(part) { fmt[part] = i++;});
  return new Date(parts[fmt['yyyy']], parts[fmt['mm']]-1, parts[fmt['dd']]);
}
/*
 * Our Code is not actually passing its format to parseDate (already had all the code to rejigger the date pieces to yyyy-mm-dd before I realized the problems with webkit's date constructor / date string parser). -fbartho 2010-11-30
 */

exports.DateField = EditText.subclass(
/** @lends UI.DateField.prototype */
{
	classname: "DateField",
	/**
	 * @class The `UI.DateField` class creates text entry fields for dates. The user's input is 
	 * normalized to a format specified by the application. By default, the date is normalized to
	 * the format `yyyy-mm-dd`, where `yyyy` is the four-digit year, `mm` is the two-digit month, 
	 * and `dd` is the two-digit day. 
	 * @name UI.DateField
	 * @augments UI.EditText
	 * @constructs Create a date field.
	 * @example
	 * // Create a new UI.DateField object without setting any of its properties.
	 * var dateField = new UI.DateField();
	 * @example
	 * // Create a new UI.DateField object, setting the date format and text color.
	 * var dateField = new UI.DateField({
	 *     dateFormat: "mm-dd-yyyy",
	 *     textColor: "CCCCCC"
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.DateField` object. See `{@link UI.EditText}` for information about properties that
	 *		are supported.
	 * @since 1.0
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		var constructorRVal = $super(properties);
		this.setDateFormat("yyyy-mm-dd");
		this.ondatechange = function(newDate){};
		
		this.setInputType(EditText.InputTypes.Date);
		return constructorRVal;
	},
    
	/**
	 * Trigger an event callback for this `DateField`.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} event The event that triggers a callback function.
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	performEventCallback: function($super, event) {
		try {
			if (event.eventType == 'change') {
				// Make Sure the Text is changed (call $super), before we call our listeners!
				var oldText = this.getText();
				$super(event);
				this.ondatechange(this.getDate());
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	_filterAndInsertDashes:function(oldText,newText) {
		var t = newText;
		if((oldText.length == t.length + 1) && oldText[oldText.length-1] == "-") {
			//This lets the user backspace through - marks as if they weren't there.
			// fbartho: Currently not in use! 2010-12-10
			//this.setText(t.substring(0,t.length-1));
			return t.substring(0,t.length-1);
		}
		
		var nt = "";
		var j = 0;
		for(var i = 0; i < t.length && nt.length < this.formatStr.length; i++,j++) {
			if(j < this.formatStr.length && this.formatStr[j] == "-" && i < t.length){
				if(t[i] == "-"|| t[i] == "/"){
					nt+="-";
					continue;
				}
				else {
					nt+="-";
					nt+=t[i];
					continue;
				}
			}
			if ( i < t.length && (t[i] == "-" || t[i] == "/") ) {
				--j; 
				continue;
			}
			nt+=t[i];
		}
		
		if(this.formatStr.length > j && (this.formatStr[j] == "-" || this.formatStr[j] == "/") ) {
			nt+="-";
		}
		
		return nt;
	},
	/**
	 * Normalize the format of the user's text input, converting forward slashes to dashes.
	 * @returns {void}
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */    
	normalizeDateLayout:function() {
		var ot = this.getText();
		var nt = this._filterAndInsertDashes(this.getText(),this.getText());
		if(ot!=nt)this.setText(nt);
	},
	/**
	 * Retrieve the current date format that will be used to normalize the user's input.
	 * @returns {String} The current date format that will be used to normalize the user's input.
	 * @see UI.DateField#setDateFormat
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	getDateFormat:function() {
		return this.formatStr;
	},
	/**
	 * Set the date format that will be used to normalize the user's input. Valid values include
	 * the following, where `mm` is the two-digit month, `dd` is the two-digit day, and `yyyy` is
	 * the four-digit year:
	 * 
	 * + `yyyy-mm-dd`
	 * + `mm-yyyy`
	 * + `yyyy-mm`
	 * + `mm-dd-yyyy`
	 * + `dd-mm-yyyy`
	 * @param {String} dateFormat The new date format that will be used to normalize the user's
	 *		input.
	 * @returns {void}
	 * @see UI.DateField#getDateFormat
	 * @status Javascript, iOS, Android, Flash, Test
	 * @since 1.0
	 */
	setDateFormat:function(fStr) 
	{
		if (   fStr != "yyyy-mm-dd"
			&& fStr != "mm-yyyy"
			&& fStr != "yyyy-mm"
			&& fStr != "mm-dd-yyyy"
			&& fStr != "dd-mm-yyyy" ) {
			// Invalid Format String Error Case
			NgLogD("Error: Invalid Format String set for Birthdate Field!!\n");
			
			return;
		}
		
		this.formatStr = fStr;
		this.setPlaceholder(this.formatStr);
		return;
	},
	/**
	 * Retrieve the user's input, normalized to the date field's current date format.
	 * @returns {String} The user's text input, normalized to the current date format for this
	 *		text field.
	 * @status Javascript, iOS, Android, Flash, Test
	 * @see UI.DateField#setDateFormat
	 * @since 1.0
	 */
	getDate:function() {
		return this._dateFromText(this._filterAndInsertDashes(this.getText(),this.getText()));
	}, 
	_dateFromText:function(text) 
	{
		var tmp = null;
		var t = text;
		var bits = null;
		var b2 = null;
		if ( this.formatStr == "dd-mm-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 3 || bits[2].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.pop());
			b2.push(bits.pop());
			tmp = parseDate(b2.join("-"));
		} else if ( this.formatStr == "mm-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 2 || bits[1].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.pop());
			b2.push("01");
			var tStr = b2.join("-");
			
			tmp = parseDate(tStr);
		} else if ( this.formatStr == "yyyy-mm" ) {
			bits = t.split("-");
			if(bits.length != 2 || bits[0].length != 4)
				return null;
			
			tmp = parseDate(t+"-01");
		} else if ( this.formatStr == "mm-dd-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 3 || bits[2].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.shift());
			b2.push(bits.shift());
			tmp = parseDate(b2.join("-"));
		} else {
			tmp = parseDate(t);
		}
		
		if(!isValidDate(tmp)) {
			NgLogD("Failed to parse date: "+text+"   -  "+tmp+"\n");
			return null;
		}
		return tmp;
	}
});

//TODO: make a proper DatePicker?
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ProgressDialog'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ProgressDialog'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ProgressDialog'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ProgressDialog.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var ProgressDialog = exports.ProgressDialog = Element.subclass(
/** @lends UI.ProgressDialog.prototype */
{
	'type':'progressdialog',

    /**
	 * @name UI.ProgressDialog
     * @class The `UI.ProgressDialog` class displays progress updates from an application. This
	 * class is typically used in combination with `{@link UI.ProgressBar}`.
	 *
 	 * A `UI.ProgressDialog` object's appearance can change automatically when its view state 
	 * changes. For example, the text in the dialog can change when the dialog is disabled. To 
	 * implement this feature, your application can call a `UI.ProgressDialog` setter method more 
	 * than once, passing a different value in the `flags` parameter each time. In addition, your 
	 * application can include properties for multiple view states in the constructor. See the 
	 * `{@link UI}` module overview for more information.
     * @constructs Create a progress dialog.
     * @augments UI.Element
	 * @example
	 * // Create a new UI.ProgressDialog object without setting any of its properties.
	 * var dialog = new UI.ProgressDialog();
	 * @example
	 * // Create a new UI.ProgressDialog object, setting its title and text.
	 * var dialogTitle = "Please Wait";
	 * var dialogText = "Loading images...";
	 * var dialog = new UI.ProgressDialog({
	 *     title: dialogTitle,
	 *     text: dialogText
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new 
	 *		`UI.ProgressDialog` object.
     * @since 1.0
     */

	/** @ignore */
    initialize: function($super, properties) {
		if (ProgressDialog._init) ProgressDialog._init();
        return $super(properties);
    },
	/**
	 * Show the progress dialog.
	 * @function
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */    
    show: Commands.show,
	/**
	 * Hide the progress dialog.
	 * @function
	 * @returns {void}
	 * @status iOS, Android, Flash, Test
	 */    
    hide: Commands.hide
});

ProgressDialog._init = function() {
	delete ProgressDialog._init;
	if (Element._init) Element._init();
	
	/**
	 * Set the `title` property, which defines the progress dialog's title for a specified view
	 * state.
	 * @name UI.ProgressDialog#setTitle
	 * @function
	 * @example
	 * var dialog = new UI.ProgressDialog();
	 * dialog.setTitle("Please Wait");
	 * @param {String} title The title for the progress dialog.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this title. To specify a title for a view that is in multiple states, you can use the
	 * 		`|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.ProgressDialog#getTitle
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `title` property, which defines the progress dialog's title for a
	 * specified view state.
	 * @name UI.ProgressDialog#getTitle
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current title.
	 * @see UI.ProgressDialog#setTitle
	 * @status iOS, Android, Flash, Test
	 */
	ProgressDialog.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * Set the `text` property, which defines the progress dialog's text for a specified view state.
	 * @name UI.ProgressDialog#setText
	 * @function
	 * @example
	 * var dialog = new UI.ProgressDialog();
	 * var text = "Loading images...";
	 * dialog.setText(text);
	 * @param {String} text The text for the progress dialog.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.ProgressDialog#getText
	 * @status iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `text` property, which defines the progress dialog's text for a
	 * specified view state.
	 * @name UI.ProgressDialog#getText
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text for the progress dialog.
	 * @see UI.ProgressDialog#setText
	 * @status iOS, Android, Flash, Test
	 */
	ProgressDialog.synthesizePropertyWithState('text', Commands.setText);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Toast'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Toast'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Toast'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Toast.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Toast = exports.Toast = Element.subclass(
/** @lends UI.Toast.prototype */
{	
    'type': 'toast',
    /**
	 * @class The `UI.Toast` class creates temporary messages on the device's screen. On Android
	 * devices, these messages slide up from the bottom of the screen. On iOS devices, these 
	 * messages slide down from the top of the screen.
	 *
	 * A `UI.Toast` object's appearance can change automatically when its view state changes. For
	 * example, the toast's text can change automatically when the temporary message gains focus or
	 * is selected. To implement this feature, your application can call a single `UI.Toast` method
	 * more than once, passing a different value in the `flags` parameter each time. In addition,
	 * your application can include properties for multiple view states in the constructor. See the
	 * `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.Toast#event:setOnDisappear}` to provide a 
	 * callback function for the `disappear` event, the callback function you specify will apply in 
	 * all view states.
	 * @name UI.Toast
	 * @constructs Create a temporary message.
	 * @augments UI.View
	 * @example
	 * // Create a temporary message without specifying any properties.
	 * var toast = new UI.Toast();
	 * @example
	 * // Create a temporary message, setting the text that will appear in the
	 * // message.
	 * var toast = new UI.Toast({
	 *     text: "Update complete";
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new `UI.Toast`
	 *		object.
	 * @since 1.0.2
	 */

	/** @ignore */
	initialize: function($super, properties) {
		if (Toast._init) Toast._init();
		$super(properties);
	},
	
	/** 
	 * Show the temporary message.
	 * @function
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
    show: Commands.show
});

Toast._init = function() {
	delete Toast._init;
	if (Element._init) Element._init();

	/**
	 * Set the `text` property, which defines the temporary message's text for a specified view
	 * state.
	 * @name UI.Toast#setText
	 * @function
	 * @example
	 * var toast = new UI.Toast();
	 * toast.setText("Update complete");
	 * @param {String} text The new text for the temporary message.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this text. To specify text for a view that is in multiple states, you can use the `|`
	 * 		operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.Toast#getText
	 * @status iOS, Android, Flash, Test, FlashTested
	 */
	/**
	 * Retrieve the value of the `text` property, which defines the temporary message's text for a
	 * specified view state.
	 * @name UI.Toast#getText
	 * @function	 
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {String} The current text for the temporary message.
	 * @see UI.Toast#setText
	 * @status iOS, Android, Flash, Test
	 */
	Toast.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * Set a function to call when a `disappear` event occurs. This event occurs when a temporary
	 * message is removed from the screen.
	 * @name UI.Toast#setOnDisappear
	 * @event
	 * @example
	 * // Destroy the temporary message after it disappears.
	 * var toast = new UI.Toast();
	 * toast.setOnDisappear(function() {
	 *     toast.destroy();
	 * });
	 * @cb {Function} disappearCallback The function to call when a `disappear` event occurs.
	 * @cb-returns {void}
	 * @returns {void}
	 * @see UI.Toast#event:getOnDisappear
	 */
	/**
	 * Retrieve the function to call when a `disappear` event occurs.
	 * @name UI.Toast#getOnDisappear
	 * @event
	 * @returns {Function} The current callback function.
	 * @see UI.Toast#event:setOnDisappear
	 * @status Flash, Test, FlashTested
	 */
	Toast.registerEventType('disappear');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Spinner'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Spinner'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Spinner'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Spinner.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Spinner = exports.Spinner = AbstractView.subclass(
/** @lends UI.Spinner.prototype */
{
	'type':'spinner',
	
	/**
	 * @class The `UI.Spinner` class creates spinning activity indicators in a user interface.
	 * @name UI.Spinner
	 * @constructs Create a spinning activity indicator.
	 * @augments UI.AbstractView
	 * @since 1.0.6
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (Spinner._init) Spinner._init();
		return $super(properties);
	}
});

Spinner._init = function() {
	delete Spinner._init;
	if (AbstractView._init) AbstractView._init();
	
	Spinner.synthesizeProperty('darkStyle', Commands.setDarkStyle);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ProgressBar'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ProgressBar'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ProgressBar'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/ProgressBar.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var WindowR = require('NGCore/Client/UI/Window');

var ProgressBar = exports.ProgressBar = AbstractView.subclass(
/** @lends UI.ProgressBar.prototype */
{
	'type':'progressbar',

    /**
     * @class The `UI.ProgressBar` class creates horizontal progress bars. To update the progress
	 * bar, your application must call the `{@link UI.ProgressBar#setProgress}` method.
	 *
	 * A progress bar has a primary gradient and a secondary gradient. This enables you to create a
	 * progress bar that shows two progress states at once. For example, you could create a progress
	 * bar that shows a user's current position in a game level as well as the position of the next
	 * save point.
	 *
	 * A `UI.ProgressBar` object's appearance can change automatically when its view state changes. 
	 * For example, the progress bar's outline or fill can change automatically when the progress
	 * bar gains focus or is selected. To implement this feature, your application can call a
	 * `UI.ProgressBar` setter method more than once, passing a different value in the `flags`
	 * parameter each time. In addition, your application can include properties for multiple view
	 * states in the constructor. See the `{@link UI}` module overview for more information.
	 * 
	 * **Note**: Some of this class' methods do not allow you to set different properties for each
	 * view state. For example, when you use `{@link UI.ProgressBar#setProgress}` to control the
	 * amount of progress that is shown, this amount of progress will apply in all view states.
	 * @name UI.ProgressBar
     * @constructs Create a progress bar.
     * @augments UI.AbstractView
	 * @example
	 * // Create a new UI.ProgressBar object without setting any of its properties.
	 * var progressBar = new UI.ProgressBar();
	 * @example
	 * // Create a new UI.ProgressBar object, setting its progress amount.
	 * var progressAmount = 0.1;
	 * var progressBar = new UI.ProgressBar({
	 *     progress: progressAmount
	 * });
	 * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.ProgressBar` object.
     * @since 1.0
     */

	/** @ignore */
    initialize: function($super, properties) {
		if (ProgressBar._init) ProgressBar._init();
        return $super(properties);
    },

	useForUpdateProgress: Commands.useForUpdateProgress
});

ProgressBar._init = function() {
	delete ProgressBar._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * Retrieve the value of the `progressGradient` property, which defines the outlines, shadows,
	 * rounded corners, and gradient fills that are currently applied to the progress indicator for
	 * the specified view state.
	 * @name UI.ProgressBar#getProgressGradient
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The progress bar's appearance for the specified view state.
	 * @see UI.ProgressBar#setProgressGradient
	 * @status Javascript, Android
	 */
	/**
	 * Set the `progressGradient` property, which defines the outlines, shadows, rounded corners, 
	 * and gradient fills that are applied to the progress indicator for the specified view state. 
	 * See `{@link UI.Style#setGradient}` for information about this property.
	 * @name UI.ProgressBar#setProgressGradient
	 * @function
	 * @example
	 * // Set a gradient that has rounded corners with an eight-pixel radius; a
	 * // black outer border; and a gradient fill that fades from gray to 
	 * // light gray.
	 * var progressBar = new UI.ProgressBar();
	 * progressBar.setProgressGradient({
	 *     corners: "8 8 8 8",
	 *     outerLine: "FF000000 1.5",
	 *     gradient: ["FF888888 0.0", "FFE4E4E4 1.0"]
	 * });
	 * @param {Object} gradient The new appearance for the progress bar.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this appearance. To specify the appearance for a view that is in multiple states, you
	 * 		can use the `|` operator to combine multiple flags.
	 * @see UI.ProgressBar#getProgressGradient
	 * @returns {void}
	 * @status Android
	 */
	ProgressBar.synthesizePropertyWithState('progressGradient', Commands.setProgressGradient);
	/**
	 * Retrieve the value of the `secondaryGradient` property, which defines the outlines, shadows, 
	 * rounded corners, and gradient fills that are currently applied to the secondary progress 
	 * indicator for the specified view state. See `{@link UI.Style#setGradient}` for information
	 * about this property.
	 * @name UI.ProgressBar#getSecondaryGradient
	 * @function
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The specified view state.
	 * @returns {Object} The progress bar's secondary gradient for the specified view state.
	 * @see UI.SecondaryBar#setSecondaryGradient
	 * @status Javascript, Android
	 */
	/**
	 * Set the `secondaryGradient` property, which defines the outlines, shadows, rounded corners,
	 * and gradient fills that are applied to the secondary progress indicator for the specified 
	 * view state. See `{@link UI.Style#setGradient}` for information about this property.
	 * @name UI.ProgressBar#setSecondaryGradient
	 * @function 
	 * @example
	 * // Set a gradient that has rounded corners with an eight-pixel radius; a
	 * // black outer border; and a gradient fill that fades from gray to 
	 * // light gray.
	 * var progressBar = new UI.ProgressBar();
	 * progressBar.setSecondaryGradient({
	 *     corners: "8 8 8 8",
	 *     outerLine: "FF000000 1.5",
	 *     gradient: ["FF888888 0.0", "FFE4E4E4 1.0"]
	 * });
	 * @param {Object} gradient The new secondary gradient for the progress bar.
	 * @param {UI.Commands#State} [flags=UI.Commands.State.Normal] The view state in which to use
	 *		this secondary gradient. To specify the secondary gradient for a view that is in 
	 * 		multiple states, you can use the `|` operator to combine multiple flags.
	 * @returns {void}
	 * @see UI.SecondaryBar#getSecondaryGradient
	 * @see UI.Style#setGradient
	 * @status Android
	 */
	ProgressBar.synthesizePropertyWithState('secondaryGradient', Commands.setSecondaryGradient);
	
	var setProgressGuarded = function(arg0) {
		var args = (arg0 instanceof Array) ? arg0 : Array.prototype.slice.call(arguments);
		while (args.length < 2) args.push(0);
		Commands.setProgress.apply(this, args);
	};
	/**
	 * Retrieve the value of the `progress` and `secondaryProgress` properties, which indicate the
	 * amount of progress that is displayed on the primary and secondary progress bars.
	 * @name UI.ProgressBar#getProgress
	 * @function
	 * @returns {Number[]} The current progress and secondary progress amounts. Specified as an
	 *		array of two floats, where the first represents the progress amount and the second
	 *		represents the secondary progress amount.
	 * @see UI.ProgressBar#setProgress
	 * @status Javascript, Android
	 */
	/**
	 * Set the `progress` and `secondaryProgress` properties, which indicate the amount of progress
	 * that is displayed on the primary and secondary progress bars. Each property is specified as 
	 * a float ranging from 0.0, which represents 0% complete, to 1.0, which represents 100%
	 * complete.
	 * @name UI.ProgressBar#setProgress
	 * @function
	 * @param {Number[]|Number} arg0 An array of two floats, where the first represents the progress
	 *		amount and the second represents the secondary progress amount. Both floats can range
	 *		from 0.0 to 1.0. You can also pass these values in as separate parameters. If you omit
	 *		the secondary progress amount, it will default to 0.
	 * @returns {void}
	 * @see UI.ProgressBar#getProgress
	 * @status Javascript, Android
	 */
	ProgressBar.synthesizeCompoundProperty('progress', setProgressGuarded);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// UI diagnostic emitter; collects info from UI subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////
    
//
// Create and export a DiagnosticEmitter for UI.  
//

exports.Diagnostics = Core.DiagnosticEmitter.singleton(
{
    classname: 'UI_Diagnostics',

    /**
     * @class the <code>UI.Diagnostics</code> class constructs a singleton object
     * to obtain detailed UI diagnostic information from.
     *
     * The emitter currently emits an object of the form:
     * 
     <code>
        {
	    "name":"UI",                      // Emitter name, 'UI'				          
	}  
     </code>
     * @since 1.7.5
     */
    initialize: function($super) 
    {
	$super('UI');
    }

});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AdView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AdView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AdView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/AdView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

/** @private */
var AdView = exports.AdView = AbstractView.subclass(
{
	'type':'adview',

	/**
	 * @class The <code>AdView</code> class constructs objects that handle event callback functions and ad event metadata.
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @param {String} properties
	 * @augments UI.AbstractView
	 * @deprecated As of version 1.6, this class is no longer supported. It will be removed in a
	 *		future version.
	 * @since 1.0
	 */
	initialize: function($super, properties) {
		if (AdView._init) AdView._init();
		$super(properties);
		
		this.onappear = this.bind(this._onappear);
		this.ondisappear = this.bind(this._ondisappear);
		this.onclick = this.bind(this._onclick);
	},
	
	/**
	 * An event for signaling when an <code>AdView</code> is on display.
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 * @since 1.0
	 */
	onappear: function() {
	 },
	
	/**
	 * An event for signaling when an <code>AdView</code> has been closed.
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 * @since 1.0
	 */
	ondisappear: function() { 
	},
	
	/**
	 * @protected
	 * @since 1.0
	 */
	_onappear: function($super, event) {
		( $super || function(){} )(event);
//		Core.Analytics._getPipe().revenueEvent("ADSHOW",  this.getAdEventMetadata());
	},
	
	/**
	 * @protected
	 * @since 1.0
	 */
	_ondisappear: function($super, event) {
		( $super || function(){} )(event);
//		Core.Analytics._getPipe().revenueEvent("ADCLOSE", this.getAdEventMetadata());
	},
	
	performEventCallback: function($super, event) {
		if (event.eventType == 'click')
		{
//			Core.Analytics._getPipe().revenueEvent("ADCLCK", this.getAdEventMetadata());
			NgLogD("AD WAS CLICKED in AdView wooo!!!!");
			( $super || function(){} )(event);
		}
		if (event.eventType == 'load')
		{
//			Core.Analytics._getPipe().revenueEvent("ADLOAD", this.getAdEventMetadata());
			NgLogD("AD WAS LOADED in AdView wooo!!!!");
			( $super || function(){} )(event);
		}
	},
	/**
	* Pause this <code>AdView</code>.<br /><br />
	* <b>Note:</b> If an <code>AdView</code> is already paused, this call does nothing.
	* @see UI.AdView#resumeAds
	* @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	* @status Android
	* @since 1.0
	*/
	pauseAds: function() {
		Commands.pauseAds.call(this);
	},
	/**
	* Resume this <code>AdView</code> from a paused state. Setting this will resume the <code>AdView</code> from the current position.
	* @see UI.AdView#resumeAds
	* @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	* @status Android
	* @since 1.0
	*/
	resumeAds: function() {
		Commands.resumeAds.call(this);
	},
	/**
	* Set the refresh rate for this <code>AdView</code>. 
	* @param {Number} refreshRate The amount of time each ad is on display (in milliseconds).
	* @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	* @status Android
	* @since 1.0
	*/
	setRefreshRate: function(refreshRate) {
		Commands.setAdRefreshRate.call(this, refreshRate);
	},
	/**
	* Set this <code>AdView</code> to automatically play.
	* @status Android
	* @param {Boolean} autoplay Set as <code>true</code> if autoplay is enabled.
	* @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	* @since 1.0
	*/
	setAutoplay: function(autoplay) {
		Commands.setAdRefreshRate.call(this, autoplay);
	},
	
	/**
	 * Retrieve event metadata from this <code>AdView</code>. 
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 * @since 1.0
	 */
	getAdEventMetadata: function(){
		NgLogD("AD EventMetetData was requested!");
		var AdMeteData = "DefaultAdEventMetaData";
		return AdMeteData;
	}
});

// Event Handlers
AdView._init = function() {
	delete AdView._init;
	if (AbstractView._init) AbstractView._init();

    /**
	 * @name UI.AdView#getActive
	 * @description Retrieve the value of the <code>active</code> property.
	 * @returns {Boolean} Returns <code>true</code> if the <code>AdView</code> object is set to active.
	 * @see UI.AdView#setActive
	 * @status iOS, Android, Flash, Test
	 * @function
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 */
	AdView.synthesizeProperty('active', Commands.setActive);
    
	/**
	 * @name UI.AdView#setOnClick
	 * @description Set a function to call on <code>click</code> events.	 
	 * @param {Function} clickCallback The new <code>click</code> callback function. <br /><br />
	 * <b>Note:</b> The <code>click</code> event is disabled if the value for this parameter is not a function.<br />
	 * @see UI.AdView#event:setOnClick
 	 * @status Android, Test
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 */
	/**
	 * @name UI.AdView#getOnClick
	 * @description Retrieve the function to call on <code>click</code> events.<br />
	 * @see UI.AdView#event:getOnClick
	 * @returns {Function} The current <code>click</code> callback function.<br />
 	 * @status Android, Test
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 */
	AdView.registerEventType('click');
	/**
	 * @name UI.AdView#setOnLoad
	 * @description Set a function to call on <code>load</code> events.	 
	 * @param {Function} loadCallback The new <code>load</code> callback function. <br /><br />
	 * <b>Note:</b> The <code>load</code> event is disabled if the value for this parameter is not a function.<br />
	 * @see UI.AdView#event:getOnClick
 	 * @status Android, Test
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 */
	/**
	 * @name UI.AdView#getOnLoad
	 * @description Retrieve the function to call on <code>load</code> events.<br />
	 * @see UI.AdView#event:getOnClick
	 * @returns {Function} The current <code>load</code> callback function.<br />
 	 * @status Android, Test
	 * @event
	 * @deprecated Since version 1.6. The UI.AdView class will be removed in a future version.
	 */
	AdView.registerEventType('load');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/DocumentView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/DocumentView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/DocumentView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/DocumentView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var DocumentView = exports.DocumentView = AbstractView.subclass(
/** @lends UI.DocumentView.prototype */
{
	'type':'documentview',
	/**
	 * @class The `UI.DocumentView` class is used to display local HTML files.
	 * @name UI.DocumentView
	 * @constructs Create a document view.
	 * @augments UI.AbstractView
	 * @deprecated As of version 1.6, this class is no longer supported. It will be removed in a
	 *		future version.
     * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.DocumentView` object.
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (DocumentView._init) DocumentView._init();
		$super(properties);
	}
});

// Properties
DocumentView._init = function() {
	delete DocumentView._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * Set the `documentURL` property, which specifies the URL to load.
	 * @name UI.DocumentView#setDocumentURL
	 * @function
	 * @deprecated Since version 1.6. The UI.DocumentView class will be removed in a future
	 *		version.
	 * @param {String} documentURL The new document URL.
	 * @returns {void}
	 * @see UI.DocumentView#getDocumentURL
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * Retrieve the value of the `documentURL` property, which specifies the URL to load.
	 * @name UI.DocumentView#getDocumentURL
	 * @function
	 * @deprecated Since version 1.6. The UI.DocumentView class will be removed in a future
	 *		version.
	 * @returns {String} The current document URL.
	 * @see UI.DocumentView#setDocumentURL
	 * @status iOS, Android, Flash, Test
	 */
	DocumentView.synthesizeProperty('documentURL', Commands.setSourceDocument);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CheckoutView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CheckoutView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CheckoutView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/CheckoutView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var Commands = require('NGCore/Client/UI/Commands').Commands;

var CheckoutView = exports.CheckoutView = AbstractView.subclass(
/** @lends UI.CheckoutView.prototype */
{
	'type':'checkoutview',
	/**
	 * @class The `UI.CheckoutView` class is used to support in-app payments.
	 * @name UI.CheckoutView
     * @constructs Create a checkout view.
	 * @augments UI.AbstractView
	 * @deprecated As of version 1.6, this class is no longer supported. It will be removed in a
	 *		future version.
     * @param {Object} [properties] An object whose properties will be added to the new
	 *		`UI.CheckoutView` object.
	 * @since 1.0.2
	 */
	
	/** @ignore */
	initialize: function($super, properties) {
		if (CheckoutView._init) CheckoutView._init();
		$super(properties);
	}
});

// Properties
CheckoutView._init = function() {
	delete CheckoutView._init;
	if (AbstractView._init) AbstractView._init();
	
	// THESE ARE METHODS NOT PROPERTIES... THIS SHOULD BE FIXED.
	// We define ONLY setters, and no getters (write-only props, no local copies)
	/**
	 * Set the post data for the checkout view.
	 * @name UI.CheckoutView#setPostData
	 * @function
	 * @deprecated Since version 1.6. The UI.CheckoutView class will be removed in a future
	 *		version.
	 * @param {String} postData The new post data for the checkout view.
	 * @returns {void}
	 * @status Android
	 */
	CheckoutView.registerAccessors('postData', null, Commands.setPostData);
	/**
	 * Set the URL to use for an HTTP `POST` request.
	 * @name UI.CheckoutView#setPostURL
	 * @function
	 * @deprecated Since version 1.6. The UI.CheckoutView class will be removed in a future
	 *		version.
	 * @param {String} postURL The URL to use.
	 * @returns {void}
	 * @status Android
	 */
	CheckoutView.registerAccessors('postURL', null, Commands.loadPostURL);
	/**
	 * Set the URL to use for an HTTP `GET` request.
	 * @name UI.CheckoutView#setGetURL
	 * @function
	 * @deprecated Since version 1.6. The UI.CheckoutView class will be removed in a future
	 *		version.
	 * @param {String} getURL The URL to load.
	 * @returns {void}
	 * @status Android
	 */
	CheckoutView.registerAccessors('getURL', null, Commands.loadGetURL);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/MapAnnotation'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/MapAnnotation'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/MapAnnotation'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/MapAnnotation.js';

var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var MapAnnotation = exports.MapAnnotation = Element.subclass(
/** @lends UI.MapAnnotation.prototype */
{
	'type':'mapannotation',
	/**
	* @class <code>MapAnnotation</code>
	* @name UI.MapAnnotation
	* @augments Core.Class
	* @since 1.1.1.2
	*/
	initialize: function($super, properties) {
		return $super(properties);
	},

	setCalloutLeftView: function(view)
	{
		this._calloutLeftView = view;
		Commands.setCalloutLeftView.call(this, view.__objectRegistryId);
	},

	getCalloutLeftView: function()
	{
		return this._calloutLeftView;
	},

	setCalloutRightView: function(view)
	{
		this._calloutRightView = view;
		Commands.setCalloutRightView.call(this, view.__objectRegistryId);
	},

	getCalloutRightView: function()
	{
		return this._calloutRightView;
	},

	setView: function(view)
	{
		this._view = view;
		Commands.setView.call(this, view.__objectRegistryId);
	},

	getView: function()
	{
		return this._view;
	},

	setImage: function(image)
	{
		console.log("WARNING : MapAnnotation.setImage has been deprecated. Use MapAnnotation.setView instead.");
		var iV = new UI.Image();
		iV.setImage(image);
		iV.setFrame([0, 0, 40, 40]);
		this.setView(iV);
	},

	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		$super(e);
	}
});

// Properties
(function() {

	MapAnnotation.synthesizeCompoundProperty('coordinate', Commands.setCoordinate);
	
	MapAnnotation.synthesizeCompoundProperty('centerOffset', Commands.setCenterOffset);
	
	MapAnnotation.synthesizeProperty('calloutTitle', Commands.setCalloutTitle);

	MapAnnotation.synthesizeProperty('calloutSubtitle', Commands.setCalloutSubtitle);
	
	MapAnnotation.synthesizeProperty('calloutEnabled', Commands.setCalloutEnabled);

	MapAnnotation.registerEventType('select');
	MapAnnotation.registerEventType('deselect');
})();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/MapView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/MapView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/MapView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/MapView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var MapAnnotation = require('NGCore/Client/UI/MapAnnotation').MapAnnotation;

var MapView = exports.MapView = AbstractView.subclass(
/** @lends UI.MapView.prototype */
{
	'type':'mapview',
	/**
	* @class <code>MapView</code>
	* @name UI.MapView
	* @augments UI.View
	* @since 1.1.1.2
	*/
	initialize: function($super, properties) {
		this._annotations = [];
		this._region = [];
		return $super(properties);
	},
	
	getCenterCoordinate: function()
	{
		return [this._region[0], this._region[1]];
	},
    
    setCenterCoordinate: function(lat, lon, animated)
    {
        this._region[0] = lat;
        this._region[1] = lon;
        if (!this._region[2])
            this._region[2] = 0.05;
        if (!this._region[3])
            this._region[3] = 0.05;            
        this.setRegion(this._region[0], this._region[1], this._region[2], this._region[3], animated);
    },
	
	getCoordinateSpan: function()
	{
		return [this._region[2], this._region[3]];
	},	
	
	selectAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			var index = this._annotations.indexOf(annotation);
			if (index != -1) {
				Commands.selectAnnotation.call(this, annotation.__objectRegistryId);
				return;
			}
		}
		Commands.selectAnnotation.call(this, -1);
	},
	
	addAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			this._annotations.push(annotation);
			
			Commands.addAnnotation.call(this, annotation.__objectRegistryId);
			
		} else throw {message: this.type + ".addAnnotation: " + annotation + " is not a MapAnnotation!"};
		return this;
	},
	
	removeAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			// Remove this node from parent's child list
			var index = this._annotations.indexOf(annotation);
			if (index != -1) {
				this._annotations.splice(index, 1);
			}
			
			// Remove from the parent at the system level
			Commands.removeAnnotation.call(this, annotation.__objectRegistryId);
		} else throw {message: this.type + ".removeAnnotation: " + annotation + " is not a MapAnnotation!"};
		return annotation;
	},
	
	/**
	 * @private
	 */    
	updateRegionFits: function(lat, lon ,latD , lonD) {
		//console.log(lat + " " + lon + " " + latD + " " + lonD);
		//console.log(this._region[0] + " " + this._region[1] + " " + this._region[2] + " " + this._region[3]);
		this._region[0] = lat;
		this._region[1] = lon;
		this._region[2] = latD;
		this._region[3] = lonD;
	},
	
	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		if (e.eventType == 'regionchange') this.updateRegionFits(e.latitude, e.longitude , e.latitudeDelta , e.longitudeDelta);
		$super(e);
	}
});

// Properties
(function() {
	MapView.synthesizeProperty('scrollable', Commands.setScrollable);
	
	MapView.synthesizeProperty('zoomable', Commands.setZoomable);
	
	MapView.synthesizeCompoundProperty('region', Commands.setRegion);
	
	MapView.registerEventType('regionchange');
})();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/_CutSceneView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/_CutSceneView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/_CutSceneView'] = exports; 
var __dirname = 'NGCore/Client/UI';
var __filename = 'NGCore/Client/UI/_CutSceneView.js';

var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var CutSceneView = exports.CutSceneView = AbstractView.subclass(
/** @lends UI.CutSceneView.prototype */
{
	'type':'_cutsceneview',
	
	/**
	* @class The <code>CutSceneView</code> class constructs objects that handle menu CutSceneViews in a user interface. 
	* @name UI.CutSceneView
	* @augments UI.AbstractView
	*/
	initialize: function($super, properties) {
		if (CutSceneView._init) CutSceneView._init();
		return $super(properties);
	},
	
	play: function(url, callbackFn) {
		var cbId = (typeof callbackFn == 'function')
			? Commands.registerTemporaryCallback(callbackFn.bind(this))
			: "";
		Commands.playVideo.call(this, url, cbId);
	}
});

CutSceneView._init = function() {
	delete CutSceneView._init;
	if (AbstractView._init) AbstractView._init();
	
	// No init for this class
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI'] || {}; $MODULE_REGISTRY['NGCore/Client/UI'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/UI.js';

var UILoader = function(map) {
	// Internal function to define isolated-scope getters.
	var loadFn = function(object, key, fn) {
		return function() {
			delete object[key];
			return object[key] = fn.call(this);
		};
	};

	for (var key in map) {
		if (typeof map[key] == 'function') {
			this.__defineGetter__(key, loadFn(this, key, map[key]));
		} else {
			this[key] = map[key];
		}
	}
};

/**
 * @name UI
 * @namespace Provide user interface components such as buttons, text fields, and web views.
 * @description
 * The `UI` module provides access to user interface (UI) components. You can use the `UI` module's
 * classes to create all of the following types of UI components:
 *
 * + Alert dialogs (`{@link UI.AlertDialog}`)
 * + Checkboxes (`{@link UI.CheckBox}`)
 * + Date fields (`{@link UI.DateField}`)
 * + Images (`{@link UI.Image}`)
 * + Progress bars (`{@link UI.ProgressBar}`)
 * + Progress dialogs (`{@link UI.ProgressDialog}`)
 * + Progress indicators (`{@link UI.Spinner}`)
 * + Rectangles that help to position UI components (`{@link UI.ViewGeometry}`,
 * `{@link UI.ViewGeometry.Rect}`, `{@link UI.ViewGeometry.Scale}`)
 * + Scrolling lists (`{@link UI.ListView}`, `{@link UI.ListViewItem}`,
 * `{@link UI.ListViewSection}`, `{@link UI.ScrollView}`)
 * + Table cells (`{@link UI.CellView}`)
 * + Temporary messages (`{@link UI.Toast}`)
 * + Text fields, single-line and multi-line (`{@link UI.EditText}`, `{@link UI.EditTextArea}`)
 * + Text labels (`{@link UI.Label}`)
 * + Web views (`{@link UI.WebView}`)
 *
 * The `UI` module also provides the `{@link UI.View}` class, which enables you to group UI
 * components into views. You can then use the `{@link UI.NavController}` class to navigate between
 * views based on user input. In addition, you can use the `{@link UI.Style}` class to create a set
 * of style properties that can be reused by multiple UI components.
 *
 * Finally, the `UI` module provides several static functions that enable you to:
 *
 * + Animate changes to a `UI` object's properties (`{@link UI.animate}`)
 * + Capture a screenshot from the device (`{@link UI.takeScreenshot}`)
 * + Choose a photo from the user's camera roll, or take a new photo using the device's camera
 * (`{@link UI.choosePhoto}`, `{@link UI.choosePhotoCamera}`)
 * + Combine multiple images into a single file (`{@link UI.compositeImages}`)
 * + Measure the dimensions of a text string (`{@link UI.measureText}`)
 *
 * ## UI and GL2 Modules ##
 * The `UI` module includes the `{@link UI.GLView}` class, which provides applications with access
 * to OpenGL. Applications should not attempt to display `UI` and `GL2` objects at the same time,
 * with the sole exception of `{@link UI.GLView}` objects. Displaying other `UI` objects at the same
 * time as `GL2` objects can result in poor performance.
 * 
 * If your application needs to combine UI components and other graphics on the same screen, 
 * consider using the ngGo toolkit. Its `GLUI` module reimplements the `UI` module in OpenGL, 
 * enabling you to combine UI components with other graphics. Although `GLUI` does not support all
 * of the `UI` module's styling options, it offers enough flexibility for many applications.  You
 * can download ngGo from the Downloads section on the
 * [Mobage Developer Portal](https://developer.mobage.com/).
 *
 * ## Handling Events ##
 * Classes in the `UI` module are event-driven. For example, each instance of a `UI` class can fire
 * events when the user makes a selection, or when the UI component appears or disappears. Your
 * application processes these events by defining a callback function for each one. The callback
 * function can then take an action such as processing the user's input, destroying the UI
 * component, or moving to a different view.
 *
 * To determine which events a component supports, review the Events section of the class'
 * documentation. The documentation also explains which parameters are passed to the callback
 * function for each type of event.
 *
 * **Note**: An event will not fire unless you define a callback function to handle the event.
 *
 * ## Styling UI Components ##
 * Each UI component supports a variety of style properties that manage the component's contents and
 * appearance. For example, you can use these style properties to add fills, borders, and rounded 
 * corners to a UI component, or to add images and text to a component.
 * 
 * To determine which style properties a component supports, review the getter and setter methods 
 * the component's class. For example, the `{@link UI.Toast}` class provides one setter method,
 * `{@link UI.Toast#setText}`, which provides access to the style property `text`.
 *
 * **Note**: If you need to access a large number of style properties at once, you can streamline
 * your code by using the component's `setAttributes()` and `getAttributes()` methods, which are
 * inherited from `{@link UI.AbstractView}`. In addition, you can set an object's style properties
 * when you instantiate the object, avoiding the need for separate method calls.
 *
 * ## Managing View States ##
 * The `UI` module defines a collection of view states, which you can use to manage the appearance
 * of UI components based on their state. For example, you can define different styles for a
 * `{@link UI.CheckBox}` object based on whether it is disabled, checked, or pressed. You can also
 * define styles for a component that is in multiple states at once, such as a `{@link UI.CheckBox}`
 * object that is both pressed and checked. In addition, you can define custom view states for your
 * application. See `{@link UI.Commands#State}` for details about the view states that are
 * supported.
 * 
 * There are several ways to specify unique style properties for a specific view state:
 * 
 * 1. Call the setter method for each property, and include the `flags` parameter to define which
 * view states will use the specified style.
 * 2. Define style properties for multiple view states when you instantiate the UI component.
 * To define a style property for a view state, add the name of the view state to the beginning of 
 * the property name, and capitalize the property name. For example, to specify an image border for
 * a UI component that has focus, pass the `focusedImageBorder` property to the constructor. This 
 * approach is supported only for the `normal`, `focused`, `selected`, `pressed`, and `disabled` 
 * view states. To specify a style property for a custom view state, or for a component that is in
 * multiple states, you must use the component's setter methods.
 * 3. Define style properties for multiple view states when you create a `{@link UI.Style}` object.
 * You can define a style property for a view state as described above.
 * 
 * ## Reusing Style Properties for Multiple Objects ##
 * If your application will use the same appearance for multiple objects, create a
 * `{@link UI.Style}` object that defines the style properties for those objects. You can then call
 * the objects' `setStyle()` and `getStyle()` methods to manage the objects' styles, or you can pass
 * the `UI.Style` object in the `style` property of the object's constructor. By using `UI.Style`
 * objects, you reduce the amount of communication between JavaScript and native code, which can 
 * significantly improve your application's performance.
 *
 * In some cases, your application may include two UI components whose style differs only slightly.
 * You can assign a single `UI.Style` object to both of these components, then override the
 * `UI.Style` object's style properties by applying style properties directly to the UI component.
 */

UILoader.prototype = {
/** @lends UI.prototype */

	/**
	 * Animate changes to the `alpha`, `frame`, and `scrollPosition` properties of one or more UI
	 * components. This method also animates the addition and removal of child views.
	 *
	 * To animate a set of changes, you must define a function that actually changes the properties.
	 * You then pass this function to `UI.animate()` in the `action` parameter.
	 *
	 * **Note**: If a UI component is currently being animated, do not animate additional changes to
	 * the component's properties.
	 * @name UI.animate
	 * @function
	 * @static
	 * @example
	 * // Fade in a string of text.
	 * var textProperties = {
	 *     alpha: 0.0,
	 *     text: "Sample text",
	 *     textSize: 24,
	 *     textColor: "000000",
	 *     textFont: "Arial"
	 * };
	 * var label = new UI.Label(textProperties);
	 * var windowSize = [Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight()];
	 * var textDimensions = UI.measureText(textProperties.text, windowSize[0],
	 *   windowSize[1], textProperties.textFont, textProperties.textSize, 
	 *   function(dimensions) {
	 *     // Center the label within the window.
	 *     var xOrigin = (windowSize[0] / 2) - (dimensions.width / 2);
	 *     var yOrigin = (windowSize[1] / 2) - (dimensions.height / 2);
	 *     label.setFrame([xOrigin, yOrigin, dimensions.width, dimensions.height]);
	 *     // Add the label to UI.Window.document.
	 *     UI.Window.document.addChild(label);
	 *     // Animate the change to the label's alpha property, fading the label in
	 *     // over 2 seconds.
	 *     UI.animate(function() {
	 *         label.setAlpha(1.0);
	 *     }, 2000, function(event) {
	 *         console.log("It is " + event.canceled + " that the animation was " +
	 *           "canceled.");
	 *     });
	 * });
	 * @param {Function} action A function that sets the property or properties to be animated.
	 *		This function can change the properties of any number of UI components.
	 * @param {Number} duration The time over which to animate the changes, in milliseconds.
	 * @cb {Function} onCompletion The function to call after the animation ends.
	 * @cb-param {Object} event Information about the event.
	 * @cb-param {Boolean} event.canceled Set to `true` if the animation was canceled.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.0
	 */
    animate: function() { return this.Commands.animate.apply(this,Array.prototype.slice.call(arguments)); },

    /**
	 * Combine multiple images into a single image, and write the single image to the device's
	 * file system.
	 * 
	 * By default, the image is saved in PNG format. To use JPEG format, specify a filename with the
	 * extension .jpg.
	 * @name UI.compositeImages
	 * @function
	 * @static
	 * @example
	 * // Replace the right side of an existing 200 x 200 pixel image, and save
	 * // the new image file to the device's storage.
	 * var filename = "example.png";
	 * var images = [
	 *     {
	 *         image: "./Content/background.png",
	 *         rect: [0, 0, 200, 200]
	 *     },
	 *     {
	 *         image: "./Content/new-right-side.png",
	 *         rect: [100, 0, 100, 100]
	 *     }
	 * ];
	 * UI.compositeImages(200, 200, filename, images, function(data) {
	 *     if (data.error) {
	 *         console.log("Unable to create composite image: " + data.error);
	 *     } else {
	 *         // Update the filename.
	 *         filename = data.filename;
	 *     }
	 * });
	 * @param {Number} w The width, in pixels, of the new image.
	 * @param {Number} h The height, in pixels, of the new image.
	 * @param {String} filename The preferred filename for the new image. Use the extension .jpg to
	 *		save the file in JPEG format. By default, the file is saved in PNG format. **Note**: The
	 *		file may be saved using a different name. Use the callback function to identify the 
	 *		file's actual name.
	 * @param {Object[]} infoArray An array of objects that identify the images to be composited.
	 * @param {UI.Commands#FitMode} [infoArray[].fit=UI.Commands.FitMode.Inside] The image fit mode
	 *		to use when scaling the existing image.
	 * @param {Number[]|UI.ViewGeometry#Gravity} [infoArray[].gravity=[0.5, 0.5]] The image gravity
	 *		to use when placing the existing image within the new image. See
	 *		`{@link UI.Image#setImageGravity}` for more details about this property.
	 * @param {String} infoArray[].image A filename for an existing image to include in the
	 *		composite image.
	 * @param {Number[]} [infoArray[].insets=[0, 0, 0, 0]] The insets that will be used to clip the
	 *		edges of the image. Specified as an array of four floats, starting with the top inset
	 *		and going clockwise around the image.
	 * @param {Number[]} [infoArray[].rect] An array of integers that specify a rectangle where the 
	 *		existing image will be placed in the composite image. (By default, this method uses a
	 *		rectangle that is the same size as the new image.) The array contains the following four
	 *		values, in this order:
	 *
	 * 1. The X origin at which to place the top left corner of the existing image.
	 * 2. The Y origin at which to place the top left corner of the existing image.
	 * 3. The width, in pixels, of the image rectangle.
	 * 4. The height, in pixels, of the image rectangle.
	 * @param {Number[]} [infoArray[].transform] The affine transformation to apply to the existing
	 *		image. See `{@link UI.Image#setImageTransform}` for more information about affine
	 *		transformations. Specified as an array of six floats: `[a, b, c, d, tx, ty]`.
	 * @cb {Function} callback The function to call after creating the composite image.
	 * @cb-param {Object} data Information about the composite image.
	 * @cb-param {String} [data.error] A description of the error, if any.
	 * @cb-param {String} [data.filename] The filename for the composite image. **Note**: This value
	 *		may differ from the value that was sent in the `filename` parameter.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.1.1.2
	 */
    compositeImages: function(w, h, filename, infoArray, callback) {
        var cb = this.Commands.registerTemporaryCallback(callback);
        if (cb) {
			this.Commands.doCompositeImages(w, h, filename, infoArray, cb);
		}
    },

    /**
     * Display a full-screen interface for selecting an existing image from the device's camera
	 * roll, and write the selected image to the device's file system. You can retrieve the image
	 * at its original size, or you can rescale the image to fit within a width and height you
	 * specify.
	 *
	 * By default, the image is saved in PNG format. To use JPEG format, specify a filename with the
	 * extension .jpg.
	 * @name UI.choosePhoto
	 * @function
	 * @static
	 * @example
	 * // Retrieve an image that has been scaled to fit within a 100 x 200 rectangle.
	 * var filename = "example.png";
	 * var view = new UI.View();
	 * UI.choosePhoto(100, 200, filename, {}, function(data) {
	 *     if (data.error) {
	 *         // The user probably canceled instead of choosing an image.
	 *         console.log("Unable to select an image: " + data.error);
	 *     } else {
	 *         // Update the filename.
	 *         filename = data.filename;
	 *     }
	 * }, view);
	 * @param {Number} targetWide The width, in pixels, to use for scaling the image. Use 0 to
	 *		retrieve an unscaled image.
	 * @param {Number} targetHigh The height, in pixels, to use for scaling the image. Use 0 to
	 *		retrieve an unscaled image.
	 * @param {String} filename The preferred filename for the new image. Use the extension .jpg to
	 *		save the file in JPEG format. By default, the file is saved in PNG format. **Note**: The
	 *		file may be saved using a different name. Use the callback function to identify the 
	 *		file's actual name.
	 * @param {Object} options Options for retrieving the image.
	 * @param {UI.Commands#FitMode} [options.fit=UI.Commands.FitMode.Inside] The image fit mode to
	 *		use when scaling the existing image.
	 * @param {Number[]|UI.ViewGeometry#Gravity} [options.gravity=[0.5, 0.5]] The image gravity to
	 *		use when placing the existing image within the retrieved image. See
	 *		`{@link UI.Image#setImageGravity}` for more details about this property.
	 * @param {Number[]} [options.insets=[0, 0, 0, 0]] The insets that will be used to clip the
	 *		edges of the image. Specified as an array of four floats, starting with the top inset
	 *		and going clockwise around the image.
	 * @param {Number[]} [options.rect] An array of integers that specify a rectangle where the 
	 *		existing image will be placed in the new image. (By default, this method uses a
	 *		rectangle that is the same size as the new image.) The array contains the following four
	 *		values, in this order:
	 *
	 * 1. The X origin at which to place the top left corner of the existing image.
	 * 2. The Y origin at which to place the top left corner of the existing image.
	 * 3. The width, in pixels, of the image rectangle.
	 * 4. The height, in pixels, of the image rectangle.
	 * @param {Number[]} [options.transform] The affine transformation to apply to the existing
	 *		image. See `{@link UI.Image#setImageTransform}` for more information about affine
	 *		transformations. Specified as an array of six floats: `[a, b, c, d, tx, ty]`.
	 * @cb {Function} callback The function to call after choosing an image.
	 * @cb-param {Object} data Information about the image.
	 * @cb-param {String} [data.error] A description of the error, if any.
	 * @cb-param {String} [data.filename] The filename for the image. **Note**: This value may
	 *		differ from the value that was sent in the `filename` parameter.
	 * @cb-returns {void}
	 * @param {Object} invokingView The view that is invoking the image picker.
	 * @returns {void}
	 * @since 1.3.1b
	 */
    choosePhoto: function(targetWide, targetHigh, filename, options, callback, invokingView) {
       if (!invokingView || !invokingView.__objectRegistryId) {
            new exports.UI.Toast({
                'text': "Photo picker requires an invoking view.",
                'onDisappear': function() {
                    this.destroy();
                }
            }).show();
            return;
        }

        var cb = this.Commands.registerTemporaryCallback(callback);
		if (cb) {
        	this.Commands.doChoosePhoto(targetWide, targetHigh, filename, options || {}, cb, invokingView.__objectRegistryId);
		}
    },

    /**
     * Display a full-screen interface for taking a new photo with the device's camera, and write
	 * the photo to the device's file system. You can retrieve the photo at its original size, or 
	 * you can rescale the photo to fit within a width and height you specify.
	 *
	 * By default, the image is saved in PNG format. To use JPEG format, specify a filename with the
	 * extension .jpg.
	 * @name UI.choosePhotoCamera
	 * @function
	 * @static
	 * @example
	 * // Take a photo, and scale it to fit within a 100 x 200 rectangle.
	 * var filename = "example.png";
	 * UI.choosePhotoCamera(100, 200, filename, {}, function(data) {
	 *     if (data.error) {
	 *         // The user probably canceled instead of taking a photo.
	 *         console.log("Unable to retrieve a photo: " + data.error);
	 *     } else {
	 *         // Update the filename.
	 *         filename = data.filename;
	 *     }
	 * });
	 * @param {Number} targetWide The width, in pixels, to use for scaling the photo. Use 0 to
	 *		retrieve an unscaled photo.
	 * @param {Number} targetHigh The height, in pixels, to use for scaling the photo. Use 0 to
	 *		retrieve an unscaled photo.
	 * @param {String} filename The preferred filename for the new photo. Use the extension .jpg to
	 *		save the file in JPEG format. By default, the file is saved in PNG format. **Note**: The
	 *		file may be saved using a different name. Use the callback function to identify the 
	 *		file's actual name.
	 * @param {Object} options Options for retrieving the image.
	 * @param {UI.Commands#FitMode} [options.fit=UI.Commands.FitMode.Inside] The image fit mode to
	 *		use when scaling the existing image.
	 * @param {Number[]|UI.ViewGeometry#Gravity} [options.gravity=[0.5, 0.5]] The image gravity to
	 *		use when placing the existing image within the retrieved image. See
	 *		`{@link UI.Image#setImageGravity}` for more details about this property.
	 * @param {Number[]} [options.insets=[0, 0, 0, 0]] The insets that will be used to clip the
	 *		edges of the image. Specified as an array of four floats, starting with the top inset
	 *		and going clockwise around the image.
	 * @param {Number[]} [options.rect] An array of integers that specify a rectangle where the 
	 *		existing image will be placed in the new image. (By default, this method uses a
	 *		rectangle that is the same size as the new image.) The array contains the following four
	 *		values, in this order:
	 *
	 * 1. The X origin at which to place the top left corner of the existing image.
	 * 2. The Y origin at which to place the top left corner of the existing image.
	 * 3. The width, in pixels, of the image rectangle.
	 * 4. The height, in pixels, of the image rectangle.
	 * @param {Number[]} [options.transform] The affine transformation to apply to the existing
	 *		image. See `{@link UI.Image#setImageTransform}` for more information about affine
	 *		transformations. Specified as an array of six floats: `[a, b, c, d, tx, ty]`.
	 * @cb {Function} callback The function to call after taking a photo.
	 * @cb-param {Object} data Information about the photo.
	 * @cb-param {String} [data.error] A description of the error, if any.
	 * @cb-param {String} [data.filename] The filename for the photo. **Note**: This value may
	 *		differ from the value that was sent in the `filename` parameter.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.3.1b
	 */
    choosePhotoCamera: function(width, height, filename, options, callback) {
        var cb = this.Commands.registerTemporaryCallback(callback);
		if (cb) {
        	this.Commands.doChooseCamera(width, height, filename, options || {}, cb);
		}
    },


    /**
	 * Capture a static image of the screen. You can retrieve the screenshot at its original size, 
	 * or you can rescale the image to fit within a width and height you specify.
	 *
	 * By default, screenshots include graphics that were drawn by classes in the `UI` and
	 * `{@link GL2}` modules. Use the `options.screenshotType` parameter to exclude either type of
	 * graphics from the screenshot.
	 *
	 * By default, the image is saved in PNG format. To use JPEG format, specify a filename with the
	 * extension .jpg.
	 * @name UI.takeScreenshot
	 * @function
	 * @static
	 * @example
	 * // Take a screenshot, and scale it to fit within a 100 x 200 rectangle.
	 * var filename = "example.png";
	 * UI.takeScreenshot(100, 200, filename, {}, function(data) {
	 *     if (data.error) {
	 *         console.log("Unable to retrieve a screenshot: " + data.error);
	 *     } else {
	 *         // Update the filename.
	 *         filename = data.filename;
	 *     }
	 * });
	 * @param {Number} targetWide The width, in pixels, to use for scaling the photo. Use 0 to
	 *		retrieve an unscaled image.
	 * @param {Number} targetHigh The height, in pixels, to use for scaling the photo. Use 0 to
	 *		retrieve an unscaled image.
	 * @param {String} filename The preferred filename for the new image. Use the extension .jpg to
	 *		save the file in JPEG format. By default, the file is saved in PNG format. **Note**: The
	 *		file may be saved using a different name. Use the callback function to identify the 
	 *		file's actual name.
	 * @param {Object} options Options for retrieving the screenshot.
	 * @param {UI.Commands#FitMode} [options.fit=UI.Commands.FitMode.Inside] The image fit mode to
	 *		use when scaling the screenshot.
	 * @param {Number[]|UI.ViewGeometry#Gravity} [options.gravity=[0.5, 0.5]] The image gravity to
	 *		use when placing the screenshot within the retrieved image. See
	 *		`{@link UI.Image#setImageGravity}` for more details about this property.
	 * @param {Number[]} [options.insets=[0, 0, 0, 0]] The insets that will be used to clip the
	 *		edges of the image. Specified as an array of four floats, starting with the top inset
	 *		and going clockwise around the image.
	 * @param {Number[]} [options.rect] An array of integers that specify a rectangle where the 
	 *		screenshot will be placed in the new image. (By default, this method uses a rectangle
	 *		that is the same size as the new image.) The array contains the following four values,
	 *		in this order:
	 *
	 * 1. The X origin at which to place the top left corner of the screenshot.
	 * 2. The Y origin at which to place the top left corner of the screenshot.
	 * 3. The width, in pixels, of the image rectangle.
	 * 4. The height, in pixels, of the image rectangle.
	 * @param {Number[]} [options.transform] The affine transformation to apply to the screenshot.
	 *		See `{@link UI.Image#setImageTransform}` for more information about affine
	 *		transformations. Specified as an array of six floats: `[a, b, c, d, tx, ty]`.
	 * @param {UI.Commands.ScreenshotType} [options.screenshotType] Indicates whether to include
	 *		graphics drawn with the `UI` module, the `{@link GL2}` module, or both modules. By
	 *		default, screenshots include graphics from both modules.
	 * @cb {Function} callback The function to call after taking a screenshot.
	 * @cb-param {Object} data Information about the screenshot.
	 * @cb-param {String} [data.error] A description of the error, if any.
	 * @cb-param {String} [data.filename] The filename for the screenshot. **Note**: This value may
	 *		differ from the value that was sent in the `filename` parameter.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.6.5
	 */
	takeScreenshot: function(width, height, filename, options, callback) {
		var cb = this.Commands.registerTemporaryCallback(callback);
		if (cb) {
			this.Commands.takeScreenshot(width, height, filename, options || {}, cb);
		}
	},

	/**
	 * Retrieve the width and height, in pixels, of a text block. The dimensions are measured by
	 * attempting to lay the text out inside of a rectangle whose width and height you specify,
	 * using a font and font size that you specify. If the text overflows the rectangle's height,
	 * only the text that fits within the rectangle is measured.
	 *
	 * You can also measure the dimensions of a text block without width and/or height constraints,
	 * which enables you to determine how much space would be required to display the text block.
	 * @name UI.measureText
	 * @function
	 * @static
	 * @example
	 * // Measure the dimensions of a text block that is allowed to take up the
	 * // entire screen.
	 * var string = "You have to learn the rules of the game. And then you have to " +
	 *   "play better than anyone else.";
	 * var blockSize = [];
	 * var lineWidths = [];
	 * var totalWidth = 0;
	 * UI.measureText(string, Device.LayoutEmitter.getWidth(),
	 *   Device.LayoutEmitter.getHeight(), "DroidSans", 24, function(dimensions) {
	 *     blockSize = [dimensions.width, dimensions.height];
	 *     lineWidths = dimensions.lineWidths;
	 *     totalWidth = dimensions.totalWidth;
	 * });
	 * @param {String} text The string of text to measure.
	 * @param {Number} w The width, in pixels, of the rectangle that will be used to lay out the
	 *		text. Specify an empty string to measure the text without a width constraint.
	 * @param {Number} h The height, in pixels, of the rectangle that will be used to lay out the
	 *		text. Specify an empty string to measure the text without a height constraint.
	 * @param {String} font The name of the font to use for measuring the text.
	 * @param {Number} size The font size, in pixels, to use for measuring the text.
	 * @cb {Function} callback The function to call after measuring the text.
	 * @cb-param {Object} dimensions Information about the text dimensions.
	 * @cb-param {Number} dimensions.height The height, in pixels, of the block of text.
	 * @cb-param {Number[]} dimensions.lineWidths The widths, in pixels, of each line in the block
	 *		of text.
	 * @cb-param {Number} dimensions.totalWidth The combined width, in pixels, of all of the lines
	 *		in the text block.
	 * @cb-param {Number} dimensions.width The width, in pixels, of the block of text.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.4.2
	 */
	measureText: function( text, w, h, font, size, callback) {
		var cb = this.Commands.registerTemporaryCallback(callback);
		if (cb !== '') {
			this.Commands.measureText(text, w || -1, h || -1, font, size, cb);
		}
	},
	/**
	 * Hide the on-screen keyboard if it is showing, regardless of which text field or text area is 
	 * selected.
	 * @name UI.hideKeyboard
	 * @function
	 * @static
	 * @returns {void}
	 * @since 1.6.5
	 */
	hideKeyboard: function() {
		this.Commands.hideKeyboard();
	}
};

exports.UI = new UILoader({
	"Commands": function() { return require("NGCore/Client/UI/Commands").Commands; },
	"FontStyle": function() { return this.Commands.FontStyle; },
	"State": function() { return this.Commands.State; },
	"FitMode": function() { return this.Commands.FitMode; },
	
	"Window": function() { return require("NGCore/Client/UI/Window").Window; },
	"Element": function() { return require("NGCore/Client/UI/Element").Element; },
	"ViewGeometry": function() { return require("NGCore/Client/UI/ViewGeometry").ViewGeometry; },
	"Scale": function() { return exports.UI.ViewGeometry.Scale; },
	"View": function() { return require("NGCore/Client/UI/View").View; },
	"Label": function() { return require("NGCore/Client/UI/Label").Label; },
	"Image": function() { return require("NGCore/Client/UI/Image").Image; },
	"Button": function() { return require("NGCore/Client/UI/Button").Button; },
	"GLView": function() { return require("NGCore/Client/UI/GLView").GLView; },
	"NavController": function() { return require("NGCore/Client/UI/NavController").NavController; },
	"WebView": function() { return require("NGCore/Client/UI/WebView").WebView; },
	"ScrollView": function() { return require("NGCore/Client/UI/ScrollView").ScrollView; },
	"ListView": function() { return require("NGCore/Client/UI/ListView").ListView; },
	"ListViewSection": function() { return require("NGCore/Client/UI/ListViewSection").ListViewSection; },
	"ListViewItem": function() { return require("NGCore/Client/UI/ListViewItem").ListViewItem; },
	"CellView": function() { return require("NGCore/Client/UI/CellView").CellView; },
	"CheckBox": function() { return require("NGCore/Client/UI/CheckBox").CheckBox; },
	"EditText": function() { return require("NGCore/Client/UI/EditText").EditText; },
	"EditTextArea": function() { return require("NGCore/Client/UI/EditTextArea").EditTextArea; },
	"DateField": function() { return require("NGCore/Client/UI/DateField").DateField; },
	"AlertDialog": function() { return require("NGCore/Client/UI/AlertDialog").AlertDialog; },
	"ProgressDialog": function() { return require("NGCore/Client/UI/ProgressDialog").ProgressDialog; },
	"Toast": function() { return require("NGCore/Client/UI/Toast").Toast; },
	"Style": function() { return require("NGCore/Client/UI/Style").Style; },
	"Spinner": function() { return require("NGCore/Client/UI/Spinner").Spinner; },
	"ProgressBar": function() { return require("NGCore/Client/UI/ProgressBar").ProgressBar; },
	"Diagnostics": function() { return require("NGCore/Client/UI/Diagnostics").Diagnostics; },
/** @private */
	"AdView": function() { return require("NGCore/Client/UI/AdView").AdView; },
	"DocumentView": function() { return require("NGCore/Client/UI/DocumentView").DocumentView; },
	"CheckoutView": function() { return require("NGCore/Client/UI/CheckoutView").CheckoutView; },
	"MapView": function() { return require("NGCore/Client/UI/MapView").MapView; },
	"MapAnnotation": function() { return require("NGCore/Client/UI/MapAnnotation").MapAnnotation; },
	"_CutSceneView": function() { return require("NGCore/Client/UI/_CutSceneView").CutSceneView; }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Node'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Node'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Node'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Node.js';

var Core = require('NGCore/Client/Core').Core;


var Node = exports.Node = Core.Class.subclass(
/** @lends GL2.Node.prototype */
{
	classname: 'Node',

	/**
	 * @class The `GL2.Node` class creates objects that can be used as containers to group,
	 * organize, and transform other components of a `GL2` scene. It also serves as a base class for
	 * the following classes:
	 *
	 * + `{@link GL2.Primitive}`
	 * + `{@link GL2.Sprite}`
	 * + `{@link GL2.Text}`
	 *
	 * The components of a `GL2` scene are organized into a tree of nodes, or a scene graph. The
	 * scene graph's organization affects how the scene's components are displayed. For example, if
	 * a sprite is assigned to a node that has been rotated, the sprite will also be rotated. The
	 * absolute position of a node is determined by the following properties of the node and its
	 * ancestors, which are applied in this order:
	 *
	 * 1. Scaling factors for width and height (see `{@link GL2.Node#setScale}`)
	 * 2. Rotation (see `{@link GL2.Node#setRotation}`)
	 * 3. Position (see `{@link GL2.Node#setPosition}`)
	 *
	 * To determine the final transform for a node, `GL2` takes the node's properties, then combines
	 * them with the properties of all of the node's ancestors. Although `GL2.Node` objects do not
	 * have a visual representation, all of their properties contribute to the combined transform.
	 *
	 * As a result, when you set or retrieve a node's properties, keep in mind that the properties
	 * are being defined relative to the node's ancestors. For example, if a parent node has its
	 * origin at the coordinate `(50, 50)` within the global scene, and you create a child node
	 * whose origin is set to `(25, 25)`, the child node will be drawn at the coordinate `(75, 75)`
	 * within the global scene; its position is relative to its ancestors' positions.
	 *
	 * Each node also has a depth property, which controls the order of drawing and touch events.
	 * When nodes are drawn, nodes with a lower depth are obscured by nodes with a higher depth. In
	 * contrast, touch events give priority to the top node in the stack; they propagate downward
	 * from the node with the highest depth to the node with the lowest depth. At any point, a touch
	 * target can capture the touch event and prevent it from propagating further. See
	 * `{@link GL2.TouchTarget#getTouchEmitter}` for more information about capturing touch events.
	 *
	 * **Note**: If a clipping rectangle has been applied to the node, it will affect both drawing
	 * and touch events. See `{@link GL2.Node#setClipRect}` for details.
	 *
	 * By default, nodes are grouped with their siblings, and they are sorted relative to their
	 * parent node as though the parent node had a depth of `0`. You can call
	 * `{@link GL2.Node#setChildrenDepthGrouped}` to modify this behavior.
	 *
	 * Nodes can exist independent of the scene graph. However, a node will not be displayed and
	 * cannot receive touch events unless it is attached to the root of the scene graph, either
	 * directly or through a parent node. See `{@link GL2.Root}` for details about the root of the
	 * scene graph.
	 *
	 * All nodes have a corresponding native object in ngCore's native layer. As a result, creating
	 * and destroying large numbers of nodes can affect an application's performance. If you are
	 * removing a node from the scene graph, but you will need to display the node again, you should
	 * normally avoid calling `{@link GL2.Node#destroy}` and then recreating the node. Instead,
	 * remove the node from the scene graph, or specify that the node is not visible or touchable,
	 * then display the node again later.
	 * @constructs Create a node.
	 * @augments Core.Class
	 * @since 1.0
	 */
    initialize: function()
    {
		Core.ObjectRegistry.register(this);
        this._parent = null;
        this._position = new Core.Point();
        this._scale = new Core.Vector(1, 1);
        this._color = new Core.Color(1, 1, 1);
        this._alpha = 1;
        this._rotation = 0;
        this._depth = 0;
        this._visible = true;
        this._touchable = true;

        this._childrenDepthGrouped = true;
        this._children = [];

		this._clipRect = new Core.Rect(0, 0, -1, -1);
        this._clipRectEnabled = false;

		this._createSendGen(this.__objectRegistryId);

    },

	/**
	 * Remove the node's children (if any), detach the node from its parent (if any), and destroy
	 * the node, releasing the resources allocated by the node.
	 *
	 * **Important**: Destroying a node does not destroy the node's children.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		var children = this._children;
		while(children.length)
		{
			this.removeChild(children[0]);
		}

		if(this._parent)
		{
			this._parent.removeChild(this);
		}

		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Retrieve the node's position, measured at its upper left corner.
	 * @returns {Core.Point} The node's current position, measured at its upper left corner.
	 * @see GL2.Node#setPosition
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPosition: function()
	{
		return this._position;
	},

	/**
	 * Retrieve the node's scaling factor, represented as a multiple of the node's width and height.
	 * @returns {Core.Vector} The current scaling factor for the node's width and height.
	 * @see GL2.Node#setScale
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getScale: function()
	{
		return this._scale;
	},

	/**
	 * Retrieve the node's RGB color. Although `GL2.Node` objects are not rendered to the screen,
	 * the color is used to transform the color of child nodes.
	 * @returns {Core.Color} The node's current RGB color.
	 * @see GL2.Node#setColor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getColor: function()
	{
		return this._color;
	},

	/**
	 * Retrieve the node's opacity.
	 * @returns {Number} The node's current opacity, expressed as a float ranging from `0.0`, or
	 *		completely transparent, to `1.0`, or completely opaque.
	 * @see GL2.Node#setAlpha
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAlpha: function()
	{
		return this._alpha;
	},

	/**
	 * Retrieve the node's rotation, measured in degrees about the Z axis.
	 * @returns {Number} The node's current rotation, expressed as a float representing degrees.
	 * @see GL2.Node#setRotation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getRotation: function()
	{
		return this._rotation;
	},

	/**
	 * Retrieve the node's depth.
	 * @returns {Number} The node's current depth, expressed as a float.
	 * @see GL2.Node#setDepth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getDepth: function()
	{
		return this._depth;
	},

	/**
	 * Determine whether the node is visible.
	 * @returns {Boolean} Set to `true` if the node is visible.
	 * @see GL2.Node#setVisible
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getVisible: function()
	{
		return this._visible;
	},

	/**
	 * Determine whether the node will receive touch events.
	 * @returns {Boolean} Set to `true` if the node will receive touch events.
	 * @see GL2.Node#setTouchable
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getTouchable: function()
	{
		return this._touchable;
	},

	/**
	 * Determine whether node trees and their children will be displayed based on the depth of their
	 * top-level nodes.
	 * @returns {Boolean} Set to `true` if node trees and their children will be displayed based on
	 *		the depth of their top-level nodes. Set to `false` if node trees that share the same
	 *		parent will be interleaved.
	 * @see GL2.Node#setChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getChildrenDepthGrouped: function()
	{
		return this._childrenDepthGrouped;
	},

	/**
	 * Retrieve the node's clipping rectangle, which is defined based on the global scene's
	 * coordinate system.
	 * @returns {Core.Rect} The current clipping rectangle, defined based on the global scene's
	 *		coordinate system.
	 * @see GL2.Node#setClipRect
	 * @status iOS, Android
	 * @since 1.4.1
	 */
	getClipRect: function()
	{
		return this._clipRect;
	},

	/**
	 * Determine whether the node's clipping rectangle is enabled.
	 * @returns {Boolean} Set to `true` if the node's clipping rectangle is enabled.
	 * @see GL2.Node#setClipRectEnabled
	 * @status iOS, Android
	 * @since 1.4.1
	 */
	getClipRectEnabled: function()
	{
		return this._clipRectEnabled;
	},

	/**
	 * Retrieve the node's parent node.
	 * @returns {GL2.Node} The current parent node, or `null` if the node does not have a parent
	 *		node.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getParent: function()
	{
		return this._parent;
	},

	/**
	 * Retrieve the node's children.
	 * @returns {Object[]} The node's current children.
	 * @status Flash, Test, FlashTested
	 * @since 1.1.6
	 */
	getChildren: function()
	{
		return this._children.slice();
	},


    /**
	 * Set the node's position, measured at its upper left corner. By default, the node's
	 * position is set to `(0, 0)`.
	 * @example
	 * var node = new GL2.Node();
	 * // Set the node's position using a Core.Point object.
	 * node.setPosition(new Core.Point(50, 100));
	 * // Set the node's position using two numbers.
	 * node.setPosition(25, 25);
	 * @param {Core.Point|Number} position The node's new position, measured at its upper left
	 *		corner. Specified as a `{@link Core.Point}` object or as two separate floats that
	 *		represent the X and Y coordinates of the origin, in that order.
	 * @returns {this}
	 * @see GL2.Node#getPosition
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setPosition: function(x, y)
	{
		var p = this._position;
		switch (arguments.length) {
		case 1:
			p.setAll(x);
			break;
		case 2:
			p.setAll(x, y);
			break;
		default:
			p.setAll.apply(p, arguments);
			break;
		}
		this._setPositionSendGen(p.getX(),p.getY());
		return this;
	},

    /**
	 * Set the node's scaling factor, represented as a multiple of the node's width and height. The
	 * node is scaled from its anchor point. By default, the node's scaling factor is set to
	 * `[1, 1]`, meaning that it is not scaled.
	 * @example
	 * var node = new GL2.Node();
	 * // Set the node's scale using a Core.Vector object.
	 * node.setScale(new Core.Vector(2, 0.5));
	 * // Set the node's scale using two numbers.
	 * node.setScale(3, 2);
	 * @param {Core.Vector|Number} scale The new scaling factor for the node's width and height.
	 *		Specified as a `{@link Core.Vector}` object or as two separate floats that represent
	 *		the X and Y scaling factors, or a single float which represents both X and Y scaling factors.
	 * @returns {this}
	 * @see GL2.Node#getScale
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setScale: function(scale)
	{
		var s = this._scale;
		if (typeof scale === 'number' && arguments.length === 1) {
			s.setAll(scale, scale);
		} else {
			s.setAll.apply(s, arguments);
		}
		this._setScaleSendGen(s.getX(), s.getY());
		return this;
	},
	/**
	 * Set the node's RGB color. The RGB values of each pixel in a child node are multiplied by the
	 * RGB values for the parent node. By default, the color is set to `[1, 1, 1]`, which does not
	 * affect the color of child nodes.
	 * @example
	 * // Draw an orange node using a Core.Color object.
	 * var node = new GL2.Node();
	 * node.setColor(new Core.Color(1.0, 0.5, 0));
	 * // Draw a purple text area by specifying the text area's RGB values
	 * // individually. GL2.Text objects inherit the setColor() method from
	 * // GL2.Node.
	 * var text = new GL2.Text();
	 * text.setColor(0.5, 0. 1.0);
	 * // Add the purple text area as a child of the orange node. The nodes' RGB
	 * // colors are multiplied by one another, and the resulting color is dark red:
	 * // ((1.0 * 0.5), (0.5 * 0), (0 * 1.0)) = (0.5, 0, 0). The text is displayed
	 * // in dark red.
	 * node.addChild(text);
	 * @param {Core.Color|Number} color The node's new RGB color. Specified as a
	 *		`{@link Core.Color}` object or as three separate floats that represent the red, green,
	 *		and blue values of the color, in that order; each float can range from `0` to `1`.
	 * @returns {this}
	 * @see GL2.Node#getColor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setColor: function(color)
	{
		var c = this._color;
		c.setAll.apply(c, arguments);
		this._setColorSendGen(c.getRed(),c.getGreen(),c.getBlue());
		return this;
	},
    /**
	 * Set the node's opacity. The pixels in a parent node are individually blended with the pixels
	 * in a child node based on their opacity. By default, the node's opacity is `1`, or fully
	 * opaque.
	 * @example
	 * // Draw red text below a white node that has an opacity of 0.5, resulting in
	 * // pink text. Note that the GL2.Text object inherits the setColor() method
	 * // from GL2.Node.
	 * var node = new GL2.Node();  // defaults to a fully opaque white background
	 * node.setAlpha(0.5);
	 * var text = new GL2.Text();
	 * text.setColor(1.0, 0, 0);
	 * node.addChild(text);
	 * @param {Number} alpha The node's new opacity, expressed as a float ranging from `0.0`, or
	 *		completely transparent, to `1.0`, or completely opaque.
	 * @returns {this}
	 * @see GL2.Node#getAlpha
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setAlpha: function(alpha)
	{
		this._alpha = alpha;
		this._setAlphaSendGen(alpha);
		return this;
	},

    /**
	 * Set the node's rotation, measured in degrees about the Z axis. By default, the node's
	 * rotation is `0`.
	 * @example
	 * // Rotate a node by 45 degrees.
	 * var node = new GL2.Node();
	 * node.setRotation(45);
	 * @example
	 * // Rotate a node by 0.5 radians (approximately 28.65 degrees).
	 * function radiansToDegrees(radians) {
	 *     return radians * (180 / Math.PI);
	 * }
	 *
	 * var node = new GL2.Node();
	 * node.setRotation(radiansToDegrees(0.5));
	 * @param {Number} rotation The node's new rotation, expressed as a float representing degrees.
	 * @returns {this}
	 * @see GL2.Node#getRotation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setRotation: function(rotation)
	{
		this._rotation = rotation;
		this._setRotationSendGen(rotation);
		return this;
	},

    /**
	 * Set the node's depth. If two nodes have the same depth, nodes will be sorted based on
	 * their indexes; nodes with lower indexes will be treated as if they had a lower depth. By
	 * default, the node's depth is `0`.
	 *
	 * Nodes with lower depths will be drawn under nodes with higher depths. If a touch event falls
	 * within two nodes, the node with the higher depth will receive the touch event first; if that
	 * node does not capture the touch event, it propagates to the node with the lower depth.
	 *
	 * **Note**: To control how child nodes are interleaved, call
	 * `{@link GL2.Node#setChildrenDepthGrouped}`.
	 * @example
	 * // Create a parent node with two child nodes, each of which has a
	 * // different depth.
	 * var parentNode = new GL2.Node(),
	 *     childNodeLow = new GL2.Node(),
	 *     childNodeHigh = new GL2.Node();
	 * parentNode.addChild(childNodeLow).addChild(childNodeHigh);
	 * childNodeLow.setDepth(10);  // drawn below childNodeHigh; receives touch
	 *                             // events second
	 * childNodeHigh.setDepth(20); // drawn above childNodeLow; receives touch
	 *                             // events first
	 * @param {Number} depth The node's new depth, expressed as a float.
	 * @returns {this}
	 * @see GL2.Node#getChildrenDepthGrouped
	 * @see GL2.Node#getDepth
	 * @see GL2.Node#setChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setDepth: function(depth)
	{
		if(this._depth != depth)
		{
			this._depth = depth;
			this._setDepthSendGen(depth);
		}
		return this;
	},

    /**
	 * Set whether the node is visible. By default, the node is visible.
	 * @param {Boolean} visible Set to `true` to make the node visible.
	 * @returns {this}
	 * @see GL2.Node#getVisible
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setVisible: function(visible)
	{
		if(this._visible != visible)
		{
			this._visible = visible;
			this._setVisibleSendGen(visible);
		}
		return this;
	},

    /**
	 * Set whether the node will receive touch events. By default, the node receives touch
	 * events.
	 *
	 * **Important**: Nodes that do not receive touch events have better performance than nodes
	 * that receive touch events. If a node and its children do not need to support touch input,
	 * call this method and set the value of `touchable` to `false`.
	 * @param {Boolean} touchable Set to `true` to enable touch events for the node.
	 * @returns {this}
	 * @see GL2.Node#getTouchable
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setTouchable: function(touchable)
	{
		this._touchable = touchable;
		this._setTouchableSendGen(touchable);
		return this;
	},

	/**
	 * Set whether to display node trees and their children based on the depth of their top-level
	 * nodes. By default, this option is set to `true`.
	 *
	 * When `childrenDepthGrouped` is set to `true`, children are always grouped based on the depth
	 * of their parent node. For example, suppose that a scene graph includes two node trees, Y and
	 * Z, that share node X as their parent and have the same depth. However, node tree Z has a
	 * higher index:
	 *
	 *     Node X
	 *     +-- Node Y (depth = 0, index = 0)
	 *     |   +-- shadow sprite (depth = 10)
	 *     |   +-- character sprite (depth = 20)
	 *     |
	 *     +-- Node Z (depth = 0, index = 1)
	 *         +-- shadow sprite (depth = 10)
	 *         +-- character sprite (depth = 20)
	 *
	 * If `childrenDepthGrouped` is set to `true`, Z and its children will all be displayed on top 
	 * of Y and its children, regardless of the depth of Y and Z's child nodes. The drawing order
	 * for the entire scene graph will be as follows:
	 *
	 * 1. Node Z character sprite
	 * 2. Node Z shadow sprite
	 * 3. Node Z
	 * 4. Node Y character sprite
	 * 5. Node Y shadow sprite
	 * 6. Node Y
	 * 7. Node X
	 *
	 * When this option is set to `false`, two node trees that share the same parent will be
	 * interleaved with one another when they are drawn. With the scene graph shown above, nodes Y
	 * and Z, as well as their children, will be interleaved with one another based on their depth
	 * and indexes. Because the character sprites have a depth of `20`, they will be drawn on top of
	 * the shadow sprites, which have a depth of `10`. The drawing order for the entire scene graph
	 * will be as follows:
	 *
	 * 1. Node Z character sprite
	 * 2. Node Y character sprite
	 * 3. Node Z shadow sprite
	 * 4. Node Y shadow sprite
	 * 5. Node Z
	 * 6. Node Y
	 * 7. Node X
	 * @param {Boolean} childrenDepthGrouped Set to `true` to display node trees and their children
	 *		based on the depth of their top-level nodes. Set to `false` to interleave node trees
	 *		that share the same parent.
	 * @returns {this}
	 * @see GL2.Node#getChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setChildrenDepthGrouped: function(childrenDepthGrouped)
	{
		if(this._childrenDepthGrouped != childrenDepthGrouped)
		{
			this._childrenDepthGrouped = childrenDepthGrouped;
			this._setChildrenDepthGroupedSendGen(childrenDepthGrouped);
		}
		return this;
	},

	/**
	 * Add a child node.
	 * @example
	 * var parentNode = new GL2.Node(),
	 *     childNode = new GL2.Node();
	 * parentNode.addChild(childNode);
	 * @param {Object} child The child node to add. This parameter must contain an object instance
	 *		that inherits from `GL2.Node`.
	 * @returns {this}
	 * @see GL2.Node#removeChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	addChild: function(child)
	{
		// Add to children list.
		this._children.push(child);

		// Tell child.
		child._didAddToParent(this);

		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));

		return this;
	},

	/**
	 * Remove a child node and its descendants from the node.
	 * @example
	 * var parentNode = new GL2.Node(),
	 *     childNode = new GL2.Node();
	 * parentNode.addChild(childNode);
	 * // To remove childNode from parentNode:
	 * parentNode.removeChild(childNode);
	 * @param {Object} child The child node to remove from the node. This parameter must contain an
	 *		object instance that is a child of the node and that inherits from `GL2.Node`.
	 * @throws {Error} The specified node is not a child node.
	 * @returns {this}
	 * @see GL2.Node#addChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	removeChild: function(child)
	{
		// Tell child.
		child._willRemoveFromParent();

		// Remove from children list.
		var index = this._children.indexOf(child);
		if(index == -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);

		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));

		return this;
	},

	/**
	 * Translate a location in the global scene's coordinate space to the node's local coordinate
	 * space.
	 * @param {Core.Point} location The location in the global scene to transform.
	 * @returns {Core.Point} The location's coordinate within the node's local coordinate space.
	 * @see GL2.Node#localToScreen
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	screenToLocal: function(location)
	{
		var parent = this._parent;
		if(!parent)
			return undefined;

		location = parent.screenToLocal(location);
		if(!location)
			return undefined;

		var x = location.getX();
		var y = location.getY();

		// Undo translation.
		var p = this._position;
		x -= p.getX();
		y -= p.getY();

		// Undo rotation.
		var r = this._rotation * Math.PI / 180;
		var cosr = Math.cos(r);
		var sinr = Math.sin(r);
		var tx = cosr*x + sinr*y;
		var ty = -sinr*x + cosr*y;
		x = tx;
		y = ty;

		// Undo scale.
		var s = this._scale;
		x /= s.getX();
		y /= s.getY();

		return new Core.Point(x, y);
	},

	/**
	 * Translate a location in the node's local coordinate space to the global scene's coordinate
	 * coordinate space. Use this method to translate between two local coordinate spaces.
	 * @param {Core.Point} location The location in the node's local coordinate space to transform.
	 * @returns {Core.Point} The location's coordinate within the global scene's coordinate space.
	 * @see GL2.Node#screenToLocal
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	localToScreen: function(location)
	{
		var x = location.getX();
		var y = location.getY();

		// Undo scale.
		var s = this._scale;
		x *= s.getX();
		y *= s.getY();

		// Undo rotation.
		var r = -this._rotation * Math.PI / 180;
		var cosr = Math.cos(r);
		var sinr = Math.sin(r);
		var tx = cosr*x + sinr*y;
		var ty = -sinr*x + cosr*y;
		x = tx;
		y = ty;

		// Undo translation.
		var p = this._position;
		x += p.getX();
		y += p.getY();

		var parent = this._parent;
		if(!parent)
			return undefined;

		location = parent.localToScreen(new Core.Point(x, y));
		if(!location)
			return undefined;
		return location;
	},

    /**
	 * Set the node's clipping rectangle, which is defined based on the global scene's coordinate
	 * system. The clipping rectangle does not inherit scaling and rotation from its ancestor nodes.
	 * By default, the clipping rectangle is set to `(0, 0, -1, -1)`, which does not clip any
	 * portion of the node.
	 *
	 * When an application specifies a clipping rectangle, then enables it by calling
	 * `{@link GL2.Node#setClipRectEnabled}`, content outside of the clipping rectangle is not
	 * drawn, and touch targets outside of the clipping rectangle do not respond to touch inputs.
	 *
	 * If one or more ancestor nodes have a clipping rectangle enabled, the clipping rectangle used
	 * for rendering and touch input will be the intersection of the node's clipping rectangle and
	 * the ancestor nodes' clipping rectangles.
	 * @example
	 * var node = new GL2.Node();
	 * node.setClipRect(new Core.Rect(0, 28, 100, 32));
	 * @param {Core.Rect} rect The new clipping rectangle, defined based on the global scene's
	 *		coordinate system.
	 * @returns {this}
	 * @see GL2.Node#getClipRect
	 * @see GL2.Node#setClipRectEnabled
	 * @status iOS, Android
	 * @since 1.4.1
	 */
	setClipRect: function(rect)
	{
		var cr = this._clipRect;
		cr.setAll.apply(cr, arguments);

		var o = cr.getOrigin();
		var s = cr.getSize();
		this._setClipRectSendGen(o.getX(), o.getY(), s.getWidth(), s.getHeight());

		return this;
	},

    /**
	 * Set whether the node's clipping rectangle is enabled. By default, the clipping rectangle is
	 * not enabled.
	 * @param {Boolean} clipRectEnabled Set to `true` to enable the node's clipping rectangle.
	 * @returns {this}
	 * @see GL2.Node#getClipRectEnabled
	 * @see GL2.Node#setClipRect
	 * @status iOS, Android
	 * @since 1.4.1
	 */
	setClipRectEnabled: function(clipRectEnabled)
	{
		if(this._clipRectEnabled != clipRectEnabled)
		{
			this._clipRectEnabled = clipRectEnabled;
			this._setClipRectEnabledSendGen(clipRectEnabled);
		}
		return this;
	},

	_didAddToParent: function(parent)
	{
		if(this._parent)
			this._parent.removeChild(this);

		this._parent = parent;
	},

	_willRemoveFromParent: function()
	{
		this._parent = null;
	},

	_synchronizeNodeRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodeRecvGen(cmd, msg))
			return;
		this._position.setAll(msg.x, msg.y);
		this._rotation = msg.rotation;
	},

	_synchronizeNodePosRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodePosRecvGen(cmd, msg))
			return;
		this._position.setAll(msg.x, msg.y);
	},

	_synchronizeNodeRotRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodeRotRecvGen(cmd, msg))
			return;
		this._rotation = msg.rotation;
	},

	_synchronizeNodeScaleRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodeScaleRecvGen(cmd, msg))
			return;
		this._scale.setAll(msg.sx, msg.sy);
	},

	_synchronizeNodeAlphaRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodeAlphaRecvGen(cmd, msg))
			return;
		this._alpha = msg.alpha;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 307,
	// Method create = -1
	// Method destroy = 2
	// Method setPosition = 3
	// Method setScale = 4
	// Method setColor = 5
	// Method setAlpha = 6
	// Method setRotation = 7
	// Method setDepth = 8
	// Method setVisible = 9
	// Method setTouchable = 10
	// Method setChildrenDepthGrouped = 11
	// Method addChild = 12
	// Method removeChild = 13
	// Method synchronizeNode = 14
	// Method setClipRect = 15
	// Method setClipRectEnabled = 16
	// Method synchronizeNodePos = 17
	// Method synchronizeNodeRot = 18
	// Method synchronizeNodeScale = 19
	// Method synchronizeNodeAlpha = 20
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 14:
					instance._synchronizeNodeRecv( cmd );
					break;
				case 17:
					instance._synchronizeNodePosRecv( cmd );
					break;
				case 18:
					instance._synchronizeNodeRotRecv( cmd );
					break;
				case 19:
					instance._synchronizeNodeScaleRecv( cmd );
					break;
				case 20:
					instance._synchronizeNodeAlphaRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Node._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Node._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[307] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_synchronizeNodeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "rotation" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "rotation" ] === undefined )
		{
			NgLogE("Could not parse rotation in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_synchronizeNodePosRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNodePos from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in Node.synchronizeNodePos from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in Node.synchronizeNodePos from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_synchronizeNodeRotRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNodeRot from command: " + cmd );
			return false;
		}
		
		obj[ "rotation" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "rotation" ] === undefined )
		{
			NgLogE("Could not parse rotation in Node.synchronizeNodeRot from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_synchronizeNodeScaleRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNodeScale from command: " + cmd );
			return false;
		}
		
		obj[ "sx" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "sx" ] === undefined )
		{
			NgLogE("Could not parse sx in Node.synchronizeNodeScale from command: " + cmd );
			return false;
		}
		
		obj[ "sy" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "sy" ] === undefined )
		{
			NgLogE("Could not parse sy in Node.synchronizeNodeScale from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_synchronizeNodeAlphaRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNodeAlpha from command: " + cmd );
			return false;
		}
		
		obj[ "alpha" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "alpha" ] === undefined )
		{
			NgLogE("Could not parse alpha in Node.synchronizeNodeAlpha from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x133ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1330002, this );
	},
	
	/** @private */
	_setPositionSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1330003, this, [ +x, +y ] );
	},
	
	/** @private */
	_setScaleSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1330004, this, [ +x, +y ] );
	},
	
	/** @private */
	_setColorSendGen: function( red, green, blue )
	{
		Core.Proc.appendToCommandString( 0x1330005, this, [ +red, +green, +blue ] );
	},
	
	/** @private */
	_setAlphaSendGen: function( alpha )
	{
		Core.Proc.appendToCommandString( 0x1330006, this, [ +alpha ] );
	},
	
	/** @private */
	_setRotationSendGen: function( rotation )
	{
		Core.Proc.appendToCommandString( 0x1330007, this, [ +rotation ] );
	},
	
	/** @private */
	_setDepthSendGen: function( depth )
	{
		Core.Proc.appendToCommandString( 0x1330008, this, [ +depth ] );
	},
	
	/** @private */
	_setVisibleSendGen: function( visible )
	{
		Core.Proc.appendToCommandString( 0x1330009, this, [ ( visible ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setTouchableSendGen: function( touchable )
	{
		Core.Proc.appendToCommandString( 0x133000a, this, [ ( touchable ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setChildrenDepthGroupedSendGen: function( childrenDepthGrouped )
	{
		Core.Proc.appendToCommandString( 0x133000b, this, [ ( childrenDepthGrouped ? 1 : 0 ) ] );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x133000c, this, [ +child ] );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x133000d, this, [ +child ] );
	},
	
	/** @private */
	_setClipRectSendGen: function( x, y, w, h )
	{
		Core.Proc.appendToCommandString( 0x133000f, this, [ +x, +y, +w, +h ] );
	},
	
	/** @private */
	_setClipRectEnabledSendGen: function( clipRectEnabled )
	{
		Core.Proc.appendToCommandString( 0x1330010, this, [ ( clipRectEnabled ? 1 : 0 ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPosition: function( x, y ) {}
	
	// setScale: function( x, y ) {}
	
	// setColor: function( red, green, blue ) {}
	
	// setAlpha: function( alpha ) {}
	
	// setRotation: function( rotation ) {}
	
	// setDepth: function( depth ) {}
	
	// setVisible: function( visible ) {}
	
	// setTouchable: function( touchable ) {}
	
	// setChildrenDepthGrouped: function( childrenDepthGrouped ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// _synchronizeNodeRecv: function( cmd ) {}
	// setClipRect: function( x, y, w, h ) {}
	
	// setClipRectEnabled: function( clipRectEnabled ) {}
	
	// _synchronizeNodePosRecv: function( cmd ) {}
	// _synchronizeNodeRotRecv: function( cmd ) {}
	// _synchronizeNodeScaleRecv: function( cmd ) {}
	// _synchronizeNodeAlphaRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/RenderTarget'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/RenderTarget'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/RenderTarget'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/RenderTarget.js';

var Core = require('NGCore/Client/Core').Core;
var Node = require('NGCore/Client/GL2/Node').Node;


var RenderTarget = exports.RenderTarget = Core.Class.subclass(
	/** @lends GL2.RenderTarget.prototype */
{
	classname: 'RenderTarget',

	/**
	 * @class The `GL2.RenderTarget` class renders multiple `GL2` objects into a single render
	 * target. This target can be attached to a `{@link GL2.Animation.Frame}` object and displayed
	 * as part of an animation. The render target can also be saved to a file.
	 * @constructs Create a render target.
	 * @example
	 * // Create a square, opaque render target.
	 * var renderTarget = new GL2.RenderTarget(256, 256, true);
	 * @param {Number} width The width of the render target. Must be a power of two.
	 * @param {Number} height The height of the render target. Must be a power of two.
	 * @param {Boolean} [isOpaque=false] Set to `true` to omit the alpha channel from the render
	 *		target.
	 * @since 1.3.1b
	 */
	initialize: function (width, height, isOpaque) {
		Core.ObjectRegistry.register(this);
		this._children = [];
		this._width = width;
		this._height = height;
		this._isOpaque = isOpaque ? true : false;
		this._createSendGen(this.__objectRegistryId, width, height, this._isOpaque);
		this._callbackIndexCounter = 1;
		this._callbacks = [];
	},

	/**
	 * Destroy the render target, and release the resources allocated by the render target.
	 * @returns {void}
	 * @since 1.3.1b
	 */
	destroy: function () {
		var children = this._children;
		while (children.length) {
			this.removeChild(children[0]);
		}
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Add a child node to the render target.
	 *
	 * If the render target is being displayed in an animation, and the application has called
	 * `{@link GL2.RenderTarget#setAutoUpdate}` to enable automatic updates, the child node will be
	 * drawn in the next frame of the animation. In all other cases, the child node will not be
	 * drawn in the render target until the application calls `{@link GL2.RenderTarget#update}`.
	 * @example
	 * var renderTarget = new GL2.RenderTarget(1024, 256);
	 * var childNode = new GL2.Node();
	 * renderTarget.addChild(childNode);
	 * @param {Object} child The child node to add. The object must inherit from `{@link GL2.Node}`.
	 * @returns {this}
	 * @since 1.3.1b
	 */
	addChild: function (child) {
		this._children.push(child);
		child._didAddToParent(this);
		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));
		return this;
	},

	/**
	 * Remove a child node from the render target. When the render target is redrawn, the child node
	 * will not be drawn.
	 *
	 * If the render target is being displayed in an animation, and the application has called
	 * `{@link GL2.RenderTarget#setAutoUpdate}` to enable automatic updates, the child node will not
	 * be drawn in the next frame of the animation. In all other cases, the child node will continue
	 * to be shown in the render target until the application calls
	 * `{@link GL2.RenderTarget#update}`.
	 * @example
	 * var renderTarget = new GL2.RenderTarget(256, 512);
	 * var childNode = new GL2.Node();
	 * renderTarget.addChild(childNode);
	 * // When the application no longer needs to include the child node in the
	 * // render target:
	 * renderTarget.removeChild(childNode);
	 * @param {Object} child The child node to remove. The object must inherit from
	 *		`{@link GL2.Node}`.
	 * @returns {this}
	 * @since 1.3.1b
	 */
	removeChild: function (child) {
		child._willRemoveFromParent();
		var index = this._children.indexOf(child);
		if (index === -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);
		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));
		return this;
	},

	/**
	 * Redraw the render target.
	 *
	 * Call this method after you make changes to the render target's child nodes. **Note**: If the
	 * render target is being displayed in an animation, and the application has called
	 * `{@link GL2.RenderTarget#setAutoUpdate}` to enable automatic updates, you do not need to call
	 * this method after changing the render target's child nodes.
	 *
	 * Also, call this method after the application has been suspended and resumed. **Note**: If the
	 * application has called `{@link GL2.RenderTarget#setBackingStoreEnable}` to enable the backing
	 * store, you do not need to call this method after the application resumes.
	 * @returns {this}
	 * @see GL2.RenderTarget#setAutoUpdate
	 * @since 1.3.1b
	 */
	update: function () {
		this._updateSendGen();
		return this;
	},

	/**
	 * Specify whether to automatically redraw the render target during every frame of an animation.
	 * Setting this option to `true` is equivalent to calling `{@link GL2.RenderTarget#update}`
	 * for every frame of an animation. If you set this option to `false`, or if the render target
	 * is not being displayed in an animation, you must call `{@link GL2.RenderTarget#update}` to
	 * redraw the render target.
	 * @param {Boolean} [autoUpdateEnable=true] Set to `true` to redraw the render target during
	 *		every frame of an animation.
	 * @returns {this}
	 * @see GL2.RenderTarget#update
	 * @since 1.3.1b
	 */
	setAutoUpdate: function (autoUpdateEnable) {
		var enable = (autoUpdateEnable || (autoUpdateEnable === undefined)) ? true : false;
		this._setAutoUpdateSendGen(enable);
		return this;
	},

	/**
	 * Specify whether the render target should be cleared before its child nodes are redrawn. By
	 * default, the render target is not cleared.
	 * @param {Boolean} [clearEnabled=true] Set to `true` to clear the render target before its
	 *		child nodes are redrawn.
	 * @returns {this}
	 * @since 1.3.1b
	 */
	setClearEnable : function (clearEnable) {
		var enable = (clearEnable || (clearEnable === undefined)) ? true : false;
		this._setClearEnableSendGen(enable);
		return this;
	},

	/**
	 * Set the render target's background color by using a `{@link Core.Color}` object. By default,
	 * the render target uses a white background. If the render target has an alpha channel, you can
	 * call `{@link GL2.RenderTarget#setClearColorAlpha}` to change the opacity of the background
	 * color.
	 * @example
	 * // Create a render target with a blue background.
	 * var renderTarget = new GL2.RenderTarget(64, 256);
	 * renderTarget.setClearColor(new Core.Color(0.3, 0.4, 0.5));
	 * @param {Core.Color} color The background color for the render target.
	 * @returns {this}
	 * @since 1.3.1b
	 */
	setClearColor : function () {
		var r, g, b, color;
		if (arguments.length === 1)
		{
			color = arguments[0];
			r = color.getRed();
			g = color.getGreen();
			b = color.getBlue();
		}
		else
		{
			r = arguments[0];
			g = arguments[1];
			b = arguments[2];
		}
		this._setClearColorSendGen(r, g, b);
		return this;
	},

	/**
	 * Set the render target's background color by specifying red, green, and blue values. By
	 * default, the render target uses a white background. If the render target has an alpha
	 * channel, you can call `{@link GL2.RenderTarget#setClearColorAlpha}` to set the opacity of the
	 * background color.
	 *
	 * Each parameter to this method is a float ranging from 0 to 1. To convert from an RGB color
	 * that is specified with values ranging from 0 to 255, simply divide each component's value by
	 * 255.
	 * @name GL2.RenderTarget#setClearColor^2
	 * @function
	 * @example
	 * // Create a render target with a blue background.
	 * var renderTarget = new GL2.RenderTarget(512, 256);
	 * renderTarget.setClearColor(0.3, 0.4, 0.5);
	 * @param {Number} red The red component of the background color, ranging from 0 to 1.
	 * @param {Number} green The green component of the background color, ranging from 0 to 1.
	 * @param {Number} blue Blue The blue component of the background color, ranging from 0 to 1.
	 * @returns {this}
	 * @since 1.3.1b
	 */

	/**
	 * Set the opacity of the render target's background color. By default, the render target is
	 * completely opaque.
	 * @param {Number} alpha The opacity of the render target's background color, ranging from 0
	 *		(fully transparent) to 1 (fully opaque).
	 * @returns {this}
	 * @since 1.3.1b
	 */
	setClearColorAlpha : function (alpha) {
		this._setClearColorAlphaSendGen(alpha);
		return this;
	},

	/**
	 * Save the render target's current visual state to the device's file system.
	 *
	 * To save the file in PNG format, specify a filename with the extension .png. To save the file
	 * in JPEG format, specify a filename with the extension .jpg.
	 * @example
	 * // Save a render target's current visual state to a PNG file. Clip the
	 * // image to a 128-pixel square that is centered on the render target.
	 * var renderTarget = new GL2.RenderTarget(256, 256);
	 * var rect = new Core.Rect(64, 64, 128, 128);
	 * renderTarget.save("render-target.png", rect, function(filename) {
	 *     console.log("Saved the render target as " + filename);
	 * });
	 * @param {String} filename The filename to use for the image. To save the file in PNG format,
	 * 		specify a filename with the extension .png. To save the file in JPEG format, specify a
	 *		filename with the extension .jpg.
	 * @param {Core.Rect} rect The rectangle that will be used to clip the render target. To output
	 *		the entire render target, set this parameter to `null`.
	 * @cb {Function} [callback] The function to call after saving the image.
	 * @cb-param {String} filename The filename that was used for the image.
	 * @cb-returns {void}
	 * @returns {void}
	 * @since 1.3.1b
	 */
	save : function (filename, rect, callback) {
		var id = 0;
		if (callback) {
			id = this._callbackIndexCounter++;
			this._callbacks[id] = callback;
		}
		var x = rect ? rect.getOrigin().getX() : -1;
		var y = rect ? rect.getOrigin().getY() : -1;
		var w = rect ? rect.getSize().getWidth() : -1;
		var h = rect ? rect.getSize().getHeight() : -1;
		this._saveSendGen(id, filename, x, y, w, h);
	},

	/**
	 * @private
	 */
	_invokeCallbackRecv: function (cmd)	{
		var msg = {};
		if (!this._invokeCallbackRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		var err = msg.error;
		if (!id) {
			NgLogE("invokeCallbackRecv command : bad id = " + id);
			return;
		}
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("invokeCallbackRecv command : No registered callback found, id = " + id);
			return;
		}
		delete this._callbacks[id];
		cb(err);
	},

	/**
	 * Specify whether to enable the render target's backing store. By default, the backing store is
	 * disabled.
	 *
	 * The backing store ensures that the render target will be drawn correctly after the
	 * application is suspended and resumed. If the backing store is not enabled, your application
	 * must call `{@link GL2.RenderTarget#update}` after the application resumes.
	 * @param {Boolean} [backingStoreEnable=true] Set to `true` to enable the backing store.
	 * @returns {this}
	 * @since 1.3.1b
	 */
	setBackingStoreEnable: function (backingStoreEnable) {
		var enable = (backingStoreEnable || (backingStoreEnable === undefined)) ? true : false;
		this._setBackingStoreEnableSendGen(enable);
		return this;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 353,
	// Method create = -1
	// Method destroy = 2
	// Method addChild = 3
	// Method removeChild = 4
	// Method update = 5
	// Method setAutoUpdate = 6
	// Method setClearEnable = 7
	// Method setClearColor = 8
	// Method setClearColorAlpha = 9
	// Method save = 10
	// Method invokeCallback = 11
	// Method setBackingStoreEnable = 12
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 11:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in RenderTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in RenderTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[353] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( objectRegistryId, width, height, isOpaque )
	{
		Core.Proc.appendToCommandString( 0x161ffff, [ +objectRegistryId, +width, +height, ( isOpaque ? 1 : 0 ) ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1610002, this );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x1610003, this, [ +child ] );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x1610004, this, [ +child ] );
	},
	
	/** @private */
	_updateSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1610005, this );
	},
	
	/** @private */
	_setAutoUpdateSendGen: function( autoUpdateEnable )
	{
		Core.Proc.appendToCommandString( 0x1610006, this, [ ( autoUpdateEnable ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setClearEnableSendGen: function( clearEnable )
	{
		Core.Proc.appendToCommandString( 0x1610007, this, [ ( clearEnable ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setClearColorSendGen: function( r, g, b )
	{
		Core.Proc.appendToCommandString( 0x1610008, this, [ +r, +g, +b ] );
	},
	
	/** @private */
	_setClearColorAlphaSendGen: function( a )
	{
		Core.Proc.appendToCommandString( 0x1610009, this, [ +a ] );
	},
	
	/** @private */
	_saveSendGen: function( callbackId, filename, originX, originY, width, height )
	{
		Core.Proc.appendToCommandString( 0x161000a, this, [ +callbackId, Core.Proc.encodeString( filename ), +originX, +originY, +width, +height ] );
	},
	
	/** @private */
	_setBackingStoreEnableSendGen: function( backingStoreEnable )
	{
		Core.Proc.appendToCommandString( 0x161000c, this, [ ( backingStoreEnable ? 1 : 0 ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( objectRegistryId, width, height, isOpaque ) {}
	
	// destroy: function(  ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// update: function(  ) {}
	
	// setAutoUpdate: function( autoUpdateEnable ) {}
	
	// setClearEnable: function( clearEnable ) {}
	
	// setClearColor: function( r, g, b ) {}
	
	// setClearColorAlpha: function( a ) {}
	
	// save: function( callbackId, filename, originX, originY, width, height ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	// setBackingStoreEnable: function( backingStoreEnable ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Animation'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Animation'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Animation'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Animation.js';

var Core = require('NGCore/Client/Core').Core;
var RenderTarget = require('NGCore/Client/GL2/RenderTarget').RenderTarget;


var Animation = exports.Animation = Core.Class.subclass(
/** @lends GL2.Animation.prototype */
{
	classname: 'Animation',

	/**
	 * @class The `GL2.Animation` class creates animations that are composed of one or more
	 * `{@link GL2.Animation.Frame}` objects, which define the contents and duration of each
	 * animation frame. To play an animation, attach it to a `{@link GL2.Primitive}` or
	 * `{@link GL2.Sprite}` object.
	 *
	 * Most of the properties that control how an animation frame is displayed, such as the texture
	 * wrap mode and blending mode, are defined by the `GL2.Animation` object. All of the
	 * animation's frames will use the same setting for these properties.
	 * `{@link GL2.Animation.Frame}` objects define the properties that vary between individual
	 * frames in an animation, such as the frame's duration and the image that is displayed in a
	 * frame.
	 *
	 * Use the `{@link GL2.MotionController}` and `{@link GL2.MotionData}` classes for tween-based
	 * animations of a static texture using keyframes.
	 *
	 * **Note**: You can call `{@link GL2.Animation.setTextureColorDepth}` to control the bit depth
	 * of uncompressed, truecolor textures that are used in animations. The value you specify will
     * apply to all animations. You must call this method after the `{@link UI.GLView}` object has
     * been initialized and before any `GL2` textures have been created.
	 * @constructs Create an animation.
	 * @augments Core.Class
	 */
    initialize: function()
    {
		Core.ObjectRegistry.register(this);

        this._wrapMode = this.WrapMode.WrapNone;
        this._blendEnabled = true;
        this._blendMode = this.BlendMode.Alpha;
        this._filteringEnabled = true;
		this._loopingEnabled = true;
		this._totalDuration = 0;
		this._frames = [];

		this._createSendGen(this.__objectRegistryId);
    },

	/**
	 * Destroy the animation, and release the resources allocated by the animation.
	 *
	 * **Important**: Destroying an animation does not destroy the animation's frames.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Retrieve the animation's texture wrap mode.
	 * @returns {GL2.Animation#WrapMode} The current texture wrap mode.
	 * @see GL2.Animation#setWrapMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getWrapMode: function()
	{
		return this._wrapMode;
	},

	/**
	 * Determine whether alpha blending is enabled for the animation.
	 * @returns {Boolean} Set to `true` if alpha blending is enabled.
	 * @see GL2.Animation#setBlendEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getBlendEnabled: function()
	{
		return this._blendEnabled;
	},

	/**
	 * Determine whether filtering is enabled for the animation.
	 * @returns {Boolean} Set to `true` if filtering is enabled.
	 * @see GL2.Animation#setFilteringEnabled
	 * @status Flash, Test, FlashTested
	 * @since 1.0
	 */
	getFilteringEnabled: function()
	{
		return this._filteringEnabled;
	},

	/**
	 * Determine whether looping is enabled for the animation.
	 * @returns {Boolean} Set to `true` if looping is enabled.
	 * @see GL2.Animation#setLoopingEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getLoopingEnabled: function()
	{
		return this._loopingEnabled;
	},

	/**
	 * Retrieve the animation's total duration, in milliseconds.
	 * @returns {Number} The animation's total duration, in milliseconds.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getTotalDuration: function()
	{
		return this._totalDuration;
	},

	/**
	 * Retrieve the total number of frames in the animation.
	 * @returns {Number} The total number of frames.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFrameCount: function()
	{
		return this._frames.length;
	},

	/**
	 * Retrieve the animation frame at the specified index.
	 * @param {Number} index The index of the frame to retrieve.
	 * @returns {GL2.Animation.Frame} The animation frame at the specified index.
	 * @see GL2.Animation#setFrame
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFrame: function(index)
	{
		return this._frames[index];
	},

    /**
	 * Set the animation's texture wrap mode. The texture wrap mode controls whether textures will
	 * be wrapped on the U and V dimensions of each animation frame. By default, the texture wrap
	 * mode is set to `{@link GL2.Animation#WrapMode.WrapNone}`, which clamps the texture on the U
	 * and V dimensions.
	 * @example
	 * var animation = new GL2.Animation();
	 * animation.setWrapMode(GL2.Animation.WrapMode.WrapUV);
	 * @param {GL2.Animation#WrapMode} wrapMode The new texture wrap mode for the animation.
	 * @returns {this}
	 * @see GL2.Animation#getWrapMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setWrapMode: function(wrapMode)
	{
		this._wrapMode = wrapMode;

		this._setWrapModeSendGen(wrapMode);

		return this;
	},

    /**
	 * Set whether alpha blending is enabled for the animation. Alpha blending is enabled by
	 * default.
	 *
	 * **Note**: If all of an animation's frames are opaque, disabling alpha blending can improve
	 * performance.
	 * @example
	 * var animation = new GL2.Animation();
	 * animation.setBlendEnabled(false);
	 * @param {Boolean} blendEnabled Set to `true` to enable alpha blending.
	 * @returns {this}
	 * @see GL2.Animation#getBlendEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setBlendEnabled: function(blendEnabled)
	{
		this._blendEnabled = blendEnabled;

		this._setBlendEnabledSendGen(blendEnabled);

		return this;
	},

	/**
	 * Set the animation's alpha blend mode. By default, the alpha blend mode is set to
	 * `{@link GL2.Animation#BlendMode.Alpha}`, which renders blended images differently based on
	 * the order in which they are drawn.
	 * @example
	 * var animation = new GL2.Animation();
	 * animation.setBlendMode(GL2.Animation.BlendMode.Add);
	 * @param {GL2.Animation#BlendMode} blendMode The new alpha blend mode for the animation.
	 * @see GL2.Animation#setBlendEnabled
	 * @returns {this}
	 * @status Android, Flash, AndroidTested
	 * @since 1.3.1b
	 */
	setBlendMode: function(blendMode)
	{
		this._blendMode = blendMode;

		this._setBlendModeSendGen(blendMode);

		return this;
	},

	getBlendMode: function()
	{
		return this._blendMode;
	},

    /**
	 * Set whether bilinear filtering is enabled for the animation, which improves the quality of
	 * each frame in the animation as the frame's image is scaled up or down. Bilinear filtering is
	 * enabled by default.
	 * @param {Boolean} filteringEnabled Set to `true` to enable bilinear filtering.
	 * @returns {this}
	 * @see GL2.Animation#getFilteringEnabled
	 * @status Flash
	 * @since 1.0
	 */
    setFilteringEnabled: function(filteringEnabled)
	{
		this._filteringEnabled = filteringEnabled;

		this._setFilteringEnabledSendGen(filteringEnabled);

		return this;
	},

    /**
	 * Set whether the animation will play in a loop. Looping is enabled by default.
	 * @param {Boolean} loopingEnabled Set as `true` to enable animation looping.
	 * @returns {this}
	 * @see GL2.Animation#getLoopingEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setLoopingEnabled: function(loopingEnabled)
	{
		this._loopingEnabled = loopingEnabled;

		this._setLoopingEnabledSendGen(loopingEnabled);

		return this;
	},

    /**
	 * Add a frame to the end of the animation. Calling this method is equivalent to calling
	 * `{@link GL2.Animation#spliceFrames}` in the following way:
	 *
	 *     animation.spliceFrames(animation.getFrameCount(), 0, frame);
	 * @example
	 * var animation = new GL2.Animation();
	 * var frame = new GL2.Animation.Frame("./Content/unicorn.png", 50,
	 *   new Core.Size(64, 64), new Core.Point(0.5, 0.5), new Core.Rect(0, 0, 0.5, 0.5));
	 * animation.pushFrame(frame);
	 * @param {GL2.Animation.Frame} frame The frame to add.
	 * @returns {this}
	 * @see GL2.Animation#setFrame
	 * @see GL2.Animation#spliceFrames
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    pushFrame: function(frame)
	{
		return this.spliceFrames(this._frames.length, 0, frame);
	},

    /**
	 * Replace the animation frame at a specified index. Calling this method is equivalent to
	 * calling `{@link GL2.Animation#spliceFrames}` in the following way:
	 *
	 *     animation.spliceFrames(i, 1, frame);
	 * @param {Number} i The index of the frame to replace.
	 * @param {GL2.Animation.Frame} frame The frame to insert.
	 * @returns {this}
	 * @see GL2.Animation#getFrame
	 * @see GL2.Animation#spliceFrames
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setFrame: function(i, frame)
	{
		return this.spliceFrames(i, 1, frame);
	},

    /**
	 * Remove a specified number of animation frames, and replace them with zero or more animation
	 * frames or render targets. You can pass any number of new frames and render targets to this
	 * method.
	 * @example
	 * // Create a new animation with four frames, then replace the third frame
	 * // with two new frames.
	 * var animation = new GL2.Animation();
	 *
	 * // The original images for the animation are contained in a sprite sheet
	 * // with four different sprites, arranged in a 2 x 2 grid.
	 * var frameSize = new Core.Size(64, 64);
	 * var anchor = new Core.Point(0.5, 0.5);
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/unicorn.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0, 0, 0.5, 0.5));
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/unicorn.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0.5, 0, 0.5, 0.5));
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/unicorn.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0, 0.5, 0.5, 0.5));
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/unicorn.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0.5, 0.5, 0.5, 0.5));
	 *
	 * // The new images are contained in a sprite sheet with two different sprites,
	 * // arranged horizontally.
	 * var newFrame1 = new GL2.Animation.Frame("./Content/shiny_unicorn.png", 50,
	 *   frameSize, anchor, new Core.Rect(0, 0, 0.5, 1));
	 * var newFrame2 = new GL2.Animation.Frame("./Content/shiny_unicorn.png", 50,
	 *   frameSize, anchor, new Core.Rect(0.5, 0, 0.5, 1));
	 *
	 * // Replace the third frame with the two new frames.
	 * animation.spliceFrames(2, 1, newFrame1, newFrame2);
	 * @example
	 * // Create a new animation with three frames, then remove the second frame.
	 * var animation = new GL2.Animation();
	 *
	 * // The images for the animation are contained in a sprite sheet with three
	 * // different sprites, arranged horizontally.
	 * var frameSize = new Core.Size(64, 64);
	 * var anchor = new Core.Point(0.5, 0.5);
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/monster.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0, 0, 0.333, 1));
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/monster.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0.333, 0, 0.333, 1));
	 * animation.pushFrame(new GL2.Animation.Frame("./Content/monster.png"), 50,
	 *   frameSize, anchor, new Core.Rect(0.666, 0, 0.333, 1));
	 *
	 * // Remove the second frame.
	 * animation.spliceFrames(1, 1);
	 * @param {Number} start The index of the first frame or render target to remove.
	 * @param {Number} len The total number of frames or render targets to remove.
	 * @param {GL2.Animation.Frame} [frames] The frame to insert.
	 *		To insert more than one frame, pass additional arguments to the method.
	 * @returns {this}
	 * @see GL2.Animation#pushFrame
	 * @see GL2.Animation#setFrame
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    spliceFrames: function(start, len, frames)
	{
		var i;
		var frameCount = arguments.length-2;
		var frame;

		// Determine if we should use the v2 version of the messsage, which supports renderTargets.
		// This is so that new javaScript that doesn't use renderTargets will still work with an old binary.
		var useV2 = false;
		for (i = 0; i < frameCount; ++i) {
			frame = arguments[i+2];
			if (frame && frame.getImage) {
				if (frame.getImage().classname === 'RenderTarget') {
					useV2 = true;
				}
			} else {
				return this;  // bad frame
			}
		}

		// Decrement from total duration.
		for (i=start; i < start + len; ++i) {
			this._totalDuration -= this._frames[i].getDuration();
		}

		this._frames.splice.apply(this._frames, arguments);

		if (useV2) {
			this._spliceFrames2SendGen(start, len, frameCount);
		} else {
			this._spliceFramesSendGen(start, len, frameCount);
		}

		for (i = 0; i < frameCount; ++i)
		{
			frame = arguments[i+2];
			var duration = frame.getDuration();
			var size = frame.getSize();
			var anchor = frame.getAnchor();
			var uvs = frame.getUVs();
			var uvOrigin = uvs.getOrigin();
			var uvSize = uvs.getSize();
			var image = frame.getImage();

			// if image is a renderTarget
			var renderTargetID = 0;
			if (image.classname === 'RenderTarget') {
				renderTargetID = image.__objectRegistryId;
				image = '';
			}

			if (useV2) {
				this._frame2SendGen(image,
									renderTargetID,
									duration,
									size.getWidth(),
									size.getHeight(),
									anchor.getX(),
									anchor.getY(),
									uvOrigin.getX(),
									uvOrigin.getY(),
									uvSize.getWidth(),
									uvSize.getHeight());
			} else {
				this._frameSendGen(image,
								   duration,
								   size.getWidth(),
								   size.getHeight(),
								   anchor.getX(),
								   anchor.getY(),
								   uvOrigin.getX(),
								   uvOrigin.getY(),
								   uvSize.getWidth(),
								   uvSize.getHeight());
			}
			this._totalDuration += duration;
		}

		return this;
	},

	/**
	 * Set the bit depth to use, in bits per pixel, for uncompressed, truecolor textures that are
	 * used in an animation. By default, each texture is drawn at its original bit depth.
	 *
	 * **Important**: You must call this static method after the `{@link UI.GLView}` object has been
	 * initialized and before any `GL2` textures have been created.
	 * @name GL2.Animation.setTextureColorDepth
	 * @function
	 * @static
	 * @example
	 * GL2.Animation.setTextureColorDepth(16);
	 * @param {Number} depth The bit depth to use, in bits per pixel, for uncompressed, truecolor
	 *		textures that are used in an animation. Use `16` to select 16bpp. Use `0` to draw the
	 *		texture at its original bit depth.
	 * @returns {void}
	 * @since 1.6
	 */

	$setTextureColorDepth: function(depth)
	{
		this._setTextureColorDepthSendGen(depth);
	},

	$Frame: Core.Class.subclass(
	/** @lends GL2.Animation.Frame.prototype */
	{
		classname: 'Frame',

		/**
		 * @class `GL2.Animation.Frame` objects define the properties of an individual frame in an
		 * animation, including the frame's source image, duration, size, and anchor point. You can
		 * also use sprite sheets by specifying that the animation frame should display only a
		 * portion of the source image.
		 * @constructs Create an animation frame.
		 * @example
		 * // Create an animation frame that contains the bottom right image in a
		 * // 3 x 3 sprite sheet.
		 * var frame = new GL2.Animation.Frame("./Content/unicorn.png"), 50,
		 *   new Core.Size(64, 64), new Core.Point(0.5, 0.5),
		 *   new Core.Rect(0.666, 0.666, 0.333, 0.333));
		 * @param {String|GL2.RenderTarget} image The directory path to an image, or an instance of
		 *		`{@link GL2.RenderTarget}`. If this parameter contains the path to an image, the
		 *		image must be in PNG (.png) or JPEG (.jpg) format; its dimensions must be a power of
		 *		two; it must be square; and it must be referenced in the `textures` or
		 *		`textures_encrypted` section of your application's manifest.
		 * @param {Number} duration The duration of the frame, in milliseconds.
		 * @param {Core.Size} size The size of the frame, in pixels. The frame will be scaled based
		 *		on its parent nodes' transformations.
		 * @param {Core.Point} [anchor=[0.5, 0.5]] The offset within the frame that defines the
		 *		anchor point for scaling and rotation. See `{@link GL2.Animation.Frame#getAnchor}`
		 *		for details. If you omit this parameter, you must also omit the `uvs` parameter.
		 * @param {Core.Rect} [uvs=[0, 0, 1, 1]] The image region to use for the frame. Specified in
		 *		UV coordinates ranging from 0 to 1, which represent a percentage of the original
		 *		image's width and height. The four coordinates represent the U origin, the V origin,
		 *		the U width, and the V height, in that order.
		 * @see GL2.Animation
		 * @augments Core.Class
		 * @since 1.0
		 */
		initialize: function(image, duration, size, anchor, uvs)
		{
			this._image     = image;
			this._duration  = duration || 0;
			this._size   = new Core.Size(size);

			if(anchor)
				this._anchor = new Core.Point(anchor);
			else
				this._anchor = new Core.Point(0.5, 0.5);

			if(uvs)
				this._uvs = new Core.Rect(uvs);
			else
				this._uvs = new Core.Rect(0, 0, 1, 1);
		},

		/**
		 * Retrieve the image contained in the animation frame. The returned value will be either
		 * the path to an image or a `{@link GL2.RenderTarget}` object.
		 * @returns {String|GL2.RenderTarget} The path to the animation frame's image, or a
		 *		`{@link GL2.RenderTarget}` object.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getImage:    function()
		{
			return this._image;
		},

		/**
		 * Retrieve the duration of the animation frame, in milliseconds.
		 * @returns {Number} The duration of the frame, in milliseconds.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getDuration:  function()
		{
			return this._duration;
		},

		/**
		 * Retrieve the size of the animation frame, in pixels.
		 * @returns {Core.Size} The size of the frame, in pixels.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getSize:    function()
		{
			return this._size;
		},

		/**
		 * Retrieve the offset of the animation frame's anchor point. The anchor point defines the
		 * origin of any scaling or rotation that is applied to the frame. Its offset is defined as
		 * a multiple of the frame's width and height. For example, the default anchor offset,
		 * `[0.5, 0.5]`, represents a point that is centered on the U and V axes.
		 *
		 * **Note**: The anchor point is calculated before transformations are applied to the
		 * animation frame.
		 * @returns {Core.Point} The offset of the frame's anchor point.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getAnchor:  function()
		{
			return this._anchor;
		},

		/**
		 * Retrieve the image region, in UV coordinates, to use for the animation frame.
		 * @returns {Core.Rect} The image region for the frame.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getUVs:    function()
		{
			return this._uvs;
		}
	}),

	/**
	 * Enumeration for UV wrapping modes.
	 * @name WrapMode
	 * @fieldOf GL2.Animation#
	 */

	/**
	 * Clamp in both U and V.
	 * @name WrapMode.WrapNone
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

	/**
	 * Wrap in U, clamp in V.
	 * @name WrapMode.WrapU
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

	/**
	 * Wrap in V, clamp in U.
	 * @name WrapMode.WrapV
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

	/**
	 * Wrap in both U and V.
	 * @name WrapMode.WrapUV
	 * @fieldOf GL2.Animation#
	 * @constant
	 */


	/**
	 * Enumeration for alpha blend modes.
	 * @name BlendMode
	 * @fieldOf GL2.Animation#
	 */

	/**
	 * Use the blending function `(SourceColor * SourceAlpha) + (DestinationColor * (1 -
	 * SourceAlpha))`. For example, if the source color has an alpha of 0.6, it will contribute 60%
	 * of the blended color, and the destination color will contribute 40% of the blended color.
	 * Blended images will be rendered differently based on the order in which they are drawn.
	 * @name BlendMode.Alpha
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

	/**
	 * Use the blending function `(SourceColor * SourceAlpha) + (DestinationColor * 1)`. The source
	 * color's red, green, and blue values are adjusted based on their alpha values, then added to
	 * the destination color's red, green, and blue values. Blended images will be rendered the same
	 * way regardless of the order in which they are drawn.
	 * @name BlendMode.Add
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

	/**
	 * Use the blending function `(DestinationColor * 1) - (SourceColor * SourceAlpha)`. The source
	 * color's red, green, and blue values are adjusted based on their alpha values, then subtracted
	 * from the destination color's red, green, and blue values. Blended images will be rendered
	 * differently based on the order in which they are drawn.
	 * @name BlendMode.Subtract
	 * @fieldOf GL2.Animation#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	WrapMode:
	{ 
		WrapNone: 0,
		WrapU: 1,
		WrapV: 2,
		WrapUV: 3
	},
	
	BlendMode:
	{ 
		Alpha: 1,
		Add: 2,
		Subtract: 3
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 306,
	// Method create = -1
	// Method destroy = 2
	// Method setWrapMode = 3
	// Method setBlendEnabled = 4
	// Method setLoopingEnabled = 5
	// Method spliceFrames = 6
	// Method frame = 7
	// Method setFilteringEnabled = 8
	// Method spliceFrames2 = 9
	// Method frame2 = 10
	// Method setBlendMode = 11
	// Method setTextureColorDepth = -12
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Animation._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Animation._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[306] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x132ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1320002, this );
	},
	
	/** @private */
	_setWrapModeSendGen: function( wrapMode )
	{
		Core.Proc.appendToCommandString( 0x1320003, this, [ +wrapMode ] );
	},
	
	/** @private */
	_setBlendEnabledSendGen: function( blendEnabled )
	{
		Core.Proc.appendToCommandString( 0x1320004, this, [ ( blendEnabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	_setLoopingEnabledSendGen: function( loopingEnabled )
	{
		Core.Proc.appendToCommandString( 0x1320005, this, [ ( loopingEnabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	_spliceFramesSendGen: function( start, len, frameCount )
	{
		Core.Proc.appendToCommandString( 0x1320006, this, [ +start, +len, +frameCount ] );
	},
	
	/** @private */
	_frameSendGen: function( image, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV )
	{
		Core.Proc.appendSubcommandToCommandString( [ Core.Proc.encodeString( image ), +duration, +width, +height, +anchorX, +anchorY, +startU, +startV, +sizeU, +sizeV ] );
	},
	
	/** @private */
	_setFilteringEnabledSendGen: function( filteringEnabled )
	{
		Core.Proc.appendToCommandString( 0x1320008, this, [ ( filteringEnabled ? 1 : 0 ) ] );
	},
	
	/** @private */
	_spliceFrames2SendGen: function( start, len, frameCount )
	{
		Core.Proc.appendToCommandString( 0x1320009, this, [ +start, +len, +frameCount ] );
	},
	
	/** @private */
	_frame2SendGen: function( image, renderTargetID, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV )
	{
		Core.Proc.appendSubcommandToCommandString( [ Core.Proc.encodeString( image ), +renderTargetID, +duration, +width, +height, +anchorX, +anchorY, +startU, +startV, +sizeU, +sizeV ] );
	},
	
	/** @private */
	_setBlendModeSendGen: function( blendMode )
	{
		Core.Proc.appendToCommandString( 0x132000b, this, [ +blendMode ] );
	},
	
	/** @private */
	$_setTextureColorDepthSendGen: function( depth )
	{
		Core.Proc.appendToCommandString( 0x132fff4, [ +depth ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setWrapMode: function( wrapMode ) {}
	
	// setBlendEnabled: function( blendEnabled ) {}
	
	// setLoopingEnabled: function( loopingEnabled ) {}
	
	// spliceFrames: function( start, len, frameCount ) {}
	
	// frame: function( image, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV ) {}
	
	// setFilteringEnabled: function( filteringEnabled ) {}
	
	// spliceFrames2: function( start, len, frameCount ) {}
	
	// frame2: function( image, renderTargetID, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV ) {}
	
	// setBlendMode: function( blendMode ) {}
	
	// $setTextureColorDepth: function( depth ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/EmitterData'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/EmitterData'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/EmitterData'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/EmitterData.js';

////////////////////////////////////////////////////////////////////////////////
// Class EmitterData
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;


////////////////////////////////////////////////////////////////////////////////

var EmitterData = exports.EmitterData = Core.Class.subclass(
/** @lends GL2.EmitterData.prototype */
{
    classname: 'EmitterData',
    /**
     * @class The `EmitterData` class stores particle effect definition data that multiple `{@link GL2.Emitter}` objects can reference.
     *
     * Currently the only supported `EmitterData` format is `GravityEmitterData`.
     *
     *
     * ###GravityEmitterData JSON format for GL2.EmitterData###
     *
     * ####Overview####
     *
     * GL2.EmitterData uses a block of JSON to describe the behavior of a particle emitter system.
     * It is passed to a GL2.EmitterData object using the initFromData or initFromJSONFile.
     * Additionally, the mergeData call can be used to dynamically update data fields in real-time.
     *
     *
     * The GravityEmitterData form expects a valid JSON block of a single object with a 
     * set of key value pairs, wherein the keys must be strings.
     *
     *
     * The following caveats apply:
     *
     * 
     * + If a recognized key is not present, a default value is chosen for that key.</li>
     * + If an unknown key is present in the JSON, it is ignored.</li>
     * + If the value for a specific field is an unexpected type, an error is returned in the callback.</li>
     * + If there is a JSON parse error, an error is returned in the callback.</li>
     * 
     *
     * ####Recognized Keys####
     *
     * In general, keys that affect a particular attribute of the particle system will have the same prefix.
     * For example: all keys starting with "rotation_" will affect the rotation of each particle.
     *
     * ####Example JSON description of an explosion effect####
     *
     * <pre>
     * {
     *     "emitShape_type": "circle",
     *     "emitShape_circle_innerRadius": 0,
     *     "emitShape_circle_outerRadius": 20,
     *     "initVel_angle": 0,
     *     "initVel_angleDelta": 180,
     *     "initVel_speedMin": 30,
     *     "initVel_speedMax": 150,
     *     "physics_accel": [0, 200],
     *     "physics_radialAccel": 0,
     *     "physics_tangentialAccel": 0,
     *     "physics_dragCoeff": 2.0,
     *     "color_type": "randAnim",
     *     "color_randAnim_startMin": [0.5, 0.0, 0.0],
     *     "color_randAnim_startMax": [1.0, 1.0, 0.0],
     *     "color_randAnim_endMin": [0.5, 0.0, 0.0],
     *     "color_randAnim_endMax": [1.0, 0.0, 0.0],
     *     "alpha_type": "fade",
     *     "alpha_fade_in": 0.0,
     *     "alpha_fade_out": 0.5,
     *     "rotation_angle": 0,
     *     "rotation_spinRateMin": -2000,
     *     "rotation_spinRateMax": -1000,
     *     "rotation_alignToVelocity": false,
     *     "attractor_type": "none",
     *     "attractor_position": [0, 100],
     *     "attractor_falloff": "linear",
     *     "attractor_strength": 1,
     *     "size_type": "rand",
     *     "size_preserveAspectRatio": true,
     *     "size_aspectRatio": 1.0,
     *     "size_rand_min": [3, 3],
     *     "size_rand_max": [7, 7],
     *     "texture_type": "randPick",
     *     "texture_randPick": [{ "image": "Content/ballfx.png", "uvMin": [0.25, 0.5], "uvMax": [0.5, 0.75], "magFilter": "linear" },
     *                          { "image": "Content/ballfx.png", "uvMin": [0.75, 0.25], "uvMax": [1, 0.5], "magFilter": "linear" }],
     *     "emitter_position": [0, 0],
     *     "emitter_duration": 0,
     *     "emitter_lifetimeMin": 0.5,
     *     "emitter_lifetimeMax": 1.5,
     *     "emitter_rate": 70,
     *     "emitter_maxParticles": 70,
     *     "emitter_sortOrder": "none",
     *     "emitter_blendMode": "alpha",
     *     "emitter_freeParticles": true
     * }
     * </pre>
     *
     * ###Emitter###
     *
     * These values control the number and rate at which particles are emitted, as well as 
     * other properties which describe the lifetime of each particle, the sorting order, 
     * blend mode and coordinate frame.
     *
     * + `emitter_position` {[Number, Number]} - The origin of the emitter, in the local frame of the GL2.Emitter node. Default: [0, 0]
     * + `emitter_duration` {Number} - The amount of time particles will be emitted after `GL2.Emitter.play()` is called.
     *   0 indicates all particles are spawned at once. -1 indicates infinite spawning of particles. Default: 3.
     * + `emitter_lifetimeMin` {Number} - The minimum lifetime of a particle.  The lifetime of a specific particle is be randomly chosen, between the min and max. Default: 1
     * + `emitter_lifetimeMax` {Number} - The minimum lifetime of a particle.  The lifetime of a specific particle is be randomly chosen, between the min and max. Default: 2
     * + `emitter_rate` {Number} - When playing a GL2.Emitter will emit particles at this rate, in particles per second. Default: 20
     * + `emitter_maxParticles` {Number} - The total number of particles rendered and simulated is capped by this number.
     *   Increasing this number will increase both the memory used by the particle system and increase the CPU cost of playing it. Default: 50
     * + `emitter_freeParticles` {Boolean} - When a particle is spawned by the particle system on a moving GL2.Emitter it can either follow the motion of the emitter, or not.
     *   Setting this to false will cause all particles to follow changes in the GL2.Emitter transform. Default: false
     * + `emitter_sortOrder` {String} - When particles are drawn, some particles can be drawn on top of other particles from the same emitter.
     *   This parameter gives you the ability to set the sorting order. Default: "none"
     *     + "none" - no sorting
     *     + "oldestOnTop" - older particles will draw over of younger ones.
     *     + "newestOnTop" - new particles will draw over older ones.
     * + `emitter_blendMode` {String} - Used to control how each particle blends with the frame-buffer. Default: "alpha"
     *     + "opaque" - no blending at all.
     *     + "alpha" - alpha blending
     *     + "preMultipliedAlpha" - mix between alpha and additive blending.
     *     + "add" - additive blending.
     *     + "subtract" - subtractive blending.
     *
     * ###EmitShape###
     *
     * These values control where new particles are created.
     * Particles are created at a random position within the specified emitShape.
     * These values are in the GL2.Emitter coordinate frame; however, they can be offset 
     * using the `emitter_position` key.
     *
     * + `emitShape_type` {String} - type of volume. Default: "box"
     *     + "box" - Particles are spawned within an axis aligned box, the box size is specified by the `emitShape_box_max` and `emitShape_box_min` values.
     *     + "line" - Particles are spawned along the given line, the size of the line is specified by the `emitShape_line_length`, `emitShape_line_thickness` and `emitShape_line_angle` values.
     *     + "circle" - Particles are spawned within a circle, the size of the circle is specified by the `emitShape_circle_innerRadius` and `emitShape_circle_outerRadius` values.
     * + `emitShape_box_min` {[Number, Number]} - minimum values for the box, the first is in the x-dimension the second in the y-dimension. Default: [-50, -50]
     * + `emitShape_box_max` {[Number, Number]} - maximum values for the box, the first is in the x-dimension the second in the y-dimension. Default: [50, 50]
     * + `emitShape_line_length` {Number} - length of line.  Line is centered at `emitter_position`. Default: 100
     * + `emitShape_line_thickness` {Number} - thickness of line. Default: 10
     * + `emitShape_line_angle` {Number} - Angle of line in degrees.  0 indicates a horizontal line.
     *   Other angles will rotate it about its center at `emitter_position`. Default: 0
     *
     * ###InitVel###
     *
     * These values control the initial velocity of a particle when it is created.
     *
     * + `initVel_angle` {Number} - Angle in degrees, that specify the direction of travel. Default: 0
     * + `initVel_angleDelta` {Number} - Starting angle is randomized plus or minus this angle. Default: 10
     * + `initVel_speedMin` {Number} - Minimum speed of particle. Actual speed will be randomized between min and max. Default: 10
     * + `initVel_speedMax` {Number} - Maximum speed of particle. Actual speed will be randomized between min and max. Default: 20
     *
     * ###Physics###
     *
     * These values control how a particle accelerates or decelerates over time.
     *
     * + `physics_accel` {[Number, Number]} - Acceleration vector in GL2.Emitter local coordinate frame. Default: [0, 0]
     * + `physics_radialAccel` {Number} - Acceleration toward (negative values) or away from the origin, in GL2.Emitter local coordinate frame. Default: 0
     * + `physics_tangentialAccel` {Number} - Acceleration clockwise or counter-clockwise around the origin, in GL2.Emitter local coordinate frame. Default: 0
     * + `physics_dragCoeff` {Number} - Drag coefficient. Larger values will increase drag, smaller values will decrease it.  A value of 0 will disable drag.
     *   Drag is applied according to this equation: a = -k * v + g, where a is the acceleration applied to the particle, 
     *   k is the dragCoefficient, v is the velocity of the particle, and g is acceleration due to "gravity", which is the value from `physics_accel`.
     *   Note: enabling drag will increase CPU load when the effect is played. Default: 0
     *
     * ###Color###
     *
     *
     * These values control the color of a particle over time.
     *
     *
     * + `color_type` {String} Default: "constant"
     *     + "constant" - All particles will have the same color, specified by the `color_constant` key.
     *     + "rand" - A particle color will be randomly chosen between `color_rand_min` and `color_rand_max`.
     *     + "randAnim" - The particle start and end color will be randomly chosen. The color will change from the start color to the end color over the lifetime of the particle.
     *     + "keyframes" - The particle color is determines by a set of key frames.
     * + `color_constant` {[Number, Number, Number]} - Constant color of a particle.  Only active if `color_type` is "constant". Default: [1, 1, 1]
     * + `color_rand_min` {[Number, Number, Number]} - Minimum value for each color channel. Only active if `color_type` is "rand". Default: [1, 1, 1]
     * + `color_rand_max` {[Number, Number, Number]} - Maximum value for each color channel. Only active if `color_type` is "rand". Default: [1, 1, 1]
     * + `color_randAnim_startMin` {[Number, Number, Number]} - Minimum start value for each color channel. Only active if `color_type` is "randAnim". Default: [1, 1, 1]
     * + `color_randAnim_startMax` {[Number, Number, Number]} - Maximum start value for each color channel. Only active if `color_type` is "randAnim". Default: [1, 1, 1]
     * + `color_randAnim_endMin` {[Number, Number, Number]} - Minimum end value for each color channel. Only active if `color_type` is "randAnim". Default: [1, 1, 1]
     * + `color_randAnim_endMax` {[Number, Number, Number]} - Maximum end value for each color channel. Only active if `color_type` is "randAnim". Default: [1, 1, 1]
     * + `color_keyframes` {[{"key": Number, "value": [Number, Number, Number]}, ...]} - An array of keyframe objects.  Default: []
     *
     *   Each keyframe is an object with two keys:
     *
     *
     *   + "key" {Number} - a value from (0, 1) where 0 is the beginning of a particles lifetime and 1 is the end.
     *   + "value" - {[Number, Number, Number]} - the color desired at that time.
     *
     * ###Alpha###
     *
     * These values control the transparency of a particle over time.
     *
     * + `alpha_type` {String} Default: "fade"
     *     + "constant" - All particles will have a constant transparency value, specified by `alpha_constant`.
     *     + "fade" - Particles will fade in from transparent to opaque, then back to transparent.
     *     + "keyframe" - The particle transparency is determined by a set of key-frames.
     * + `alpha_constant` {Number} - Particle transparency (0 transparent, 1 opaque). Only active if `alpha_tpe` is "constant". Default: 1
     * + `alpha_fade_in` {Number} - Value specifying when particle will become opaque after being created.
     *   This value is from 0 to 1, where 0 is the beginning of a particle lifetime and 1 is the end.
     *   Only active if particle type is "fade".  Default: 0.1
     * + `alpha_fade_out` {Number} - Value specifying when particle will start becoming transparent before becoming fully transparent at the end of the particles lifetime.
     *   This value is from 0 to 1, where 0 is the beginning of a particle lifetime and 1 is the end.
     *   Only active if particle type is "fade".  Default: 0.9
     * + `alpha_keyframes` {[{"key": Number, "value": Number}, ...]} - An array of keyframe objects. Default: []
     *
     *   Each keyframe is an object with two keys:
     *     + "key" {Number} - a value from (0, 1) where 0 is the beginning of a particles lifetime and 1 is the end.
     *     + "value" - {Number} - the transparency value desired at that time.
     *
     * ###Rotation###
     *
     * These values control the rotation of a particle over time.
     *
     * + `rotation_angle` {Number} - Number in degrees, 0 indicates no rotation, positive numbers are clockwise rotations. Default: 0
     * + `rotation_spinRateMin` {Number} - Number in degrees per second. Actual particle spin rate will be chosen randomly between min and max. Default: 0
     * + `rotation_spinRateMax` {Number} - Number in degrees per second. Actual particle spin rate will be chosen randomly between min and max. Default: 0
     * + `rotation_alignToVelocity` {Boolean} - If true the rotation of the particle will be aligned with its velocity. Default: false
     *
     * ###Attractor###
     *
     * The particles within the particle system can be attracted to a specific position over time.
     *
     *
     * + `attractor_type` {String} Default: "none"
     *     + "none" - Attractor is disabled.
     *     + "local" - Attractor is specified in GL2.Emitter local coordinates.
     * + `attractor_position` {[Number, Number]} - position of GL2.Emitter. Default: [0, 0]
     * + `attractor_falloff` {String} - A particle is slowly attracted to the `attractor_position` over time.
     *   This parameter controls how fast or slow this attraction takes place. Default: "linear"
     *     + "linear" - particles move at a constant rate.
     *     + "easeIn" - particles start slowly and accelerate as they approach the destination
     *     + "easeOut" - particles start fast and decelerate as they approach the destination
     *     + "parabolic" - particles start fast, decelerate as they approach the midpoint, then accelerate as they approach the destination
     * + `attractor_strength` {Number} - Using this you can control the strength of the 
     *    attractor. When the value is 1 particles are guaranteed to end exactly on the 
     *    `attractor_position`. When the value is 0 there will be no attraction at all.
     *
     * ###Size###
     *
     * These values control the size of a particle over time.
     *
     * + `size_type` {String} Default: "constant"
     *     + "constant" - Particles will only have a single size specified by the `size_constant` value.
     *     + "rand" - Particle sizes will be randomly chosen between `size_rand_min` and `size_rand_max`.
     *     + "randAnim" - Particle sizes will be animated between a randomly determined start and end size.
     *     + "keyframes" - Particle size will specified by an array of keyframes.
     * + `size_preserveAspectRatio` {Boolean} - When true all particle sizes will have the aspect ratio. Default: false
     * + `size_aspectRatio` {Number} - The aspect ratio, (width / height) of each particle. Only takes effect if `size_preserveAspectRatio` is true. Default: 1
     * + `size_constant` {[Number, Number]} - The size of a particle. Only takes effect if `size_type` is "constant". Default: [10, 10]
     * + `size_rand_min` {[Number, Number]} - The minimum size of a particle. Only takes effect if `size_type` is "rand". Default: [10, 10]
     * + `size_rand_max` {[Number, Number]} - The maximum size of a particle. Only takes effect if `size_type` is "rand". Default: [10, 10]
     * + `size_randAnim_startMin` {[Number, Number]} - The minimum size of a particle's starting size. Only takes effect if `size_type` is "randAnim". Default: [10, 10]
     * + `size_randAnim_startMax` {[Number, Number]} - The maximum size of a particle's starting size. Only takes effect if `size_type` is "randAnim". Default: [10, 10]
     * + `size_randAnim_endMin` {[Number, Number]} - The minimum size of a particle's ending size. Only takes effect if `size_type` is "randAnim". Default: [10, 10]
     * + `size_randAnim_endMax` {[Number, Number]} - The maximum size of a particle's ending size. Only takes effect if `size_type` is "randAnim". Default: [10, 10]
     * + `size_keyframes` {[{"key": Number, "value": [Number, Number]}, ...]} - An array of keyframe objects. Default: []
     *   Each keyframe is an object with two keys:
     *     + "key" {Number} - a value from (0, 1) where 0 is the beginning of a particle's lifetime and 1 is the end.
     *     + "value" - {[Number, Number]} - the size value desired at that time.
     *
     * ###Texture###
     *
     * These values control textures used on a particle over time.
     * A texture object is a JSON block with the the following fields:
     *
     * + `image` {String} - filename of texture. Default: ""
     * + `uvMin` {[Number, Number]} - upper left hand corner of the particle texture in uv space.
     *   This can be used to select sub-rectangle within a sprite sheet. Default: [0, 0]
     * + `uvMax` {[Number, Number]} - lower right hand corner of the particle texture in uv space.
     *   This can be used to select sub-rectangle within a sprite sheet. Default: [1, 1]
     * + `uWrap` {String} - applies to x or u coordinate of the texture only. Default: "clampToEdge"
     *     + "clampToEdge" - any u value outside of the texture will be clamped to the color at the edge of the texture.
     *     + "wrap" - any u value outside of the texture will be wrapped.
     * + `vWrap` {String} - applies to y or v coordinate of the texture only. Default: "clampToEdge"
     *     + "clampToEdge" - any v value outside of the texture will be clamped to the color at the edge of the texture.
     *     + "wrap" - any v value outside of the texture will be wrapped.
     * + `minFilter` {String} - how filtering occurs when texture is minified, i.e. is smaller than the screen resolution. Default: "linear"
     *     + "nearest" - this nearest texel value is chosen.
     *     + "linear" - the texel value is computing by averaging the four nearest texels.
     * + `magFilter` {String} - how filtering occurs when texture is magnified, i.e. is larger than screen resolution. Default: "linear"
     *     + "nearest" - this nearest texel value is chosen.
     *     + "linear" - the texel value is computing by averaging the four nearest texels.
     *
     * These fields take a texture object as a parameter:
     *
     * + `texture_type` {String} Default: "none"
     *     + "constant" - Each particle has the same texture, specified by `texture_constant`.
     *     + "randPick" - Each particle has a single texture, chosen at random from a set of textures.
     *     + "keyframes" - Each particle animates through a series of textures.
     *     + "none" - particle is an untextured solid square
     * + `texture_constant` {Object} - Describes particle texture used for all particles.  Only used if `texture_type` is "constant".
     * + `texture_randPick` {[Object, ...]} - An array of objects that describe a texture.
     * + `texture_keyframes` {[{"key": Number, "value": Object}, ...]} - An array of keyframes.
     *   Each keyframe is an object with two keys:
     *     + "key" {Number} - a value from (0, 1) where 0 is the beginning of a particles lifetime and 1 is the end.
     *     + "value" - {Object} - the texture object desired at that time.
     *
     * @constructs The default constructor.
     * @augments Core.Class
     * @since 1.8
     */
    initialize: function ()
    {
        Core.ObjectRegistry.register(this);
        this._createSendGen(this.__objectRegistryId);
        this._callbackIndexCounter = 1;
        this._callbacks = [];
    },

    /**
     * Destroys this `EmitterData` object.
     * When you call `destroy` on a `EmitterData` object that is referred to by existing `{@link GL2.Emitter}`
     * objects, the `EmitterData` object is not destroyed until the last referring `{@link GL2.Emitter}` object is destroyed.
     * @returns {void}
     * @since 1.8
     * @status iOS, Android, Flash
     */
    destroy: function ()
    {
        this._destroySendGen();
        Core.ObjectRegistry.unregister(this);
    },

    /**
     * Verifies that `dataFormat` is a legal `EmitterData.DataFormat` enum.
     * @param {GL2.EmitterData.DataFormat} dataFormat The data format to check. Currently, only GL2.EmitterData.GravityEmitterData is supported.
     * @returns {Boolean}
     * @since 1.8
     * @status iOS, Android, Flash
     */
    isDataFormatSupported: function (dataFormat)
    {
        if (Core.Capabilities.meetsBinaryVersion && Core.Capabilities.meetsBinaryVersion([1,8,0,0,0])) {
            return dataFormat === EmitterData.DataFormat.GravityEmitterData;
        } else {
            return false;
        }
    },

    /**
     * Initialize this `EmitterData` object with particle system data in a given format.
     * This will completely erase and replace all existing data currently used by this `EmitterData`.
     * If you wish to only modify a subset of the existing data, not replace all of it, use the {@link GL2.EmitterData#mergeData} method instead.
     * The callback will be evoked when data parsing is complete or in the event of an error.
     * The callback is called with two arguments an error object with a code and description fields, as well as the `EmitterData` object itself.
     * @param {Object | String} dataOrJSONString A data object or a string in JSON format
     * @param {GL2.EmitterData.DataFormat} dataFormat The data format of the dataOrJSONString argument
     * @cb {Function} callback Called in the case of an error when reading the object or string
     * @cb-param {Object} error Error object detailing the parse error
     * @cb-param {GL2.EmitterData.ErrorCode} error.code 
     * @cb-param {String} error.description Description of the error
     * @cb-returns {void}
     * @returns {GL2.EmitterData}
     * @since 1.8
     * @status iOS, Android, Flash
     */
    initFromData: function (dataOrJSONString, dataFormat, callback)
    {
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof dataOrJSONString === 'string' || typeof dataOrJSONString === 'object') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				if (typeof dataOrJSONString === 'string') {
					this._initFromDataSendGen(dataOrJSONString, dataFormat, id);
				} else {
					this._initFromDataSendGen(JSON.stringify(dataOrJSONString), dataFormat, id);
				}
			} else {
				if (callback && typeof callback === 'function') {
					callback({ code: EmitterData.ErrorCode.TypeError, description: "Expected Object or String" }, this);
				}
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback({ code: EmitterData.ErrorCode.UnsupportedFormat, description: "Data Format Not Supported" }, this);
			}
		}
		return this;
	},

    /**
     * Change a subset of this `EmitterData` object properties. This will only change the data specified.
     * Any unspecified data will not be changed.  This can be used to apply delta updates.
     * @param {Object | String} dataOrJSONString A data object or a string in JSON format
     * @returns {this}
     * @since 1.8
     * @status iOS, Android, Flash
     */
    mergeData: function (dataOrJSONString)
    {
        if (typeof dataOrJSONString === 'string') {
            this._mergeDataSendGen(dataOrJSONString);
        } else {
            this._mergeDataSendGen(JSON.stringify(dataOrJSONString));
        }
        return this;
    },

    /**
     * Initialize this `EmitterData` object with particle system data in the given format from a JSON formatted file.
     * This will completely erase and replace all existing data currently used by this `EmitterData`.
     * The callback will be envoked when data parsing is complete or in the case of an error.
     * @example
     * ed.initFromJSONFile('Content/explosion.json', GL2.EmitterData.DataFormat.GravityEmitterData, function (error, ed) {
     *     if (error) {
     *         console.log("error.code = " + error.code + ", error.description = " + error.description);
     *         throw new Error(error.description);
     *     } else {
     *         console.log('success!');
     *     }
     * });
     * @param {String} filename The path to the file relative to the game root
     * @param {GL2.EmitterData.DataFormat} dataFormat The data format of the file argument
     * @cb {Function} callback Called in the case of an error when reading the object or string
     * @cb-param {Object} error Error object detailing the parse error
     * @cb-param {GL2.EmitterData.ErrorCode} error.code 
     * @cb-param {String} error.description Description of the error
     * @cb-returns {void}
     * @returns {GL2.EmitterData}
     * @since 1.8
     * @status iOS, Android, Flash
     */
    initFromJSONFile: function (filename, dataFormat, callback)
    {
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof filename === 'string') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				this._initFromJSONFileSendGen(filename, dataFormat, id);
			} else {
				callback({ code: EmitterData.ErrorCode.InvalidFilename, description: "Invalid filename" }, this);
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback({ code: EmitterData.ErrorCode.UnsupportedFormat, description: "Data Format Not Supported" }, this);
			}
		}
		return this;
	},

    /**
     * @private
     */
    _invokeCallbackRecv: function (cmd) {
        var msg = {};
        if (!this._invokeCallbackRecvGen(cmd, msg)) {
            return;
        }

        var id = msg.callbackId;
        if (!id) {
            NgLogE("GL2.EmitterData._invokeCallbackRecv command : bad id = " + id);
            return;
        }
        var cb = this._callbacks[id];
        if (!cb) {
            NgLogE("GL2.EmitterData._invokeCallbackRecv command : No registered callback found, id = " + id);
            return;
        }
        delete this._callbacks[id];
        if (msg.description) {
            // pass error to callback
            cb({ code: msg.code, description: msg.description }, this);
        } else {
            // no error, pass null to callback
            cb(null, this);
        }
    },

// {{?Wg Generated Code}}
	
	// Enums.
	DataFormat:
	{ 
		GravityEmitterData: 0
	},
	
	ErrorCode:
	{ 
		TypeError: 0,
		UnsupportedFormat: 1,
		InvalidFilename: 2,
		ParseError: 3,
		DataError: 4
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 367,
	// Method create = -1
	// Method destroy = 2
	// Method initFromData = 3
	// Method initFromJSONFile = 4
	// Method invokeCallback = 5
	// Method mergeData = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in EmitterData._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in EmitterData._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[367] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in EmitterData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in EmitterData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "description" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "description" ] === undefined )
		{
			NgLogE("Could not parse description in EmitterData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "code" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "code" ] === undefined )
		{
			NgLogE("Could not parse code in EmitterData.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( id )
	{
		Core.Proc.appendToCommandString( 0x16fffff, [ +id ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16f0002, this );
	},
	
	/** @private */
	_initFromDataSendGen: function( emitterData, dataFormat, callbackId )
	{
		Core.Proc.appendToCommandString( 0x16f0003, this, [ Core.Proc.encodeString( emitterData ), +dataFormat, +callbackId ] );
	},
	
	/** @private */
	_initFromJSONFileSendGen: function( filename, dataFormat, callbackId )
	{
		Core.Proc.appendToCommandString( 0x16f0004, this, [ Core.Proc.encodeString( filename ), +dataFormat, +callbackId ] );
	},
	
	/** @private */
	_mergeDataSendGen: function( emitterData )
	{
		Core.Proc.appendToCommandString( 0x16f0006, this, [ Core.Proc.encodeString( emitterData ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( id ) {}
	
	// destroy: function(  ) {}
	
	// initFromData: function( emitterData, dataFormat, callbackId ) {}
	
	// initFromJSONFile: function( filename, dataFormat, callbackId ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	// mergeData: function( emitterData ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Emitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Emitter'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Emitter'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Emitter.js';

////////////////////////////////////////////////////////////////////////////////
// Class Emitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;
var Node = require('NGCore/Client/GL2/Node').Node;
var EmitterData = require('NGCore/Client/GL2/EmitterData').EmitterData;


////////////////////////////////////////////////////////////////////////////////

var Emitter = exports.Emitter = Node.subclass(
/** @lends GL2.Emitter.prototype */
{
	classname: 'Emitter',

	/**
	 * @class The `GL2.Emitter` class is a `{@link GL2.Node}` that can play a particle effect defined by a `{@link GL2.EmitterData}` object.
	 *
	 * `{@link GL2.EmitterData}` objects are associated with the `Emitter` using the 
	 * `setData` method. Once `EmitterData` is associated with the Emitter, the particle
	 * effect can be played by calling the `play` method or stopped by using the `stop` 
	 * method. The application can be notified when the particle system has stopped emitting 
	 * particles by registering a callback with the `onDoneCallback` method.
	 * Similarly, the application can be notified when all the particles in the system 
	 * have been killed (i.e. no longer visible) by using the `onDeadCallback` method.
	 *
	 * All particles in the system are relative to the `Emitter` object's position, scale, 
	 * and  rotation, which can be changed using the `setPosition`, `setScale`, and 
	 * `setRotation` methods inherited from the {@link GL2.Node} base class.
	 * @name GL2.Emitter
	 * @constructs The default constructor.
	 * @augments GL2.Node
	 * @since 1.8
	 */
	initialize: function () {

	},

    /**
     * Destroys this GL2.Emitter. When using objects with
     * a native counterpart, you must explicitly destroy them to avoid leaking memory.
     * @returns {void}
     * @since 1.8
     * @status iOS, Android, Flash
     */
	destroy: function () {

	},

	/**
	 * Begins playback of the particle system.
     * @returns {void}
     * @since 1.8
     * @status iOS, Android, Flash
	 */
	play: function () {
		this._playSendGen();
	},

	/**
	 * Stops playback of the particle system.
	 * 
     * @returns {void}
     * @param {GL2.Emitter.StopMode} stopMode Determines whether to stop emitting particles 
     * _and_ stop playback or to stop emitting particles and allow individual particles to
     * complete their playback cycle.
     * @since 1.8
     * @status iOS, Android, Flash
     * @see GL2.Emitter#StopMode
	 */
	stop: function (stopMode) {
		var mode = (stopMode === undefined) ? Emitter.StopMode.Soft : stopMode;

		this._stopSendGen(mode);
	},

	/**
	 * Associates a `{@link GL2.EmitterData}` object with this `Emitter`.
	 * This is required for play and stop to function.
     * @returns {void}
     * @param {GL2.EmitterData} data An `EmitterData` object describing the behavior of the particle system.
     * @since 1.8
     * @status iOS, Android, Flash
	 */
	setData: function (data) {
		this._setDataSendGen(data.__objectRegistryId);
	},

	/**
	 * Registers a user defined callback function that will be called when this emitter 
	 * stops emitting particles.
     * @returns {void}
     * @cb {Function} doneCallback The function that will be called upon completion of the animation
     * @cb-param {GL2.Emitter} emitter The emitter which triggered the callback
     * @cb-returns {void}
     * @since 1.8
     * @status iOS, Android, Flash
	 */
	setDoneCallback: function (doneCallback)
	{
		this._doneCallback = doneCallback;
	},

	/**
	 * Registers a user defined callback function that will be called when all of this 
	 * emitter's particles have finished their playback cycle.
     * @returns {void}
     * @cb {Function} deadCallback
     * @cb-param {GL2.Emitter} emitter The emitter which triggered the callback
     * @cb-returns {void}
     * @since 1.8
     * @status iOS, Android, Flash
	 */
	setDeadCallback: function (deadCallback)
	{
		this._deadCallback = deadCallback;
	},

	/**
	 * @private
	 */
	_invokeDoneCallbackRecv: function () {
		if (this._doneCallback)
			this._doneCallback(this);
	},

	/**
	 * @private
	 */
	_invokeDeadCallbackRecv: function () {
		if (this._deadCallback)
			this._deadCallback(this);
	},
	
	/**
	 * Enumeration for stop modes.
	 * @name StopMode
	 * @fieldOf GL2.Emitter#
	 * @see GL2.Emitter#stop
	 */
	/**
	 * The system will stop emitting particles. Any existing particles will continue to play to
	 * completion.
	 * @name StopMode.Soft
	 * @fieldOf GL2.Emitter#
	 * @constant
	 */
	/**
	 * The system will stop emitting particles. All existing particles will immediately stop as
	 * well.
	 * @name StopMode.Hard
	 * @fieldOf GL2.Emitter#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	StopMode:
	{ 
		Soft: 0,
		Hard: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 368,
	// Method create = -1
	// Method destroy = 2
	// Method setData = 3
	// Method play = 4
	// Method stop = 5
	// Method invokeDoneCallback = 6
	// Method invokeDeadCallback = 7
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._invokeDoneCallbackRecv( cmd );
					break;
				case 7:
					instance._invokeDeadCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Emitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Emitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[368] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeDoneCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Emitter.invokeDoneCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_invokeDeadCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Emitter.invokeDeadCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( id )
	{
		Core.Proc.appendToCommandString( 0x170ffff, [ +id ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1700002, this );
	},
	
	/** @private */
	_setDataSendGen: function( emitterDataId )
	{
		Core.Proc.appendToCommandString( 0x1700003, this, [ +emitterDataId ] );
	},
	
	/** @private */
	_playSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1700004, this );
	},
	
	/** @private */
	_stopSendGen: function( stopMode )
	{
		Core.Proc.appendToCommandString( 0x1700005, this, [ +stopMode ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( id ) {}
	
	// destroy: function(  ) {}
	
	// setData: function( emitterDataId ) {}
	
	// play: function(  ) {}
	
	// stop: function( stopMode ) {}
	
	// _invokeDoneCallbackRecv: function( cmd ) {}
	// _invokeDeadCallbackRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Font'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Font'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Font'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Font.js';

////////////////////////////////////////////////////////////////////////////////
// Class Font
// Font object implementation
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;


////////////////////////////////////////////////////////////////////////////////

var Font = exports.Font = Core.Class.subclass(
/** @lends GL2.Font.prototype */
{
	classname: 'Font',

	/**
	 * @class The `GL2.Font` class creates font objects that can be used by `{@link GL2.Text}`
	 * objects. When you create a new font object, you can specify that the font should be loaded
	 * asynchronously, so that the application is not blocked while it waits for the font to load.
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @example
	 * var obj = new GL2.Font("Content/fontname.ttf",
	 *    {
	 *        location: GL2.Font.FontLocation.Manifest,
	 *        size: 16,
	 *        readFontAsync: true
	 *    },
	 *    function (error, object) {
	 *        if (error) {
	 *            console.log("Unable to read font family file: " + error.description);
	 *        } else {
	 *            console.log("The font family file was read: " + object.getFontFamily());
	 *        }
	 *    }
	 * );
	 * @param {String} fontFamily Name of the font family to load.
	 * @param {Object} [options] Options for loading the font.
	 * @param {Boolean} [options.readFontAsync=false] Set to `true` to load the font asynchronously.
	 * @param {GL2.Font.FontLocation} [options.location=GL2.Font.FontLocation.Default] Location of
	 *		the font family to load.
	 * @param {Number} [options.size=18] Size of the font, in pixels per em.
	 * @cb {Function} [createCallback] createCallback The function to call after the font has been
	 *		loaded.
	 * @cb-param {Object} error error Information about the error, if any.
	 * @cb-param {GL2.Font#ErrorCode} [error.code] [error.code] A code identifying the error type.
	 * @cb-param {String} [error.description] [error.description] A description of the error.
	 * @cb-param {GL2.Font} object object The `GL2.Font` object.
	 * @cb-returns {void}
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.8
	 */
	initialize: function( fontFamily, options, createCallback )
	{
		// default state
		this._isFontValid = false;
		this._fontFamily = '';
		this._options = Font.OptionFlags.DefaultOptions;
		this._location = Font.FontLocation.Default;
		this._size = 18;

		// parameters
		if ( fontFamily && typeof( fontFamily ) == 'string' ) {
			this._fontFamily = fontFamily;
		}

		if ( options && typeof( options ) == 'object' ) {
			if ( options['readFontAsync'] ) {
				this._options |= Font.OptionFlags.ReadFontAsync;
			}
			if ( options['location'] ) {
				this._location = options['location'];
			}
			if ( options['size'] ) {
				this._size = options['size'];
			}
		} else {
			createCallback = options;
		}

		// callback management
		this._nextCbId = 0;
		this._cb = {};
		this._storeCb = function( cb ) {
			var cbId = -1;
			if ( cb && typeof( cb ) == 'function' ) {
				cbId = this._nextCbId++;
				this._cb[cbId] = cb;
			}
			return cbId;
		};
		this._restoreCb = function( cbId ) {
			var cb = function () {};
			if ( cbId >= 0 ) {
				cb = this._cb[cbId];
				delete this._cb[cbId];
			}
			return cb;
		};

		// finish up
		Core.ObjectRegistry.register( this );

		this._createSendGen(    this.__objectRegistryId,
								this._storeCb( createCallback ),
								this._fontFamily,
								this._options,
								this._location,
								this._size );

	},

	/**
	 * Destroy the `GL2.Font` object, and release the resources allocated by the font.
	 *
	 * **Note**: If another `GL2` object is using the `GL2.Font` object, the font resources will not
	 * be released.
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.8
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister( this );
	},

	/** @private */
    _onCreateCbRecv: function( cmd ) {
		var obj = {};
		if ( this._onCreateCbRecvGen( cmd, obj ) ) {
			if ( obj['callbackId'] >= 0 ) {
				var cb = this._restoreCb( obj['callbackId'] );
				var err = obj['errCode'] ? { code:obj['errCode'], description:obj['errStr'] } : null;
                if ( !err ) {
                    this._isFontValid = true;
                }
				cb( err, this );
			}
		}
    },


// API

	/**
	 * Retrieve the name of the font family.
	 * @returns {String} The font family for this font object.
	 * @status iOS, Android
	 * @since 1.8
	 */
	getFontFamily: function()
	{
		return this._fontFamily;
	},

	/**
	 * Retrieve the location where the font family is stored.
	 * @returns {GL2.Font.FontLocation} The location where the font family is stored.
	 * @status iOS, Android
	 * @since 1.8
	 */
	getFontLocation: function()
	{
		return this._location;
	},

	/**
	 * Retrieve the font size.
	 * @returns {Number} The font size, in pixels per em.
	 * @status iOS, Android
	 * @since 1.8
	 */
	getFontSize: function()
	{
		return this._size;
	},
	
	/**
	 * Enumeration for font loading errors.
	 * @name ErrorCode
	 * @fieldOf GL2.Font#
	 */
	
	/**
	 * No error occurred.
	 * @name ErrorCode.NoError
	 * @fieldOf GL2.Font#
	 * @constant
	 */

	/**
	 * An unknown error occurred.
	 * @name ErrorCode.Unknown
	 * @fieldOf GL2.Font#
	 * @constant
	 */

	/**
	 * The requested font was not found.
	 * @name ErrorCode.NotFound
	 * @fieldOf GL2.Font#
	 * @constant
	 */

	/**
	 * The requested operation is not available.
	 * @name ErrorCode.Unsupported
	 * @fieldOf GL2.Font#
	 * @constant
	 */
	
	/**
	 * Enumeration for font loading options.
	 * @name OptionFlags
	 * @fieldOf GL2.Font#
	 * @private
	 */

	/**
	 * Use the default options.
	 * @name OptionFlags.DefaultOptions
	 * @fieldOf GL2.Font#
	 * @constant
	 * @private
	 */

	/**
	 * Load the font asynchronously.
	 * @name OptionFlags.ReadFontAsync
	 * @fieldOf GL2.Font#
	 * @constant
	 * @private
	 */

	/**
	 * Enumeration to choose the source of fonts for `GL2.Font`.
	 * @name FontLocation
	 * @fieldOf GL2.Font#
	 */

	/**
	 * Use the default fonts, which are the system fonts. Equivalent to
	 * `{@link GL2.Font#FontLocation.System}`.
	 * @name FontLocation.Default
	 * @fieldOf GL2.Font#
	 * @constant
	 */

	/**
	 * Use the system fonts.
	 * @name FontLocation.System
	 * @fieldOf GL2.Font#
	 * @constant
	 */

	/**
	 * Use the fonts that are bundled with ngCore. Not currently supported.
	 * @name FontLocation.Bundled
	 * @fieldOf GL2.Font#
	 * @constant
	 * @ignore
	 */

	/**
	 * Use custom fonts that are loaded through the application manifest.
	 * @name FontLocation.Manifest
	 * @fieldOf GL2.Font#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	ErrorCode:
	{ 
		NoError: 0,
		Unknown: -1,
		NotFound: -2,
		Unsupported: -3
	},
	
	FontLocation:
	{ 
		Default: 0,
		System: 1,
		Bundled: 2,
		Manifest: 3
	},
	
	OptionFlags:
	{ 
		DefaultOptions: 0,
		ReadFontAsync: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 369,
	// Method create = -1
	// Method destroy = 2
	// Method onCreateCb = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._onCreateCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Font._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Font._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[369] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onCreateCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Font.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Font.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Font.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Font.onCreateCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId, callbackId, fontFamily, options, fontLocation, fontSize )
	{
		Core.Proc.appendToCommandString( 0x171ffff, [ +__objectRegistryId, +callbackId, Core.Proc.encodeString( fontFamily ), +options, +fontLocation, +fontSize ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1710002, this );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId, callbackId, fontFamily, options, fontLocation, fontSize ) {}
	
	// destroy: function(  ) {}
	
	// _onCreateCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/MotionData'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/MotionData'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/MotionData'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/MotionData.js';

var Core = require ('NGCore/Client/Core').Core;


var MotionData = exports.MotionData = Core.Class.subclass(
/** @lends GL2.MotionData.prototype */
{
	classname: 'MotionData',

    /**
     * @class
     * MotionData The `MotionData` class stores animation keyframe data that multiple `{@link GL2.MotionController}` objects can reference. A `MotionData` object
     * can store multiple animations. Each animation has a unique name, stored as a string.
     *
     * Animation keyframe data is stored as a JSON object with the following properties:
     *
     * + `motions`: This key is the root property of an animation. Each animation object has a unique name and contains the subsequent `Keyframe` and `source` elements.
     * + name: A unique string that identifies the animation.
     * + `Keyframe`: An array of keyframe definitions. Each keyframe has the following properties:
     *     + `x`: X position coordinate relative to the coordinates in the `source` field. The `source` field coordinates are generated by calling `{@link GL2.Node.setPosition}`.
     *     + `y`: Y position coordinate relative to the coordinates in the `source` field. The `source` field coordinates are generated by calling `{@link GL2.Node.setPosition}`.
     *     + `scaleX`: A positive horizontal scale multiplication factor.
     *     + `scaleY`: A positive vertical scale multiplication factor.
     *     + `index`: The frame this keyframe represents. An index of 0 represents the first frame of the animation.
     *     + `alpha`: A value from 0 to 1 indicating the opacity percentage of the alpha channel.
     *     + `rotation`: A rotation value from -180 degrees to 180 degrees.
     * + `source`: A source object defines properties of the animation and has the following properties:
     *     + `framerate`: An integer that specifies how many animation frames play per second. The value of `framerate` and the highest `index` value of any element in the `Keyframe`
     *        array define the duration of the animation. An animation with a `framerate` value of 30 and a `Keyframe` with the highest `index` value of 60 takes 2 seconds to play, for example.
     *     + `x`: X position coordinate generated by calling `{@link GL2.Node.setPosition}`.
     *     + `y`: Y position coordinate generated by calling `{@link GL2.Node.setPosition}`.
     *     + `scaleX`: A positive horizontal scale multiplication factor.
     *     + `scaleY`: A positive vertical scale multiplication factor.
     *     + `alpha`: A value from 0 to 1 indicating the opacity percentage of the alpha channel.
     *     + `rotation`: A rotation value from -180 degrees to 180 degrees.
     *
     * **Example animation JSON block**
     *
     * <pre>
     * {
     *     "motions": {
     *         "alphafade": {
     *             "Keyframe": [{
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 0,
     *                 "alpha": 1,
     *                 "rotation": 0
     *             }, {
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 15,
     *                 "alpha": 0,
     *                 "rotation": 0
     *             }, {
     *                 "x": 0,
     *                 "scaleX": 1,
     *                 "y": 0,
     *                 "scaleY": 1,
     *                 "index": 30,
     *                 "alpha": 1,
     *                 "rotation": 0
     *             }],
     *             "source": [{
     *                 "frameRate": 30,
     *                 "x": 100.84,
     *                 "scaleX": 1,
     *                 "y": -94.2,
     *                 "scaleY": 1,
     *                 "rotation": 0,
     *                 "alpha": 1
     *             }]
     *         }
     *     }
     * }
     * </pre>
     *
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     *     var mc;
     *     if (error) {
     *         console.log('error');
     *     } else {
     *         mc = new GL2.MotionController(md);
     *     }
     * });
     * @constructs Create a MotionData instance.
     * @since 1.7
     */
	initialize: function ()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._callbackIndexCounter = 1;
		this._callbacks = [];
	},

    /**
     * @function
     *
     * Destroy this `MotionData` object.
     * Destroy all `{@link GL2.MotionController}` instances that reference a `MotionData` object before calling this method.
     * When you call this method on a `MotionData` object that is referred to by existing `{@link GL2.MotionController}`
     * objects, the `MotionData` object is not destroyed until the last referring `{@link GL2.MotionController}` object is destroyed.
     *
     * @returns {void}
     * @since 1.7
     */
	destroy: function ()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

    /**
     * @function
     *
     * Verifies that a given `MotionData.DataFormat` enum has a legal value.
     * @example
     * md = new GL2.MotionData();
     * if (md.isDataFormatSupported(GL2.MotionData.DataFormat.FlashClassicTween)) {
     * 	console.log('Flash Classic Tween is supported!');
     * }
     * @param {GL2.MotionData.DataFormat} dataFormat The data format to test.
     * @returns {Boolean} true when the given dataFormat enum has a legal value. This method returns <code>false</code> in all other cases.
     * @since 1.7
     */
	isDataFormatSupported: function (dataFormat)
	{
		if (Core.Capabilities.meetsBinaryVersion && Core.Capabilities.meetsBinaryVersion([1,7,0,0,0])) {
			return dataFormat === MotionData.DataFormat.FlashClassicTween;
		} else {
			return false;
		}
	},

    /**
     * @function
     *
     * Initialize this `MotionData` object with keyframe data in the given format. This method loads the data in JavaScript.
     * @param {Object|String} dataOrJSONString Animation data. This parameter can be a raw JavaScript object or a JSON string.
     * @param {GL2.MotionData.DataFormat} dataFormat The format for the keyframe data.
     * @cb {Function} callback The function to call after creating the transaction.
     * @cb-param {String} error The error string. This parameter is undefined if there is no error.
     * @cb-param {MotionData} object This <code>MotionData</code> object.
     * @cb-returns {void}
     * @example
     * var data = {
     * 	motions: {
     * 		left_to_right: {
     * 			Kefyrame: [{x: 0, y: 120, scaleX: 1, scaleY: 1, rotation: 0, index: 0},
     * 					   {x: 320, y: 120, scaleX: 1, scaleY: 1, rotation: 0, index: 30}],
     * 			source: [{x: 0, y: 0, scaleX: 1, scaleY: 1, rotation: 0}]
     * 		}
     * 	}
     * };
     * md = new GL2.MotionData();
     * md.initFromData(data, GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     * 	if (error) {
     * 		console.log('error');
     * 	} else {
     * 		console.log('success');
     * 	}
     * });
     * @returns {this}
     * @since 1.7
     */
    initFromData: function (dataOrJSONString, dataFormat, callback)
	{
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof dataOrJSONString === 'string' || typeof dataOrJSONString === 'object') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				if (typeof dataOrJSONString === 'string') {
					this._initFromDataSendGen(dataOrJSONString, dataFormat, id);
				} else {
					this._initFromDataSendGen(JSON.stringify(dataOrJSONString), dataFormat, id);
				}
			} else {
				if (callback && typeof callback === 'function') {
					callback("Expected Object or String");
				}
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback("Data Format Not Supported");
			}
		}
		return this;
	},

    /**
     * @function
     *
     * Initialize this `MotionData` object with keyframe data from a JSON file. This method loads the data in native code.
     * @param {String} filename The file where the animation data is stored in JSON format.
     * @param {GL2.MotionData.DataFormat} dataFormat The format for the keyframe data.
     * @cb {Function} callback The function to call after creating the transaction.
     * @cb-param {String} error The error string. This parameter is undefined if there is no error.
     * @cb-param {GL2.MotionData} object This <code>MotionData</code> object.
     * @cb-returns {void}
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     * 	if (error) {
     * 		console.log('error');
     * 	} else {
     * 		console.log('success');
     * 	}
     * });
     * @returns {this}
     * @since 1.7
     */
	initFromJSONFile: function (filename, dataFormat, callback)
	{
		var id;
		if (this.isDataFormatSupported(dataFormat))
		{
			if (typeof filename === 'string') {
				// register callback
				id = this._callbackIndexCounter++;
				this._callbacks[id] = callback;
				this._initFromJSONFileSendGen(filename, dataFormat, id);
			} else {
				callback("Invalid filename");
			}
		} else {
			if (callback && typeof callback === 'function') {
				callback("Data Format Not Supported");
			}
		}
		return this;
	},

	/**
	 * @private
     */
	_invokeCallbackRecv: function (cmd) {
		var msg = {};
		if (!this._invokeCallbackRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		var err = msg.error;
		if (!id) {
			NgLogE("GL2.MotionData._invokeCallbackRecv command : bad id = " + id);
			return;
		}
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("GL2.MotionData._invokeCallbackRecv command : No registered callback found, id = " + id);
			return;
		}
		delete this._callbacks[id];
		cb(err, this);
	},

    /**
     * Enumerated values for `MotionData` objects.
     * @name DataFormat
     * @fieldOf GL2.MotionData#
     */

    /**
     * The Flash Classic Tween animation format
     * @name DataFormat.FlashClassicTween
     * @fieldOf GL2.MotionData#
     * @constant
     */

// {{?Wg Generated Code}}
	
	// Enums.
	DataFormat:
	{ 
		FlashClassicTween: 0
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 364,
	// Method create = -1
	// Method destroy = 2
	// Method initFromData = 3
	// Method initFromJSONFile = 4
	// Method invokeCallback = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MotionData._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MotionData._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[364] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in MotionData.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( id )
	{
		Core.Proc.appendToCommandString( 0x16cffff, [ +id ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16c0002, this );
	},
	
	/** @private */
	_initFromDataSendGen: function( animData, dataFormat, callbackId )
	{
		Core.Proc.appendToCommandString( 0x16c0003, this, [ Core.Proc.encodeString( animData ), +dataFormat, +callbackId ] );
	},
	
	/** @private */
	_initFromJSONFileSendGen: function( filename, dataFormat, callbackId )
	{
		Core.Proc.appendToCommandString( 0x16c0004, this, [ Core.Proc.encodeString( filename ), +dataFormat, +callbackId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( id ) {}
	
	// destroy: function(  ) {}
	
	// initFromData: function( animData, dataFormat, callbackId ) {}
	
	// initFromJSONFile: function( filename, dataFormat, callbackId ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/MotionController'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/MotionController'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/MotionController'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/MotionController.js';

var Core = require ('NGCore/Client/Core').Core;
var Node = require('NGCore/Client/GL2/Node').Node;
var MotionData = require('NGCore/Client/GL2/MotionData').MotionData;


var MotionController = exports.MotionController = Core.Class.subclass(
/** @lends GL2.MotionController.prototype */
{
    classname: 'MotionController',

    /**
     * @class
     * The `MotionController` class animates the motion of several `{@link GL2.Node}` objects using keyframe data that is stored in a `{@link GL2.MotionData}` object. You can use
     * the methods in this class in parallel with `{@link GL2.Animation}` or independently. The `{@link GL2.Animation}` class provides functionality to support flip-book style animation
     * for sprite sheets, while `MotionController` enables apps to animate a static texture around the screen.
     * Multiple `MotionController` objects can share a single `{@link GL2.MotionData}` object. Sharing a `{@link GL2.MotionData}` object
     * reduces total memory footprint for your app.
     * A single `MotionController` object can animate multiple nodes at once. This capability enables your app to animate multi-sprite characters as
     * single unit.
     *
     * **Note**: The `position` and `rotation` fields of an animated `{@link GL2.Node}` object do not reflect to the
     * underlying JavaScript by default. Synchronizing these fields has a high performance cost. Use the `MotionController.syncContinuous` or `MotionController.syncFrames`
     * methods when you need to update these fields.
     *
     * @constructs Create a `MotionController` object to manage animations.
     * @param {GL2.MotionData} MotionData A `{@link GL2.MotionData}` object that holds keyframe animation data.
     * @augments Core.Class
     * @since 1.7
     */
	initialize: function (motionData)
	{
		Core.ObjectRegistry.register(this);
		this._motionData = motionData;
		this._syncCallbacks = {};
		this._timeScale = 1.0;

		this._createSendGen(this.__objectRegistryId, motionData.__objectRegistryId);
	},

    /**
     * Destroy this `MotionController` object.
     * Any `{@link GL2.Node}` objects bound to this controller become unbound and stop animating.
     * @since 1.7
     */
	destroy: function ()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

    /**
     * @function
     *
     * Bind a named animation to a `{@link GL2.Node}` object.
     * This function looks up the named animation in the `{@link GL2.MotionData}` object that is associated with this `MotionController` object.
     * This function animates the bound `{@link GL2.Node}` instance when this `MotionController` plays.
     * A specific named animation can be bound to a maximum of one `{@link GL2.Node}` object. You can call this method multiple times to
     * bind a single `{@link GL2.MotionController}` object to multiple named animations.
     * You can use a single `MotionController` object to animate a set of multiple `{@link GL2.Node}` objects.
     * You can use the optional `syncFlags` parameter to specify a set of fields to animate, such as `Position` and `Rotation` but not `Scale`. See the enums documentation for more
     * information about these fields.
     * The `syncFlags` parameter can be in two formats:
     *
     * + The result of a bitwise OR operation on several `syncFlags` values.
     * + An array of `syncFlags` values.
     *
     * This method has no effect when the animation is not found.
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     *  var mc, sprite, syncFlags;
     *  if (error) {
     *      console.log('error');
     *  } else {
     *      mc = new GL2.MotionController(md);
     *      sprite = new GL2.Sprite().setImage('Content/sprite.png', [100, 100], [0.5, 0.5]);
     *      // animate sprite position and scale ONLY.
     *      syncFlags = GL2.MotionController.SyncFlags.Position | GL2.MotionController.SyncFlags.Scale;
     *      mc.bind('sprite_anim_name', sprite, syncFlags);
     *      mc.play();
     *  }
     * });
     * @param {String} name The name of the animation to look up and bind.
     * @param {GL2.Node} node The <code>{@link GL2.Node}</code> object to bind to the named animation.
     * @param {Number | Array} [syncFlags=GL2.MotionController.SyncFlags.All] An array of <code>GL2.MotionController.syncFlags</code> values or the result of a
     * bitwise OR operation across several <code>GL2.MotionController.syncFlags</code> values.
     * @returns {this}
     * @since 1.7
     */
	bind: function (name, node, syncFlags)
	{
		var flags, i;
		if (syncFlags instanceof Array) {
			flags = 0;
			for (i = 0; i < syncFlags.length; i++) {
				flags = flags | syncFlags[i];
			}
		} else if (typeof syncFlags === 'number') {
			flags = syncFlags;
		} else {
			flags = MotionController.SyncFlags.All;
		}
		delete this._syncCallbacks[name];
		this._bindSendGen(name, node.__objectRegistryId, flags);
		return this;
	},

    /**
     * @function
     *
     * Unbind a named animation from a `{@link GL2.Node}` object. The `{@link GL2.Node}` object stops receiving updates.
     * The animation continues to play and any other `{@link GL2.Node}` objects that are bound to the named animation
     * continue to receive updates.
     * @param {String} name The name of the animation to unbind from the <code>{@link GL2.Node}</code> object.
     * @returns {this}
     * @since 1.7
     */
	unbind: function (name)
	{
		delete this._syncCallbacks[name];
		this._unbindSendGen(name);
		return this;
	},

    /**
     * @function
     *
     * Play all animations currently bound to any `{@link GL2.Node}` object.
     * Animations begin playing from frame 0. Each bound `{@link GL2.Node}` object updates to follow the animations bound to that object.
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     *  var mc, sprite, syncFlags;
     *  if (error) {
     *      console.log('error');
     *  } else {
     *      mc = new GL2.MotionController(md);
     *      sprite = new GL2.Sprite().setImage('Content/sprite.png', [100, 100], [0.5, 0.5]);
     *      // animate sprite position and scale ONLY.
     *      syncFlags = GL2.MotionController.SyncFlags.Position | GL2.MotionController.SyncFlags.Scale;
     *      mc.bind('sprite_anim_name', sprite, syncFlags);
     *      mc.play(GL2.MotionController.PlayMode.Loop);
     *  }
     * });
     * @param {GL2.MotionController.PlayMode} [playMode=GL2.MotionController.PlayMode.Normal] The play mode for the animations.
     * @returns {this}
     * @since 1.7
     */
	play: function (playMode)
	{
		var mode = playMode || MotionController.PlayMode.Normal;
		this._playSendGen(mode);
		return this;
	},

    /**
     * @function
     *
     * Stop updating all currently bound animations.
     * @returns {this}
     * @since 1.7
     */
	stop: function ()
	{
		this._stopSendGen();
		return this;
	},

    /**
     * @function
     *
     * Updates the `{@link GL2.Node}` object bound to the named animation when the animation plays.
     * This method updates the fields requested by the `syncFlags` parameter for every animation frame that this `MotionController` object plays.
     * To minimize the performance effect of these updates, minimize the number of animations and the number of fields to update.
     * Use `syncFrames` to synchronize on specific animation frames.
     * The optional `syncFlags` parameter can be used to specify a set of fields to animate, such as `Position` and `Rotation` but not `Scale`.
     * The `syncFlags` parameter can be in two formats:
     *
     * + The result of a bitwise OR operation on several `syncFlags` values.
     * + An array of `syncFlag` values.
     *
     * @example
     * mc.syncContinuous('sprite_anim_name', GL2.MotionController.SyncFlags.Position);
     * @param {String} name The name of the animation bound to the Node that you wish to update.
     * @param {Number | Array} [syncFlags=GL2.MotionController.syncFlags.All] An array of <code>syncFlags</code> values, or the result of a bitwise OR operation across several <code>syncFlags</code> values.
     * @returns {this}
     * @since 1.7
     */
	syncContinuous: function (name, syncFlags)
	{
		var flags, i;
		if (syncFlags instanceof Array) {
			flags = 0;
			for (i = 0; i < syncFlags.length; i++) {
				flags = flags | syncFlags[i];
			}
		} else if (typeof syncFlags === 'number') {
			flags = syncFlags;
		} else {
			flags = MotionController.SyncFlags.All;
		}
		delete this._syncCallbacks[name];
		this._syncContinuousSendGen(name, flags);
		return this;
	},

    /**
     * @function
     *
     * Updates the `{@link GL2.Node}` object bound to the named animation when the animation plays.
     * This method updates the fields requested by the `syncFlags` parameter for each frame number passed in the `frameArray` parameter.
     * To minimize the performance effect of these updates, minimize the number of animations and the number of fields to update.
     * @param {String} name The name of the animation bound to the <code>{@link GL2.Node}</code> object to update.
     * @param {Array} frameArray Array of frame numbers. Negative frame numbers are relative to last keyframe. The last keyframe's number is -1.
     * @param {Number | Array} [syncFlags=GL2.MotionController.syncFlags.All] An array of <code>syncFlags values</code>, or the result of a bitwise OR operation across several <code>syncFlags</code> values.
     * @cb {Function} callback The function to call after creating the transaction.
     * @cb-param {GL2.MotionController} object This <code>MotionController</code> object.
     * @cb-param {Number} frame The frame this callback function is associated with.
     * @cb-returns {void}
     * @example
     * var sprite = new GL2.Sprite().setImage('Content/sprite.png', [100, 100], [0.5, 0.5]);
     * mc.bind('sprite_anim_name', sprite);
     * mc.syncFrames('sprite_anim_name', [0, -1], GL2.MotionController.SyncFlags.Position, function (mc, frame) {
     *  var x = sprite.getPosition().getX();
     *  var y = sprite.getPosition().getY();
     *  if (frame === 0) {
     *      console.log('On first frame, pos = (' + x + ', ' + y + ')');
     *  } if (frame === -1) {
     *      console.log('On last frame, pos = (' + x + ', ' + y + ')');
     *  }
     * });
     * @returns {this}
     * @since 1.7
     */
	syncFrames: function (name, frameArray, syncFlags, callback)
	{
		if (!(frameArray instanceof Array)) {
			throw new Error("TypeError: Expected frameArray to be an Array");
		}

		var flags, i, hasCallback;
		if (syncFlags instanceof Array) {
			flags = 0;
			for (i = 0; i < syncFlags.length; i++) {
				flags = flags | syncFlags[i];
			}
		} else if (typeof syncFlags === 'number') {
			flags = syncFlags;
		} else {
			flags = MotionController.SyncFlags.All;
		}

		if (callback && typeof callback === 'function') {
			// register callback
			this._syncCallbacks[name] = callback;
			hasCallback = true;
		} else {
			delete this._syncCallbacks[name];
			hasCallback = false;
		}

		this._syncFramesSendGen(name, flags, hasCallback, frameArray.length);
		for (i = 0; i < frameArray.length; i++) {
			this._frameSendGen(frameArray[i]);
		}
		return this;
	},

    /**
     * @function
     *
     * Set the animation playback speed. If you call this method while an animation is playing, the speed of that animation changes.
     * @example
     * md = new GL2.MotionData();
     * md.initFromJSONFile('Content/animations.json', GL2.MotionData.DataFormat.FlashClassicTween, function (error, md) {
     *  var mc, sprite, syncFlags;
     *  if (error) {
     *      console.log('error');
     *  } else {
     *      mc = new GL2.MotionController(md);
     *      sprite = new GL2.Sprite().setImage('Content/sprite.png', [100, 100], [0.5, 0.5]);
     *      // animate sprite position and scale ONLY.
     *      syncFlags = GL2.MotionController.SyncFlags.Position | GL2.MotionController.SyncFlags.Scale;
     *      mc.bind('sprite_anim_name', sprite, syncFlags);
     *      mc.setTimeScale(0.5);
     *      mc.play(GL2.MotionController.PlayMode.Loop);
     *  }
     * });
     * @param {Number} timeScale The animation speed. Use a value of 1.0 to play the animation at normal speed. A value of 2.0 indicates double speed.
     * @returns {this}
     * @since 1.7
     */
	setTimeScale: function (timeScale)
	{
		this._setTimeScaleSendGen(timeScale);
		this._timeScale = timeScale;
		return this;
	},

    /**
     * @function
     *
     * Retrieve the current animation playback speed.
     * @returns {Number} timeScale The animation speed for the current animation.
     * @since 1.7
     */
	getTimeScale: function ()
	{
		return this._timeScale;
	},

	/**
	 * @private
	 */
	_invokeCallbackRecv: function(cmd)
	{
		var msg = {};
		if (!this._invokeCallbackRecvGen(cmd, msg)) {
			return;
		}

		var name = msg.name;
		if (!name) {
			NgLogE("GL2.MotionController._invokeCallbackRecv command : bad name = " + name);
			return;
		}
		var cb = this._syncCallbacks[name];
		if (!cb) {
			NgLogE("GL2.MotionController._invokeCallbackRecv command : No registered callback found, name = " + name);
			return;
		}
		cb(this, msg.frame);
	},

    /**
     * Enumerated values for `MotionController` objects.
     * @name SyncFlags
     * @fieldOf GL2.MotionController#
     */

    /**
     * No fields.
     * @name SyncFlags.None
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Position field.
     * @name SyncFlags.Position
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Rotation field.
     * @name SyncFlags.Rotation
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Scale field.
     * @name SyncFlags.Scale
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Alpha channel field.
     * @name SyncFlags.Alpha
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * All fields.
     * @name SyncFlags.All
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Enumerated values for `MotionController` objects.
     * @name PlayMode
     * @fieldOf GL2.MotionController#
     */

    /**
     * Stop the animation at the end.
     * @name PlayMode.Normal
     * @fieldOf GL2.MotionController#
     * @constant
     */

    /**
     * Repeat the animation at the end.
     * @name PlayMode.Loop
     * @fieldOf GL2.MotionController#
     * @constant
     */

// {{?Wg Generated Code}}
	
	// Enums.
	SyncFlags:
	{ 
		None: 0,
		Position: 1,
		Rotation: 2,
		Scale: 4,
		Alpha: 8,
		All: 15
	},
	
	PlayMode:
	{ 
		Normal: 0,
		Loop: 1
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 363,
	// Method create = -1
	// Method destroy = 2
	// Method bind = 3
	// Method unbind = 4
	// Method syncContinuous = 5
	// Method syncFrames = 6
	// Method frame = 7
	// Method play = 8
	// Method stop = 9
	// Method invokeCallback = 10
	// Method setTimeScale = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 10:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MotionController._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MotionController._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[363] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionController.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "name" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "name" ] === undefined )
		{
			NgLogE("Could not parse name in MotionController.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "frame" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "frame" ] === undefined )
		{
			NgLogE("Could not parse frame in MotionController.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( id, motionDataId )
	{
		Core.Proc.appendToCommandString( 0x16bffff, [ +id, +motionDataId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16b0002, this );
	},
	
	/** @private */
	_bindSendGen: function( name, nodeId, syncFlags )
	{
		Core.Proc.appendToCommandString( 0x16b0003, this, [ Core.Proc.encodeString( name ), +nodeId, +syncFlags ] );
	},
	
	/** @private */
	_unbindSendGen: function( name )
	{
		Core.Proc.appendToCommandString( 0x16b0004, this, [ Core.Proc.encodeString( name ) ] );
	},
	
	/** @private */
	_syncContinuousSendGen: function( name, syncFlags )
	{
		Core.Proc.appendToCommandString( 0x16b0005, this, [ Core.Proc.encodeString( name ), +syncFlags ] );
	},
	
	/** @private */
	_syncFramesSendGen: function( name, syncFlags, hasCallback, frameCount )
	{
		Core.Proc.appendToCommandString( 0x16b0006, this, [ Core.Proc.encodeString( name ), +syncFlags, ( hasCallback ? 1 : 0 ), +frameCount ] );
	},
	
	/** @private */
	_frameSendGen: function( frame )
	{
		Core.Proc.appendSubcommandToCommandString( [ +frame ] );
	},
	
	/** @private */
	_playSendGen: function( playMode )
	{
		Core.Proc.appendToCommandString( 0x16b0008, this, [ +playMode ] );
	},
	
	/** @private */
	_stopSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16b0009, this );
	},
	
	/** @private */
	_setTimeScaleSendGen: function( timeScale )
	{
		Core.Proc.appendToCommandString( 0x16b000b, this, [ +timeScale ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( id, motionDataId ) {}
	
	// destroy: function(  ) {}
	
	// bind: function( name, nodeId, syncFlags ) {}
	
	// unbind: function( name ) {}
	
	// syncContinuous: function( name, syncFlags ) {}
	
	// syncFrames: function( name, syncFlags, hasCallback, frameCount ) {}
	
	// frame: function( frame ) {}
	
	// play: function( playMode ) {}
	
	// stop: function(  ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	// setTimeScale: function( timeScale ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Texture'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Texture'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Texture'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Texture.js';

////////////////////////////////////////////////////////////////////////////////
// Class Texture
// Texture object implementation
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;


////////////////////////////////////////////////////////////////////////////////

var Texture = exports.Texture = Core.Class.subclass(
/** @lends GL2.Texture.prototype */
{
	classname: 'Texture',

	/**
	 * @class The `GL2.Texture` class creates texture objects synchronously or
	 * asynchronously. By specifying `readImageAsync` as `true` in the options object when
	 * creating the `GL2.Texture`, the application can continue processing without blocking
	 * execution while waiting for the texture file to load.
     *
     * `GL2.Texture` can be used in place of a literal image filename
     * string in calls to `{@link GL2.Sprite#setImage}` and `{@link GL2.Primitive#setImage}`.
     * The texture object's image is referenced and bound to the node.
     *
     * `{@link GL2.Texture#getFilename}` can be used in place of a literal image filename
     * string in calls to `{@link GL2.Sprite#setImage}`, `{@link GL2.Primitive#setImage}` and `{@link GL2.Animation.Frame}`.
     * The texture object's image is referenced and bound to the node or animation frame.
     *
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @param {String} filename Name of the image file to read.
	 * @param {Object} [options] Options for loading the texture.
	 * @param {Boolean} [options.readImageAsync] Read image asynchronously if true. `createCallback` is invoked when operation completes.
	 * @param {Boolean} [options.truecolorDepth16] Truecolor image depth is 16bpp after decoding if true.
	 * @cb {Function} [createCallback] createCallback Callback function for this texture's create operation.
	 * @cb-param {Object} error error Information about the error, if any.
	 * @cb-param {GL2.Texture#ErrorCode} [error.code] [error.code] A code identifying the error type.
	 * @cb-param {String} [error.description] [error.description] A description of the error.
	 * @cb-param {GL2.Texture} object object `this` object.
	 * @cb-returns {void}
     * @example
     * var obj = new GL2.Texture(
     *    "Content/ngmoco.pvr",
     *    {
     *        "truecolorDepth16" : false,
     *        "readImageAsync" : true
     *    },
     *    function (error, object) {
     *        if (error) {
     *            console.log("Unable to read image file: " + error.description);
     *        } else {
     *            console.log("The image file was read: " + object.getFilename());
     *        }
     *    }
     * );
	 * @status iOS, Android
	 * @since 1.7
	 */
	initialize: function( filename, options, createCallback )
	{
        // default state
        this._isImageValid = false;
		this._filename = '';
        this._options = Texture.OptionFlags.Default;
        this._minFilter = Texture.FilterMode.Linear;
        this._magFilter = Texture.FilterMode.Linear;
        this._wrapS = Texture.WrapMode.Clamp;
        this._wrapT = Texture.WrapMode.Clamp;

        // parameters
        if ( filename && typeof( filename ) == 'string' ) {
            this._filename = filename;
        }

        if ( options && typeof( options ) == 'object' ) {
            if ( options['readImageAsync'] ) {
                this._options |= Texture.OptionFlags.ReadImageAsync;
            }
            if ( options['truecolorDepth16'] ) {
                this._options |= Texture.OptionFlags.TruecolorDepth_BPP16;
            }
            if ( options['minFilter'] ) {
                this._minFilter = options['minFilter'];
            }
            if ( options['magFilter'] ) {
                this._magFilter = options['magFilter'];
            }
            if ( options['wrapS'] ) {
                this._wrapS = options['wrapS'];
            }
            if ( options['wrapT'] ) {
                this._wrapT = options['wrapT'];
            }
        } else {
            createCallback = options;
        }

        // callback management
		this._nextCbId = 0;
        this._cb = {};
		this._storeCb = function( cb ) {
			var cbId = -1;
			if ( cb && typeof( cb ) == 'function' ) {
				cbId = this._nextCbId++;
				this._cb[cbId] = cb;
			}
			return cbId;
		};
		this._restoreCb = function( cbId ) {
            var cb = function () {};
            if ( cbId >= 0 ) {
                cb = this._cb[cbId];
                delete this._cb[cbId];
			}
            return cb;
		};

        // finish up
		Core.ObjectRegistry.register( this );

		this._createSendGen(    this.__objectRegistryId,
                                this._storeCb( createCallback ),
                                this._filename,
                                this._options,
                                this._minFilter,
                                this._magFilter,
                                this._wrapS,
                                this._wrapT );
	},

	/**
	 * Destroy the `GL2.Texture` object, and release the resources allocated by the texture.
     *
     * **Note**: Image resources will be deallocated if there are no references held by `GL2.Node` objects.
     *
	 * @returns {void}
	 * @status iOS, Android
	 * @since 1.7
	 */
    destroy: function()
    {
        this._destroySendGen();
        Core.ObjectRegistry.unregister( this );
    },

// API

    /** @ignore initialize docs until 1.8
     *
     * and provides control over specific properties of the texture.
     *
     * **Note**: Calls to `{@link GL2.Texture#setFilterModes}` and `{@link GL2.Texture#setWrapModes}`
     * will affect all instances and usages of that texture object by sprites, primitives, and animations.
     *
	 * @param {GL2.Texture.FilterMode} [options.minFilter] Minification filter mode.
	 * @param {GL2.Texture.FilterMode} [options.magFilter] Magnification filter mode.
	 * @param {GL2.Texture.WrapMode} [options.wrapS] S-axis wrap mode.
	 * @param {GL2.Texture.WrapMode} [options.wrapT] T-axis wrap mode.
     */

	/**
	 * Get `GL2.Texture` filename.
	 * @returns {String} The name of the image file associated with this texture object.
	 * @status iOS, Android
	 * @since 1.7
	 */
    getFilename: function() {
        return this._filename;
    },
	
	/**
	 * Set `GL2.Texture` filter modes.
	 * @param {GL2.Texture.FilterMode} minFilter Minification filter mode for this texture.
	 * @param {GL2.Texture.FilterMode} magFilter Magnification filter mode for this texture.
	 * @returns `this` to support method invocation chaining.
	 * @status iOS, Android
     * @private
	 */
    setFilterModes: function( minFilter, magFilter ) {
        this._minFilter = minFilter;
        this._magFilter = magFilter;
        this._setFilterModesSendGen( minFilter, magFilter );
        return this;
    },

	/**
	 * Get `GL2.Texture` filter modes.
	 * @returns {Object} Texture filter modes in the form of { minFilter:value, magFilter:value }
	 * @status iOS, Android
     * @private
	 */
    getFilterModes: function() {
        return { minFilter:this._minFilter, magFilter:this._magFilter };
    },

	/**
	 * Set `GL2.Texture` wrap modes.
	 * @param {GL2.Texture.WrapMode} wrapS S-axis wrap mode for this texture.
	 * @param {GL2.Texture.WrapMode} wrapT T-axis wrap mode for this texture.
	 * @returns `this` to support method invocation chaining.
	 * @status iOS, Android
     * @private
	 */
    setWrapModes: function( wrapS, wrapT ) {
        this._wrapS = wrapS;
        this._wrapT = wrapT;
        this._setWrapModesSendGen( wrapS, wrapT );
        return this;
    },

	/**
	 * Get `GL2.Texture` wrap modes.
	 * @returns {Object} Texture wrap modes in the form of { wrapS:value, wrapT:value }
	 * @status iOS, Android
     * @private
	 */
    getWrapModes: function() {
        return { wrapS:this._wrapS, wrapT:this._wrapT };
    },

	/**
     * Read meta data information about an image file.
     * @name GL2.Texture.readImageInfo
     * @function
     * @static
     *
     * @param {String} filename Name of image file to open and read meta data information.
     * @cb {Function} readCallback Callback function for image read operation.
	 * @cb-param {Object} error Information about the error, if any.
	 * @cb-param {GL2.Texture#ErrorCode} [error.code] A code identifying the error type.
	 * @cb-param {String} [error.description] A description of the error.
	 * @cb-param {Number} width The width in pixels of the image file.
	 * @cb-param {Number} height The height in pixels of the image file.
	 * @cb-param {Boolean} hasAlpha Flag is `true` if the image file contains alpha transparency.
	 * @cb-returns {void}
     * @example
     * GL2.Texture.readImageInfo("Content/ngmoco.pvr", function (error, width, height, hasAlpha) {
     *      if (error) {
     *          console.log("Unable to read image file info: " + error.description);
     *      } else {
     *          console.log("The image file info: " + width + ", " + height + ", " + hasAlpha);
     *      }
     * });
	 * @status iOS, Android
	 * @since 1.7
     */

	$readImageInfo: function( filename, readCallback ) {
        if ( !this._readCallbacks ) {
            this._readCallbacks = { uidGenerator:1 };
        }
        this._readCallbacks[++this._readCallbacks.uidGenerator] = readCallback;
        this._readImageInfoSendGen( this._readCallbacks.uidGenerator, filename );
    },

	/** @private */
    _onCreateCbRecv: function( cmd ) {
		var obj = {};
		if ( this._onCreateCbRecvGen( cmd, obj ) ) {
			if ( obj['callbackId'] >= 0 ) {
				var cb = this._restoreCb( obj['callbackId'] );
				var err = obj['errCode'] ? { code:obj['errCode'], description:obj['errStr'] } : null;
                if ( !err ) {
                    this._isImageValid = true;
                }
				cb( err, this );
			}
		}
    },

	/** @private */
	$_readImageInfoCbRecv: function( cmd ) {
        var obj = {};
        this._readImageInfoCbRecvGen( cmd, obj );

        if ( this._readCallbacks.hasOwnProperty( obj.callbackId ) ) {
            var err = obj['errCode'] ? { code:obj['errCode'], description:obj['errStr'] } : null;
            this._readCallbacks[obj.callbackId]( err, obj['width'], obj['height'], obj['hasAlpha'] );
            delete this._readCallbacks[obj.callbackId];
        }
    },

	/**
	 * No error occurred.
	 * @name ErrorCode.NoError
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * An unknown error occurred.
	 * @name ErrorCode.Unknown
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * The file was not found.
	 * @name ErrorCode.NotFound
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * The requested operation is not available.
	 * @name ErrorCode.Unsupported
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * Filter texture using nearest texel sampling.
	 * @name FilterMode.Nearest
	 * @fieldOf GL2.Texture#
	 * @constant
     * @private
	 */

	/**
	 * Filter texture using linear interpolation sampling.
	 * @name FilterMode.Linear
	 * @fieldOf GL2.Texture#
	 * @constant
     * @private
	 */

	/**
	 * Create texture without special options.
	 * @name OptionFlags.Default
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * Create texture using asynchronous processing if `true`.
	 * @name OptionFlags.ReadImageAsync
	 * @fieldOf GL2.Texture#
	 * @constant
	 */

	/**
	 * Create texture with a bit depth of 16 bits per pixel if `true`. This option applies to uncompressed, truecolor formats.
	 * @name OptionFlags.TruecolorDepth_BPP16
	 * @fieldOf GL2.Texture#
	 * @constant
     * @see GL2.Animation.setTextureColorDepth
	 */

	/**
	 * Clamp texture coordinates to the edge of the image along the indicated axis.
	 * @name WrapMode.Clamp
	 * @fieldOf GL2.Texture#
	 * @constant
     * @private
	 */

	/**
	 * Repeat texture coordinates using the fractional part along the indicated axis.
	 * @name WrapMode.Repeat
	 * @fieldOf GL2.Texture#
	 * @constant
     * @private
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	/** Texture Callback errors */
	ErrorCode:
	{ 
		NoError: 0,
		Unknown: -1,
		NotFound: -2,
		Unsupported: -3
	},
	
	/** @private Texture Filtering */
	FilterMode:
	{ 
		Nearest: 1,
		Linear: 2
	},
	
	/** Texture creation options */
	OptionFlags:
	{ 
		Default: 0,
		ReadImageAsync: 1,
		TruecolorDepth_BPP16: 2
	},
	
	/** @private Texture Wrapping */
	WrapMode:
	{ 
		Clamp: 1,
		Repeat: 2
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 365,
	// Method create = -1
	// Method destroy = 2
	// Method setFilterModes = 3
	// Method setWrapModes = 4
	// Method onCreateCb = 5
	// Method readImageInfoCb = -6
	// Method readImageInfo = -7
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._onCreateCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Texture._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -6:
					Texture._readImageInfoCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Texture._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[365] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onCreateCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Texture.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Texture.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Texture.onCreateCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Texture.onCreateCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	$_readImageInfoCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 6 )
		{
			NgLogE("Could not parse due to wrong argument count in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "errCode" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "errCode" ] === undefined )
		{
			NgLogE("Could not parse errCode in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "errStr" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "errStr" ] === undefined )
		{
			NgLogE("Could not parse errStr in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "width" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "width" ] === undefined )
		{
			NgLogE("Could not parse width in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "height" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "height" ] === undefined )
		{
			NgLogE("Could not parse height in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		obj[ "hasAlpha" ] = Core.Proc.parseBool( cmd[ 5 ] );
		if( obj[ "hasAlpha" ] === undefined )
		{
			NgLogE("Could not parse hasAlpha in Texture.readImageInfoCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId, callbackId, filename, options, minFilter, magFilter, wrapS, wrapT )
	{
		Core.Proc.appendToCommandString( 0x16dffff, [ +__objectRegistryId, +callbackId, Core.Proc.encodeString( filename ), +options, +minFilter, +magFilter, +wrapS, +wrapT ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x16d0002, this );
	},
	
	/** @private */
	_setFilterModesSendGen: function( minFilter, magFilter )
	{
		Core.Proc.appendToCommandString( 0x16d0003, this, [ +minFilter, +magFilter ] );
	},
	
	/** @private */
	_setWrapModesSendGen: function( wrapS, wrapT )
	{
		Core.Proc.appendToCommandString( 0x16d0004, this, [ +wrapS, +wrapT ] );
	},
	
	/** @private */
	$_readImageInfoSendGen: function( callbackId, filename )
	{
		Core.Proc.appendToCommandString( 0x16dfff9, [ +callbackId, Core.Proc.encodeString( filename ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId, callbackId, filename, options, minFilter, magFilter, wrapS, wrapT ) {}
	
	// destroy: function(  ) {}
	
	// setFilterModes: function( minFilter, magFilter ) {}
	
	// setWrapModes: function( wrapS, wrapT ) {}
	
	// _onCreateCbRecv: function( cmd ) {}
	// $_readImageInfoCbRecv: function( cmd ) {}
	// $readImageInfo: function( callbackId, filename ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Primitive'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Primitive'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Primitive'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Primitive.js';

var Node = require('NGCore/Client/GL2/Node').Node;
var Animation = require('NGCore/Client/GL2/Animation').Animation;
var Texture = require('NGCore/Client/GL2/Texture').Texture;
var Core = require('NGCore/Client/Core').Core;


var Primitive = exports.Primitive = Node.subclass(
/** @lends GL2.Primitive.prototype */
{
	classname: 'Primitive',

	/**
	 * @class The `GL2.Primitive` class provides the ability to draw arbitrary vertex-based polygons
	 * in two dimensions. Its APIs are similar to the `{@link GL2.Sprite}` class, which is used to
	 * display images and animations that are not warped or skewed.
	 *
	 * A primitive's vertexes are specified with `{@link GL2.Primitive.Vertex}` objects. Primitives
	 * can display solid colors, static images, or animations. Images and animations can be pinned
	 * to the primitive's vertexes. You can warp or skew an image by creating a primitive that
	 * represents the desired shape of the image, then pinning the image to the primitive's
	 * vertexes.
	 *
	 * By default, the primitive uses its vertexes to draw individual triangles; every group of
	 * three vertexes in the primitive represents a triangle. You can change this behavior by
	 * calling `{@link GL2.Primitive#setType}`.
	 *
	 * **Note**: Call `{@link Core.UpdateEmitter#setTickRate}` to set the frame rate for all
	 * animations that are attached to primitives.
	 * @constructs Create a primitive.
	 * @augments GL2.Node
	 */
    initialize: function()
    {
        this._animation = null;
		this._ownsAnimation = false;

		this._animationCompleteEmitter = new Core.MessageEmitter();
        this._type = this.Type.Triangles;
        this._vertexes = [];
    },

	/**
	 * Destroy the primitive, and release the resources allocated by the primitive.
	 *
	 * If the primitive is displaying a single image that was set by calling
	 * `{@link GL2.Primitive#setImage}`, calling `destroy()` will also destroy the reference to the
	 * image. If the primitive is displaying an animation that was set by calling
	 * `{@link GL2.Primitive#setAnimation}`, you must also call `{@link GL2.Animation#destroy}` to
	 * destroy the animation.
	 *
	 * **Important**: Destroying a primitive does not destroy the primitive's vertexes.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		var ownedAnim = this._unhookOwnedAnimation();
		if (ownedAnim)
			ownedAnim.destroy();
		this._animationCompleteEmitter.destroy();
	},

	/**
	 * Retrieve the number of vertexes in the primitive.
	 * @returns {Number} The current number of vertexes.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getVertexCount: function()
	{
		return this._vertexes.length;
	},

	/**
	 * Retrieve a single vertex from the primitive's vertexes.
	 * @param {Number} index The index of the vertex to retrieve.
	 * @returns {GL2.Primitive.Vertex} The current vertex at the specified index.
	 * @see GL2.Primitive#setVertex
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getVertex: function(index)
	{
		return this._vertexes[index];
	},

	/**
	 * Determine the type of geometry that the primitive will render.
	 * @returns {GL2.Primitive#Type} The type of geometry that the primitive will render.
	 * @see GL2.Primitive#setType
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getType: function()
	{
		return this._type;
	},

	/**
	 * Retrieve the primitive's current animation. If the primitive is displaying a single image
	 * that was set by calling `{@link GL2.Primitive#setImage}`, or if no animation has been
	 * assigned to the primitive, this method will return `null`.
	 * @returns {GL2.Animation} The primitive's current animation, or `null` if no animation is
	 *		assigned to the primitive.
	 * @see GL2.Primitive#setAnimation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAnimation: function()
	{
		if(this._ownsAnimation) return null;

		return this._animation;
	},

	/**
	 * Retrieve the primitive's "animation complete" emitter. This emitter fires when the primitive
	 * has finished playing the last frame of a non-looping animation. If a listener is attached to
	 * the emitter, the primitive will be passed to the listener's callback function.
	 *
	 * **Note**: If the animation is interrupted before it finishes playing, the "animation
	 * complete" emitter will not fire.
	 * @example
	 * var Listener = Core.MessageListener.subclass({
	 *     initialize: function() {
	 *         this.animation = new GL2.Animation();
	 *         this.primitive = new GL2.Primitive();
	 *         this.primitive.setAnimation(animation);
	 *         this.primitive.getAnimationCompleteEmitter().
	 *           addListener(this, this.onComplete.bind(this));
	 *     },
	 *
	 *     onComplete: function(primitive) {
	 *         console.log("Animation complete.");
	 *     }
	 * });
	 *
	 * // Instantiate the object.
	 * var listener = new Listener();
	 * @returns {Core.MessageEmitter} The "animation complete" emitter.
	 * @see Core.MessageEmitter
	 * @see Core.MessageListener
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	getAnimationCompleteEmitter: function()
	{
		return this._animationCompleteEmitter;
	},

	/**
	 * Set the animation to display in the primitive. The animation will start playing immediately,
	 * replacing any image or animation that was previously assigned to the primitive.
	 * @example
	 * var animation = new GL2.Animation();
	 * var primitive = new GL2.Primitive();
	 * primitive.setAnimation(animation);
	 * @param {GL2.Animation} animation The animation to display.
	 * @param {Number} [startTime=0] The time offset, in milliseconds, at which to start playing the
	 *		animation. For example, if an animation has ten frames, each of which is displayed for
	 *		50 milliseconds, and you specify the value `250`, playback will begin halfway through
	 *		the animation.
	 * @returns {void}
	 * @see GL2.Primitive#getAnimation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setAnimation: function(animation, startTime)
	{
		var ownedAnim = this._unhookOwnedAnimation();
		this._animation = animation;
		this._setAnimationSendGen( Core.ObjectRegistry.objectToId(animation), startTime || 0 );
		if (ownedAnim)
			ownedAnim.destroy();
	},

    /**
	 * Set a single image to display in the primitive. The image will be displayed immediately,
	 * replacing any image or animation that was previously assigned to the primitive. If the image
	 * is not square, or if its width and height are not a power of two, the image will be stretched
	 * into a square with power-of-two dimensions.
	 * // Create a primitive that displays a single image, which is taken from the
	 * // top right corner of a 4 x 4 sprite sheet.
	 * var primitive = new GL2.Primitive();
	 * primitive.setImage("./Content/unicorn.png"), new Core.Size(64, 64),
	 *   new Core.Point(0.5, 0.5), new Core.Rect(0, 0, 0.5, 0.5));
	 * @param {String|GL2.Texture} image The directory path to an image or a `GL2.Texture` object.
	 * @param {Core.Size} size The size, in pixels, of the image to display,
	 * @param {Core.Point} [anchor=[0.5, 0.5]] The offset within the node that defines the
	 *		anchor point for scaling and rotation. The anchor point defines the origin of any
	 *		scaling or rotation that is applied to the node. Its offset is defined as a multiple of
	 *		the node's width and height. For example, the default anchor offset, `[0.5, 0.5]`,
	 *		represents a point that is centered on the U and V axes. If you omit this parameter, you
	 *		must also omit the `uvs` parameter.
	 * @param {Core.Rect} [uvs=[0, 0, 1, 1]] The region within the image to display. Specified in UV
	 *		coordinates ranging from 0 to 1, which represent a percentage of the original image's
	 *		width and height. The four coordinates represent the U origin, the V origin, the U
	 *		width, and the V height, in that order. By default, the entire image is displayed.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setImage: function(image, size, anchor, uvs)
	{
		var prevOwnedAnim = this._unhookOwnedAnimation();

		// Create a single frame animation.
		var args = Array.prototype.slice.call(arguments, 0);
        // replace Texture with filename
        if (image.classname === "Texture")
        {
            args[0] = image.getFilename();
        }
		args.splice(1, 0, 0); // Insert a duration of zero into our arguments.
		var frame = new Animation.Frame(args[0], args[1], args[2], args[3], args[4]);
		var animation = new Animation();
		animation.pushFrame(frame);

		this._animation = animation;
		this._ownsAnimation = true;

		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation),0);

		if (prevOwnedAnim)
			prevOwnedAnim.destroy();

		return this;
	},

    /**
	 * Set the type of geometry that the primitive will render. See `{@link GL2.Primitive#Type}`
	 * for information about the types of geometry that are supported.
	 * @example
	 * var primitive = new GL2.Primitive();
	 * primitive.setType(GL2.Primitive.Type.TriangleFan);
	 * @param {GL2.Primitive#Type} type The type of geometry that the primitive will render.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setType: function(type)
	{
		this._type = type;

		this._setTypeSendGen(type);

		return this;
	},

    /**
	 * Add a vertex to the end of the primitive's list of vertexes. Calling this method is
	 * equivalent to calling `{@link GL2.Primitive#spliceVertexes}` in the following way:
	 *
	 *     primitive.spliceVertexes(primitive.getVertexCount(), 0, vertex);
	 * @example
	 * var primitive = new GL2.Primitive();
	 * primitive.pushVertex(new GL2.Primitive.Vertex([0, 0], [0, 0], [0.3, 0.4, 0.5]));
     * @param {GL2.Primitive.Vertex} vertex The vertex to add.
     * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
     */
    pushVertex: function(vertex)
	{
		return this.spliceVertexes(this._vertexes.length, 0, vertex);
	},

    /**
	 * Replace the vertex at a specified index. Calling this method is equivalent to
	 * calling `{@link GL2.Primitive#spliceVertexes}` in the following way:
	 *
	 *     primitive.spliceVertexes(i, 1, vertex);
	 * @param {Number} i The index of the vertex to replace.
	 * @param {GL2.Primitive.Vertex} vertex The vertex to insert.
	 * @returns {this}
	 * @see GL2.Primitive#getVertex
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setVertex: function(i, vertex)
	{
		return this.spliceVertexes(i, 1, vertex);
	},

    /**
	 * Remove a specified number of vertexes, and replace them with zero or more vertexes. You can
	 * pass any number of new vertexes to this method.
	 * @example
	 * // Create a square primitive with four vertexes, then turn the square into
	 * // an irregularly shaped polygon by replacing the third vertex.
	 * var widthHeight = 100;
	 * var color = [0.3, 0.4, 0.5];
	 * var primitive = new GL2.Primitive();
	 * primitive.setType(GL2.Primitive.Type.TriangleFan);
	 * primitive.pushVertex(new GL2.Primitive.Vertex([0, 0], [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([widthHeight, 0], [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([widthHeight, widthHeight],
	 *   [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([0, widthHeight], [0, 0], color));
	 *
	 * // Replace the third vertex.
	 * primitive.spliceVertexes(2, 1, new GL2.Primitive.Vertex([widthHeight + 10, -10],
	 *   [0, 0], color));
	 * @example
	 * // Create a square primitive with four vertexes, then turn the square into
	 * // a triangle by removing the second vertex.
	 * var widthHeight = 100;
	 * var color = [0.3, 0.4, 0.5];
	 * var primitive = new GL2.Primitive();
	 * primitive.setType(GL2.Primitive.Type.TriangleFan);
	 * primitive.pushVertex(new GL2.Primitive.Vertex([0, 0], [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([widthHeight, 0], [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([widthHeight, widthHeight],
	 *   [0, 0], color));
	 * primitive.pushVertex(new GL2.Primitive.Vertex([0, widthHeight], [0, 0], color));
	 *
	 * // Remove the second vertex.
	 * primitive.spliceVertexes(1, 1);
	 * @param {Number} start The index of the first vertex to remove.
	 * @param {Number} len The total number of vertexes to remove.
	 * @param {GL2.Primitive.Vertex} [vertex] The vertex to insert. To insert more than one vertex,
	 *		pass additional arguments to the method.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    spliceVertexes: function(start, len, vertexes)
	{

		this._vertexes.splice.apply(this._vertexes, arguments);

		var vertexCount = arguments.length-2;
		this._spliceVertexesSendGen(start,len,vertexCount);

		for(var i=0; i < vertexCount; ++i)
		{
			var vertex = arguments[i+2];
			var position = vertex.getPosition();
			var uv = vertex.getUV();
			var color = vertex.getColor();
			this._vertexSendGen(
				position.getX(),
				position.getY(),
				uv.getX(),
				uv.getY(),
				color.getRed(),
				color.getGreen(),
				color.getBlue()
			);
		}

		return this;
	},

	$Vertex: Core.Class.subclass(
	/** @lends GL2.Primitive.Vertex.prototype */
	{
		classname: 'Vertex',

		/**
		 * @class `GL2.Primitive.Vertex` objects specify the location, texture coordinates, and
		 * color of a vertex in a primitive.
		 *
		 * + The vertex's location is in pixel coordinates and is relative to its ancestors'
		 * position, scale, and rotation.
		 * + The texture coordinate indicates the UV coordinate in the primitive's image or
		 * animation that will be pinned to the vertex.
		 * + The color represents a fill color that will radiate out from the vertex into the
		 * primitive. If two vertexes have different colors, the fill colors will be faded into one
		 * another.
		 * @constructs Create a vertex for a primitive.
		 * @augments Core.Class
		 * @example
		 * // Create a vertex that contributes an orange fill to the primitive and
		 * // pins images and animations at their top left corner.
		 * var vertex = new GL2.Primitive.Vertex([200, 100], [0, 0], [1.0, 0.5, 0]);
		 * @param {Core.Point|Number[]} position The vertex's location, in pixel coordinates
		 *		relative to its ancestors' position, scale, and totation. Specified as a
		 *		`{@link Core.Point}` object or as two separate floats that represent the U and V
		 *		coordinates, in that order.
		 * @param {Core.Point|Number[]} uv The UV coordinates in the primitive's image or animation
		 *		that will be pinned to the vertex. Specified as a `{@link Core.Point}` object or as
		 *		two separate floats that represent the U and V coordinates, in that order; each
		 *		float can range from `0` to `1`.
		 * @param {Core.Color|Number[]} color The vertex's RGB color. Specified as a
		 *		`{@link Core.Color}` object or as three separate floats that represent the red,
		 *		green, and blue values of the color, in that order; each float can range from `0` to
		 *		`1`.
		 * @see GL2.Primitive
		 * @since 1.0
		 */
		initialize: function(position, uv, color)
		{
			this._position = new Core.Point(position);
			this._uv = new Core.Point(uv);
			this._color = new Core.Color(color);
		},

		/**
		 * Retrieve the vertex's current location, measured in pixel coordinates that are relative
		 * to its ancestors' position, scale, and rotation.
		 * @returns {Core.Point} The vertex's current location, in pixel coordinates relative to its
		 *		ancestors' position, scale, and totation.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getPosition: function()
		{
			return this._position;
		},

		/**
		 * Retrieve the UV coordinates in the primitive's image or animation that will be pinned to
		 * the vertex.
		 * @returns {Core.Point} The current UV coordinates in the primitive's image or animation
		 *		that will be pinned to the vertex.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getUV: function()
		{
			return this._uv;
		},

		/**
		 * Retrieve the fill color that will radiate out from the vertex into the primitive.
		 * @returns {Core.Color} The current RGB color.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
		 * @since 1.0
		 */
		getColor: function()
		{
			return this._color;
		}
	}),

	_unhookOwnedAnimation: function()
	{
		var retVal = undefined;
		if(this._ownsAnimation)
		{
			// Set our animation to NULL to unlink ourselves from the animation on the backend
			// or else trying to destory the animation will fail because we are still using it.
			this._setAnimationSendGen(0,0);
			retVal = this._animation;
			this._animation = null;
			this._ownsAnimation = false;
		}
		this._animation = null;
		this._image = null;
		return retVal;
	},

	/**
	 * Enumeration for the types of geometry that a primitive can render.
	 * @name Type
	 * @fieldOf GL2.Primitive#
	 */

	/**
	 * Every group of three vertexes defines a separate triangle. The number of vertexes must be
	 * divisible by three.
	 *
	 * For example, if a primitive includes vertexes `[A, B, C, D, E, F]`, the following triangles
	 * will be drawn:
	 *
	 * + `ABC`
	 * + `DEF`
	 * @name Type.Triangles
	 * @fieldOf GL2.Primitive#
	 * @constant
	 */

	/**
	 * Every vertex defines a triangle that includes the previous two vertexes. Use this option to
	 * create a series of connected triangles. The primitive must have at least three vertexes.
	 *
	 * For example, if a primitive includes vertexes `[A, B, C, D, E, F]`, the following triangles
	 * will be drawn:
	 *
	 * + `ABC`
	 * + `BCD`
	 * + `CDE`
	 * + `DEF`
	 * @name Type.TriangleStrip
	 * @fieldOf GL2.Primitive#
	 * @constant
	 */

	/**
	 * Every vertex defines a triangle that includes the first vertex and the previous vertex. Use
	 * this option to create several triangles that form a polygon. The primitive must have at least
	 * three vertexes.
	 *
	 * For example, if a primitive includes vertexes `[A, B, C, D, E, F]`, the following triangles
	 * will be drawn:
	 *
	 * + `ABC`
	 * + `ACD`
	 * + `ADE`
	 * + `AEF`
	 * @name Type.TriangleFan
	 * @fieldOf GL2.Primitive#
	 * @constant
	 */

	/**
	 * Every pair of two vertexes defines a line segment. Each line segment is drawn with a width of
	 * one pixel. The number of vertexes must be divisible by two.
	 *
	 * For example, if a primitive includes vertexes `[A, B, C, D, E, F]`, the following line
	 * segments will be drawn:
	 *
	 * + `AB`
	 * + `CD`
	 * + `EF`
	 * @name Type.LineList
	 * @fieldOf GL2.Primitive#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Type:
	{ 
		Triangles: 0,
		TriangleStrip: 1,
		TriangleFan: 2,
		LineList: 3
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 308,
	// Method create = -1
	// Method spliceVertexes = 2
	// Method vertex = 3
	// Method setType = 4
	// Method setAnimation = 5
	// Method animationComplete = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._animationCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Primitive._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Primitive._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[308] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_animationCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Primitive.animationComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x134ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_spliceVertexesSendGen: function( start, len, vertexCount )
	{
		Core.Proc.appendToCommandString( 0x1340002, this, [ +start, +len, +vertexCount ] );
	},
	
	/** @private */
	_vertexSendGen: function( x, y, u, v, red, green, blue )
	{
		Core.Proc.appendSubcommandToCommandString( [ +x, +y, +u, +v, +red, +green, +blue ] );
	},
	
	/** @private */
	_setTypeSendGen: function( type )
	{
		Core.Proc.appendToCommandString( 0x1340004, this, [ +type ] );
	},
	
	/** @private */
	_setAnimationSendGen: function( animation, startTime )
	{
		Core.Proc.appendToCommandString( 0x1340005, this, [ +animation, +startTime ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// spliceVertexes: function( start, len, vertexCount ) {}
	
	// vertex: function( x, y, u, v, red, green, blue ) {}
	
	// setType: function( type ) {}
	
	// setAnimation: function( animation, startTime ) {}
	
	// _animationCompleteRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Touch'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Touch'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Touch'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Touch.js';

var Core = require('NGCore/Client/Core').Core;

var Touch = exports.Touch = Core.Class.subclass(
/** @lends GL2.Touch.prototype */
{
	classname: 'Touch',

	/**
	 * @class The `GL2.Touch` class provides objects that identify touch events and track a finger's
	 * movement across the device's screen. `GL2.Touch` objects are created by a
	 * `{@link GL2.TouchTarget}` object's touch emitter, then passed to the emitter's message
	 * listener. See `{@link GL2.TouchTarget#getTouchEmitter}` for details about creating a message
	 * listener for a touch emitter.
	 *
	 * **Note**: Do not instantiate this class directly.
	 * @constructs
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		this._id = 0;
		this._action = {};
		this._position = new Core.Point();
		this._targetIds = null;
		this._targetIdMap = {};
	},

	/**
	 * Retrieve a list of touch targets that are tracking the touch object's events.
	 * @returns {GL2.TouchTarget[]} An array of touch targets that are tracking the touch object's
	 *		events.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getTouchTargets: function()
	{
		var ids = this._targetIds;
		var result = [];
		if (ids) {
			for(var i = 0; i < ids.length; i++)
			{
				var t = Core.ObjectRegistry.idToObject(ids[i]);
				if(t) result.push(t);
			}
		}
		return result;
	},

	/**
	 * Determine whether the user's initial touch fell within the specified touch target.
	 * @param {GL2.TouchTarget} touchTarget The touch target to evaluate.
	 * @returns {Boolean} Set to `true` if the user's initial touch fell within the touch target.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	getIsInside: function(touchTarget)
	{
		// Check if the object's id is in the touchtargets map
		return ( Core.ObjectRegistry.objectToId(touchTarget) in this._targetIdMap);
	},

	/**
	 * Retrieve the touch object's current position within the global scene's coordinate space.
	 * @returns {Core.Point} The position of the touch object within the global scene's coordinate
	 *		space.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPosition: function()
	{
		return this._position;
	},

	/**
	 * Retrieve the touch object's unique ID.
	 *
	 * **Note**: Do not use this ID as an index to an array. The ID is often a very large number,
	 * and using it as an array index can cause JavaScript to allocate a much larger array than
	 * necessary.
	 * @returns {Number} The touch object's unique id.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getId: function()
	{
		return this._id;
	},

	/**
	 * Retrieve the current phase of the touch event that the touch object is tracking. Call this
	 * method from the touch emitter's listener. See `{@link GL2.TouchTarget#getTouchEmitter}` for
	 * an example of how to use this method.
	 *
	 * If this method returns the value `{@link GL2.Touch#Action.Start}`, the touch emitter's
	 * listener can capture the event by returning `true` from the event handler. If the event
	 * handler returns `true`, the emitter continues to fire throughout the touch event. If the
	 * event handler does not return `true`, the event propagates downwards to other touch targets.
	 * @returns {GL2.Touch#Action} The current phase of the touch event that the touch object is
	 *		tracking.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAction: function()
	{
		return this._action;
	},

	_setId: function(id)
	{
		this._id = id;
	},

	_setAction: function(action)
	{
		this._action = action;
	},

	_setPosition: function(position)
	{
		this._position.setAll(arguments);
	},

	_setTargetIds: function(targetIds)
	{
		// We transfer the array of numeric target IDs into a
		// map so we can support getIsInside call which uses 'in'.
		this._targetIds = targetIds.slice();
		this._targetIdMap = {};
		for (var i = 0; i < targetIds.length; i++)
			this._targetIdMap[targetIds[i]] = null;
	},

	/**
	 * Enumeration for the phases of a touch event.
	 * @name Action
	 * @fieldOf GL2.Touch#
	 */

	/**
	 * The user's finger started touching the screen.
	 * @name Action.Start
	 * @fieldOf GL2.Touch#
	 * @constant
	 */

	/**
	 * The user's finger stopped touching the screen.
	 * @name Action.End
	 * @fieldOf GL2.Touch#
	 * @constant
	 */

	/**
	 * The user's finger moved to a new location on the screen.
	 * @name Action.Move
	 * @fieldOf GL2.Touch#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	Action:
	{ 
		Start: 0,
		End: 1,
		Move: 2
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 312,
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Touch._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Touch._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[312] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Sprite'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Sprite'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Sprite'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Sprite.js';

var Core = require('NGCore/Client/Core').Core;
var Node = require('NGCore/Client/GL2/Node').Node;
var Animation = require('NGCore/Client/GL2/Animation').Animation;
var Texture = require('NGCore/Client/GL2/Texture').Texture;


var Sprite = exports.Sprite = Node.subclass(
/** @lends GL2.Sprite.prototype */
{
	classname: 'Sprite',

	/**
	 * @class The `GL2.Sprite` class is used to display a sprite that contains a single image or an
	 * animation. Its APIs are similar to the `{@link GL2.Primitive}` class, which is used to draw
	 * vertex-based polygons.
	 *
	 * Sprites cannot warp or skew their images and animations. Use the `{@link GL2.Primitive}`
	 * class if you need to warp or skew an image or animation.
	 *
	 * **Note**: Call `{@link Core.UpdateEmitter#setTickRate}` to set the frame rate for all
	 * animations that are attached to sprites.
	 * @constructs Create a sprite.
	 * @augments GL2.Node
	 * @since 1.0
	 */
    initialize: function()
    {
		this._clubObject = null;
        this._animation = null;
		this._ownsAnimation = false;

		this._animationCompleteEmitter = new Core.MessageEmitter();
    },

	/**
	 * Destroy the sprite, and release the resources allocated by the sprite.
	 *
	 * If the sprite is displaying a single image that was set by calling
	 * `{@link GL2.Sprite#setImage}`, calling `destroy()` will also destroy the reference to the
	 * image. If the sprite is displaying an animation that was set by calling
	 * `{@link GL2.Sprite#setAnimation}`, you must also call `{@link GL2.Animation#destroy}` to
	 * destroy the animation.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		var ownedAnim = this._unhookOwnedAnimation();
		if (ownedAnim)
			ownedAnim.destroy();
		this._animationCompleteEmitter.destroy();
	},

	/**
	 * Retrieve the sprite's current animation. If the sprite is displaying a single image that was
	 * set by calling `{@link GL2.Sprite#setImage}`, or if no animation has been assigned to the
	 * sprite, this method will return `null`.
	 * @returns {GL2.Animation} The sprite's current animation, or `null` if no animation is
	 *		assigned to the sprite.
	 * @see GL2.Sprite#setAnimation
	 * @see GL2.Sprite#setImage
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAnimation: function()
	{
		if(this._ownsAnimation) return null;

		return this._animation;
	},

    /**
	 * Retrieve the sprite's "animation complete" emitter. This emitter fires when the sprite
	 * has finished playing the last frame of a non-looping animation. If a listener is attached to
	 * the emitter, the sprite will be passed to the listener's callback function.
	 *
	 * **Note**: If the animation is interrupted before it finishes playing, the "animation
	 * complete" emitter will not fire.
	 * @example
	 * var Listener = Core.MessageListener.subclass({
	 *     initialize: function() {
	 *         this.animation = new GL2.Animation();
	 *         this.sprite = new GL2.Sprite();
	 *         this.sprite.setAnimation(animation);
	 *         this.sprite.getAnimationCompleteEmitter().
	 *           addListener(this, this.onComplete.bind(this));
	 *     },
	 *
	 *     onComplete: function(sprite) {
	 *         console.log("Animation complete.");
	 *     }
	 * });
	 *
	 * // Instantiate the object.
	 * var listener = new Listener();
	 * @returns {Core.MessageEmitter} The "animation complete" emitter.
	 * @see Core.MessageEmitter
	 * @see Core.MessageListener
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAnimationCompleteEmitter: function()
	{
		return this._animationCompleteEmitter;
	},

    /**
	 * Set the animation to display in the sprite. The animation will start playing immediately,
	 * replacing any image or animation that was previously assigned to the sprite.
	 * @example
	 * var animation = new GL2.Animation();
	 * var sprite = new GL2.Sprite();
	 * sprite.setAnimation(animation);
	 * @param {GL2.Animation} animation The animation to display.
	 * @param {Number} [startTime=0] The time offset, in milliseconds, at which to start playing the
	 *		animation. For example, if an animation has ten frames, each of which is displayed for
	 *		50 milliseconds, and you specify the value `250`, playback will begin halfway through
	 *		the animation.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setAnimation: function(animation, startTime)
	{
		var ownedAnim = this._unhookOwnedAnimation();
		this._animation = animation;
		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation), startTime || 0);
		if (ownedAnim)
			ownedAnim.destroy();
		return this;
	},

    /**
	 * Set a single image to display in the sprite. The image will be displayed immediately,
	 * replacing any image or animation that was previously assigned to the sprite. If the image is
	 * not square, or if its width and height are not a power of two, the image will be stretched
	 * into a square with power-of-two dimensions.
	 * @example
	 * // Create a sprite that displays a single image, which is taken from the
	 * // top right corner of a 4 x 4 sprite sheet.
	 * var sprite = new GL2.Sprite();
	 * sprite.setImage("./Content/unicorn.png"), new Core.Size(64, 64),
	 *   new Core.Point(0.5, 0.5), new Core.Rect(0, 0, 0.5, 0.5));
	 * @param {String|GL2.Texture} image The directory path to an image or a `GL2.Texture` object.
	 * @param {Core.Size} size The size, in pixels, of the image to display,
	 * @param {Core.Point} [anchor=[0.5, 0.5]] 	The offset within the node that defines the
	 *		anchor point for scaling and rotation. 	The anchor point defines the origin of any
	 *		scaling or rotation that is applied to the node. Its offset is defined as a multiple of
	 *		the node's width and height. For example, the default anchor offset, `[0.5, 0.5]`,
	 *		represents a point that is centered on the U and V axes. If you omit this parameter, you
	 *		must also omit the `uvs` parameter.
	 * @param {Core.Rect} [uvs=[0, 0, 1, 1]] The region within the image to display. Specified in UV
	 *		coordinates ranging from 0 to 1, which represent a percentage of the original image's
	 *		width and height. The four coordinates represent the U origin, the V origin, the U
	 *		width, and the V height, in that order. By default, the entire image is displayed.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setImage: function(image, size, anchor, uvs)
	{
		var prevOwnedAnim = this._unhookOwnedAnimation();

		// Create a single frame animation.
		var args = Array.prototype.slice.call(arguments, 0);
        // replace Texture with filename
        if (image.classname === "Texture")
        {
            args[0] = image.getFilename();
        }
		args.splice(1, 0, 0); // Insert a duration of zero into our arguments.
		var frame = new Animation.Frame(args[0], args[1], args[2], args[3], args[4]);
		var animation = new Animation();
		animation.pushFrame(frame);

		this._animation = animation;
		this._ownsAnimation = true;

		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation),0);

		if (prevOwnedAnim)
			prevOwnedAnim.destroy();

		return this;
	},

	_unhookOwnedAnimation: function()
	{
		var retVal = undefined;
		if(this._ownsAnimation)
		{
			// Set our animation to NULL to unlink ourselves from the animation on the backend
			// or else trying to destroy the animation will fail because we are still using it.
			this._setAnimationSendGen(0,0);
			retVal = this._animation;
			this._animation = null;
			this._ownsAnimation = false;
		}
		this._animation = null;
		return retVal;
	},

	_animationCompleteRecv: function(cmd)
	{
		var msg = {};
		if(!this._animationCompleteRecvGen(cmd, msg))
			return;

		this._animationCompleteEmitter.emit(this);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 310,
	// Method create = -1
	// Method setAnimation = 2
	// Method animationComplete = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._animationCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Sprite._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Sprite._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[310] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_animationCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Sprite.animationComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x136ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_setAnimationSendGen: function( animation, startTime )
	{
		Core.Proc.appendToCommandString( 0x1360002, this, [ +animation, +startTime ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setAnimation: function( animation, startTime ) {}
	
	// _animationCompleteRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/TouchTarget'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/TouchTarget'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/TouchTarget'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/TouchTarget.js';

var Node = require('NGCore/Client/GL2/Node').Node;
var Sprite = require('NGCore/Client/GL2/Sprite').Sprite;
var Core = require('NGCore/Client/Core').Core;


var TouchTarget = exports.TouchTarget = Node.subclass(
/** @lends GL2.TouchTarget.prototype */
{
	classname: 'TouchTarget',

	/**
	 * @class The `GL2.TouchTarget` class provides applications with access to touch events.
	 *
	 * **Note**: Do not use `GL2.TouchTarget` to monitor touch events for `{@link UI}` objects.
	 * Instead, use the events that are provided by each class in the `{@link UI}` module.
	 *
	 * A touch target is a rectangular area that is defined based on its size and its offset from
	 * the X and Y origin. If the user touches an area of the screen that is covered by the touch
	 * target, the touch target fires a `touch` event, which your application can receive by
	 * attaching a message listener to the touch emitter. To attach a listener, call
	 * `{@link GL2.TouchTarget#getTouchEmitter}`.
	 *
	 * A touch target will activate even if its parent or ancestor nodes are not visible. You can
	 * call the `setTouchable()` method, inherited from `{@link GL2.Node}`, to disable a touch
	 * target.
	 *
	 * **Note**: If a clipping rectangle is active, and the touch target is outside of the clipping
	 * rectangle, the touch target will not be touchable. See `{@link GL2.Node#setClipRect}` and
	 * `{@link GL2.Node#setClipRectEnabled}` for additional details about clipping rectangles.
	 *
	 * When you instantiate a touch target, it is created with a size of `0` and an anchor point of
	 * `[0, 0]`. Call `{@link GL2.TouchTarget#setSize}` and `{@link GL2.TouchTarget#setAnchor}` to
	 * change these properties so they define an area that can receive touch events. In most cases,
	 * you will set these properties so they are identical to the corresponding properties of a
	 * `{@link GL2.Primitive}`, `{@link GL2.Sprite}`, or `{@link GL2.Text}` object. You can then add
	 * the touch target as a child of the visible node and call the `setPosition()` method,
	 * inherited from `{@link GL2.Node}`, to indicate that the touch target has an offset of 0 from
	 * its parent node. The touch target will inherit transformations from its parent node.
	 * @constructs Create a touch target.
	 * @augments GL2.Node
	 * @since 1.0
	 */
    initialize: function()
    {
		this._size = new Core.Size();
		this._anchor = new Core.Point(0, 0);
		this._touchEmitter = new Core.MessageEmitter();
    },

	/**
	 * Destroy the touch target, and release the resources allocated by the touch target.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
	},

	/**
	 * Retrieve the size of the touch target. The size is relative to the scale that has been
	 * applied to the parent node.
	 * @example
	 * // Create a parent node that scales up its child nodes.
	 * var node = new GL2.Node();
	 * node.setScale(50, 25);
	 * // Add a touch target to the parent node.
	 * var touchTarget = new GL2.TouchTarget();
	 * node.addChild(touchTarget);
	 * // Because the touch target's parent node has been scaled, the following call
	 * // to setSize() will result in a touch target that covers a 50 pixel by 25 pixel
	 * // rectangle on the device's screen.
	 * touchTarget.setSize(new Core.Size(1, 1));
	 * // The value returned by getSize() does not reflect any scaling that has been
	 * // applied to the parent node.
	 * var targetSize = touchTarget.getSize();
	 * console.log(targetSize.getWidth());  // prints "1"
	 * console.log(targetSize.getHeight()); // prints "1"
	 * @returns {Core.Size} The current size of the touch target.
	 * @see GL2.TouchTarget#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSize: function()
	{
		return this._size;
	},

	/**
	 * Retrieve the offset of the touch target's anchor point. The anchor point defines the
	 * origin of any scaling or rotation that is applied to the touch target.
	 * @returns {Core.Point} The current offset of the touch target's anchor point.
	 * @see GL2.TouchTarget#setAnchor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getAnchor: function()
	{
		return this._anchor;
	},

	/**
	 * Retrieve the touch emitter for the touch target. By adding a listener to the touch emitter,
	 * you can monitor touch events as the user touches the target, moves a finger across the
	 * screen, and stops touching the screen. The touch emitter calls the listener's callback
	 * function, passing in a `{@link GL2.Touch}` object.
	 *
	 * The emitter fires its first event when the user touches the touch target. If the handler for
	 * this initial event returns the value `true`, the emitter captures the touch event and
	 * continues to fire as long as the user continues to touch the screen, regardless of whether
	 * the user's finger is within the touch target. The emitter stops firing when the user's finger
	 * is no longer touching the screen.
	 *
	 * If the handler for the initial touch event does not return `true`, the touch event will
	 * continue to propagate to touch targets that have a lower depth.
	 * @example
	 * // Create a subclass of Core.MessageListener that covers the entire screen
	 * // with a touch target and handles touch events.
	 * var Target = Core.MessageListener.subclass({
	 *     initialize: function() {
	 *         this.node = new GL2.Node();
	 *         this.target = new GL2.TouchTarget();
	 *
	 *         var anchor = new Core.Point(0.5, 0.5);
	 *         var size = new Core.Size(Device.LayoutEmitter.getWidth(),
	 *           Device.LayoutEmitter.getHeight());
	 *         this.target.setAnchor(anchor);
	 *         this.target.setSize(size);
	 *
	 *         this.target.getTouchEmitter().addListener(this, this.onTouch.
	 *           bind(this));
	 *
	 *         node.addChild(this.target);
	 *         GL2.Root.addChild(this.node);
	 *     },
	 *
	 *     onTouch: function(touch) {
	 *         switch(touch.getAction()) {
	 *             case touch.Action.Start:
	 *                 // Start tracking the touch event.
	 *                 this.trackingId = touch.getId();
	 *                 this.trackingPosition = touch.getPosition();
	 *
	 *                 // Identify the touch event's offset from the global
	 *                 // scene coordinates.
	 *                 var local = this.screenToLocal(this.trackingPosition);
	 *                 var current = this.getPosition();
	 *                 this.trackingOffset = new Core.Vector(current.getX() - local.getX(),
	 *                   current.getY() - local.getY());
	 *
	 *                 // Return true so that we continue to get touch events.
	 *                 return true;
	 *
	 *             case touch.Action.Move:
	 *                 // Make sure this is the same touch that we are
	 *                 // currently tracking.
	 *                 if (this.trackingId != touch.getId()) {
	 *                     return;
	 *                 }
	 *                 // Update the touch position.
	 *                 this.trackingPosition = touch.getPosition();
	 *                 break;
	 *
	 *             case touch.Action.End:
	 *                 // Make sure this is the same touch that we are
	 *                 // currently tracking.
	 *                 if (this.trackingId != touch.getId()) {
	 *                     return;
	 *                 }
	 *                 // Clear the ID and position.
	 *                 this.trackingId = this.trackingPosition = null;
	 *                 break;
	 *         }
	 *     }
	 * });
	 *
	 * // Instantiate the object.
	 * var myTouchTarget = new Target();
	 * @returns {Core.MessageEmitter} The touch emitter for this touch area.
	 * @see Core.MessageEmitter
	 * @see Core.MessageListener
	 * @see GL2.Touch#getAction
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getTouchEmitter: function()
	{
		return this._touchEmitter;
	},

    /**
	 * Set the touch target's width and height. The size is relative to the scale that has been
	 * applied to the parent node.
	 * @example
	 * // Create a parent node that scales up its child nodes.
	 * var node = new GL2.Node();
	 * node.setScale(50, 25);
	 * // Add a touch target to the parent node.
	 * var touchTarget = new GL2.TouchTarget();
	 * node.addChild(touchTarget);
	 * // Because the touch target's parent node has been scaled, the following call
	 * // to setSize() will result in a touch target that covers a 50 pixel by 25 pixel
	 * // rectangle on the device's screen.
	 * touchTarget.setSize(new Core.Size(1, 1));
	 * @param {Core.Size} size The touch target's new width and height.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setSize: function(size)
	{
		var s = this._size;
		s.setAll.apply(s, arguments);

		this._setSizeSendGen(s.getWidth(),s.getHeight());

		return this;
	},

	/**
	 * Set the offset of the touch target's anchor point. The anchor point defines the origin of
	 * any scaling or rotation that is applied to the touch target. Its offset is defined as a
	 * multiple of the touch target's width and height. For example, the anchor point offset
	 * `[0.5, 0.5]` represents a point that is centered on the X and Y axes.
	 *
	 * **Note**: The anchor point is calculated before transformations are applied to the touch
	 * target.
 	 * @example
	 * var touchTarget = new GL2.TouchTarget();
	 * touchTarget.setAnchor(new Core.Point(0.25, 0.25));
	 * @param {Core.Point} anchor The new offset of the touch target's anchor point.
	 * @returns {this}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAnchor: function(anchor)
	{
		var a = this._anchor;
		a.setAll.apply(a, arguments);

		this._setAnchorSendGen(a.getX(),a.getY());

		return this;
	},

	/**
	 * Translate a location in the global scene's coordinate space to the touch target's local
	 * coordinate space. Use this method to determine a touch event's offset from the touch target.
	 *
	 * For an example of how to use this method, see the example for
	 * `{@link GL2.TouchTarget#getTouchEmitter}`.
	 * @name GL2.TouchTarget#screenToLocal
	 * @function
	 * @param {Core.Point} location The location to transform.
	 * @returns {Core.Point} The location's coordinates within the touch target's local coordinate
	 *		space.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */

	screenToLocal: function($super, location)
	{
		location = $super(location);
		if(!location)
			return undefined;

		var a = this._anchor;
		var s = this._size;

		location.setX(location.getX() + a.getX() * s.getWidth());
		location.setY(location.getY() + a.getY() * s.getHeight());
		return location;
	},

	/**
	 * Translate a location in the touch target's local coordinate space to the global scene's
	 * coordinate space. Use this method to translate between two local coordinate spaces.
	 * @name GL2.TouchTarget#localToScreen
	 * @function
	 * @param {Core.Point} location The location in the touch target's local coordinate space to
	 *		transform.
	 * @returns {Core.Point} The location's coordinate within the global scene's coordinate space.
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */

	localToScreen: function($super, location)
	{
		var a = this._anchor;
		var s = this._size;

		location.setX(location.getX() - a.getX() * s.getWidth());
		location.setY(location.getY() - a.getY() * s.getHeight());

		location = $super(location);
		if(!location)
			return undefined;
		return location;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 313,
	// Method create = -1
	// Method setSize = 2
	// Method setAnchor = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in TouchTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in TouchTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[313] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x139ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_setSizeSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( 0x1390002, this, [ +width, +height ] );
	},
	
	/** @private */
	_setAnchorSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1390003, this, [ +x, +y ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setSize: function( width, height ) {}
	
	// setAnchor: function( x, y ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// GL2 diagnostic emitter; collects info from GL2 subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

//
// Create and export a DiagnosticEmitter for GL2.
//

var Diagnostics = exports.Diagnostics = Core.DiagnosticEmitter.singleton(
    /** @lends GL2.Diagnostics.prototype */
{
    classname: 'GL2_Diagnostics',

    /**
     * @class the <code>GL2.Diagnostics</code> class constructs a singleton object
     * that emits detailed GL2 diagnostic information to its listeners.
     *
     * The emitter currently emits an object of the form:
     * <pre>
     *  {
     *      "name":"GL2",                  // Emitter name, 'GL2'
     *
     *      "graph_nodes": {Number},       // Number of nodes in the scene graph
     *
     *      "gl2_scene_time":{             // A Timer object reporting total time traversing the scene:
     *           "samples": {Number},      // Number of timer executions captured this interval
     *           "average": {Number},      // Average time spent in the timed block
     *           "min": {Number},          // Minimum time spent in the timed block
     *           "max": {Number}           // Maximum time spent in the timed block
     *      },                             // Other {Timer} below are identical.
     *
     *      "gl2_touch_time":{Timer},      // Time spent processing Touch events
     *
     *      "ngfx_last_frame":{                // Object containing ngfx statistics from the last frame:
     *          "total_vertices": {Number},    // Total vertices drawn
     *          "total_primitives": {Number},  // Total number of GL2.Primitives drawn
     *          "total_indices": {Number},     // Total number of indices processed over all primitives
     *          "total_draw_calls": {Number}   // Total number of times draw calls were made into GL.
     *      },
     *
     *      "ngfx_texture_info":{              // Object containing info on currently loaded textures:
     *          "total_bytes": {Number},       // Total size of all loaded textures
     *          "num_textures_total":{Number}, // Number of textures loaded
     *          "num_textures_by_size":{       // Object containing a breakdown of how many of each size:
     *              {String} : {Number},       // Entries of the form "'nnnn bytes': m, ..."
     *              ...
     *          }
     *      },
     *
     *      "gl2_animations": {                // Object containing information about loaded Animations:
     *          "motion_controllers": {        // Object containing GL2.MotionController info:
     *              "num_total": {Number}      // Total number of motion controllers
     *              "num_playing": {Number},   // Number of motion controllers currently playing
     *          },
     *
     *          "motion_data": {               // Object containing GL2.MotionData info:
     *              "num_total": {Number},     // Total number of MotionData objects created
     *              "total_size": {Number}     // Total heap bytes consumed by MotionData objects
     *          }
     *      }
     *  }
     * </pre>
     * @name GL2.Diagnostics
     * @augments Core.DiagnosticEmitter
     * @constructs
     * @singleton
     * @since 1.7
     */

    initialize: function($super)
    {
	$super('GL2');
    }

});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Root'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Root'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Root'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Root.js';

var Core = require('NGCore/Client/Core').Core;
var Touch = require('NGCore/Client/GL2/Touch').Touch;
var Diagnostics = require('NGCore/Client/GL2/Diagnostics').Diagnostics;
var Node = require('NGCore/Client/GL2/Node').Node;


var Root = exports.Root = Core.Class.singleton(
/** @lends GL2.Root.prototype */
{
	classname: 'Root',

	/**
	 * @class The `GL2.Root` class is a singleton that acts as a container for the `GL2` objects
	 * that comprise the scene graph. `GL2` node trees must be added to the `GL2.Root` singleton so
	 * that their individual nodes can be displayed and can receive touch events.
	 * @name GL2.Root
	 * @augments Core.Class
	 * @constructs
	 * @singleton
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
	    Diagnostics.pushCollector(this.nodesInGraph.bind(this));

		this._children = [];

		this._createSendGen(this.__objectRegistryId);

		this._touchTracking = {};
	},

	/**
	 * Add a node tree to the root of the scene graph.
	 * @example
	 * var mainNode = new GL2.Node(),
	 *     sprite = new GL2.Sprite(),
	 *     text = new GL2.Text();
	 * mainNode.addChild(sprite).addChild(text);
	 * GL2.Root.addChild(mainNode);
	 * @param {Object} child The node tree to add. This parameter must contain an object instance
	 *		that inherits from `{@link GL2.Node}`.
	 * @returns {void}
	 * @see GL2.Root#removeChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	addChild: function(child)
	{
		this._children.push(child);
		child._didAddToParent(this);

		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));
	},

	/**
	 * Remove a node tree from the root of the scene graph.
	 *
	 * **Note**: Removing a node tree from the scene graph does not destroy the node tree. You must
	 * explicitly call `destroy()` on the parent node and its children when you no longer need to
	 * use the node tree.
	 * @example
	 * var sprite = new GL2.Sprite();
	 * GL2.Root.addChild(sprite);
	 * // Additional code here.
	 * // Later, when the application is no longer using the sprite:
	 * GL2.Root.removeChild(sprite);
	 * @param {Object} child The node tree to remove. This parameter must contain an object instance
	 *		that inherits from `{@link GL2.Node}`.
	 * @throws {Error} The specified node tree is not a child of `GL2.Root`.
	 * @returns {void}
	 * @see GL2.Root#addChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	removeChild: function(child)
	{
		child._willRemoveFromParent();

		var index = this._children.indexOf(child);
		if(index == -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);

		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));
	},

	/**
	 * Translate a location in the global scene's coordinate space to the coordinate space of the
	 * scene graph's root. These two coordinate spaces are identical; therefore, you will not
	 * normally need to call this method.
	 * @param {Core.Point} location The location to transform.
	 * @returns {Core.Point} The location's coordinates within the local coordinate space of the
	 *		scene graph's root.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	screenToLocal: function(location)
	{
		return location;
	},

	/**
	 * Translate a location in the coordinate space of the scene graph's root to the global scene's
	 * coordinate space. These two coordinate spaces are identical; therefore, you will not
	 * normally need to call this method.
	 * @param {Core.Point} location The location to transform.
	 * @returns {Core.Point} The location's coordinates within the global scene's coordinate space.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	localToScreen: function(location)
	{
		return location;
	},

	_onTouchEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._onTouchEventRecvGen(cmd, msg))
			return;

		// Build touch object.
		var touchId = msg.touchId;
		var touchAction = msg.touchAction;
		var touch = new Touch();
	        var i, o, track;
		touch._setId(touchId);
		touch._setAction(touchAction);
		touch._setPosition(msg.x, msg.y);

		// Extract all touch targets.
		var ids = [];
		for(i=0; i < msg.touchTargetCount; ++i)
		{
			var t = {};
			if(!this._touchTargetRecvGen(cmd, t))
				return;
			// Add an array entry for every touch event that we have gotten from native.
			ids.push(t.nodeId);
		}

		touch._setTargetIds(ids);

		switch(touchAction)
		{
			case Touch.Action.Start:
				// Dispatch to all touch targets until one handles it.
				for(var key in ids)
				{
					var id=ids[key];
					o = Core.ObjectRegistry.idToObject(id);
					if(o && o.getTouchEmitter().chain(touch))
					{
						this._touchTracking[touchId] = id;
						break;
					}
				}
				break;
			case Touch.Action.End:
				// Dispatch to tracking object.
				track = this._touchTracking[touchId];
				if(track)
				{
					o = Core.ObjectRegistry.idToObject(track);
                    if (o)
                        o.getTouchEmitter().chain(touch);
					delete this._touchTracking[touch.getId()];
				}
				break;
			case Touch.Action.Move:
				// Dispatch to tracking object.
				track = this._touchTracking[touchId];
				if(track)
				{
					o = Core.ObjectRegistry.idToObject(track);
                    if (o)
                        o.getTouchEmitter().chain(touch);
				}
				break;
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 309,
	// Method create = -1
	// Method addChild = 2
	// Method removeChild = 3
	// Method onTouchEvent = 4
	// Method touchTarget = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._onTouchEventRecv( cmd );
					break;
				case 5:
					instance._touchTargetRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Root._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Root._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[309] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onTouchEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 5 )
		{
			NgLogE("Could not parse due to wrong argument count in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "touchId" ] === undefined )
		{
			NgLogE("Could not parse touchId in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchAction" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "touchAction" ] === undefined )
		{
			NgLogE("Could not parse touchAction in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchTargetCount" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "touchTargetCount" ] === undefined )
		{
			NgLogE("Could not parse touchTargetCount in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 5);
		return true;
	},
	
	/** @private */
	_touchTargetRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Root.touchTarget from command: " + cmd );
			return false;
		}
		
		obj[ "nodeId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "nodeId" ] === undefined )
		{
			NgLogE("Could not parse nodeId in Root.touchTarget from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 1);
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x135ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x1350002, this, [ +child ] );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( 0x1350003, this, [ +child ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// _onTouchEventRecv: function( cmd ) {}
	// _touchTargetRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

	,
    // Diagnostics collector
    nodesInGraph: function(interval) 
    {
	var diag = {graph_nodes: 0};

	// Do BFS, don't recurse; SG may be deep
	var nodes = this._children.slice();
	while(nodes.length > 0)
	{
	    var node = nodes.shift();
	    nodes = nodes.concat(node._children);
	    diag.graph_nodes++;
	}

	return diag;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Text'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Text'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Text'] = exports; 
var __dirname = 'NGCore/Client/GL2';
var __filename = 'NGCore/Client/GL2/Text.js';

var Core = require('NGCore/Client/Core').Core;
var Node = require('NGCore/Client/GL2/Node').Node;
var Font = require('NGCore/Client/GL2/Font').Font;


var Text = exports.Text = Node.subclass(
/** @lends GL2.Text.prototype */
{
	classname: 'Text',

	/**
	 * @class The `GL2.Text` class enables applications to display text areas. The methods in this
	 * class control the text area's font, alignment, and placement.
	 *
	 * By default, text areas are styled as follows:
	 *
	 * 1. Text is rendered in Arial, using 18 pixels per em.
	 * 2. Text is horizontally and vertically centered with the text area.
	 * 3. The text area's size is not constrained. If a width constraint is added, the text area's
	 * text string will wrap onto multiple lines.
	 * 4. The text area's anchor point is centered within the text area.
	 *
	 * **Important**: Text areas may have rendering problems when they are scaled. Do not apply a
	 * scale to text areas unless absolutely necessary. In addition, minimize the number of font
	 * sizes that your application uses; each new font size uses additional memory on the device.
	 * @constructs Create a text area.
	 * @augments GL2.Node
	 * @param {String} [text] The text to display.
	 * @since 1.0
	 */
    initialize: function(text)
    {
		this._size = new Core.Size();
		this._anchor = new Core.Point(0.5, 0.5);
        this._horizontalAlign = this.HorizontalAlign.Center;
        this._verticalAlign = this.VerticalAlign.Middle;
        this._text = '';
		if (text)
			 this.setText(text);

        this._fontFamily = '';
        this._fontSize = 18;
		this._overflowMode = this.OverflowMode.Multiline;
		this._fontLocation = this.FontLocation.Default;

		this._font = null;

		this._callbackIdCounter = 1;
		this._callbacks = {};
    },

	/**
	 * Destroy the text area, and release the resources allocated by the text area.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
	},

	/**
	 * Retrieve the width and height of the text area. If one of these dimensions is set to 0, the
	 * rendering engine will allow that dimension to expand if necessary to fit the text.
	 * @returns {Core.Size} The current size of the text area, in pixels.
	 * @see GL2.Text#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getSize: function()
	{
		return this._size;
	},

	/**
	 * Retrieve the offset of the text area's anchor point. The anchor point defines the origin of
	 * any scaling or rotation that is applied to the text area.
	 * @returns {Core.Point} The current offset of the text area's anchor point.
	 * @see GL2.Text#setAnchor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getAnchor: function()
	{
		return this._anchor;
	},

	/**
	 * Retrieve the text area's horizontal alignment.
	 * @returns {GL2.Text#HorizontalAlign} The current horizontal alignment of the text area.
	 * @see GL2.Text#setHorizontalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getHorizontalAlign: function()
	{
		return this._horizontalAlign;
	},

	/**
	 * Retrieve the text area's vertical alignment.
	 * @returns {GL2.Text#VerticalAlign} The current vertical alignment of the text area.
	 * @see GL2.Text#setVerticalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getVerticalAlign: function()
	{
		return this._verticalAlign;
	},

	/**
	 * Retrieve the text string to render in the text area.
	 * @returns {String} The current text string to render in the text area.
	 * @see GL2.Text#setText
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getText: function()
	{
		return this._text;
	},

	/**
	 * Retrieve the text area's font family.
	 * @returns {String|GL2.Font} The current font family for the text area.
	 * @see GL2.Text#setFontFamily
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFontFamily: function()
	{

		return this._fontFamily;
	},

	/**
	 * Retrieve the text area's font size, in pixels per em.
	 * @returns {Number} The current font size for the text area.
	 * @see GL2.Text#setFontSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getFontSize: function()
	{

		return this._fontSize;
	},

	/**
	 * Retrieve the text area's overflow mode, which defines the text area's behavior when the text
	 * area is not large enough to fit the text string.
	 * @returns {GL2.Text#OverflowMode} The current overflow mode for the text area.
	 * @see GL2.Text#OverflowMode
	 * @see GL2.Text#setOverflowMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getOverflowMode: function()
	{
		return this._overflowMode;
	},

    /**
	 * Set the text area's width and height. The size is relative to the scale that has been applied
	 * to the parent node.
	 *
	 * **Important**: Text areas may have rendering problems when they are scaled. Do not apply a
	 * scale to text areas unless absolutely necessary.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setSize(200, 100);
	 * @param {Core.Size} size The text area's new width and height, in pixels.
	 * @returns {this}
	 * @see GL2.Text#getSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setSize: function(size)
	{
		var s = this._size;
		s.setAll.apply(s, arguments);

		this._setSizeSendGen(s.getWidth(),s.getHeight());

		return this;
	},

    /**
	 * Set the offset of the text area's anchor point. The anchor point defines the origin of any
	 * scaling or rotation that is applied to the text area. Its offset is defined as a multiple of
	 * the text area's width and height. For example, the default anchor offset, `[0.5, 0.5]`,
	 * represents a point that is centered on the U and V axes.
	 *
	 * If the text area's width or height is set to 0, the anchor point's offset is measured based
	 * on the rendered size of the text string.
	 *
	 * **Note**: The anchor point is calculated before transformations are applied to the text area.
	 * @example
	 * // Create a text area with horizontally and vertically centered text.
	 * var textArea = new GL2.Text("Next Level");
	 * textArea.setHorizontalAlign(GL2.Text.HorizontalAlign.Center).
	 *   setVerticalAlign(GL2.Text.VerticalAlign.Middle).
	 *   setAnchor(new Core.Point(0.5, 0.5));
	 * @param {Core.Point} location The new offset of the text area's anchor point.
	 * @returns {this}
	 * @see GL2.Text#getAnchor
	 * @see GL2.Text#setHorizontalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setAnchor: function(location)
	{
		var a = this._anchor;
		a.setAll.apply(a, arguments);

		this._setAnchorSendGen(a.getX(),a.getY());

		return this;
	},

    /**
	 * Set the text area's horizontal alignment.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setHorizontalAlign(GL2.Text.HorizontalAlign.Right);
	 * @param {GL2.Text#HorizontalAlign} horizontalAlign The new horizontal alignment for the text
	 *		area.
	 * @returns {this}
	 * @see GL2.Text#getHorizontalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setHorizontalAlign: function(horizontalAlign)
	{
		this._horizontalAlign = horizontalAlign;

		this._setHorizontalAlignSendGen(horizontalAlign);

		return this;
	},

    /**
	 * Set the text area's vertical alignment.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setVerticalAlign(GL2.Text.VerticalAlign.Bottom);
	 * @param {GL2.Text#VerticalAlign} verticalAlign The new vertical alignment for the text area.
	 * @returns {this}
	 * @see GL2.Text#getVerticalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setVerticalAlign: function(verticalAlign)
	{
		this._verticalAlign = verticalAlign;

		this._setVerticalAlignSendGen(verticalAlign);

		return this;
	},

    /**
	 * Set the text string to display in the text area.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setText("Choose an Item");
	 * @param {String} text The new text string to display in the text area.
	 * @returns {this}
	 * @see GL2.Text#getText
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setText: function(text)
	{
		this._text = text;

		this._setTextSendGen(text);

		return this;
	},

    /**
	 * Set the font family to use for the text area. By default, you can use the font families that
	 * are provided by the device. You can also use the font families that are bundled with ngCore
	 * or include your own font family in the application bundle.
	 *
	 * To retrieve a list of font families that are provided by the device, call
	 * `{@link Core.Capabilities#getAvailableFonts}`.
	 *
	 * To use a font family that is bundled with your application, do the following:
	 *
	 * 1. Include the necessary font files in your application's `manifest.json` file, or in a
	 * secondary manifest. The font files must be in TrueType (.ttf) or OpenType (.otf) format. You
	 * can include the font files in the `other` or `other_encrypted` section of `manifest.json`.
	 * 2.  Call `{@link GL2.Text#setFontLocation}` to indicate that the text area will use a font
	 * family from the application bundle.
	 * 3. Call `setFontFamily()`, and pass in the path to the font file.
	 *
	 * In addition, you can use the `{@link GL2.Font}` class to load a font, then pass the
	 * `GL2.Font` object to this method. The `GL2.Font` class enables you to load a font
	 * asynchronously, so the application is not blocked while it waits for the font to load.
	 * @example
	 * // Use a random system-provided font.
	 * var textArea = new GL2.Text();
	 * var systemFonts = Core.Capabilities.getAvailableFonts();
	 * textArea.setFontFamily(systemFonts[Math.floor(Math.random() * systemFonts.length)]);
	 * @example
	 * // Use a font family from the application bundle.
	 * var textArea = new GL2.Text();
	 * textArea.setFontLocation(GL2.Text.FontLocation.Manifest);
	 * textArea.setFontFamily("./Content/fontName.otf");
	 * @param {String|GL2.Font} fontFamily The name of the font family to use in the text area; the
	 *		path to a font file in the application bundle; or a `{@link GL2.Font}` object that
	 *		contains a font resource.
	 * @returns {this}
	 * @see Core.Capabilities#getAvailableFonts
	 * @see GL2.Text#FontLocation
	 * @see GL2.Text#getFontFamily
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
    setFontFamily: function(fontFamily)
	{


		this._fontFamily = fontFamily;

		this._setFontFamilySendGen(fontFamily);

		this._font = null;

		return this;
	},

    /**
	 * Set the text area's font size, in pixels per em.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setFontSize(24);
	 * @param {Number} fontSize The text area's new font size, in pixels per em.
	 * @returns {this}
	 * @see GL2.Text#getFontSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setFontSize: function(fontSize)
	{


		this._fontSize = fontSize;

		this._setFontSizeSendGen(fontSize);

		this._font = null;

		return this;
	},

	/**
	 * Retrieve the text area's overflow mode, which defines the text area's behavior when the text
	 * area is not large enough to fit the text string.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setOverflowMode(GL2.Text.OverflowMode.ReduceFontSize);
	 * @param {GL2.Text#OverflowMode} overflowMode The new overflow mode for the text area.
	 * @returns {this}
	 * @see GL2.Text#getOverflowMode
	 * @see GL2.Text#OverflowMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	setOverflowMode: function(overflowMode)
	{
		this._overflowMode = overflowMode;

		this._setOverflowModeSendGen(overflowMode);

		return this;
	},

	/**
	 * Set the location of font families that can be used by the text area. By default, the text
	 * area can use font families that are provided by the device.
	 * @example
	 * var textArea = new GL2.Text();
	 * textArea.setFontLocation(GL2.Text.FontLocation.Manifest);
	 * @param {GL2.Text#FontLocation} fontLocation The location of font families that can be used by
	 *		the text area.
	 * @returns {this}
	 * @see GL2.Text#setFontFamily
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	setFontLocation: function(fontLocation)
	{


		this._fontLocation = fontLocation;

		this._setFontLocationSendGen(fontLocation);

		this._font = null;

		return this;
	},

	/**
	 * Translate a location in the global scene's coordinate space to the text area's local
	 * coordinate space.
	 * @name GL2.Text#screenToLocal
	 * @function
	 * @param {Core.Point} location The location in the global scene to transform.
	 * @returns {Core.Point} The location's coordinate within the text area's local coordinate
	 *		space.
	 * @see GL2.Text#localToScreen
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */

	screenToLocal: function($super, location)
	{
		location = $super(location);
		if(!location)
			return undefined;

		var a = this._anchor;
		var s = this._size;

		location.setX(location.getX() + a.getX() * s.getWidth());
		location.setY(location.getY() + a.getY() * s.getHeight());
		return location;
	},

	/**
	 * Translate a location in the text area's local coordinate space to the global scene's
	 * coordinate space. Use this method to translate between two local coordinate spaces.
	 * @name GL2.Text#localToScreen
	 * @function
	 * @param {Core.Point} location The location in the text area's local coordinate space to
	 *		transform.
	 * @returns {Core.Point} The location's coordinate within the global scene's coordinate space.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */

	localToScreen: function($super, location)
	{
		var a = this._anchor;
		var s = this._size;

		location.setX(location.getX() - a.getX() * s.getWidth());
		location.setY(location.getY() - a.getY() * s.getHeight());

		location = $super(location);
		if(!location)
			return undefined;
		return location;
	},


	/**
	 * Measure the text area's total width and height, as well as the width of each line of text.
	 *
	 * **Note**: Before you call this method, you must add text to the text area or set the text
	 * area's size.
     * @example
	 * var textArea = new GL2.Text("Play Game");
	 * var size = new Core.Size();
	 * var lineWidths = [];
	 * var totalWidth = 0;
	 * textArea.measureArea(function(result) {
	 *     size.setAll(result.width, result.height);
	 *     lineWidths = result.lineWidths;
	 *     totalWidth = result.totalWidth;
	 * });
     * @cb {Function} callback The function to call after measuring the text.
     * @cb-param {Object} result Information about the text area's size.
     * @cb-param {Number} result.width The width, in pixels, of the block of text.
     * @cb-param {Number} result.height The height, in pixels, of the block of text.
     * @cb-param {Number[]} result.lineWidths The widths, in pixels, of each line in the block of
	 *		text.
     * @cb-param {Number} result.totalWidth The combined width, in pixels, of all of the lines in
	 *		the text block.
	 * @cb-returns {void}
     * @returns {void}
	 * @since 1.6
	 */
	measureArea: function(callback)
	{
		var callbackId = this._callbackIdCounter++;
		this._callbacks[callbackId] = callback;
		this._measureAreaSendGen(callbackId);
 	},

	_measureAreaCbRecv: function(cmd)
	{
		var msg = {};
		if (! this._measureAreaCbRecvGen(cmd, msg))
			return;

		var callbackId = msg["callbackId"];
		var result = msg["result"];

		var callback = this._callbacks[callbackId];
		delete this._callbacks[callbackId];

		callback(result);
	},

	/**
	 * Set the text area's font family by providing a `{@link GL2.Font}` object. The `GL2.Font`
	 * object's settings will override the existing font family, font location, and font size.
	 * @example
	 * var font = new GL2.Font("Default"),
	 * var text = new GL2.Text();
	 * text.setFont(font);
	 * @param {GL2.Font} font The font to use for this text area.
	 * @returns {this}
	 * @see GL2.Text#setFontFamily
	 * @status iOS, Android
	 * @since 1.8
	 */
	setFont: function( font )
	{

		this._font = font;

		this._setFontSendGen(Core.ObjectRegistry.objectToId(font));

		return this;
	},

	/**
	 * Enumeration for horizontal alignment modes.
	 * @name HorizontalAlign
	 * @fieldOf GL2.Text#
	 */

	/**
	 * Align text to the left.
	 * @name HorizontalAlign.Left
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Align text in the center.
	 * @name HorizontalAlign.Center
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Align text to the right.
	 * @name HorizontalAlign.Right
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Enumeration for vertical alignment modes.
	 * @name VerticalAlign
	 * @fieldOf GL2.Text#
	 */

	/**
	 * Align text at the top.
	 * @name VerticalAlign.Top
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Align text in the middle.
	 * @name VerticalAlign.Middle
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Align text at the bottom.
	 * @name VerticalAlign.Bottom
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Enumeration for the behavior when there is too much text to fit on one line.
	 * @name OverflowMode
	 * @fieldOf GL2.Text#
	 */

	/**
	 * Reduce the font size until the text fits.
	 * @name OverflowMode.ReduceFontSize
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Split the text into multiple lines.
	 * @name OverflowMode.Multiline
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Enumeration to choose the source of fonts for the application.
	 * @name FontLocation
	 * @fieldOf GL2.Text#
	 */

	/**
	 * Use the default fonts, which are the system fonts. Equivalent to
	 * `{@link GL2.Text#FontLocation.System}`.
	 * @name FontLocation.Default
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Use the system fonts.
	 * @name FontLocation.System
	 * @fieldOf GL2.Text#
	 * @constant
	 */

	/**
	 * Use the fonts that are bundled with ngCore. Not currently supported.
	 * @name FontLocation.Bundled
	 * @fieldOf GL2.Text#
	 * @constant
	 * @ignore
	 */

	/**
	 * Use custom fonts that are loaded through the application manifest.
	 * @name FontLocation.Manifest
	 * @fieldOf GL2.Text#
	 * @constant
	 */

// {{?Wg Generated Code}}
	
	// Enums.
	HorizontalAlign:
	{ 
		Left: 0,
		Center: 1,
		Right: 2
	},
	
	VerticalAlign:
	{ 
		Top: 0,
		Middle: 1,
		Bottom: 2
	},
	
	OverflowMode:
	{ 
		ReduceFontSize: 0,
		Multiline: 1
	},
	
	FontLocation:
	{ 
		Default: 0,
		System: 1,
		Bundled: 2,
		Manifest: 3
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 311,
	// Method create = -1
	// Method destroy = 2
	// Method setSize = 3
	// Method setAnchor = 4
	// Method setHorizontalAlign = 5
	// Method setVerticalAlign = 6
	// Method setText = 7
	// Method setFontFamily = 8
	// Method setFontSize = 9
	// Method setOverflowMode = 10
	// Method setFontLocation = 11
	// Method measureArea = 12
	// Method measureAreaCb = 13
	// Method setFont = 14
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 13:
					instance._measureAreaCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Text._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Text._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[311] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_measureAreaCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 2 )
		{
			NgLogE("Could not parse due to wrong argument count in Text.measureAreaCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Text.measureAreaCb from command: " + cmd );
			return false;
		}
		
		obj[ "result" ] = Core.Proc.parseObject( cmd[ 1 ] );
		if( obj[ "result" ] === undefined )
		{
			NgLogE("Could not parse result in Text.measureAreaCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x137ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1370002, this );
	},
	
	/** @private */
	_setSizeSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( 0x1370003, this, [ +width, +height ] );
	},
	
	/** @private */
	_setAnchorSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( 0x1370004, this, [ +x, +y ] );
	},
	
	/** @private */
	_setHorizontalAlignSendGen: function( align )
	{
		Core.Proc.appendToCommandString( 0x1370005, this, [ +align ] );
	},
	
	/** @private */
	_setVerticalAlignSendGen: function( align )
	{
		Core.Proc.appendToCommandString( 0x1370006, this, [ +align ] );
	},
	
	/** @private */
	_setTextSendGen: function( text )
	{
		Core.Proc.appendToCommandString( 0x1370007, this, [ Core.Proc.encodeString( text ) ] );
	},
	
	/** @private */
	_setFontFamilySendGen: function( fontFamily )
	{
		Core.Proc.appendToCommandString( 0x1370008, this, [ Core.Proc.encodeString( fontFamily ) ] );
	},
	
	/** @private */
	_setFontSizeSendGen: function( fontSize )
	{
		Core.Proc.appendToCommandString( 0x1370009, this, [ +fontSize ] );
	},
	
	/** @private */
	_setOverflowModeSendGen: function( overflowMode )
	{
		Core.Proc.appendToCommandString( 0x137000a, this, [ +overflowMode ] );
	},
	
	/** @private */
	_setFontLocationSendGen: function( fontLocation )
	{
		Core.Proc.appendToCommandString( 0x137000b, this, [ +fontLocation ] );
	},
	
	/** @private */
	_measureAreaSendGen: function( callbackId )
	{
		Core.Proc.appendToCommandString( 0x137000c, this, [ +callbackId ] );
	},
	
	/** @private */
	_setFontSendGen: function( font )
	{
		Core.Proc.appendToCommandString( 0x137000e, this, [ +font ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setSize: function( width, height ) {}
	
	// setAnchor: function( x, y ) {}
	
	// setHorizontalAlign: function( align ) {}
	
	// setVerticalAlign: function( align ) {}
	
	// setText: function( text ) {}
	
	// setFontFamily: function( fontFamily ) {}
	
	// setFontSize: function( fontSize ) {}
	
	// setOverflowMode: function( overflowMode ) {}
	
	// setFontLocation: function( fontLocation ) {}
	
	// measureArea: function( callbackId ) {}
	
	// _measureAreaCbRecv: function( cmd ) {}
	// setFont: function( font ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/GL2.js';

/**
 * @name GL2
 * @namespace Draw sprites and animations, and handle touch events.
 * @description
 * The `GL2` module renders an application's sprites and animations, leveraging the device's support
 * for the OpenGL standard. `GL2` also provides monitoring of touch events within the context of an
 * OpenGL view, which is provided by the `{@link UI.GLView}` class.
 *
 * You can use the `GL2` module's classes to do all of the following:
 *
 * + Organize and group `GL2` nodes (`{@link GL2.Node}`, `{@link GL2.Root}`)
 * + Display static images, which can be warped and stretched arbitrarily (`{@link GL2.Sprite}`,
 * `{@link GL2.Primitive}`)
 * + Display flipbook-style animations (`{@link GL2.Animation}`, `{@link GL2.Animation.Frame}`)
 * + Move images around the screen (`{@link GL2.MotionController}`, `{@link GL2.MotionData}`)
 * + Create particle effects (`{@link GL2.Emitter}`, `{@link GL2.EmitterData}`)
 * + Draw arbitrary vertex-based polygons (`{@link GL2.Primitive}`, `{@link GL2.Primitive.Vertex}`)
 * + Display text (`{@link GL2.Text}`)
 * + Track touch events (`{@link GL2.TouchTarget}`, `{@link GL2.Touch}`)
 * + Render multiple images into a single texture, which can be displayed or saved to a file
 * (`{@link GL2.RenderTarget}`)
 * + Load texture images and fonts, either synchronously or asynchronously (`{@link GL2.Texture}`,
 * `{@link GL2.Font}`)
 *
 * You can also capture a screenshot from the device by calling `{@link UI.takeScreenshot}`.
 *
 * The components of a `GL2` scene are organized into a tree of nodes, commonly referred to as a
 * scene graph. The `{@link GL2.Root}` singleton is at the top of the scene graph, and all of the
 * scene graph's nodes are children or descendants of `{@link GL2.Root}`. A node can also exist
 * independently of the scene graph, but it will not be displayed, and its touch targets will not be
 * touchable.
 *
 * Each node can have parents and ancestors, as well as children and descendants. Nodes inherit many
 * of the properties of their parents and ancestors; for example, if node X has an ancestor that is
 * rotated by 45 degrees, node X will also be rotated by 45 degrees. See `{@link GL2.Node}` for
 * additional details.
 *
 * You can use clipping rectangles to hide portions of the scene graph. See
 * `{@link GL2.Node#setClipRect}` for details. When a clipping rectangle is enabled, content outside
 * of the clipping rectangle is not drawn, and touch targets outside of the clipping rectangle do
 * not respond to touch inputs.
 *
 * The `GL2` module is supported by the `{@link UI.GLView}` class. Before an application
 * instantiates objects in the `GL2` module, it must do the following:
 *
 * 1. Instantiate a `{@link UI.GLView}` object.
 * 2. Call the object's `setFrame()` method, inherited from `{@link UI.AbstractView}`, to set the
 * view's frame. You will normally set the frame so that it encompasses the device's entire screen.
 * 3. Call the object's `setOnLoad()` method, inherited from `{@link UI.Element}`, to define a
 * callback function that will run after the `{@link UI.GLView}` object has loaded. **Important**:
 * You must wait for the callback to run before you call any method in the `GL2` module.
 * 4. Set the `active` property of the `{@link UI.GLView}` object to `true`.
 *
 * Applications should not attempt to display `{@link UI}` and `GL2` objects at the same time, with
 * the sole exception of `{@link UI.GLView}` objects. Displaying other `{@link UI}` objects at the
 * same time as `GL2` objects can result in poor performance.
 *
 * If your application needs to combine UI components and other graphics on the same screen,
 * consider using the ngGo toolkit. Its `GLUI` module reimplements the `{@link UI}` module in
 * OpenGL, enabling you to combine UI components with other graphics. Although `GLUI` does not
 * support all of the `{@link UI}` module's styling options, it offers enough flexibility for many
 * applications.  You can download ngGo from the Downloads section on the
 * [Mobage Developer Portal](https://developer.mobage.com/).
 */
function GL2Loader(map) {
	this.add = function(key, toEval) {
		this.__defineGetter__(key, function() {
			delete this[key];
			return this[key] = toEval();
		});
	};
	for (var k in map) {
		if (map.hasOwnProperty(k)) this.add(k, map[k]);
	}
}

exports.GL2 = new GL2Loader({
	'Animation': function() { return require('NGCore/Client/GL2/Animation').Animation; },
	'EmitterData': function() { return require('NGCore/Client/GL2/EmitterData').EmitterData; },
	'Emitter': function() { return require('NGCore/Client/GL2/Emitter').Emitter; },
	'Font': function() { return require('NGCore/Client/GL2/Font').Font; },
	'MotionController': function() { return require('NGCore/Client/GL2/MotionController').MotionController; },
	'MotionData': function() { return require('NGCore/Client/GL2/MotionData').MotionData; },
	'Node': function() { return require('NGCore/Client/GL2/Node').Node; },
	'Primitive': function() { return require('NGCore/Client/GL2/Primitive').Primitive; },
	'Touch': function() { return require('NGCore/Client/GL2/Touch').Touch; },
	'TouchTarget': function() { return require('NGCore/Client/GL2/TouchTarget').TouchTarget; },
	'Root': function() { return require('NGCore/Client/GL2/Root').Root; },
	'Sprite': function() { return require('NGCore/Client/GL2/Sprite').Sprite; },
	'Text': function() { return require('NGCore/Client/GL2/Text').Text; },
	'Texture': function() { return require('NGCore/Client/GL2/Texture').Texture; },
	'RenderTarget': function() { return require('NGCore/Client/GL2/RenderTarget').RenderTarget; },
	'Diagnostics': function() { return require('NGCore/Client/GL2/Diagnostics').Diagnostics; }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/Mixin'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/Mixin'] || {}; $MODULE_REGISTRY['NGGo/Foundation/Mixin'] = exports; 
var __dirname = 'NGGo/Foundation';
var __filename = 'NGGo/Foundation/Mixin.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

/**
 * @class Base class for the object which is mixed into other class.
 * @constructor
 * @name Foundation.Mixin
 */

var Mixin = Class.subclass(
/** @lends Foundation.Mixin.prototype */
{
    classname: 'Mixin',
    reserved: {
        "classname"  : "1",
//      "initialize" : "1",
//      "destroy"    : "1",
        "mixInto"    : "1",
        "_list"      : "1"
    }
});

/**
 * Generates class to be able to mix in.
 * @name Foundation.Mixin.generate
 * @function
 */
Mixin.generate = (function()
{
    return function(object)
    {
        var list = [];
        var mixInto = function(func)
        {
            var i, len, property, getter, setter, value;
            var makeInitialize = function(current, add, self){
                return function() {
                    current.apply(self, arguments);
                    add.apply(self,arguments);
                };
            };
            var makeDestroy = function(current, add, self){
                return function() {
                    add.apply(self,arguments);
                    current.apply(self, arguments);
                };
            };
            if( typeof func === 'function' )
            {
                len = list.length;
                for( i=0; i<len; i++ )
                {
                    property = list[i];
                    if( func.prototype[property] && property !== 'initialize' && property !== 'destroy' )
                    {
                        throw new Error("<NGGO> Mixin: property '"+ property+"' already exists");
                    }
                    getter = this.__lookupGetter__(property);
                    setter = this.__lookupSetter__(property);
                    if(getter || setter)
                    {
                        if( getter )
                        {
                            func.prototype.__defineGetter__(property, getter);
                        }
                        if( setter )
                        {
                            func.prototype.__defineSetter__(property, setter);
                        }
                    }else{
                        value = this[property];
                        if( typeof value === 'function' && property[0] !== '$')
                        {
                            if( property === 'initialize' )
                            {
                                var current_initialize = func.prototype.initialize;
                                if( typeof current_initialize === 'function' )
                                {
                                    func.prototype[property] = makeInitialize(current_initialize, value, this);
                                }
                                else
                                {
                                    func.prototype[property] = value;
                                }
                            }
                            else if( property === 'destroy' )
                            {
                                var current_destroy = func.prototype.destroy;
                                if( typeof current_destroy === 'function' )
                                {
                                    func.prototype[property] = makeDestroy(current_destroy, value, this);
                                }
                                else
                                {
                                    func.prototype[property] = value;
                                }
                            }
                            else
                            {
                                func.prototype[property] = value;
                            }
                        }
                        else
                        {
                            if(property[0] === '$')
                            {
                                property = property.slice(1);
                        }
                            func.prototype[property] = value;
                            func[property] = value;
                        }
                    }
                }
            }
            else if( typeof func === 'object' &&
                     typeof func.instantiate === 'function' )
            // For Singleton Class
            {
                var initFunc = function(init)
                {
                    var i = 1;
                    return function()
                    {
                        if(i){
                            i--;
                            init.apply(this);
                        }
                    };
                };
                var initialize = this.initialize;
                if( initialize )
                {
                    initialize = initFunc(initialize);
                    var instantiate = func.instantiate;
                    var wrapOringinalfunc = function(self, name)
                    {
                        return function(){
                            self.instantiate();
                            self[name](arguments);
                        };
                    };
                    for(i in func)
                    {
                        if( func.hasOwnProperty(i) && i !== 'initialize' && i !== 'instantiate' )
                        {
                            func[i] = wrapOringinalfunc(func, i);
                        }
                    }
                    var wrapInstanciateFunc = function(self)
                    {
                        return function()
                        {
                            instantiate();
                            initialize.apply(self);
                        };
                    };
                    func.instantiate = wrapInstanciateFunc(func);
                }else{
                    initialize = function() {};
                }
                var wrapfunc = function(real, self)
                {
                    return function(){
                        self.instantiate();
                        initialize.apply(self);
                        real.apply(self,arguments);
                    };
                };
                len = list.length;
                for( i=0; i<len; i++ )
                {
                    property = list[i];
                    var prototype = Object.getPrototypeOf(func);
                    if( prototype[property]  && property !== 'initialize' && property !== 'destroy' )
                    {
                        throw new Error("<NGGo> Mixin: property '"+ property+"' already exists");
                    }
                    getter = this.__lookupGetter__(property);
                    setter = this.__lookupSetter__(property);
                    if(getter || setter)
                    {
                        if( getter )
                        {
                            prototype.__defineGetter__(property, getter);
                        }
                        if( setter )
                        {
                            prototype.__defineSetter__(property, setter);
                        }
                    }
                    else
                    {
                        value = this[property];
                        if( typeof value === 'function')
                        {
                            value = wrapfunc(value, func);
                        }
                        if( typeof value === 'function' && property[0] !== '$')
                        {
                            prototype[property] = value;
                        }
                        else
                        {
                            if(property[0] === '$')
                            {
                                property = property.slice(1);
                            }
                            prototype[property] = value;
                            func[property] = value;
                        }
                    }
                }
            }
        };

        var property;
        if( typeof object !== 'object' )
        {
            if( typeof NgLogW === 'function' ){
                NgLogW("ngGo: Core.Mixin: generate: Object required");
            }
            return -1;
        }
        var ret = {
            mixInto : mixInto
        };
        for(property in object)
        {
            if( object.hasOwnProperty(property) && !Mixin.reserved[property] )
            {
                var getter = object.__lookupGetter__(property);
                var setter = object.__lookupSetter__(property);
                if(getter || setter)
                {
                    if( getter )
                    {
                        ret.__defineGetter__(property, getter);
                    }
                    if( setter )
                    {
                        ret.__defineSetter__(property, setter);
                    }
                }
                else
                {
                    ret[property] = object[property];
                }
                list.push(property);
            }
        }
        return ret;
    };
}());

exports.Mixin = Mixin;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/Class'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/Class'] || {}; $MODULE_REGISTRY['NGGo/Foundation/Class'] = exports; 
var __dirname = 'NGGo/Foundation';
var __filename = 'NGGo/Foundation/Class.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Mixin = require('NGGo/Foundation/Mixin').Mixin;

/**
 * @constructs
 * @class
 * Extend ngCore's <code>Core.Class</code> to add mixin feature. Mixin works on both <code>subclass()</code> method ans <code>singleton()</code> method.
 * @name Foundation.Class
 */

(function(){
     var core_subclass = Class.subclass;
     var core_singleton = Class.singleton;
     var mixfunc = function( object, mixins, parent, parentClass )
     {
         var i;
         var ret = parent.call( parentClass, object );
         if( !mixins || mixins.length <= 0 )
         {
             return ret;
         }
         var len = mixins.length;
         for(i=0; i<len; i++)
         {
             mix = mixins[i];
             if( mix && typeof mix === 'object' && typeof mix.mixInto === 'function' )
             {
                 mix.mixInto(ret);
             }
         }
         return ret;
     };
     Class.subclass = function( object, mixins )
     {
         return mixfunc(object, mixins, core_subclass, this);
     };
     Class.singleton = function( object, mixins )
     {
         return mixfunc(object, mixins, core_singleton, this);
     };
}());

exports.Class = Class;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/NGGOError'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/NGGOError'] || {}; $MODULE_REGISTRY['NGGo/Foundation/NGGOError'] = exports; 
var __dirname = 'NGGo/Foundation';
var __filename = 'NGGo/Foundation/NGGOError.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author    Takaaki Mizuno
 *  Website    https://developer.mobage.com/
 *  Copyright:  2011, by DeNA Co., Ltd
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

exports.NGGOError = Class.subclass(
/** @lends Foundation.NGGOError.prototype */
{
    classname: 'NGGOError',
    /**
     * @class
     * Error description object for callback functions.
     * @constructs
     * @name Foundation.NGGOError
     * @augments Core.Class
     * @param {Number} errorCode Error code. The meaning of each error code depends on the module which generate NGGOError module. 0 means "no error" and non 0 value means "error".
     * @param {String} errorText Text description of the error.
     * @property {Number} errorCode Error code. The meaning of each error code depends on the module which generate NGGOError module. 0 should means "no error".
     * @property {String} errorText Text description of the error.
     * @property {Boolean} isError (readonly)  It returns boolean value which means it is error or not. True means error.
     */
    initialize: function( errorCode, errorText )
    {
        this._errorCode = ~~(errorCode);
        this._errorText = errorText;
    },
    /**
     * Convert the error data to text.
     * @returns {String} String expression includes error code and error text.
     */
    toString: function()
    {
        return "("+this._errorCode+") "+ this._errorText;
    },
    get errorCode()
    {
        return this._errorCode;
    },
    set errorCode(value)
    {
        this._errorCode = ~~(value);
    },
    get errorText()
    {
        return this._errorText;
    },
    set errorText(value)
    {
        this._errorText = value;
    },
    get isError()
    {
        return !!this._errorCode;
    },
    set isError(value)
    {
        if( typeof NgLodW === 'function' )
        {
            NgLogW("NGGOError: isError is read only property" );
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/Observable'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/Observable'] || {}; $MODULE_REGISTRY['NGGo/Foundation/Observable'] = exports; 
var __dirname = 'NGGo/Foundation';
var __filename = 'NGGo/Foundation/Observable.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Takaaki Mizuno
 *  Website:    https://developer.mobage.com/
 *  Copyright:  2011, by DeNA Co., Ltd
 */
////////////////////////////////////////////////////////////////////////////////

var Mixin = require('NGGo/Foundation/Mixin').Mixin;

/**
 * @class Mixin object to add oberver pattern event feature.
 * @name Foundation.Observable
 * @constructs
 */
exports.Observable = Mixin.generate(
/** @lends Foundation.Observable.prototype */
{
    /**
     * Attachs observer function(s).
     * @param {String|Object} name Name of the event attach the observer. Or object includes one or more observers with event name.
     * @param {Function} func Observer function associate with name.
     * @returns {Number} ID of the attached listner(s)
     */
    addObserver: function(name, func)
    {
        var obj;
        if( typeof name === 'string' && typeof func === 'function' )
        {
            obj = {};
            obj[name] = func;
        }
        else if( typeof name === 'object' )
        {
            obj = name;
        }
        else
        {
            return -1;
        }

        if( typeof this.__observers !== 'object'
            || !this.__observers.length )
        {
            this.__observers = [];
        }
        this.__observers.push(obj);
        return this.__observers.length;
    },
    /**
     * Dettachs listner function(s)
     * @param {Object|Number} id ID of observer function(s) or object which passed to the add observer method.
     * @retuns {Number} Deleted observer ID.
     */
    deleteObserver: function(id)
    {
        var i;
        var list = this.__observers;
        if( typeof list !== "object" || !list.length )
        {
            return -1;
        }
        if( typeof id === "number" )
        {
            if( list.length >= id )
            {
                list[id-1] = {};
                return id;
            }
        }
        else if( typeof id === "object" )
        {
            var len = list.length;
            for(i=0; i<len; i++)
            {
                if( id === list[i])
                {
                    list[i] = {};
                    return i;
                }
            }
        }
        return -1;
    },
    /**
     * Delete all observers.
     */
    deleteObservers: function()
    {
        if( this.__observers )
        {
            delete this.__observers;
        }
    },
    /**
     * Get how many observers are attached to paticular event name.
     * @param {String} name Name of event.
     * @retuns {Number} Number of observer functions.
     */
    countObservers: function(name)
    {
        var i;
        var list = this.__observers;
        if( typeof list !== 'object' || !list.length )
        {
            return 0;
        }
        if( typeof name === 'string' )
        {
            var count = 0;
            var len = list.length;
            for(i=0; i<len; i++)
            {
                var h = list[i];
                if( typeof h === 'object' && typeof h[name] === 'function' )
                {
                    count++;
                }
            }
            return count;
        }
        if( typeof list !== "object" || !list.length )
        {
            return 0;
        }
        return list.length;
    },
    /**
     * Execute observer associated with the name.
     * @param {String} name Event name to notify
     */
    notify: function( name )
    {
        var i;
        var list = this.__observers;
        if( typeof name !== 'string'
            || typeof list !== "object"
            || !list.length )
        {
            return;
        }
        var args = Array.prototype.slice.call(arguments, 1);
        var len = list.length;
        for(i=0; i<len; i++)
        {
            var h = list[i];
            if( typeof h === 'object' && typeof h[name] === 'function' )
            {
                try
                {
                    h[name].apply( h, args );
                }
                catch (ex)
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
        }
        return;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/URI'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/URI'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/URI'] = exports; 
var __dirname = 'NGGo/Service/Network';
var __filename = 'NGGo/Service/Network/URI.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class = require('NGGo/Foundation/Class').Class;


var URI   = Class.subclass(
/** @lends Service.Network.URI.prototype */
{
    classname: 'URI',

    /**
     * @class Class for URI manipulations
     * @constructs
     * @name Service.Network.URI
     * @augments Core.Class
     * @property {String} scheme Scheme part of URI.
     * @property {String} host Host part of URI.
     * @property {String} path Path part of URI.
     * @property {String} query Query part of URI.
     * @property {String} fragment Fragment part of URI.
     * query
     */
    initialize: function( uri )
    {
        this._scheme   = "";
        this._host     = "";
        this._path     = [];
        this._query    = "";
        this._fragment = "";
        this._original = "";
        if( typeof uri === 'string' ){
            this._parseUriString(uri, false);
            this._original = uri;
        }
    },
    $isHttpUri: function( uri )
    {
        return this._parseUriString(uri);
    },
    $_parseUriString: function(str, checkOnly)
    {
    var reg = /^(https?):\/\/([\-_.!~*\'()a-zA-Z0-9;:\@&=+\$,%]+)\/?([\-_.!~*\'()a-zA-Z0-9;\/:\@&=+\$,%]*)\??([\-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%]*)\#?([\-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]*)/i;
        var m = str.match(reg);
        if( m )
        {
            if( !checkOnly ){
                this._scheme   = m[1].toLowerCase();
                this._host     = m[2].toLowerCase();
                this._path     = this._parsePath(m[3]);
                this._query    = this._parseQuery(m[4]);
                this._fragment = m[5];
            }
            return true;
        }
        else
        {
            return false;
        }
    },
    get scheme()
    {
        return this._scheme;
    },
    set scheme(value)
    {
        if( typeof value !== 'string' ){
            throw new Error("ngGo Service.Network.URI: scheme '"+value+"' is not suported");
        }
        value = value.toLowerCase();
        if( value === 'http' || value === 'https' )
        {
            this._scheme = value;
        }
        else
        {
            throw new Error("ngGo Service.Network.URI: scheme '"+value+"' is not suported");
        }
    },
    get host()
    {
        return this._host;
    },
    set host(value)
    {
        if( typeof value !== 'string' )
        {
            throw new Error("ngGo Service.Network.URI: host '"+value+"' is not suported");
        }
        else
        {
            this._host = value;
        }
    },
    get path()
    {
        if( this._path.length === 0 )
        {
            return "/";
        }
        return "/"+this._path.join("/");
    },
    set path(value)
    {
        if( typeof value === 'object' && value instanceof Array )
        {
            this._path = value;
        }
        else if( typeof value === 'string')
        {
            this._path = this._parsePath(value);
        }
        else
        {
            throw new Error("ngGo Service.Network.URI: path '"+value+"' is not suported");
        }
    },
    get query()
    {
        var i;
        var len = this._query.length;
        var ret = [];
        for(i=0; i<len; i++)
        {
            ret.push(this._query[i].original);
        }
        return ret.join("&");
    },
    set query(value)
    {
        if( typeof value === 'string')
        {
            this._query = this._parseQuery(value);
        }
        else
        {
            throw new Error("ngGo Service.Network.URI: query '"+value+"' is not suported");
        }
    },
    get fragment()
    {
        return this._fragment;
    },
    set fragment(value)
    {
        if( typeof value === 'string')
        {
            this._fragment = value;
        }
        else
        {
            throw new Error("ngGo Service.Network.URI: query '"+value+"' is not supported");
        }
    },
    /**
     * Return URI in string.
     * @retuns {String} URI string.
     */
    toString: function()
    {
        var uri = this.scheme+"://"
            + this.host
            + this.path;
        var query = this.query;
        if( query )
        {
            uri = uri + '?' + query;
        }
        var fragment = this.fragment;
        if( fragment )
        {
            uri = uri + "#" + fragment;
        }
        return uri;
    },
    /** @private */
    _parsePath: function(path)
    {
        if( !path || typeof path !== 'string' )
        {
            return [];
        }
        var ret = path.split('/');
        return ret;
    },
    /** @private */
    _buildPath: function(path)
    {
        if( !path || !path instanceof Array )
        {
            return '/';
        }
        return '/'+path.join('/');
    },
    _parseQuery: function(query)
    {
        var i;
        if( !query || typeof query !== 'string' )
        {
            return [];
        }
        var list = query.split("&");
        var len = list.length;
        var ret = [];
        for(i=0;i<len;i++){
            var entry = list[i].split("=");
            ret.push({
                original : list[i],
                key      : entry[0] ? decodeURIComponent(entry[0]) : "",
                value    : entry[1] ? decodeURIComponent(entry[1]) : ""
            });
        }
        return ret;
    },
    /** @private */
    _buildQuery: function(query)
    {
        var i;
        if( !query || !query instanceof Array )
        {
            return "";
        }
        var len = query.length;
        var list = [];

        for(i=0; i<length; ++i)
        {
            list.push(query[i].original);
        }
        return list.join("&");
    }
});

exports.URI = URI;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/OrderedDictionary'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/OrderedDictionary'] || {}; $MODULE_REGISTRY['NGGo/Foundation/OrderedDictionary'] = exports; 
var __dirname = 'NGGo/Foundation';
var __filename = 'NGGo/Foundation/OrderedDictionary.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Takaaki Mizuno
 *  Website:    https://developer.mobage.com/
 *  Copyright:  2011, by DeNA Co., Ltd
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGGo/Foundation/Class').Class;

var OrderedDictionary = Class.subclass(
/** @lends Foundation.OrderedDictionary.prototype */
{
    classname: 'OrderedDictionary',
    /**
     * @class
     * Dictionary like collection which persists the order of entries similar to an array.
     * @constructs
     * @param {String} [json] Initial data formatted in JSON.
     * @property {Number} length (readonly) Number of entries.
     * @property {String[]} keys (readonly) Array includes key of all entries.
     * @property {String[]} values (readonly) Array includes value of all entries.
     * @property {String[]} items (readonly) Array includes key/value of all entries.
     * @name Foundation.OrderedDictionary
     */
    initialize: function( json )
    {
        this._list = [];
        this._hash = {};
        if( typeof json === 'string' )
        {
            this._fromJSON(json);
        }
    },
    /**
     * Adds entry to the end of this dictionary and returns the new length of the array.
     * @param {String} key Key of entry
     * @param {any} obj Value of entry.
     * @returns {Number} New length of this OrderedDictionary.
     */
    push: function( key, obj )
    {
        var index = this._list.indexOf(key);
        if( index > -1 )
        {
            return -1;
        }
        this._list.push(key);
        this._hash[key] = obj;
        return this._list.length-1;
    },
    /**
     * Removes the last entry from this dictionary and returns the value of the entry.
     * @returns {any} Value of removed entry.
     */
    pop: function()
    {
        var key = this._list.pop();
        var obj = this._hash[key];
        delete this._hash[key];
        return obj;
    },
    /**
     * Removes the first entry from this dictionary and returns the value of the entry.
     * @returns {any} Value of removed entry.
     */
    shift: function()
    {
        var key = this._list.shift();
        var obj = this._hash[key];
        delete this._hash[key];
        return obj;
    },
    /**
     * Adds entry to the beginning of this dictionary and returns the new length of the array.
     * @param {String} key Key of entry
     * @param {any} obj Value of entry.
     * @returns {Number} New length of this OrderedDictionary.
     */
    unshift: function(key, obj )
    {
        var index = this._list.indexOf(key);
        if( index > -1 )
        {
            return -1;
        }
        this._list.unshift(key);
        this._hash[key] = obj;
        return 0;
    },
    /**
     * Inserts entry to paticular position and return that position. If speficied key already exists, old value has been removed and updated with new index and value.
     * @param {Number} index The position to insert entry.
     * @param {String} key Key of entry
     * @param {any} obj Value of entry.
     * @returns {Number} The position the entry inserted ( -1 will be returned if it failed ).
     */
    insert: function(index, key, obj)
    {
        // Check if specified key already exists.
        this.remove(key);
        if( index >= this._list.length )
        {
            this._list[index] = key;
        }
        else
        {
            this._list.splice(index, 0, key);
        }
        this._hash[key] = obj;
        return index;
    },
    /**
     * Set the value to entry specified by key.
     * @param {String} key key to set the value
     * @param {any} obj Value to set
     */
    set: function(key, obj)
    {
        var index = this._list.indexOf(key);
        if( index > -1 )
        {
            this._hash[key] = obj;
        }
        else
        {
            this.push(key, obj);
        }
    },
    /**
     * Set the value to entry when the key doesn't exist.
     * @param {String} key key to set the value
     * @param {any} obj Value to set
     */
    setDefault: function(key, obj)
    {
        var index = this._list.indexOf(key);
        if( index === -1 )
        {
            this.push(key, obj);
            return obj;
        }
        return this._hash[key];
    },
    /**
     * Remove entry specified by key.
     * @param {String} key ket to remove the value
     * @returns {any} Value of removed entry.
     */
    remove: function( key )
    {
        var index = this._list.indexOf(key);
        if( index === -1 )
        {
            return undefined;
        }
        this._list.splice(index, 1);
        var obj = this._hash[key];
        delete this._hash[key];
        return obj;
    },
    /**
     * Get an entry value specified by key.
     * @param {String} key Key to get the value.
     * @param {any} defaultValue Default value if the key does not exist.
     * @returns {any} value specified by given key.
     */
    get: function( key, defaultValue )
    {
        var result = this._hash[key];
        if (result === undefined)
        {
            return defaultValue;
        }
        return result;
    },
    /**
     * Get an entry value specified by index.
     * @param {Number} index index to get the value.
     * @returns {any} value specified by given index.
     */
    getByIndex: function( index )
    {
        var key = this._list[index];
        return this._hash[key];
    },
    /**
     * Get an entry key specified by index.
     * @param {Number} index index to get the key.
     * @returns {any} key specified by given index.
     */
    getKeyByIndex: function( index )
    {
        return this._list[index];
    },
    /**
     * Clear all the entries.
     */
    clear: function()
    {
        this._list = [];
        this._hash = {};
    },
    /**
     * Remove multiple entries from this OrderedDictionary
     * @param {Number} start Start index position to remove.
     * @param {Number} n  Number to remove
     * @returns {Array} Array of removed values.
     */
    splice: function(start, n)
    {
        var i;
        var list = this._list.splice(start, n);
        var len = list.length;
        var res = [];
        for( i=0; i<len; i++ )
        {
            var key = list[i];
            res.push( this._hash[key]);
            delete this._hash[key];
        }
        return res;
    },
    /**
     * Reverse the order of entries.
     */
    reverse: function()
    {
        this._list.reverse();
    },
    /**
     * Sorts the order of entries.
     * @example
     * ordereddict.sort(function(a, b) { areturn a-b; });
     * @param {Function} cmp Comparater function.
     */
    sort: function(cmp)
    {
        return this._list.sort(cmp);
    },
    /**
     * Get JSON expression of OrderedDictionary.
     * @returns {String} JSON text describe this object.
     */
    toJSON: function()
    {
        return JSON.stringify(
            {
                list: this._list,
                hash: this._hash
            }
        );
    },
    /**
     * Ailias method of toJSON.
     * @returns {String} JSON text describe this object.
     */
    toString: function()
    {
        return this.toJSON();
    },
    // property getter
    get length()
    {
        return this._list.length;
    },
    set length(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("OrderedDictionary: length is a read only property.");
        }
    },
    get keys()
    {
        var i;
        var ret = [];
        var len = this._list.length;
        for( i=0; i<len; i++ )
        {
            ret.push(this._list[i]);
        }
        return ret;
    },
    set keys(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("OrderedDictionary: keys is a read only property.");
        }
    },
    get values()
    {
        var i;
        var ret = [];
        var len = this._list.length;
        for( i=0; i<len; i++ )
        {
            ret.push(this._hash[this._list[i]]);
        }
        return ret;
    },
    set values(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("OrderedDictionary: values is a read only property.");
        }
    },
    get items()
    {
        var i;
        var ret = [];
        var len = this._list.length;
        for( i=0; i<len; i++ )
        {
            ret.push([this._list[i], this._hash[this._list[i]]]);
        }
        return ret;
    },
    set items(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("OrderedDictionary: items is a read only property.");
        }
    },
    /** @private */
    _fromJSON: function(json)
    {
        var obj;
        try
        {
            obj = JSON.parse(json);
        }
        catch (ex)
        {
            throw new Error("<NGGO> OrderedDictionary: JSON Parse Error");
        }
        if( !obj.list || !obj.hash )
        {
            return;
        }
        this._list = obj.list;
        this._hash = obj.hash;
    }
});

exports.OrderedDictionary = OrderedDictionary;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/HTTP/Cookies'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Cookies'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Cookies'] = exports; 
var __dirname = 'NGGo/Service/Network/HTTP';
var __filename = 'NGGo/Service/Network/HTTP/Cookies.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class             = require('NGGo/Foundation/Class').Class;
var OrderedDictionary = require('NGGo/Foundation/OrderedDictionary').OrderedDictionary;


var Cookies = Class.subclass(
/** @lends Service.Network.HTTP.Cookies.prototype */
{
    classname: 'Cookies',
    /**
     * @class Object to represent HTTP cookies.
     * @constructs
     * @name Service.Network.HTTP.Cookies
     * @param {String} [str] Cookie string
     * @property {Date|String} expire Expire date fragment.
     * <br><br>
     * You can pass string that <code>Date</code> object can accept.
     * @property {Boolean} secure or not.
     * @property {String} path Path fragment of cookie.
     * @property {String} domain Domain fragment of cookie.
     * @property {Number} length (readonly) Number of cookie values. length is read only property.
     */
    initialize: function(str)
    {
        this._cookie = undefined;
        this._expire = undefined;
        this._path   = undefined;
        this._domain = undefined;
        this._secure = false;
        if( typeof str === 'string')
        {
            this._parseCookie(str);
        }
        else
        {
            this._cookie = new OrderedDictionary();
        }
    },
    /**
     * Return Cookie string for HTTP request header.
     * @returns {String} Cookie string for HTTP request Cookie header.
     */
    toString: function()
    {
        var all, needattr;
        if( this._expire )
        {
            // this instance is for "set-cookie:"
            all = false;
            needattr = true;
        }
        else
        {
            // this instance is for "cookie:"
            all = true;
            needattr = false;
        }
        return this._buildCookie(all, needattr, false);
    },
    /**
     * Return array of each cookie entry.
     * @returns {Array} Array of each cookie name value pair.
     */
    toArray: function()
    {
        if( !this._cookie )
        {
            return [];
        }
        var all, needattr;
        if( this._expire )
        {
            // this instance is for "set-cookie:"
            all = false;
            needattr = true;
        }
        else
        {
            // this instance is for "cookie:"
            all = true;
            needattr = false;
        }
        return this._buildCookie(all, needattr, true);
    },
    /**
     * Get cookie value of given name
     * @param {String} name name to get cookie
     * @returns {String} The value of cookie
     */
    get: function(name)
    {
        return this._cookie.get(name);
    },
    /**
     * Set cookie value of given name
     * @param {String} name name to set cookie
     * @param {String} value value of cookie
     */
    set: function(name, value)
    {
        this._cookie.set(name,value);
    },
    /**
     * Remove cookie value of given name
     * @param {String} name name to remove cookie
     * @returns {String} Removed value
     */
    remove: function(name)
    {
        return this._cookie.remove(name);
    },
    get expire()
    {
        return this._expire;
    },
    set expire(value)
    {
        if( typeof value === 'object' && value instanceof Date )
        {
            this._expire = value;
        }
        else
        {
            this._expire = new Date(value);
        }
    },
    get secure()
    {
        return this._secure;
    },
    set secure(value)
    {
        this._secure = !!value;
    },
    get path()
    {
        return this._path;
    },
    set path(value)
    {
        this._path = value;
    },
    get domain()
    {
        return this._domain;
    },
    set domain(value)
    {
        this._domain = value;
    },
    get length(){
        return this._cookie.length;
    },
    set length(value){
        if( typeof NgLogW === 'function' )
        {
            NgLogW("length is a read only property.");
        }
    },
    /** @private */
    _parseCookie: function(str)
    {
        var i;
        var array = str.split(";");
        var reg = /\s*([^=]+)=\s*(.+)/;
        this._cookie = new OrderedDictionary();
        var len = array.length;
        for(i=0;i<len;i++)
        {
            var m = array[i].match(reg);
            if( m )
            {
                var key   = m[1];
                var value = m[2];
                switch(key.toLowerCase()){
                case "expires":
                    this._expire = new Date(value);
                    break;
                case "path":
                    this._path = value;
                    break;
                case "domain":
                    this._domain = value;
                    break;
                default:
                    this._cookie.set(key, value);
                    break;
                }
            }
            else if(array[i] === 'secure' )
            {
                this._secure = true;
            }
        }
    },
    /** @private */
    _buildCookie: function(all, needattr, wantarray)
    {
        var i;
        var cookies = this._cookie;
        if( !cookies || cookies.length === 0 )
        {
            return wantarray ? [] : "";
        }
        var array = [];
        var len = cookies.length;
        if( !all )
        {
            len = 1;
        }
        for( i=0; i<len; i++ )
        {
            array.push(cookies.getKeyByIndex(i)+"="+cookies.getByIndex(i));
        }
        if( needattr )
        {
            if( this._expire )
            {
                array.push("expire="+this._expire.toUTCString());
            }
            if( this._path )
            {
                array.push("path="+this._path);
            }
            if( this._domain )
            {
                array.push("domain="+this._domain);
            }
            if( this._secure )
            {
                array.push("secure");
            }
        }
        return wantarray ? array : array.join(";");
    }
});

exports.Cookies = Cookies;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/HTTP/Headers'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Headers'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Headers'] = exports; 
var __dirname = 'NGGo/Service/Network/HTTP';
var __filename = 'NGGo/Service/Network/HTTP/Headers.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class             = require('NGGo/Foundation/Class').Class;
var OrderedDictionary = require('NGGo/Foundation/OrderedDictionary').OrderedDictionary;
var Cookies           = require('NGGo/Service/Network/HTTP/Cookies').Cookies;


var Headers = Class.subclass(
/** @lends Service.Network.HTTP.Headers.prototype */
{
    classname: 'Headers',
    _dateType: {
        "If-Modified-Since" : 1,
        "Last-Modified"     : 1
    },
    _cookieType: {
        "Set-Cookie" : 1,
        "Cookie"     : 1
    },
    /**
     * @class Class represents HTTP request/response headers.
     * @property {Number} length (readonly) Number of header. length is read only property.
     * @property {String} userAgent User-Agent header value accessor.
     * @property {String} contentType Content-Type header value accessor.
     * @property {String} contentTypeCharset Encoding str for content-Type header value.
     * @property {String} lastModified Last-Modified header value accessor.
     * @property {String} ifModifiedSince If-Modified-Since header value accessor.
     * @property {Boolean} contentIsText (readonly) It indicate the downloaded content is text or not.
     * @property {Boolean} contentIsJSON (readonly) It indicate the downloaded content is JSON or not.
     * @property {Object} HTTP.Cookies object for Cookie header.
     * @constructs
     * @augments Core.Class
     */
    initialize: function()
    {
        this._dict = new OrderedDictionary();
        this._cookies = new Cookies();
    },
    /**
     * Get header value specified by name.  If the header has only one value, it returns String. If the header has more than 2 values, it returns Array.
     * @param {String} name the name of HTTP header
     * @returns {String} the value of the http header field. If the field  have multipul values, it will return Array object.
     */
    get: function(name)
    {
        return this._dict.get(name);
    },
    /**
     * Set header value specified by name. If the header is already exist, old value is replaced with new value. value can be String or Array.
     * @param {String} name the name of HTTP header
     * @param {String} value the value of HTTP header
     */
    set: function(name, value)
    {
        if( this._dateType[name] )
        {
            value = new Date(value);
        }
        else if ( this._cookieType[name] )
        {
            if( typeof value === 'object' && value instanceof Cookies )
            {
                value = value.toString();
            }
        }
        this._dict.set(name, value);
    },
    /**
     * Set header value specified by name. If the header is already exist, new value will add after the old values. old value is replaced with new value. Value can be String or Array.
     * @param {String} name the name of HTTP header
     * @param {String} value the value of HTTP header
     */
    push: function(name, value)
    {
        if( this._dateType[name] )
        {
            value = new Date(value);
        }
        var current = this._dict.get(name);
        if( !current )
        {
            return this._dict.set(name, value);
        }
        else if( typeof current === 'object' && current instanceof Array )
        {
            return this._dict.set(name, current.push(value));
        }
        return this._dict.set(name, [current, value]);
    },
    /**
     * Remove header values specified with the name.
     * @param {String} name the name of HTTP header
     * @returns {String} removed values
     */
    remove: function(name)
    {
        return this._dict.remove(name);
    },
    /**
     * Make an array of headers
     * @returns {Array} Array of all headers. Each headers are represented as an object which includes "key" and "value".
     */
    toArray: function()
    {
        var i;
        var keys = this._dict.keys;
        var len = keys.length;
        var ret = [];

        for(i=0; i<len; i++)
        {
            this._toArrayRec(ret, keys[i], this._dict.get(keys[i]));
        }
        if( this._cookies && this._cookies.length > 0 )
        {
            ret.push( {key: "Cookie", value: this._cookies.toString()} );
        }
        return ret;
    },
    /**
     * Return all the headers as a formatted MIME header.
     * @returns {String} formatted MIME header.
     */
    toString: function()
    {
        var i;
        var array = this.toArray();
        var str = "";
        var len = array.length;

        for( i=0; i<len; i++ )
        {

            str = str + array[i].key + ": "+array[i].value + "\n";
        }
        return str;
    },
    get length()
    {
        return this._dict.length;
    },
    set length(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("length is a read only property.");
        }
    },
    get userAgent()
    {
        return this.get("User-Agent");
    },
    set userAgent(value)
    {
        this.set("User-Agent", value);
    },
    get contentType()
    {
        var ct = this._parseContentType(this.get("Content-Type"));
        return ct.type ? ct.type+"/"+ct.subtype : "";
    },
    set contentType(value)
    {
        var newCt = this._parseContentType(value);
        var oldCt = this._parseContentType(this.get("Content-Type"));
        if( newCt.type )
        {
            var newCtStr = newCt.type+"/"+newCt.subtype;
            if( newCt.charset )
            {
                newCtStr = newCtStr + "; charset="+newCt.charset;
            }
            else if( oldCt.charset )
            {
                newCtStr = newCtStr + "; charset="+oldCt.charset;
            }
            this.set("Content-Type", newCtStr);
        }
    },
    get contentTypeCharset()
    {
        var ct = this._parseContentType(this.get("Content-Type"));
        return ct.charset ? ct.charset : "";
    },
    set contentTypeCharset(value)
    {
        var oldCt = this._parseContentType(this.get("Content-Type"));
        if( oldCt.type )
        {
            var newCtStr = oldCt.type+"/"+oldCt.subtype;
            if( value )
            {
                newCtStr = newCtStr + "; charset="+value;
            }
            this.set("Content-Type", newCtStr);
        }
    },
    get lastModified()
    {
        this._getDateType("Last-Modified");
    },
    set lastModified(value)
    {
        this._setDateType("Last-Modified", value);
    },
    get ifModifiedSince()
    {
        this._getDateType("If-Modified-Since");
    },
    set ifModifiedSince(value)
    {
        this._setDateType("If-Modified-Since", value);
    },
    get contentIsText()
    {
        var ct = this._parseContentType(this.get("Content-Type"));
        return ct.type    === 'text' ? true :
               ct.subtype === 'json' ? true : false;
    },
    set contentIsText(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("contentIsText is a read only property.");
        }
    },
    get contentIsJSON()
    {
        var ct = this._parseContentType(this.get("Content-Type"));
        return ct.subtype === 'json'  ? true : false;
    },
    set contentIsJSON(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("contentIsJSON is a read only property.");
        }
    },
    get cookies()
    {
        return this._cookies;
    },
    set cookies(value)
    {
        this._cookies = value;
    },
    // Private Functions
    _toArrayRec: function(array, key, value)
    {
        NgLogD(key);
        var i;
        if( typeof value === 'object' )
        {
            if( value instanceof Array )
            {
                var len = value.length;
                for(i=0; i<len; i++ )
                {
                    this._toArrayRec(array, key, value[i]);
                }
            }
            else if( value instanceof Date )
            {
                array.push({ key: key, value: value.toUTCString()});
            }
            else if( value.toString )
            {
                array.push({key: key, value: value.toString()});
            }
        }
        else
        {
            array.push({ key: key, value: value});
        }
    },
    /** @private */
    _parseContentType: function(ct)
    {
        if( typeof ct === 'string' )
        {
            var reg = /([^;\/]+)\/([^;\/]+)(?:\;\s*charset=(.+))*/;
            ct = ct.toLowerCase();
            var m = ct.match(reg);
            if( m )
            {
                return {
                    type    : m[1],
                    subtype : m[2],
                    charset : m[3] ? m[3] : ""
                };
            }
        }
        return {
            type    : "",
            subtype : "",
            charset : ""
        };
    },
    /** @private */
    _getDateType: function(name)
    {
        var d = this.get(name);
        return ( typeof d === 'object' && d instanceof Date ? d : undefined );
    },
    /** @private */
    _setDateType: function(name, str)
    {
        var d;
        if( typeof str === 'object' && d instanceof Date )
        {
            d = str;
        }
        else
        {
            d = new Date(str);
        }
        this.set(name, d);
    }
});

exports.Headers = Headers;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/HTTP/Response'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Response'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/HTTP/Response'] = exports; 
var __dirname = 'NGGo/Service/Network/HTTP';
var __filename = 'NGGo/Service/Network/HTTP/Response.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class   = require('NGGo/Foundation/Class').Class;
var Headers = require('NGGo/Service/Network/HTTP/Headers').Headers;


var Response = Class.subclass(
/** @lends Service.Network.HTTP.Response.prototype */
{
    classname: 'Response',
    /**
     * @class class description
     * @example sample code
     * @constructs The default constructor.
     * @param {Network.XHR} xhr
     * @param {Object} req
     * @property {NUmber} statusCode (readonly)
     * @property {String} statusText (readonly)
     * @property {String} responseText (readonly)
     * @property {String} responseJSON (readonly)
     * @property {Boolean} isText (readonly)
     * @property {Boolean} isJSON (readonly)
     * @property {ToBeWritten} headers (readonly)
     * @augments Core.Class
     */
    initialize: function(xhr, req)
    {
        this._statusCode      = parseInt(xhr.status,10);
        this._statusText      = xhr.statusText;
        this._responseText    = xhr.responseText;
        this._redirectHistory = req.redirectList;
        this._headers         = this._buildHeaders(xhr);
        this._uri             = req.uri;
    },
    get statusCode()
    {
        return this._statusCode;
    },
    set statusCode(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: statusCode is a read only property.");
        }
    },
    get statusText()
    {
        return this._statusText;
    },
    set statusText(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: statusText is a read only property.");
        }
    },
    /**
     * @field
     * @type String
     */
    get responseText()
    {
        return this._responseText;
    },
    set responseText(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: responseText is a read only property.");
        }
    },
    get responseJSON()
    {
        try {
            return JSON.parse(this._responseText);
        } catch (ex) {
            return undefined;
        }
    },
    set responseJSON(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: responseJSON is a read only property.");
        }
    },
    get isText()
    {
        return this._headers.contentIsText();
    },
    set isText(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: isText is a read only property.");
        }
    },
    get isJSON()
    {
        return this._headers.contentIsJSON();
    },
    set isJSON(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: isJSON is a read only property.");
        }
    },
    get headers()
    {
        return this._headers;
    },
    set headers(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTP.Response: headers is a read only property.");
        }
    },
    /** @private */
    _buildHeaders: function(xhr)
    {
        var key;
        var obj = xhr.getUnflattenedResponseHeaders();
        var headers = new Headers();
        for(key in obj)
        {
            if( obj.hasOwnProperty(key))
            {
                headers.set(key, obj[key]);
            }
        }
        return headers;
    }
});

exports.Response = Response;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Data/TextCache'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Data/TextCache'] || {}; $MODULE_REGISTRY['NGGo/Service/Data/TextCache'] = exports; 
var __dirname = 'NGGo/Service/Data';
var __filename = 'NGGo/Service/Data/TextCache.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Mizumo Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Class             = require('NGCore/Client/Core/Class').Class;
var FileSystem        = require('NGCore/Client/Storage/FileSystem').FileSystem;
var KeyValueCache     = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
var OrderedDictionary = require('NGGo/Foundation/OrderedDictionary').OrderedDictionary;

/** @private */
var CacheManager = Class.singleton(
{
    classname: "CacheManager",
    TYPE:
    {
        MEMORY     : 0,
        FILESYSTEM : 1,
        KEYVALUE   : 2
    },
    POLICY:
    {
        LRU : 0,
        MRU : 1,
        LFU : 2
    },
    LOCK:
    {
        UNLOCKED  : 0,
        READWRITE : 1,
        WRITE     : 2
    },
    initialize: function()
    {
        this.cache = {};
        this.queue = {};
        this.lock  = {};
    },
    preloadCache: function(options)
    {
        this._getCache(options);
    },
    getItem: function(options, key, callback)
    {
        var args = {
            key      : key,
            callback : callback
        };
        return this._getCache(options, this._onGetCache.bind(this, options, args));
    },
    _onGetCache: function(options, args, obj)
    {
        var value;
        if( typeof obj === 'object' )
        {
            // obj is an OrderedDictionary object
            var item = obj.get(args.key);
            if( item )
            {
                value = item.value;
                var dt = new Date();
                if( options.expire > 0 && (item.datetime + options.expire) < dt.getTime()/1000 )
                {
                    obj.remove(args.key);
                    value = undefined;
                }
                else
                {
                    this._reorderCache(options,args,obj);
                }
            }
        }
        this._callFunction(args.callback, [ value ] );
        return value;
    },
    _reorderCache: function(options, args, obj)
    {
        var i;
        var item = obj.remove(args.key);
        item.count++;
        var c = item.count;
        switch(options.policy){
        case this.POLICY.LRU:
        case this.POLICY.MRU:
            obj.unshift(args.key, item);
            return;
        case this.POLICY.LFU:
            var len = obj.length;
            for(i=0; i<len; i++ )
            {
                var item2 = obj.getByIndex(i);
                if( item2.count < c )
                {
                    obj.insert(i, args.key, item);
                    return;
                }
            }
            obj.push( args.key, item);
            break;
        default:
            break;
        }
    },
    _getKey: function( options )
    {
        if( typeof options !== 'object' )
        {
            return undefined;
        }
        var prefix = Object.keys(this.TYPE);
        return prefix[options.type] + ":" + options.key;
    },
    _getCache: function(options, callback)
    {
        var key = this._getKey(options);
        if( !key )
        {
            return false;
        }
        var args = {
            key: key,
            callback: callback
        };
        if( this.cache[key] )
        {
            var value = this._callFunction(callback, [ this.cache[key] ] );
            if( this.queue[key] && this.queue[key].length > 0 )
            {
                var func = this.queue[key].shift();
                if( typeof func === 'function' )
                {
                    func();
                }
            }
            return value;
        }
        else
        {
            switch(options.type)
            {
            case this.TYPE.MEMORY:
                this.cache[key] = new OrderedDictionary();
                this._callFunction(callback, [ this.cache[key] ]);
                break;
            case this.TYPE.FILESYSTEM:
                this._loadCacheFromFile(options, args);
                break;
            case this.TYPE.KEYVALUE:
                this._loadCacheFromKeyValue(options, args);
                break;
            default:
                break;
            }
        }
        return undefined;
    },
    _callFunction: function( func, args )
    {
        if( typeof func === "function" )
        {
            try
            {
                return func.apply( undefined, args );
            }
            catch (ex)
            {
                if( NgLogException )
                {
                    NgLogException(ex);
                }
            }
        }
    },
    _lockCache: function(key, type)
    {
        if( this.lock[key] )
        {
            return false;
        }
        this.lock[key] = type;
        return true;
    },
    _unlockCache: function(key)
    {
        if( this.lock[key] )
        {
            this.lock[key] = this.LOCK.UNLOCKED;
        }
        if( this.queue[key] && this.queue[key].length > 0 )
        {
            var func = this.queue[key].shift();
            if( typeof func === 'function' )
            {
                func();
            }
        }
    },
    _canRead: function(key)
    {
        if( this.lock[key] === this.LOCK.READWRITE )
        {
            return false;
        }
        return true;
    },
    _loadCacheFromFile: function(options, args)
    {
        if( !this._lockCache(args.key, this.LOCK.READWRITE) )
        {
            if( !this.queue[args.key] )
            {
                this.queue[args.key] = [];
            }
            this.queue[args.key].push(this._getCache.bind(this, options, args.callback ));
            return;
        }
        FileSystem.readFile ( "Cache/" + args.key + ".json", false,
                              this._onLoadCache.bind(this, options, args) );
    },
    _onLoadCache: function(options, args, err, data )
    {
        if( err )
        {
            this.cache[args.key] = new OrderedDictionary();
        }
        else
        {
            try
            {
                this.cache[args.key] = new OrderedDictionary(data);
            }
            catch (ex)
            {
                this.cache[args.key] = new OrderedDictionary();
                if(typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
        this._callFunction( args.callback, [ this.cache[args.key] ] );
        this._unlockCache(args.key);
    },
    _loadCacheFromKeyValue: function(options, args)
    {
        if( !this._lockCache(args.key, this.LOCK.READWRITE) )
        {
            if( !this.queue[args.key] )
            {
                this.queue[args.key] = [];
            }
            this.queue[key].push(this._getCache.bind(this, options, args.callback ));
            return;
        }
        KeyValueCache.local.getItem("Cache/"+args.key,
                                            this._onLoadCache.bind(this, options, args) );
    },
    setItem: function(options, key, value, callback)
    {
        var args = {
            key: key,
            value: value,
            callback: callback
        };
        args.cachekey = this._getKey(options);
        if( !this._lockCache(args.cachekey, this.LOCK.WRITE) )
        {
            if( !this.queue[args.cachekey] )
            {
                this.queue[args.cachekey] = [];
            }
            this.queue[args.cachekey].push(this.setItem.bind(this, options, key, value, callback ));
            return;
        }
        this._getCache(options, this._onGetCacheForSet.bind(this, options, args));
    },
    _onGetCacheForSet: function(options, args, obj)
    {
        if( typeof obj !== 'object' )
        {
            obj = new OrderedDictionary();
            this.cache[args.cachekey] = obj;
        }
        var item = obj.remove(args.key);
        if( !item )
        {
            item = { count: 0 };
        }
        var dt = new Date();
        item.value = args.value;
        item.datetime = dt.getTime()/1000;
        if( obj.length >= options.size)
        {
            switch(options.policy)
            {
            case this.POLICY.LRU:
            case this.POLICY.LFU:
                obj.pop(args.key);
                break;
            case this.POLICY.MRU:
                obj.shift(args.key);
                break;
            default:
                obj.pop(args.key);
                break;
            }
        }
        obj.unshift(args.key, item);
        switch(options.type)
        {
        case this.TYPE.MEMORY:
            this._onLoadCacheForSet(options, args, obj, undefined);
            break;
        case this.TYPE.FILESYSTEM:
            this._saveCacheToFile(options, args, obj);
            break;
        case this.TYPE.KEYVALUE:
            this._saveCacheToKeyValue(options, args, obj);
            break;
        default:
            this._onLoadCacheForSet(options, args, obj, undefined);
            break;
        }
    },
    removeItem: function(options, key, callback )
    {
        var args = {
            key: key,
            callback: callback
        };
        args.cachekey = this._getKey(options);
        if( !this._lockCache(args.cachekey, this.LOCK.WRITE) )
        {
            if( !this.queue[args.cachekey] )
            {
                this.queue[args.cachekey] = [];
            }
            this.queue[args.cachekey].push(this.removeItem.bind(this, options, key, callback ));
            return;
        }
        this._getCache(options, this._onGetCacheForRemove.bind(this, options, args));
    },
    _onGetCacheForRemove: function(options, args, obj)
    {
        if( typeof obj !== 'object' )
        {
            obj = new OrderedDictionary();
            this.cache[args.cachekey] = obj;
        }
        if( !args.key )
        {
            obj.clear();
        }
        else
        {
            obj.remove(args.key);
        }
        switch(options.type)
        {
        case this.TYPE.MEMORY:
            this._onLoadCacheForSet(options, args, obj, undefined);
            break;
        case this.TYPE.FILESYSTEM:
            this._saveCacheToFile(options, args, obj);
            break;
        case this.TYPE.KEYVALUE:
            this._saveCacheToKeyValue(options, args, obj);
            break;
        default:
            this._onLoadCacheForSet(options, args, obj, undefined);
            break;
        }
    },
    _saveCacheToFile: function(options, args, obj)
    {
        FileSystem.writeFile( "Cache/" + args.cachekey + ".json", obj.toJSON(),
                              false, this._onLoadCacheForSet.bind(this, options, args, obj) );
    },
    _saveCacheToKeyValue: function(options, args, obj)
    {
        KeyValueCache.local.setItem("Cache/"+args.cachekey, obj.toJSON(),
                                            this._onLoadCacheForSet.bind(this, options, args, obj) );

    },
    _onLoadCacheForSet: function(options, args, obj, error)
    {
        this._callFunction(args.callback, [error, args.value]);
        this._unlockCache(args.cachekey);
    }
});

var TextCache = Class.subclass(
/** @lends Service.Data.TextCache */
{
    classname: 'TextCache',
    /**
     * Type code of <a href="Service.Data.TextCache.html"><code>TextCache</code></a>.
     * @namespace
     */
    TYPE:
    {
        /** Cache only to memory */
        MEMORY     : 0,
        /** Cache data to file */
        FILESYSTEM : 1,
        /** Cache data to key value storage */
        KEYVALUE   : 2
    },
    /**
     * Replacement policy type of <a href="Service.Data.TextCache.html"><code>TextCache</code></a>.
     * @namespace
     */
    POLICY:
    {
        /** Least Recently Used */
        LRU : 0,
        /** Most Recently Used */
        MRU : 1,
        /** Least Frequently Used */
        LFU : 2
    },
    /**
     * @class It provide the same interface for text cache on memory, filesystem and keyvalue strage.
     * @param {Object} [options] object includes option parameters.
     * @param {Number} [options.type=TextCache.TYPE.MEMORY] Type which describe where the cache data will be stored.
     * @param {Number} [options.policy=TextCache.POLICY.LRU] Replacement policy for the cache.
     * @param {Number} [options.size=100] Cache size.
     * @param {Number} [options.expire=3600] Expired time of each cache( sec ).
     * @param {String} [options.key="nggo-cache"] Key which uses for filename and key of key-value storage.
     * @constructs
     * @augments Core.Class
     * @name Service.Data.TextCache
     */
    initialize: function(options)
    {
        var name;
        var _default_options = {
            type   : this.TYPE.MEMORY,
            policy : this.POLICY.LRU,
            size   : 100,
            expire : 3600,
            key    : "nggo-cache"
        };
        if( !options || typeof options !== 'object' )
        {
            options = {};
        }
        if(!this.options)
        {
            this.options = {};
        }
        this.options.Cache = {};
        for( name in _default_options )
        {
            if( _default_options.hasOwnProperty(name))
            {
                this.options.Cache[name] = options.hasOwnProperty(name) ? options[name] : _default_options[name];
            }
        }
        CacheManager.preloadCache(this.options.Cache);
    },
    /**
     * Adds value associated with the given key to the storage.
     *
     * @param {String} key Cache key to add
     * @param {String|Number} value Value to add
     * @param {Function} [callback] Callback function which is called when the process is finished.
     */
    add: function(key, value, callback)
    {
        CacheManager.setItem(this.options.Cache, key, value, callback);
    },
    /**
     * Alias of add method.
     *
     * @param {String} key Cache key to add
     * @param {String|Number} value Value to add
     * @param {Function} [callback] Callback function which is called when the process is finished.
     */
    set: function(key, value, callback)
    {
        this.add(key, value, callback);
    },
    /**
     * Get a cache data associate with given key.
     *
     * @param {String} key Cache key to get
     * @param {Function} [callback] Callback function which is called when the process is finished.
     */
    get: function(key, callback)
    {
        return CacheManager.getItem(this.options.Cache, key, callback);
    },
    /**
     * Remove a cache data associate with given key.
     *
     * @param {String} key Cache key to get
     * @param {Function} [callback] Callback function which is called when the process is finished.
     */
    remove: function(key, callback)
    {
        CacheManager.removeItem(this.options.Cache, key, callback);
    },
    /**
     * Clear all cache data associate with the cache object.
     *
     * @param {Function} [callback] Callback function which is called when the process is finished.
     */
    clear: function(callback)
    {
        CacheManager.removeItem(this.options.Cache, undefined, callback);
    }
});

exports.TextCache = TextCache;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/HTTP/RequestCache'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/HTTP/RequestCache'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/HTTP/RequestCache'] = exports; 
var __dirname = 'NGGo/Service/Network/HTTP';
var __filename = 'NGGo/Service/Network/HTTP/RequestCache.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ngyuen Vu Thanh Tung
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class     = require('NGGo/Foundation/Class').Class;
var TextCache = require('NGGo/Service/Data/TextCache').TextCache;


var RequestCache = Class.singleton(
/** @lends Service.Network.HTTP.RequestCache.prototype */
{
    classname: 'RequestCache',
    /**
     * @class Singleton class to store request cache by using uri as a key.
     * @constructs
     * @name Service.Network.HTTP.RequestCache
     * @augments Core.Class
     */
    initialize: function()
    {
        this.length   = 0;
        this._count   = 0;
        this._default_options = {
            type   : TextCache.TYPE.MEMORY,
            policy : TextCache.POLICY.LRU,
            size   : 100,
            expire : 3600,
            key    : "nggo-requestCache"
        };
        this._cache   = new TextCache(this._default_options);
    },
    /**
     * Get cache data specified by URI
     * @param {String|Object} uri URI to get cache. A string and HTTP.URI object are acceptable.
     * @returns {String} Content cache got through HTTP.
     */
    get: function(uri)
    {
        return this._cache.get(uri.toString());
    },
    /**
     * Set cache data specified by URI
     * @param {String|Object} uri URI to set cache. A string and HTTP.URI object are acceptable.
     * @param {String} value Content got through HTTP.
     */
    set: function(uri, value)
    {
        this._cache.add(uri.toString(), value);
    },
    /**
     * Clear all cache data.
     */
    clear: function()
    {
        this._cache.clear();
    }
});

exports.RequestCache = RequestCache;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/HTTPRequest'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/HTTPRequest'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/HTTPRequest'] = exports; 
var __dirname = 'NGGo/Service/Network';
var __filename = 'NGGo/Service/Network/HTTPRequest.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki & Ngyuen Vu Thanh Tung
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var XHR          = require('NGCore/Client/Network/XHR').XHR;
var Class        = require('NGGo/Foundation/Class').Class;
var Observable   = require('NGGo/Foundation/Observable').Observable;
var URI          = require('NGGo/Service/Network/URI').URI;
var Headers      = require('NGGo/Service/Network/HTTP/Headers').Headers;
var Cookies      = require('NGGo/Service/Network/HTTP/Cookies').Cookies;
var Response     = require('NGGo/Service/Network/HTTP/Response').Response;
var RequestCache = require('NGGo/Service/Network/HTTP/RequestCache').RequestCache;


var HTTPRequest = Class.subclass(
/** @lends Service.Network.HTTPRequest.prototype */
{
    classname: 'HTTPRequest',
    /**
     * @class ngCore's Network.XHR wrapper to provide higher level HTTP access functionalities.
     * @constructor
     * @augments Core.Class
     * @property {Number} maxRetry Max retry number when the network trouble has occur.
     * @property {Number} retryInterval Initial retry interval(millisec). The interval doubles each retry.
     * @property {Number} maxRedirect Limit of how many times it will obey redirection responses in a given request cycle.
     * @property {Number} timeout Timeout time in millisec.
     * @property {Number} readyState (readonly) readyState of XHR.
     * @property {Boolean} isRequesting (readonly) Describe it is requesting now or not.
     * @property {Object} transport (readonly) Get internal Network.XHR object.
     * @property {Object} headers (readonly) Get HTTP.Headers object to use for request heraders.
     * @property {String} userAgent Useragent string used for request.
     * @property {String} contentType The content type for the request body.
     * @property {Object} cookies Set HTTP.Cookies object to send cookies to server.
     * @property {Object} ifModifiedSince Date object for "If-modified-since" header to conditional request.
     * @name Service.Network.HTTPRequest
     */
    initialize: function()
    {
        this.maxRetry      = 0;
        this.retryInterval = 1000;
        this.maxRedirect   = 7;
        this.useCache      = false;
        this.timeout       = 60000;
        this._isRequesting = false;
        this._xhr          = new XHR();
        this._headers      = new Headers();
        this._headers.userAgent          = "ngGo-HTTP-Agent/1.0 (https://developer.mobage.com/)";
        this._headers.contentType        = "application/x-www-form-urlencoded";
        this._headers.contentTypeCharset = "utf-8";
    },
    /**
     * Access remote URI by HTTP GET method.
     * @param {String|Service.Network.URI} uri URI to do GET access. A sting and HTTP.URI object are acceptable.
     * @param {Function} [doneCb] callback function which called when the access finished.
     */
    get: function(uri, doneCb)
    {
        this.send("GET",uri, undefined, doneCb);
    },
    /**
     * Access remote URI by HTTP POST method.
     * @param {String|Service.Network.URI} uri URI to do POST access. A sting and HTTP.URI object are acceptable.
     * @param {String} requestBody Request body string for POST access.
     * @param {Function} [doneCb] callback function which called when the access finished.
     */
    post: function(uri, requestBody, doneCb)
    {
        this.send("POST",uri, requestBody, doneCb);
    },
    /**
     * Access remote URI by specified method.
     * @param {String} method HTTP method name( GET, POST, HEAD, PUT, DELETE )
     * @param {String|Service.Network.URI} uri URI to do POST access. A sting and HTTP.URI object are acceptable.
     * @param {String} requestBody Request body string for POST access.
     * @param {Function} [doneCb] callback function which called when the access finished.
     */
    send: function(method, uri, requestBody, doneCb )
    {
        if( this._isRequesting )
        {
            this.abort();
        }
        if( typeof uri !== 'object' || uri.classname !== 'URI' )
        {
            uri = new URI(uri);
        }
        method = method.toUpperCase();
        //Handle caching process for GET method
        var needCache  = false;
        if (this.useCache && method === "GET")
        {
            var res = RequestCache.get(uri);
            //if uri exists in cache
            if (res)
            {
                this.notify("onReadyStateChange", res);
                this.notify("onSuccess", res);
                this.notify("onComplete", res);
                this._isRequesting = false;
                if( typeof doneCb === 'function' )
                {
                    try
                    {
                        doneCb(res);
                    }
                    catch (ex)
                    {
                        if( typeof NgLogException === 'function' )
                        {
                            NgLogException(ex);
                        }
                    }
                }
                return;
            }
            //if uri doesn't exist, will do as usual & save successful response into cache
            else
            {
                needCache = true;
            }
        }
        this._requestStatus = {
            method         : method,
            uri            : uri,
            requestBody    : requestBody,
            doneCb         : doneCb,
            needCache      : needCache,
            timeOutTimerID : 0,
            redirectCount  : 0,
            redirectList   : [uri],
            retryCount     : 0,
            retryInterval  : this.retryInterval
        };
        this._sendRequest();
    },
    /**
     * Abort request.
     * @returns {Boolean} Aborted or not. If it is not requesting( finished or not requested yet ), it returns false.
     */
    abort: function()
    {
        if( this._isRequesting )
        {
            this._xhr.reset();
            return true;
        }
        return false;
    },
    /**
     * Clear HTTP request cache.
     */
    clearCache: function()
    {
        RequestCache.clear();
    },
    get readyState()
    {
        return this._xhr.readyState;
    },
    set readyState(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTPRequest: readyState is a read only property.");
        }
    },
    get isRequesting(){
        return this._isRequesting;
    },
    set isRequesting(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTPRequest: isRequesting is a read only property.");
        }
    },
    get transport(){
        return this._xhr;
    },
    set transport(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTPRequest: transport is a read only property.");
        }
    },
    get headers()
    {
        return this._headers;
    },
    set headers(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("HTTPRequest: headers is a read only property.");
        }
    },
    get userAgent()
    {
        return this._headers.userAgent;
    },
    set userAgent(value){
        this._headers.userAgent = value;
    },
    get contentType(){
        return this._headers.contentType;
    },
    set contentType(value){
        this._headers.contentType = value;
    },
    get cookies(){
        return this._headers.cookies;
    },
    set cookies(value){
        this._headers.cookies = value;
    },
    get ifModifiedSince()
    {
        return this._headers.ifModifiedSince;
    },
    set ifModifiedSince(value)
    {
        this._headers.ifModifiedSince = value;
    },
    /** @private */
    _sendRequest: function()
    {
        var i;
        var req = this._requestStatus;
        this._xhr.reset();
        this._xhr.open(req.method,req.uri.toString());
        var headers = this.headers.toArray();
        var len = headers.length;
        for( i=0; i<len; i++ )
        {
            this._xhr.setRequestHeader(headers[i].key, headers[i].value);
            NgLogD(headers[i].key+":"+headers[i].value);
        }
        if( isFinite(this.timeout) )
        {
            this._requestStatus.timeOutTimerID = setTimeout(
                this._requestTimeOut.bind(this), this.timeout*1000 );
        }
        this._xhr.onreadystatechange = this._onReadyStateChange.bind(this);
        this._xhr.send(req.requestBody);
        this._isRequesting = true;
    },
    /** @private */
    _onReadyStateChange: function()
    {
        //Implementation follows http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
        var xhr = this._xhr;
        var req = this._requestStatus;
        var res = this._buildResponse();
        this.notify("onReadyStateChange", res);
        if( xhr.readyState !== 4 )
        {
            if( xhr.readyState === 3 )
            {
                this.notify("onLoading", res);
            }
            return;
        }
        if( req.timeOutTimerID )
        {
            clearTimeout(req.timeOutTimerID);
            req.timeOutTimerID = 0;
        }
        var status = xhr.status;
        if(status === 301 || status === 302 || status === 303 || status === 307)
        {
            var uri = xhr.getResponseHeader("Location");
            this.headers.remove("Cookie");
            if (status !== 301)
            {
                if (req.method !== "GET" && req.method !== "HEAD")
                {
                    //clear headers
                    xhr.reset();
                    //change method to GET when redirect
                    req.method = "GET";
                    req.requestBody = undefined;
                }
            }
            if( uri && req.redirectCount < this.maxRedirect )
            {
                req.redirectCount++;
                uri = new URI(uri);
                req.redirectList.push(uri);
                req.uri = uri;
                req.retryCount = 0;
                req.retryInterval = this.retryInterval;
                this._sendRequest();
                return;
            }
            return;
        }
        if( status === 0 || status === 503 )
        {
            // network error
            res = this._buildResponse();
            if( req.retryCount > this.maxRetry )
            {
                this.notify("onFailure", res);
                this.notify("onComplete", res);
            }
            else
            {
                // retry
                setTimeout( this._sendRequest.bind(this), req.retryInterval);
                req.retryCount += 1;
                req.retryInterval *= 2;
            }
            return;
        }
        else
        {
            res = this._buildResponse();
            if( status >= 200 && status < 399 )
            {
                this.notify("onSuccess", res);
                //Only cache successful GET request
                if (status === 200)
                {
                    if (this.useCache && req.method === "GET" && req.needCache)
                    {
                        RequestCache.set(req.uri, res);
                    }
                }
            }else{
                this.notify("onFailure", res);
            }
            this.notify("onComplete", res);
        }
        this._isRequesting = false;
        if( typeof req.doneCb === 'function' )
        {
            try
            {
                req.doneCb(res);
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
    },
    /** @private */
    _requestTimeOut: function()
    {
        var req = this._requestStatus;
        if( req.timeOutTimerID && this._isRequesting )
        {
            req.timeOutTimerID = 0;
            var res = this._buildResponse();
            this.abort();
            this._isRequesting = false;
            if( req.retryCount > this.maxRetry )
            {
                this.notify("onTimeout", res);
                this.notify("onFailure", res);
                this.notify("onComplete", res);
            }
            else
            {
                // retry
                setTimeout( this._sendRequest.bind(this), req.retryInterval);
                req.retryCount += 1;
                req.retryInterval *= 2;
                return;
            }
            if( typeof req.doneCb === 'function' )
            {
                try
                {
                    req.doneCb(res);
                }
                catch (ex)
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
        }
    },
    /** @private */
    _buildResponse: function()
    {
        return new Response(this._xhr, this._requestStatus);
    }
},[Observable]);

exports.HTTPRequest = HTTPRequest;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Data/ServerSync'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Data/ServerSync'] || {}; $MODULE_REGISTRY['NGGo/Service/Data/ServerSync'] = exports; 
var __dirname = 'NGGo/Service/Data';
var __filename = 'NGGo/Service/Data/ServerSync.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Shibukawa Yoshiki & Tung Nguyen Vu Thanh
 *  Website     https://developer.mobage.com/
 *  Copyright   (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var XHR          = require('NGCore/Client/Network/XHR').XHR;
var FileSystem   = require('NGCore/Client/Storage/FileSystem').FileSystem;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Class        = require('NGGo/Foundation/Class').Class;
var NGGOError    = require('NGGo/Foundation/NGGOError').NGGOError;
var HTTPRequest  = require('NGGo/Service/Network/HTTPRequest').HTTPRequest;
var Observable   = require('NGGo/Foundation/Observable').Observable;



exports.ServerSync = Class.subclass(
/** @lends Service.Data.ServerSync */
{
    classname: "ServerSync",
    /**
     * Error code of <code>ServerSync</code> class.
     * @namespace ERROR
     */
    ERROR:
    {
        INVALID_TYPE: 1,
        INVALID_PATH: 2,
        FILE_READ_ERROR: 3,
        NETWORK_ERROR: 4,
        ASSET_NOT_FOUND: 5,
        NO_DATA_ERROR: 6,
        FILE_NOT_FOUND: 404,
        INTERNAL_ERROR: 11,
        PARSE_ERROR: 10
    },
    /**
     * @class <code>ServerSync</code> is a base class of ngGo manager classes.
     * This class can read data file from vearious source, and have server connection feature.
     * @borrows Foundation.Observable#addObserver
     * @borrows Foundation.Observable#deleteObserver
     * @borrows Foundation.Observable#deleteObservers
     * @borrows Foundation.Observable#countObservers
     * @borrows Foundation.Observable#notify
     * @constructs This is a constructor class.
     * @name Service.Data.ServerSync
     * @augments Foundation.Class
     */
    initialize : function() {
        this.__isRemote = false;
    },
    /**
     * Loads the configuration from JSON string or JSobject.
     * @param {String|Object} jsonData JSON string to be parsed
     * @param {Function} [callback] Callback function for when the load has completed.
     * @returns {Service.Data.ServerSync} Error code.
     */
    loadConfigFromData: function(jsonData, param, callback)
    {
        if (typeof param === "function")
        {
            callback = param;
            param = undefined;
        }
        var self = this;
        var result = this._parseJSON(jsonData, function(data) {
            return self.__onLoadData(data, param, callback);
        });
        if ((typeof result !== "boolean" || !result) && callback)
        {
            callback(result);
        }
        return result;
    },
    /**
     * Loads the configuration from a flat file or URI.
     * @param {String|Service.Network.URI} filename File name to load the JSON config data or URI.
     * @param {Function} [callback] Callback function for when the load has completed.
     */
    loadConfigFromFile: function(path, param, callback)
    {
        if (typeof param === "function")
        {
            callback = param;
            param = undefined;
        }
        var self = this;
        var afterRead = function(error, data)
        {
            if (callback && error)
            {
                callback(error);
                return;
            }
            var result = self._parseJSON(data, function(jsobj) {
                return self.__onLoadData(jsobj, param, callback);
            });
            if ((typeof result !== "boolean" || !result) && callback)
            {
                callback(result);
            }
        };
        if( typeof path === 'object' && path.classname === 'URI' )
        {
            this.__readRemoteFile(path, afterRead);
        }
        else if( typeof path === 'string' )
        {
            if( path.slice(0,7).toLowerCase() === "http://" ||
                path.slice(0,8).toLowerCase() === "https://" )
            {
                this.__isRemote = true;
                this.__readRemoteFile(path, afterRead);
            }
            else
            {
                this.__readLocalFile(path, afterRead);
                this._localConfigFile = path;
            }
        }
        else
        {
            if(callback)
            {
                callback(new NGGOError(this.ERROR.INVALID_PATH,
                    self.classname + ": `path` should be URI object or URI string."));
            }
        }
    },
    /**
     * Loads the configuration using the asset manager.
     * @param {String} assetKey
     * @param {Function} callback Callback function it is called when the loading is finished.
     */
    loadConfigFromAsset : function(assetKey, param, callback)
    {
        var AssetManager = require('NGGo/Service/Data/AssetManager').AssetManager;
        if (typeof param === "function")
        {
            callback = param;
            param = undefined;
        }
        var filepath = AssetManager.getAssetForKey(assetKey);
        if(filepath !== "")
        {
            this.loadConfigFromFile(filepath, callback);
        }
        else
        {
            return new NGGOError(this.error.ASSET_NOT_FOUND, self.classname + ": '" + assetKey + "' is not found.");
        }
    },
    /**
     * Setup development server handling for this module
     */
    setupDevelopment: function(development, callback)
    {
        if (development.server){
            this._developServerURL = development.server;
        }
        if (development.poll[this.classname] === true){
            /*
             * Assign local file path given in default.json.
             * If not explicitly given, it will depend on whether ngBuilder supports watching for this file or not.
             */
            if (development.localFilePath){
                if (this._localConfigFile){
                    // user folder + game folder + config file
                    var path = development.localFilePath + "/" + Capabilities.getGame() + "/" + this._localConfigFile;
                    this._startWatchLocalFile(path, callback);
                }
            }
            this.startPollingServer(callback);
        }
    },
    /**
     * Sets the server URL to poll for update requests.
     * @param {String} url URL that the camera manager will poll(nggo server).
     */
    setServerURL : function(url)
    {
        this._developServerURL = url;
    },
    /**
     * Sets the key for notification data update.
     * @param {String} url URL that the camera manager will poll(nggo server).
     */
    setNotifyKey : function(key)
    {
        this._developServerUpdateKey = key;
    },
    /**
     * Starts the Camera Manager polling the ngGo dev server.
     * <br><br>
     * If polling is working, automatically load latest preference data from ngGo server.
     */
    startPollingServer : function(callback)
    {
        this._pollServer = true;
        this._pollServerForChanges(callback);
    },

    /**
     * Stops the Camera Manager from polling the ngGo dev server.
     */
    stopPollingServer : function()
    {
        this._pollServer = false;
    },
    /**
     * Data source is remote or not;
     */
    get isRemote() {
        return this.__isRemote;
    },
    set isRemote(value) {
        throw new Error("isRemote property is readonly");
    },
    /** @private */
    _parseJSON: function(data, callback) {
        var returnvalue, json;
        switch(typeof data)
        {
        case "string":
            try
            {
                json = JSON.parse(data);
            }
            catch (ex1)
            {
                return new NGGOError(this.ERROR.PARSE_ERROR,
                    this.classname + ": Input data is invalid as JSON.");
            }
            try
            {
                returnvalue = callback(json);
            }
            catch (ex2)
            {
                console.log(data);
                returnvalue = new NGGOError(this.ERROR.PARSE_ERROR,
                                     this.classname + ": Input data is invalid as JSON.");
            }
            break;
        case "object":
            returnvalue = callback(data);
            break;
        default:
            returnvalue = new NGGOError(this.ERROR.INVALID_TYPE,
                                 this.classname + ": Input data should be Object or JSON string.");
            break;
        }
        return returnvalue;
    },
    /** @private */
    _startWatchLocalFile : function(file , callback)
    {
        var url;
        if(this.classname.slice(-7) === "Manager"){
            url = this._developServerURL + "/" + this.classname.slice(0, -7);
        } else {
            url = this._developServerURL + "/" + this.classname;
        }
        var req = new HTTPRequest();
        var self = this;
        req.addObserver({
            onSuccess: function(res)
            {
                callback(undefined, res.responseText);
            },
            onFailure: function(res)
            {
                if(res.statusCode === 404 )
                {
                    callback(new NGGOError(self.ERROR.FILE_NOT_FOUND,
                            self.classname + ": [404] File not found"));
                }
                else
                {
                    callback(new NGGOError(self.ERROR.NETWORK_ERROR,
                            self.classname + ": [" + req.status + "] Network Error"));
                }
            }
        });
        req.get(url + "/WatchLocalFile?file="+file);
    },
    /** @private */
    _pollServerForChanges : function(callback)
    {
        var url;
        if(this.classname.slice(-7) === "Manager")
        {
            url = this._developServerURL + "/" + this.classname.slice(0, -7);
        } else {
            url = this._developServerURL + "/" + this.classname;
        }

        if(this._pollServer)
        {
            var req = new HTTPRequest();
            var self = this;
            req.addObserver({
                onSuccess: function(res)
                {
                    var result = JSON.parse(res.responseText);
                    if (result.changed)
                    {
                        self.loadConfigFromFile(url, function(err) {
                            if (!err) {
                                console.log("Latest data is loaded");
                                self.notify(self._developServerUpdateKey, self);
                            } else {
                                switch(err.errorCode) {
                                case self.ERROR.PARSE_ERROR:
                                    err = new Error("JSON from server could not be parse." +
                                                    " Please check your data and try again");
                                    console.log(err);
                                    console.log(err.stack);
                                    throw err;
                                case self.ERROR.INVALID_TYPE:
                                    err = new Error("The server did not return any data.");
                                    console.log(err);
                                    console.log(err.stack);
                                    break;
                                }
                            }
                        });
                    }
                    setTimeout(function() {
                        self._pollServerForChanges(callback);
                    }, 1000);
                },
                onFailure: function(res)
                {
                    if(res.statusCode === 404 )
                    {
                        callback(new NGGOError(self.ERROR.FILE_NOT_FOUND,
                                 self.classname + ": [404] File not found"));
                    }
                    else
                    {
                        callback(new NGGOError(self.ERROR.NETWORK_ERROR,
                                 self.classname + ": [" + req.status + "] Network Error"));
                    }
                }
            });
            req.get(url + "/PollForChanges");
        }
    },
    /** @private
     * This method should be overriden.
     */
    __onLoadData: function(data, param) {
        throw new Error("__onLoadData should be overridden");
    },
    /** @private */
    __readLocalFile: function(filepath, callback) {
        var self = this;
        FileSystem.readFile(filepath, false, function(err, data)
        {
            if(err)
            {
                callback(new NGGOError(self.ERROR.FILE_READ_ERROR,
                            self.classname + ": File '" + filepath + "' not found."));
            }
            else
            {
                callback(undefined, data);
            }
        });
    },
    /** @private */
    __readRemoteFile: function(path, callback) {
        var req = new HTTPRequest();
        var self = this;
        req.addObserver(
            {
                onSuccess: function(res)
                {
                    callback(undefined, res.responseText);
                },
                onFailure: function(res)
                {
                    if(res.statusCode === 404 )
                    {
                        callback(new NGGOError(self.ERROR.FILE_NOT_FOUND,
                                               self.classname + ": [404] File not found"));
                    }
                    else
                    {
                        callback(new NGGOError(self.ERROR.NETWORK_ERROR,
                                               self.classname + ": [" + req.status + "] Network Error"));
                    }
                }
            }
        );
        req.get(path);
    }
}, [Observable]);

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Data/AssetManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Data/AssetManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Data/AssetManager'] = exports; 
var __dirname = 'NGGo/Service/Data';
var __filename = 'NGGo/Service/Data/AssetManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core        = require('NGCore/Client/Core').Core;
 var ServerSync  = require('NGGo/Service/Data/ServerSync').ServerSync;

////////////////////////////////////////////////////////////////////////////////
exports.AssetManager = ServerSync.singleton(
/** @lends Service.Data.AssetManager.prototype */
{
    classname: "AssetManager",
    /**
     * @class The <code>AssetManager</code> will allow developers to abstract out the actual named asset from the intent of what the asset is.
     * <br><br>
     * The benefits of such a system is it allows artist/producers to swap out assets as they become
     * available without having to go back and modify code.
     * <br><br>
     * It can also allow developers to make many keys that all point to the same assets and producers
     * can later decide if they do infact need a new custom asset or just reuse a preexisting one.
     * <br><br>
     * All entries are consisit of following objects:<br>
     * <pre class="code">
     * { asset : "", info : null };
     * </pre>
     * <code>setAssetForKey()</code> and <code>getAssetForKey()</code> access <code>asset</code> part of this
     * entry, and <code>setInfoForKey()</code> and <code>getInfoForKey()</code> access <code>info</code> part
     * of one.
     * @example
     * var sound = AssetManager.getAssetForKey("explosion");
     * if(effect) {
     *     var effect = new Audio.Effect(sound);
     *     var activeEffect = new Audio.ActiveEffect(effect);
     *     activeEffect.play();
     * }
     * @constructs Constructor for the class
     * @name Service.Data.AssetManager
     * @augments Core.Class
     */
    initialize : function()
    {
        this.mAssetCount = 0;
        this.mAssetMap = {};
        this.mEmptyEntry = { asset : "", info : null };
        this.setNotifyKey("onAssetManagerLoadComplete");
    },

    /**
     * Resets the Asset manager and unloads any assets.
     */
    reset : function()
    {
        // Remove all the dynamic methods
        this.__flushAssetMap();
    },

    /**
     * Loads the configuration from a flat file.
     * @param {String} fileName File name.
     * @param {Object} environment Environment object which as "os", "size", "device" parameter.
     * @param {Function} [callback] Callback function.
     */
    /**
     * Loads the configuration from a data set.
     * @param {String} jsonData Which should be JSON data.
     * @param {Object} environment Environment object which as "os", "size", "device" parameter.
     * @returns {Foundation.NGGOError} Error object
     */
    /**
     * Gets an actual asset string from a key name defined in the config.
     * @param {String} key Name for the asset entry.
     * @returns {String} String of the actual asset requested.
     */
    getAssetForKey : function(key)
    {
        var entry = this.mAssetMap[key] || this.mEmptyEntry;
        entry.wasRequested = true;
        return entry.asset;
    },

    /**
     * Sets the asset instance for a given key.
     *
     * If you are changing the node it will go though and reattach the children nodes.
     * @param {String} key Name for the asset entry. If key does not exits then nothing is set.
     * @param {String} asset Actual asset access string.
     */
    setAssetForKey : function(key, asset)
    {
        if(this.mAssetMap[key])
        {
            this.mAssetMap[key].asset = asset;
        }
        if(this['getAssetForKey' + key])
        {
            this['getAssetForKey' + key] = function(){ return asset; };
        }
    },

    /**
     * Returns infomation object.
     * @param {String} key Name for the information.
     * @returns {Object} Information for the assets.
     */
    getInfoForKey : function(key)
    {
        var entry = this.mAssetMap[key] || this.mEmptyEntry;
        return entry.info;
    },

    /**
     * Sets the info struct for a given key.
     * @param {String} key Name for the information.
     * @param {Object} info Information for the assets.
     */
    setInfoForKey : function(key, info)
    {
        if(this.mAssetMap[key])
        {
            this.mAssetMap[key].info = info;
        }

        if(this['getInfoForKey' + key])
        {
            this['getInfoForKey' + key] = function(){ return info; };
        }
    },

    /**
     * As the game runs each time a call to getAssetForKey (or it's dynamically generated version)
     * is called it will log that call. The dumpTrackingMap will list each key that was requested,
     * the actual asset that was returned.
     * @returns {Object} String of json data.
     */
    dumpTrackingMap : function()
    {
        var track = {};
        // We will give the following info
        // 1) Keys Requested
        // 2) Keys Unrequested
        // 3) Assets Returned
        // 4) Assets Unused
        track.keys = {};
        track.keys.dirty = [];
        track.keys.clean = [];

        // Lets iterate over all the keys and see what we got
        var cleanAssets = {};
        var dirtyAssets = {};
        var key;
        for(key in this.mAssetMap)
        {
            if(this.mAssetMap.hasOwnProperty(key))
            {
                if(this.mAssetMap[key].wasRequested)
                {
                    track.keys.dirty.push(key);
                    dirtyAssets[this.mAssetMap[key].asset] = 1;
                }
                else
                {
                    track.keys.clean.push(key);
                    cleanAssets[this.mAssetMap[key].asset] = 1;
                }
            }
        }

        track.assets = {};
        track.assets.dirty = [];
        track.assets.clean = [];

        // Now lets build out the assets list
        var ckey;
        for(ckey in cleanAssets)
        {
            if(cleanAssets.hasOwnProperty(ckey))
            {
                track.assets.clean.push(ckey);
            }
        }
        var dkey;
        for(dkey in dirtyAssets)
        {
            if(dirtyAssets.hasOwnProperty(dkey))
            {
                track.assets.dirty.push(dkey);
            }
        }
        return track;
    },

    /**
     * Returns the total number of JSON assets.
     * @returns {Number} Number of JSON assets.
     */
    getAssetCount : function()
    {
        return this.mAssetCount;
    },

    /** @private */
    __flushAssetMap : function()
    {
        var key;
        for(key in this.mAssetMap)
        {
            if(this.mAssetMap.hasOwnProperty(key))
            {
                if(this['getAssetForKey' + key])
                {
                    delete this['getAssetForKey' + key];
                }
                if(this['setAssetForKey' + key])
                {
                    delete this['setAssetForKey' + key];
                }
                if(this['getInfoForKey' + key])
                {
                    delete this['getInfoForKey' + key];
                }
                if(this['setInfoForKey' + key])
                {
                    delete this['setInfoForKey' + key];
                }
            }
        }

        this.mAssetMap = {};
        this.mAssetCount = 0;
    },

    /** @private */
    __createAssetKeyPair : function(asset, key)
    {
        // If the key does not already exists .. create it
        this.mAssetMap[key] = this.mAssetMap[key] || {};

        // Now set the asset for the key
        this.mAssetMap[key].asset = asset;

        // Cache of the object for faster access with the set method
        var mapObj = this.mAssetMap[key];
        var self = this;

        // Create dynamic api
        this['getAssetForKey' + key] = function(){ mapObj.wasRequested = true; return asset; };
        this['setAssetForKey' + key] = function(newAsset)
        {
            self['getAssetForKey' + key] = function(){ return newAsset; };
            mapObj.asset = newAsset;
        };

        // Increment the count
        ++this.mAssetCount;
    },

    /** @private */
    __createInfoKeyPair : function(info, key)
    {
        // If the key does not already exists .. create it
        this.mAssetMap[key] = this.mAssetMap[key] || {};

        // Now set the asset for the key
        this.mAssetMap[key].info = info;

        // Cache of the object for faster access with the set method
        var mapObj = this.mAssetMap[key];
        var self = this;

        // Create dynamic api
        this['getInfoForKey' + key] = function(){ return info; };
        this['setInfoForKey' + key] = function(newInfo)
        {
            self['getInfoForKey' + key] = function(){ return newInfo; };
            mapObj.info = newInfo;
        };
    },

    /** @private */
    __onLoadData : function(data, environment)
    {
        this.__flushAssetMap();
        var screenSize = Core.Capabilities.getScreenWidth().toString() + "x"
            + Core.Capabilities.getScreenHeight().toString();
        environment = environment || { os : Core.Capabilities.getPlatformOS(), size : screenSize, device : Core.Capabilities.getDeviceName() };

        console.log("ENVIRONMENT = " + environment.os + ", " + environment.size + ", " + environment.device);

        var prop;
        // Lets walk the data file
        for(prop in data)
        {
            if(data.hasOwnProperty(prop))
            {
                var useGeneric = true;

                if(data[prop][environment.os])
                {
                    // We have the environment defined
                    var dataAtEnv = data[prop][environment.os];
                    if(dataAtEnv.device &&
                            dataAtEnv.device[environment.device] &&
                            dataAtEnv.device[environment.device].asset)
                    {
                        // we know the device so load it up
                        useGeneric = false;
                        this.__createAssetKeyPair(dataAtEnv.device[environment.device].asset, prop);
                        if(dataAtEnv.device[environment.device].info)
                        {
                            this.__createInfoKeyPair(dataAtEnv.device[environment.device].info, prop);
                        }
                    }
                    else if(dataAtEnv.size &&
                            dataAtEnv.size[environment.size] &&
                            dataAtEnv.size[environment.size].asset)
                    {
                        // We have a defined screen size
                        useGeneric = false;
                        this.__createAssetKeyPair(dataAtEnv.size[environment.size].asset, prop);
                        if(dataAtEnv.size[environment.size].info)
                        {
                            this.__createInfoKeyPair(dataAtEnv.size[environment.size].info, prop);
                        }
                    }
                    if(useGeneric && dataAtEnv.def && dataAtEnv.def.asset)
                    {
                        useGeneric = false;
                        // Load the default for the os type
                        this.__createAssetKeyPair(dataAtEnv.def.asset, prop);
                        if(dataAtEnv.def.info)
                        {
                            this.__createInfoKeyPair(dataAtEnv.def.info, prop);
                        }
                    }
                }

                if(useGeneric && data[prop].generic)
                {
                    var useDefault = true;
                    // Check to see if we defined the size struct for this
                    if( data[prop].generic.size &&
                        data[prop].generic.size[environment.size] &&
                        data[prop].generic.size[environment.size].asset)
                    {
                        this.__createAssetKeyPair(data[prop].generic.size[environment.size].asset, prop);
                        if(data[prop].generic.size[environment.size].info)
                        {
                            this.__createInfoKeyPair(data[prop].generic.size[environment.size].info, prop);
                        }
                        // Do we have a prop for the generic?  If so use it
                        else if(data[prop].generic.def && data[prop].generic.def.info)
                        {
                            this.__createInfoKeyPair(data[prop].generic.def.info, prop);
                        }
                    }
                    else if(useDefault && data[prop].generic.def && data[prop].generic.def.asset)
                    {
                        // We have a generic asset
                        this.__createAssetKeyPair(data[prop].generic.def.asset, prop);
                        if(data[prop].generic.def.info)
                        {
                            this.__createInfoKeyPair(data[prop].generic.def.info, prop);
                        }
                    }
                }
            }
        }
    },
    loadConfigFromAsset: function() {
        throw new Error("AssetManager doesn't support loadConfigFromAsset()");
    }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Display/SceneManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Display/SceneManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Display/SceneManager'] = exports; 
var __dirname = 'NGGo/Service/Display';
var __filename = 'NGGo/Service/Display/SceneManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core       = require('NGCore/Client/Core').Core;
var GL2        = require('NGCore/Client/GL2').GL2;
var Storage    = require('NGCore/Client/Storage').Storage;
var ServerSync = require('NGGo/Service/Data/ServerSync').ServerSync;
var NGGOError  = require('NGGo/Foundation/NGGOError').NGGOError;

////////////////////////////////////////////////////////////////////////////////

exports.SceneManager = ServerSync.singleton(
/** @lends Service.Display.SceneManager.prototype */
{
    classname: "SceneManager",
    /**
     * Error code of <code>ServerSync</code> class.
     * @namespace ERROR
     */
    ERROR:
    {
        DUPLICATE_KEYS: 1
    },
    /**
     * @class The <code>SceneManager</code> is a wrapper over the basic skeleton
     * of the Scene Graph to allow for quick data driven setup.
     * <br><br>
     * The SceneManager is a singleton object that will manage the basic
     * skeleton of the scene graph hierarchy. The SceneManager will provide
     * the main access point for game code to read, modify and add objects
     * to the scene.
     * <br><br>
     * Many examples of games use a much more complex
     * Scene Graph then the ngCore samples provide, and this system
     * will allow users to get a complex scene with UI, and game
     * objects up and rendering quickly.
     * @name Service.Display.SceneManager
     * @constructs
     * @augments Core.Class
     */
    initialize : function()
    {
        this.mNodes = {};
        this.mSceneData = {};
        this.mNodes.GL2_ROOT = GL2.Root;
    },

    /**
     * Loads the configuration from a flat file
     * @param {String} filename File name.
     * @param {GL2.Node} parent Parent node of this scene.
     * @param {Function} callback Callback function it is called when the loading is finished.
     * @name Service.Display.SceneManager.loadConfigFromFile
     */
    /**
     * Loads the configuration from a data set.
     * @param {String} jsonData Which should be JSON data
     * @param {GL2.Node} parent Parent node of this scene.
     * @returns {Service.Display.SceneManager.error} Error code.
     * @name Service.Display.SceneManager.loadConfigFromData
     */
    /**
     * Loads the configuration using the asset manager.
     * @param {String} assetKey
     * @param {GL2.Node} parent Parent node of this scene.
     * @param {Function} callback Callback function it is called when the loading is finished.
     * @name Service.Display.SceneManager.loadConfigFromAsset
     */
    /**
     * Gets a node from a key name defined in the config
     * @param {String} key Name for the Node
     * @returns {GL2.Node} Instance or <code>undefined</code> if no node for that key
     */
    getNodeForKey : function(key)
    {
        return this.mNodes[key];
    },

    /**
     * adds a node to the manager.
     * <br><br>
     * Notes about this method:
     * <ul>
     * <li>No dynamic API will be generated when using this call
     * <li>Duplicate node can be inserted but this can causes errors so be careful
     * <li>You can not add the GL2 Root to the manager.  It is already there with the key "GL2_ROOT" if you need it
     * </ul>
     * <br><br>
     * It is HIGHLY recommended that you define all your nodes inside a JSON data file
     * and NOT use this method, but if needed it is provided
     * @param {String} key Name for the GL2.Node. If key does exits then nothing is set.
     * @param {GL2.Node} node to be accessed for the key
     */
    addNodeForKey : function(key, node)
    {
        if(!this.mNodes[key] && node !== GL2.Root)
        {
            this.mNodes[key] = node;
        }
    },

    /**
     * Sets the node instance for a given key.
     * <br><br>
     * If you are changing the node it will go though and reattach the children nodes  <br><br>
     * This will do the following
     * <ul>
     * <li>Insert the new node.</li>
     * <li>Detach the old node.</li>
     * <li>Copy all children from the old node into the new node.</li>
     * <li>Release the old node.</li>
     * </ul>
     * @param {String} key Name for the GL2.Node. If key does not exits then nothing is set.
     * @param {GL2.Node} node New node object it is used instead of current node.
     */
    replaceNodeForKey : function(key, node)
    {
        if(node !== GL2.Root && this.mNodes[key] && this.mNodes[key] !== GL2.Root)
        {
            this._replaceNode(this.mNodes[key], node, key);
        }
    },

    /**
     * Inserts a node infront of the given node.
     * <br><br>
     * When a node is "inserted" it will add it above the node that it was given and insert the old node as a child.
     * <br><br>
     * For example assume you have a node structure that looks like:<br>
     * <pre class="code">
     *     A <-- B <-- C
     * </pre> where B is the parent of C an A is the
     * parent of A.  If you call insertNodeForKey(node, "B", "new") the graph will now look
     * like:<br>
     * <pre class="code">
     *     A <-- node(new) <-- B <-- C.
     * </pre>
     * @param {GL2.Node} node <code>GL2.Node</code> object to insert.
     * @param {String} key Name for the old node to be replaced.
     * @param {String} nodeKey Name for the new node.
     */
    insertNodeForKey : function(key, node, nodeKey)
    {
        if(node !== GL2.Root && this.mNodes[key] && this.mNodes[key] !== GL2.Root)
        {
            this._insertNode(key, this.mNodes[key], nodeKey, node);
        }
    },

    /**
     * Resets the SceneManager to it's "Initalized" state.
     * <br><br>
     * <b>NOTE:</b> This does NOT reset your scene graph nodes.  It just clears out the
     * "managed" nodes by the scene manager.  This was done so people can insert
     * nodes into SceneManager if later the reset the manager they will not lose
     * their node hierachy.
     */
    reset : function()
    {
        var key;
        for(key in this.mNodes)
        {
            if(this.mNodes.hasOwnProperty(key))
            {
                if(this['insertNode' + key])
                {
                    delete this['insertNode' + key];
                }

                if(this['replaceNode' + key])
                {
                    delete this['settNode' + key];
                }

                if(this['getNode' + key])
                {
                    delete this['getNode' + key];
                }
            }
        }


        this.mNodes = {};
        this.mSceneData = {};
        this.mNodes.GL2_Root = GL2.Root;

        this.notify("onReset", this);
    },

    /**
     * @private
     * Replaces a node in the graph.  WARNING!!!
     * this method uses privates from the node class.
     */
    _replaceNode : function(oldNode, newNode, key)
    {
        if (key === "GL2_ROOT" || oldNode === GL2.Root || newNode === GL2.Root)
        {
            throw new Error ("All set operations with the GL2 Root node are invalid");
        }
        else
        {
            // Step 1 detach node from it's parent
            var p = oldNode.getParent();
            p.removeChild(oldNode);
            p.addChild(newNode);

            var children = [];
            var oldNodeChildLen = oldNode._children;
            var idx = 0;

            for(idx = 0; idx < oldNodeChildren; ++ idx)
            {
                children.push(oldNode._children[idx]);
            }

            for(idx = 0; idx < oldNodeChildren; ++ idx)
            {
                oldNode.removeChild(children[idx]);
                newNode.addChild(children[idx]);
            }

            // Repare the dynamic functions if they exists
            if(this['getNode' + key])
            {
                this['getNode' + key] = function(){ return newNode; };
                this['getNode' + key].node = newNode;
            }

            if(this['replaceNode' + key])
            {
                this['replaceNode' + key].node = newNode;
            }


            this.notify("onNodeReplaced", key);
        }
    },
    /**
     * @private
     */
    _insertNode : function(key, oldNode, newKey, newNode)
    {
        if (key === "GL2_ROOT" || oldNode === GL2.Root || newNode === GL2.Root)
        {
            throw new Error ("All insert operations with the GL2 Root node are invalid");
        }
        else
        {
            // Add this node to the map
            this.mNodes[newKey] = newNode;
            var p = oldNode.getParent();
            p.removeChild(oldNode);
            p.addChild(newNode);
            newNode.addChild(oldNode);
            this.notify("onNodeInserted", key);
        }
    },

    /**
     * @private
     * Parse the objects local scene data and sets it up for usage
     * if the system has already been loaded then it will unload
     * all the information and then reload the framework
     */
    __onLoadData : function(data, parent)
    {
        this.mSceneData = data;
        if (parent === undefined) {
            parent = GL2.Root;
        }
        var error;
        var prop;
        for(prop in data)
        {
            if(data.hasOwnProperty(prop))
            {
                error = this._loadNode(prop, data[prop], parent);
                if (error) {
                    return error;
                }
            }
        }
    },

    /**
     * @private
     * Parse the objects local scene data and sets it up for usage
     * if the system has already been loaded then it will unload
     * all the information and then reload the framework
     */
    _loadNode : function(nodeName, nodeData, parent)
    {
        var self = this;

        if(this.mNodes[nodeName])
        {
            // OPPS, you should not have done this...
            return new NGGOError(this.ERROR.DUPLICATE_KEYS,
                                 self.classname + ": node name '"
                                 + nodeName + "' is duplicated.");
        }

        // Step 1) create the new node
        var node = new GL2.Node();
        this.mNodes[nodeName] = node;
        parent.addChild(node);

        // Step 2) Create accessor methods
        nodeData.accessor = nodeData.accessor || "read";
        if(nodeData.accessor)
        {
            // flags
            var readFlag = nodeData.accessor === "read" || nodeData.accessor === "readonly" || nodeData.accessor === "readwrite" || nodeData.accessor === "readwriteonly";
            var writeFlag = nodeData.accessor === "write" || nodeData.accessor === "writeonly" || nodeData.accessor === "readwrite" || nodeData.accessor === "readwriteonly";
            var insertFlag = nodeData.accessor !== "readonly" && nodeData.accessor !== "writeonly" && nodeData.accessor !== "none" && nodeData.accessor !== "readwriteonly";

            if(readFlag)
            {
                this['getNode' + nodeName] = function(){ return node; };
                this['getNode' + nodeName].node = node;
            }

            if(writeFlag)
            {
                this['replaceNode' + nodeName] = function(newNode)
                {
                    self._replaceNode(node, newNode, nodeName);
                };
                this['replaceNode' + nodeName].node = node;
            }

            if(insertFlag)
            {
                this['insertNode' + nodeName] = function(newNode)
                {
                    self._insertNode(node, newNode, nodeName);
                };
                this['insertNode' + nodeName].node = node;
            }
        }

        // Step 3) Manage the depth value of the node
        nodeData.depth = nodeData.depth || 0;
        node.setDepth(nodeData.depth);

        // Step 4) Set the ChildrenDepthGrouped value
        if(node.childrenDepthGrouped === false)
        {
            node.setChildrenDepthGrouped(false);
        }

        // Step 5) Process any children nodes
        var prop;
        for(prop in nodeData.children)
        {
            if(nodeData.children.hasOwnProperty(prop))
            {
                // This should be a valid guy
                this._loadNode(prop, nodeData.children[prop], node);
            }
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/AnimationManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/AnimationManager'] || {}; $MODULE_REGISTRY['NGGo/Framework/AnimationManager'] = exports; 
var __dirname = 'NGGo/Framework';
var __filename = 'NGGo/Framework/AnimationManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class     = require('NGCore/Client/Core/Class').Class;
var GL2     = require('NGCore/Client/GL2').GL2;
var Storage = require('NGCore/Client/Storage').Storage;
var NGGOError = require('NGGo/Foundation/NGGOError').NGGOError;

////////////////////////////////////////////////////////////////////////////////

exports.AnimationManager = Class.singleton(
/** @lends Framework.AnimationManager.prototype */
{
    /**
     * Error code of <code>AnimationManager</code> class.
     * @namespace ERROR
     */
    ERROR:
    {
        INVALID_TYPE: 1,
        INVALID_PATH: 2,
        FILE_READ_ERROR: 3,
        NETWORK_ERROR: 4,
        ASSET_NOT_FOUND: 5,
        FILE_NOT_FOUND: 404,
        PARSE_ERROR: 10
    },
    /**
     * @class The <code>AnimationManager</code> is the main “Gateway” object for constructing and playing animations.
     * <br><br>
     * The animation manager has the following properties:
     * <ul>
     * <li>Factory object for the AnimationController objects.</li>
     * <li>Monitors and manages the cache of “loaded” animations.</li>
     * <li>Manages the animation definitions that can be used by the system.</li>
     * </ul>
     * @constructs Constructor for the the object
     * @param {Array} sourceArray Array of objects defined as { src : {gl2.node}, name : {string} }
     * @param {Object} observer Object that will get the callbacks for the system
     * @name Framework.AnimationManager
     * @augments Core.Class
     */
    initialize : function()
    {
        //var gAnimationsCachedByProtoId = [];
        //var gAnimationsByNameCachedByProtoId = [];
        this.mAnimationMap = null;
        this.mAnimationMeta = null;

        this.mCacheSize = 0;
        this.mMaxCacheSize = -1;
        this.mAnimationCache = {};
        this.mAtlasRoot = "Content";
    },

    /**
     * Setter method for the content root the manager will use to fish out the sprite sheets.
     * @param {String} root Content root data.
     */
    setContentRoot : function(root)
    {
        this.mAtlasRoot = root;
    },

    /**
     * Loads the configuration from a flat file.
     * <br><br>
     * First parameter of callback function is error.
     * @param {String} animationFile The animation map file name.
     * @param {Function} [callback] Callback faunction it is called when loading is finished.
     */
    loadConfigFromFile : function(animationFile, callback)
    {
        // Read the animation file
        var fs = Storage.FileSystem;
        var self = this;
        var error;
        callback = callback || function() {};
        fs.readFile(animationFile, function(err, data)
        {
            if(err)
            {
                // We could not read the given animation file
                console.log("[ngGo AnimationManager: loadConfigFromFile] " +
                            "could not read the main animation file");
                error = new NGGOError(this.ERROR.INVALID_PATH,
                                      "AnimationManager: Error occured when reading "
                                       + animationFile);
                callback(error);
            }
            else
            {
                var parseSuccess = true;
                var configFiles = null;
                // Parse the json data
                try
                {
                    configFiles = JSON.parse(data);
                }
                catch(ex)
                {
                    parseSuccess = false;
                    console.log("[ngGo AnimationManager: loadConfigFromFile] " +
                                "Could not parse the main json data");
                    error = new NGGOError(this.ERROR.PARSE_ERROR,
                                         "AnimationManager: JSON Parse error in, "
                                         + animationFile + "  " + ex);
                    callback(error);
                }

                if(parseSuccess)
                {
                    if(configFiles.data)
                    {
                        // 1) Load the animation file
                        fs.readFile(configFiles.data, function(err2, dataData)
                        {
                            if(err2)
                            {
                                console.log("[ngGo AnimationManager: loadConfigFromFile] " +
                                            "could not read the animation definition file: " +
                                            configFiles.data);
                                error = new NGGOError(this.ERROR.INVALID_PATH,
                                          "AnimationManager: Error occured when reading "
                                          + configFiles.data);
                                callback(error);
                            }
                            else
                            {
                                // So the meta info is optional BUT if it is defined
                                // it must be valid!!!
                                if(configFiles.meta)
                                {
                                    fs.readFile(configFiles.meta, function(err3, dataMeta)
                                    {
                                        if(err3)
                                        {
                                            console.log("[ngGo AnimationManager: loadConfigFromFile] " +
                                                        "could not read the animation meta file: " +
                                                        configFiles.meta);
                                            error = new NGGOError(this.ERROR.INVALID_PATH,
                                              "AnimationManager: Error occured when"
                                              + " reading " + configFiles.meta);
                                            callback(error);
                                        }
                                        else
                                        {
                                            error = self.loadConfigFromData(dataData, dataMeta);
                                            callback(error);
                                        }
                                    });
                                }
                                else
                                {
                                    error = self.loadConfigFromData(dataData);
                                    callback(error);
                                }
                            }
                        });
                    }
                    else
                    {
                        console.log("[ngGo AnimationManager: loadConfigFromFile] " +
                                    "No data defined.");
                        error = new NGGOError(this.ERROR.NO_DATA_ERROR,
                                  "AnimationManager: No data is in "
                                  + animationFile);
                        callback(error);
                    }
                }
            }
        });
    },

    /**
     * Loads the configuration from a data set.
     * @param {String} animData JSON data which should be JSON data.
     * @param {String} metaData JSON data for the meta information.
     * @returns {Number} Error code (0:ok 1:error)
     */
    loadConfigFromData : function(animData, metaData)
    {
        var error;
        try
        {
            this.mAnimationMap = JSON.parse(animData);
        }
        catch(err)
        {
            // We hit an error parse on the json.  This is bad
            console.log("[ngGo AnimationManager: loadConfigFromData] " +
                        "could not parse the animation map json");
            error = new NGGOError(this.ERROR.NO_DATA_ERROR,
                      "AnimationManager: Could not parse the animation map json");
        }

        if(!error)
        {
            if(metaData)
            {
                try
                {
                    this.mAnimationMeta = JSON.parse(metaData);
                }
                catch(err2)
                {
                    // We hit an error parse on the json.  This is bad
                    console.log("[ngGo AnimationManager: loadConfigFromData] " +
                                "could not parse the animation meta json");
                    error = new NGGOError(this.ERROR.NO_DATA_ERROR,
                               "AnimationManager: Could not parse the animation meta json");
                }
            }
        }
        return error;
    },

    /**
     * Resets the AnimationManager and all its data
     */
    reset : function()
    {
        this.mAnimationMap = null;
    },

    /**
     * Accessor for the animation map data
     * @returns {Object} animation map used by the system
     */
    getAnimationMap : function()
    {
        return this.mAnimationMap;
    },

    /**
     * Gets the number of frames for a given group/animation.
     * @param {String} group Group name.
     * @param {String} animation Animation name.
     * @returns {Number} If invalid name or anim -1 is returned otherwise the count it returned.
     */
    getFrameCount : function(group, animation)
    {
        var count = -1;
        if(this.mAnimationMap)
        {
            var groupObj = this.mAnimationMap.atlas[group];
            if(groupObj && groupObj.type)
            {
                var anim = groupObj.type[animation];
                if(anim)
                {
                    count = anim.length;
                }
            }
        }
        return count;
    },

    /**
     * Returns the list of frameData for a given group and animation.
     * @param {String} group Group name.
     * @param {String} animation Animation name.
     * @returns {Array} List of frameData. If it not found, returns <code>null</code>
     */
    getFrameData : function(group, animation)
    {
        var frames = null;
        if(this.mAnimationMap)
        {
            var groupObj = this.mAnimationMap.atlas[group];
            if(groupObj && groupObj.type)
            {
                frames = groupObj.type[animation];
            }
        }
        return frames;
    },

    /**
     * Constructs GL2.Animation class from sprite atlas.
     * @param {String} group Group name.
     * @param {String} animation Animation name.
     * @returns {GL2.Sprite}
     */
    getAnimationGL2 : function(group, animationDef, frameDuration)
    {
        var  animation = null;
        if(this.mAnimationMap)
        {
            var groupObj = this.mAnimationMap.atlas[group];
            if(groupObj && groupObj.type)
            {
                var frames = groupObj.type[animationDef];
                if(frames)
                {
                    var cacheAnim = this._getCachedAnimation(group, animationDef);
                    if(cacheAnim)
                    {
                        animation = cacheAnim;
                    }
                    else
                    {
                        // Construct that animation from the given name...
                        animation = this._loadAnimation(group, animationDef, frames, groupObj.meta.asset, groupObj.meta.size, null, frameDuration);
                    }
                }
            }
        }
        return animation;
    },
    /**
     * Accessor to the motion data defined in JSON
     * @param {String} motionName Motion name.
     * @returns         Returns the raw json object or null if motion does not exists.
     *                  Currently the caller must check for null and parse the data.
     *                  The class {MotionController} does this already and is suggested
     *                  for use.
     */
    getMotionData : function(motionName)
    {
        var motion = null;

        if( this.mAnimationMap &&
            this.mAnimationMap.motions &&
            this.mAnimationMap.motions[motionName])
        {
            motion = this.mAnimationMap.motions[motionName];
        }

        return motion;
    },

    /** @private */
    _getCachedAnimation : function(group, animationDef)
    {
        var anim = null;
        if(this.mAnimationCache && this.mAnimationCache[group])
        {
            anim = this.mAnimationCache[group][animationDef];
        }
        return anim;
    },

    /** @private */
    _loadAnimation : function(group, animationName, animationFrames, spriteSheetAsset, spriteSheetSize, animationMeta, frameDuration)
    {
        // Check the arguments
        var animLen = animationFrames.length;

        // Default we will assume 10fps of animation per second
        // I should really document this somewhere....
        var frameDelay = frameDuration;

        var animation = new GL2.Animation();
        var idx;
        for(idx = 0; idx < animLen; ++idx)
        {
            var frame = animationFrames[idx];
            // It is possible you may have some null values.  These SHOULD have been
            // caught by the mapping tools but just in case they were not it doesn't
            // hurt to pull a little check... just a little on....
            if(frame)
            {
                var uvOne = ((frame.loc[0]*1.0)/(spriteSheetSize[0]*1.0));
                var uvTwo = ((frame.loc[1]*1.0)/(spriteSheetSize[1]*1.0));
                var uvThree = (frame.loc[0]*1.0+frame.size[0]*1.0)/(spriteSheetSize[0]* 1.0);
                var uvFour = (((frame.loc[1]*1.0)+(frame.size[1]*1.0))/(spriteSheetSize[1]*1.0));
                var width = frame.size[0]*1.0;
                var height = frame.size[1]*1.0;

                var xOff = 0.5 - (frame.off[0]*1.0)/(frame.size[0]);
                var yOff = 0.5 + (frame.off[1]*1.0)/(frame.size[1]);

                var uvs;
                if(frame.rot)
                {
                    console.log("[ngGo AnimationManager: _loadAnimation] " +
                        "The sprite sheet containes rotated sprites and ngCore currently does not allow this.\n"+
                        "Please change your data associated with sprite sheet: " + spriteSheetAsset);

                }
                uvs = [uvOne, uvTwo, uvThree - uvOne, uvFour - uvTwo];

                var gl2Frame = new GL2.Animation.Frame(this.mAtlasRoot + '/' + spriteSheetAsset,
                                                    frameDelay,
                                                    [width, height],
                                                    [xOff, yOff],
                                                    uvs);
                animation.pushFrame(gl2Frame);
            }
        }

        // Now lets store this guy into the cache
        if(this.mCacheSize < this.mMaxCacheSize || -1 === this.mMaxCacheSize)
        {
            if(!this.mAnimationCache[group])
            {
                this.mAnimationCache[group] = {};
            }

            this.mAnimationCache[group][animationName] = animation;
            ++this.mCacheSize;
        }

        return animation;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Display/CameraManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Display/CameraManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Display/CameraManager'] = exports; 
var __dirname = 'NGGo/Service/Display';
var __filename = 'NGGo/Service/Display/CameraManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Storage     = require('NGCore/Client/Storage').Storage;
var Network     = require('NGCore/Client/Network').Network;
var ServerSync  = require('NGGo/Service/Data/ServerSync').ServerSync;

var CameraManager = ServerSync.singleton(
/** @lends Service.Display.CameraManager.prototype */
{
    classname: "CameraManager",
    /**
     * Error code of <code>CameraManager</code> class.
     * @namespace error
     */
    error:
    {
        /** */
        ERROR_NONE : 0,
        /** */
        ERROR_ARGUMENTS : 1,
        /** */
        ERROR_JSON_PARSE : 2,
        /** */
        ERROR_JSON_FORMAT : 3,
        /** */
        ERROR_ASSET_NOT_FOUND : 4
    },
    /**
     * @class <code>CameraManager</code> handles all the tuning value types available for {@link Service.Display.Camera}.
     * @borrows Foundation.Observable#addObserver
     * @borrows Foundation.Observable#deleteObserver
     * @borrows Foundation.Observable#deleteObservers
     * @borrows Foundation.Observable#countObservers
     * @borrows Foundation.Observable#notify
     * @constructs This is singleton class.
     * @name Service.Display.CameraManager
     * @augments Core.Class
     */
    initialize : function()
    {
        this._tunables = {};
        this._loadDefaultTunableValues();
        this.setNotifyKey("onCameraTunablesUpdated");
    },
    /**
     * Returns the tunable set for a given key.
     *
     * @param {String} key Name to get the tunable set for.
     * @returns {Object} Camera Tunable values.
     */
    getTunableValuesForKey : function(key)
    {
        return this._tunables[key];
    },

    /** @private */
    __onLoadData : function(data)
    {
        for(key in data)
        {
            if(data.hasOwnProperty(key))
            {
                this._tunables[key] = data[key];
            }
        }
    },
    /** @private */
    _loadDefaultTunableValues : function()
    {
        // Setup the generic tunables table
        this._tunables.__generic = {};
        this._tunables.__generic.camera_zoom_in = 1.55;
        this._tunables.__generic.camera_zoom_out = 1.0;
        this._tunables.__generic.camera_double_tap_dist = 64;
        this._tunables.__generic.camera_double_tap_time = 400;
        this._tunables.__generic.camera_zoom_time = 0.3;
        this._tunables.__generic.camera_boarder_stretch_top = 0.1;
        this._tunables.__generic.camera_boarder_stretch_side = 0.1;
        this._tunables.__generic.camera_velocity_friction = 0.85;
        this._tunables.__generic.camera_delta_friction = 0.2;
        this._tunables.__generic.camera_snap_decay = 0.6;
        this._tunables.__generic.camera_max_velocity = 40;
        this._tunables.__generic.camera_friction = 0.875;
        this._tunables.__generic.camera_starting_zoom = 1.0;
        this._tunables.__generic.camera_soft_velocity_friction = 0.8;
        this._tunables.__generic.camera_soft_velocity_rebound_friction = 1.6;
    }
});

exports.CameraManager = CameraManager;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Display/ScreenManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Display/ScreenManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Display/ScreenManager'] = exports; 
var __dirname = 'NGGo/Service/Display';
var __filename = 'NGGo/Service/Display/ScreenManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class        = require('NGCore/Client/Core/Class').Class;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');

var ServerSync   = require('NGGo/Service/Data/ServerSync').ServerSync;

var Origin =
{
    Offset: 1,
    Center: 2
};

var LetterBoxType =
{
    GL2: 0,
    UI: 1
};

var Rect = ViewGeometry.Rect.subclass(
/** @lends Service.Display.ScreenManager.Rect.prototype */
{
    classname: 'Rect',
    /**
     * @class This class is compatible class of <code>UI.ViewGeometry.Rect</code>, but it can handle scaling and offset of logical screen.
     * @constructs
     * @augments UI.ViewGeometry.Rect
     * @name Service.Display.ScreenManager.Rect
     */
    initialize: function($super, arg0, offset, scale)
    {
        $super(arg0);
        if(arg0 instanceof Rect)
        {
            this._offset = arg0._offset;
            this._scale = arg0._scale;
        }
        else
        {
            this._offset = offset;
            this._scale = scale;
        }
    },
    /**
     * Retuns Array which includes converted parameter of x, y, h, z.
     * @returns {Number[]} Converted coordinate array.
     */
    array: function()
    {
        var offsetX = this._offset[0];
        var offsetY = this._offset[1];
        var scale = this._scale;
        return [this.x * scale + offsetX, this.y * scale + offsetY, this.w * scale, this.h * scale];
    }
});

exports.Rect = Rect;

var ScreenSetting = Class.subclass(
/** @lends Service.Display.ScreenManager.ScreenSetting.prototype */
{
    classname: 'ScreenSetting',
    /**
     * @class This class is a base class of following setting classes:
     * <ul>
     * <li><b>-</b> <code>LetterBoxSetting</code></li>
     * <li><b>-</b> <code>PanAndScanSetting</code></li>
     * <li><b>-</b> <code>FixSetting</code></li>
     * <li><b>-</b> <code>FixWidthSetting</code></li>
     * <li><b>-</b> <code>FixHeightSetting</code></li>
     * </ul>
     * These classes provide methods/properties of this class.
     * <br><br>
     * You can't create object directry. You can create by
     * <code>ScreenManager.register()</code> method and access via
     * <code>ScreenManager.settings</code> property. If you set one
     * setting as default, you can access this class's features via
     * <code>ScreenManager</code>'s methods/properties.
     * <pre class="code">
     * // Creates setting
     * ScreenManager.register({
     *     type:"LetterBox",
     *     name:"field",
     *     logicalSize:[480,320]
     * });
     * // Access via ScreenManager.settings
     * var pos = ScreenManager.settings.field.convert([100, 120]);
     * // Uses setDefault. Result is as same as above one.
     * ScreenManager.setDefault("field");
     * var pos2 = ScreenManager.convert([100, 120]);
     * </pre>
     * @property {Number[]} offset (readonly) Offset Returns offset of the logical origin point for physical screen.
     * <br><br>
     * If the setting type is not "LetterBox" or "PanAndScan",  it become [0, 0].
     * @property {String} name (readonly) Name of this setting.
     * @property {Number[]} logicalSize (readonly) Logical screen resolution of this setting.
     * @property {Number} scale (readonly) Scale value between the logical resolution and the physical resolution.
     * @property {Number[]} offset (readonly) Offset in physical resolution.
     * @constructs The default constructor.
     * @name Service.Display.ScreenManager.ScreenSetting
     * @augments Core.Class
     */
    initialize: function(screen, setting)
    {
        this._name = setting.name;
        var physicalSize = [screen.width, screen.height];
        this._logicalSize = setting.logicalSize || physicalSize;
        this._root = undefined;
        this._screen = screen;
        this._letterboxes = [];
    },
    get name()
    {
        return this._name;
    },
    set name(value)
    {
        throw new Error("name property is readonly");
    },
    get logicalSize()
    {
        return this._logicalSize;
    },
    set logicalSize(value)
    {
        throw new Error("logicalSize property is readonly");
    },
    get scale()
    {
        return this._scale;
    },
    set scale(value)
    {
        throw new Error("scale property is readonly");
    },
    get offset()
    {
        return this._offset;
    },
    set offset(value)
    {
        throw new Error("offset property is readonly");
    },
    /**
     * Creates root node for GL2. You don't have to convert all positions
     * if you add nodes as children of this. This node is set proper offset
     * and scale already.
     * <pre class="code">
     * // Create settings
     * ScreenManager.register({
     *     type: "LetterBox",
     *     name: "field",
     *     logicalSize: [800, 480]
     * });
     * ScreenManager.setDefault("field");
     * var screenRoot = ScreenManager.getRootNode();
     * GL2.Root.addChild(screenRoot);
     * // You don't have to convert coordinates!
     * screenRoot.addChild(background);
     * </pre>
     * @returns {GL2.Node} Root node for GL2 nodes.
     */
    getRootNode: function()
    {
        if (!this._root)
        {
            var Node = require('NGCore/Client/GL2/Node').Node;
            var Root = require('NGCore/Client/GL2/Root').Root;
            var root = this._root = new Node();
            root.setPosition(this._offset);
            root.setScale([this._scale, this._scale]);
        }
        return this._root;
    },
    /**
     * Converts one number with <code>scale</code>.
     * It is useful for UI.Label's text size or so on.
     * <pre class="code">
     * var textSize = Screen.settings.ui.convertNumber(10);
     * label.setTextSize(~~(textSize));
     * </pre>
     * @param {Number} number Input value for calulation.
     * @returns {Number} Converted value.
     */
    convertNumber: function(number)
    {
        return ~~(number * this._scale);
    },
    /**
     * Converts array which has 2 numbers with <code>scale</code>.
     * It is useful for position or size.
     * <br><br>
     * The origin point is changed if the second parameter is passed:<br><br>
     * <ul>
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager%23Origin.html#Offset">Origin.Offset</a></code>: Add offset value. It is good for root item in LetterBox and PanAndScan.
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager%23Origin.html#Center">Origin.Center</a></code>: Center of Screen become origin.
     * </ul>
     * If you pass the negative coordinate, the origin point moves opposite side.
     * <br><br>
     * <pre class="code">
     * var textSize = Screen.settings.ui.convertNumber(10);
     * label.setTextSize(~~(textSize));
     * </pre>
     * @param {Number[]} coordinate Input position
     * @returns {Number[]} Converted coordinate.
     */
    convert: function(coordinate, origin)
    {
        var offset, originX, originY;
        var scale = this._scale;
        var originEnum = Origin;
        if (!(coordinate instanceof Array))
        {
            var errorMsg = "Input of ScreenManager must be Array, but not: " + String(coordinate);
            console.log((new Error()).stack);
            console.log(errorMsg);
            throw new Error(errorMsg);
        }
        if (coordinate.length === 4)
        {
            var result = this.convert(coordinate.slice(0, 2), origin);
            result.push(this.convertNumber(coordinate[2]));
            result.push(this.convertNumber(coordinate[3]));
            return result;
        }
        var x = coordinate[0];
        var y = coordinate[1];
        switch(origin) {
        case originEnum.Center:
        case "center":
            originX = ~~(this.logicalSize[0] * scale * 0.5);
            originY = ~~(this.logicalSize[1] * scale * 0.5);
            break;
        case originEnum.Offset:
        case "offset":
            originX = this._offset[0];
            originY = this._offset[1];
            x = (x < 0) ? ~~(this.logicalSize[0] + x) : x;
            y = (y < 0) ? ~~(this.logicalSize[1] + y) : y;
            break;
        case originEnum.Center | originEnum.Offset:
        case "offset|center":
        case "center|offset":
            originX = ~~(this.logicalSize[0] * scale * 0.5) + this._offset[0];
            originY = ~~(this.logicalSize[1] * scale * 0.5) + this._offset[1];
            break;
        default:
            originX = 0;
            originY = 0;
            x = (x < 0) ? this.logicalSize[0] + x : x;
            y = (y < 0) ? this.logicalSize[1] + y : y;
            break;
        }
        return [originX + scale * x,
                originY + scale * y];
    },
    /**
     * Converts rectangle's position and size with <code>scale</code>.
     * <br><br>
     * Second parameter effects the origin point. It is as same as <code>convert()</code>'s sencond parameter:<br><br>
     * <ul>
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager%23Origin.html#Offset">Origin.Offset</a></code>: Add offset value. It is good for root item in LetterBox and PanAndScan.
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager%23Origin.html#Center">Origin.Center</a></code>: Center of Screen become origin.
     * </ul>
     * If you pass the negative coordinate, the origin point moves opposite side.
     * <br><br>
     * <pre class="code">
     * var rect = Screen.Manager.settings.field.convertRect({x:120, y:120, w:200, h:200}, ScreenManager.Origin.Offset);
     * label.setFrame(rect.array());
     * </pre>
     * @param {Object} rect Logical rectangle frame.
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point.
     * @returns {UI.ViewGeometry.Rect} Converted rect.
     */
    convertRect: function(rect, origin)
    {
        if (rect instanceof Array && rect.length === 4)
        {
            rect = {x:rect[0], y:rect[1], w:rect[2], h:rect[3]};
        }
        else if (isNaN(rect.x) || isNaN(rect.y) || isNaN(rect.w) || isNaN(rect.h))
        {
            console.log((new Error()).stack);
            throw new Error("ScreenManager: parameter of convertRect() should be object or 4 length array.");
        }
        var scale = this._scale;
        var position = this.convert([rect.x, rect.y], origin);
        rect = [position[0], position[1], ~~(scale * rect.w), ~~(scale * rect.h)];
        return new ViewGeometry.Rect(rect);
    },
    /**
     * Create <code>UI.ViewGeometry.Rect</code> like class it knows <code>scale</code>, and <code>offset</code>.
     * <br><br>
     * It is used for UI object. This object's <code>sliceVertical()</code>, <code>sliceHorizontal()</code>, <code>inset()</code>
     * works properly with logical size.
     * <br><br>
     * Second parameter effects the origin point. It is as same as <code>convert()</code>'s sencond parameter:<br><br>
     * <ul>
     * <li><b>-</b> <code><a href="Service.Display.Display.ScreenManager%23Origin.html#Offset">Origin.Offset</a></code>: Add offset value. It is good for root item in LetterBox and PanAndScan.
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager%23Origin.html#Center">Origin.Center</a></code>: Center of Screen become origin.
     * </ul>
     * If you pass the negative coordinate, the origin point moves opposite side.
     * <pre class="code">
     * var rect = Screen.settings.field.createRect({x:-100, y:-100, w:200, h:200}, ScreenManager.Origin.Center);
     * image.setFrame(rect.array());
     * rect.inset(20);
     * button.setFrame(rect.sliceVertical(50).array());
     * </pre>
     * @param {Object} rect Logical rectangle frame.
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point.
     * @returns {Service.Display.ScreenManager.Rect} Rect object similar to <code>UI.ViewGeometry.Rect</code>.
     */
    createRect: function(rect, origin)
    {
        if (rect instanceof Array && rect.length === 4)
        {
            rect = {x:rect[0], y:rect[1], w:rect[2], h:rect[3]};
        }
        else if (isNaN(rect.x) || isNaN(rect.y) || isNaN(rect.w) || isNaN(rect.h))
        {
            console.log((new Error()).stack);
            throw new Error("ScreenManager: parameter of createRect() should be object or 4 length array.");
        }
        var x = rect.x;
        var y = rect.y;
        var OriginEnum = Origin;
        switch(origin)
        {
        case OriginEnum.Offset:
        case "offset":
            x = (x < 0) ? this.logicalSize[0] + x : x;
            y = (y < 0) ? this.logicalSize[1] + y : y;
            return new Rect([x, y, rect.h, rect.w], this._offset, this._scale);
        case OriginEnum.Center:
        case "center":
            x += this.logicalSize[0] * 0.5;
            y += this.logicalSize[1] * 0.5;
            return new Rect([x, y, rect.h, rect.w], [0, 0], this._scale);
        default:
            x = (x < 0) ? this.logicalSize[0] + x : y;
            y = (y < 0) ? this.logicalSize[1] + y : y;
            return new Rect([x, y, rect.h, rect.w], [0, 0], this._scale);
        }
    },
    /**
     * Create <code>UI.ViewGeometry.Rect</code> like object which has logical screen size.
     * <br><br>
     * Second parameter effects the origin point. It is as same as <code>convert()</code>'s sencond parameter, but
     * only one option is available with this method:<br><br>
     * <ul>
     * <li><b>-</b> <code><a href="Service.Display.ScreenManager.html#Origin">Origin.Offset</a></code>: Add offset value. It is good for root item in LetterBox and PanAndScan.
     * </ul>
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point. It supports <code>Offset</code> only.
     * @returns {Service.Display.ScreenManager.Rect} Rect object similar to <code>UI.ViewGeometry.Rect</code>.
     */
    getFullScreenRect: function(origin)
    {
        var OriginEnum = Origin;
        switch(origin)
        {
        case OriginEnum.Offset:
        case "offset":
            return new Rect([0, 0, this.logicalSize[0], this.logicalSize[1]], this._offset, this._scale);
        default:
            return new Rect([0, 0, this.logicalSize[0], this.logicalSize[1]], [0, 0], this._scale);
        }
    },
    /**
     * This method shows letter box. Only one letter box is available even if you register several settings.
     * If the setting's type is not "LetterBox", no letter box shows.
     * @param {Service.Display.ScreenManager#LetterBoxType|String} [type] Letter box type. Default is GL2. 
     */
    showLetterBox: function(type)
    {
        this._screen._clearLetterBox();
    },
    /**
     * This method hides letter box.
     */
    hideLetterBox: function()
    {
        this._screen._clearLetterBox();
    }
});

/** @private */
var LetterBoxSetting = ScreenSetting.subclass(
{
    initialize: function($super, screen, setting)
    {
        $super(screen, setting);
        var widthScale = screen.width / this.logicalSize[0];
        var heightScale = screen.height / this.logicalSize[1];
        var scale = this._scale = Math.min(widthScale, heightScale);
        this._offset = [~~((screen.width - scale * this.logicalSize[0])*0.5),
                        ~~((screen.height - scale * this.logicalSize[1])*0.5)];
        if (this._offset[0] === 0)
        {
            // horizontal letterbox
            var letterboxHeight = this._offset[1];
            this._letterBoxes = [{x:0, y:0, w:screen.width, h:letterboxHeight+1},
                                 {x:0, y:screen.height-letterboxHeight-1, w:screen.width, h: letterboxHeight+1}];
        }
        else
        {
            // vertical letterbox
            var letterboxWidth = this._offset[0];
            this._letterBoxes = [{x:0, y:0, w:letterboxWidth+1, h:screen.height},
                                 {x:screen.width-letterboxWidth-1, y:0, w:letterboxWidth+1, h:screen.height}];
        }
    },
    showLetterBox: function(type)
    {
        if (type === undefined)
        {
            type = LetterBoxType.GL2;
        }
        this._screen._clearLetterBox();
        switch(type)
        {
        case "GL2":
        case LetterBoxType.GL2:
            this._showLetterBoxGL2();
            break;
        case "UI":
        case LetterBoxType.UI:
            this._showLetterBoxUI();
            break;
        default:
            console.log("<ScreenManager.showLetterBox> type must be GL2 or UI");
        }
    },
    _showLetterBoxGL2: function()
    {
        var Primitive = require('NGCore/Client/GL2/Primitive').Primitive;
        var i;
        for(i=0; i < 2; ++i)
        {
            var rect = this._letterBoxes[i];
            var letterBox = new Primitive();
            letterBox.setType(Primitive.Type.TriangleStrip);
            letterBox.pushVertex(new Primitive.Vertex([0, 0], [0, 0], [0, 0, 0]));
            letterBox.pushVertex(new Primitive.Vertex([rect.w, 0], [1, 0], [0, 0, 0]));
            letterBox.pushVertex(new Primitive.Vertex([0, rect.h], [0, 1], [0, 0, 0]));
            letterBox.pushVertex(new Primitive.Vertex([rect.w, rect.h], [1, 1], [0, 0, 0]));
            letterBox.setPosition(rect.x, rect.y);
            letterBox.setDepth(99999999);
            this._screen._appendLetterBoxGL2(letterBox);
        }
    },
    _showLetterBoxUI: function()
    {
        var View = require('NGCore/Client/UI/View').View;
        var i;
        for(i=0; i < 2; ++i)
        {
            var rect = this._letterBoxes[i];
            letterBox = new View({
                frame: [rect.x, rect.y, rect.w, rect.h],
                backgroundColor: "FF000000"
            });
            this._screen._appendLetterBoxUI(letterBox);
        }
    }
});


var PanAndScanSetting = ScreenSetting.subclass(
{
    initialize: function($super, screen, setting)
    {
        $super(screen, setting);
        var widthScale = screen.width / this.logicalSize[0];
        var heightScale = screen.height / this.logicalSize[1];
        var scale = this._scale = Math.max(widthScale, heightScale);
        this._offset = [~~((screen.width - scale * this.logicalSize[0])*0.5),
                        ~~((screen.height - scale * this.logicalSize[1])*0.5)];
    }
});

/** @private */
var FixSetting = ScreenSetting.subclass(
{
    initialize: function($super, screen, setting)
    {
        setting.logicalSize = [screen.width, screen.height];
        $super(screen, setting);
        this._offset = [0, 0];
        this._scale = 1;
    }
});

/** @private */
var FixHeightSetting = ScreenSetting.subclass(
{
    initialize: function($super, screen, setting)
    {
        var logicalHeight = setting.logicalHeight;
        var scale = this._scale = screen.height / logicalHeight;
        var logicalWidth = screen.width / scale;
        setting.logicalSize = [logicalWidth, logicalHeight];
        $super(screen, setting);
        this._offset = [0, 0];
    }
});

/** @private */
var FixWidthSetting = ScreenSetting.subclass(
{
    initialize: function($super, screen, setting)
    {
        var logicalWidth = setting.logicalWidth;
        var scale = this._scale = screen.width / logicalWidth;
        var logicalHeight = screen.height / scale;
        setting.logicalSize = [logicalWidth, logicalHeight];
        $super(screen, setting);
        this._offset = [0, 0];
    }
});

var ScreenManager = ServerSync.singleton(
/** @lends Service.Display.ScreenManager.prototype */
{
    classname: 'ScreenManager',
    /**
     * Error code for JSON reader method.
     * @namespace error
     */
    error:
    {
        /** No error */
        NONE : 0,
        /** Arguments error */
        ARGUMENTS : 1,
        /** JSON parse error */
        JSON_PARSE : 2,
        /** JSON format error */
        JSON_FORMAT : 3,
        /** Asset is not found */
        ASSET_NOT_FOUND : 4
    },
    /**
     * These settings are used for calculating coordinate conversion.
     * @namespace
     */
    Origin: {
        /** Adds screen offset */
        Offset: 1,
        /** Sets oordinate's origin to center of screen */
        Center: 2
    },
    /**
     * These settings are used for letter box.
     * @namespace
     */
    LetterBoxType: {
        /** Letter Box is drawn by GL2 */
        GL2: 0,
        /** Letter Box is drawn by UI */
        UI: 1
    },
    /**
     * @class The <code>ScreenManager</code> class constructs object that management screen size.
     * @property {Number} width (readonly) Physical screen width.
     * @property {Number} height (readonly) Physical screen height.
     * @constructs The default constructor.
     * @augments Service.Data.ServerSync
     * @name Service.Display.ScreenManager
     */
    initialize: function()
    {
        this._glview = undefined;
        this._tablet = false;
        this._init = false;
        this.settings = {};
        this._default = undefined;
        this._letterboxes = [];
        this._callbackReplacement = undefined;
    },
    /**
     * Initializes screen setting and <code>UI.GLView</code>. This method sets screen portrait mode.
     *
     * @param {Function} [callback] Callback function which is passed <code>UI.GLView.onLoad</code>.
     */
    setPortrait: function(callback)
    {
        this._initScreenSize();
        if(this._tablet) {
            this._initRotation(callback, "portrait", "LandscapeRight");
        } else {
            this._initRotation(callback, "portrait");
        }
    },
    /**
     * Initializes screen setting and <code>UI.GLView</code>. This method sets screen portrait mode.
     *
     * @param {Function} [callback] Callback function which is passed <code>UI.GLView.onLoad</code>.
     */
    setLandscape: function(callback)
    {
        this._initScreenSize();
        if(!this._tablet) {
            this._initRotation(callback, "landscape", "LandscapeLeft");
        } else {
            this._initRotation(callback, "landscape");
        }
    },
    get width()
    {
        return this._width;
    },
    set width(value)
    {
        throw new Error("width property is readonly");
    },
    get height()
    {
        return this._height;
    },
    set height(value)
    {
        throw new Error("height property is readonly");
    },

    /**
     * Loads config settings from data file.
     * <br><br>
     * If the orientaion parameter is in data, <br>callback</br> is called when <code>setPortrait()</code>
     * or <code>setLandscape()</code> is finishded. Otherwise, it called when finish loading. In this case,
     * first parameter of callback is error code.
     * @param {String} filename File name of data file.
     * @param {Function} [callback] Callback function.
     * @name Service.Display.ScreenManager.loadConfigFromFile
     */
    /**
     * Loads config data from data.
     * @param {String|Object} jsonData JSON string or Object.
     * @param {Function} [callback] Callback function.
     * @name Service.Display.ScreenManager.loadConfigFromData
     */
    /**
     * Registers new settings. Available types are described at <code>ScreenManager.ScreenSetting<code>.
     * This method accept JSON data. JSON data needed following parameter:
     * <pre class="code">
     * // register
     * ScreenManager.register({
     *     type: "LetterBox",
     *     name: "field",
     *     logicalSize: [480, 320]
     * });
     * </pre>
     * @param {JSON} settingJson setting information.
     * @param {String} settingJson.type Setting type.
     * @param {String} settingJson.name Name for register. Registered setting is accessed via this name.
     * @param {Number[]} settingJson.logicalSize Needed for LetterBox and PanAndScan. It is resolution of logical screen.
     * @param {Number} settingJson.logicalWidth Needed for FixWidth.
     * @param {Number} settingJson.logicalHeight Needed for FixHeight.
     */
    register: function(settingJson)
    {
        if (!this._init) {
            throw new Error("ScreenManager is not initialized. call setPortrait() or setHorizontal() first.");
        }
        var setting;
        switch(settingJson.type) {
        case "LetterBox":
            setting = new LetterBoxSetting(this, settingJson);
            break;
        case "PanAndScan":
            setting = new PanAndScanSetting(this, settingJson);
            break;
        case "Fix":
            setting = new FixSetting(this, settingJson);
            break;
        case "FixWidth":
            setting = new FixWidthSetting(this, settingJson);
            break;
        case "FixHeight":
            setting = new FixHeightSetting(this, settingJson);
            break;
        default:
            throw new Error("Unknown Screen Setting Type: " + settingJson.type);
        }
        this.settings[setting.name] = setting;
        this.screenSetting = setting;
    },
    /**
     * Sets one of settings default. Following methods and properties's shortcut are available.
     * <ul>
     * <li><code>scale</code>(readonly property)</li>
     * <li><code>offset</code>(readonly property)</li>
     * <li><code>logicalSize</code>(readonly property)</li>
     * <li><code>convert()</code></li>
     * <li><code>convertRect()</code></li>
     * <li><code>createRect()</code></li>
     * <li><code>getRootNode()</code></li>
     * <li><code>getFullScreenRect()</code></li>
     * <li><code>showLetterBox()</code></li>
     * </ul>
     * <pre class="code">
     * ScreenManager.register({type:"LetterBox", name:"field", logicalSize:[800, 480]});
     * // No default version
     * var position = ScreenManager.settings.field.convert(100, 200);
     * // Use default
     * ScreenManager.setDefault("field");
     * var position = ScreenManager.convert(100, 200);
     * </pre>
     * @param {String} key It should be the name which is already registered by <code>register()</code> method.
     */
    setDefault: function(key)
    {
        var defaultSetting = this.settings[key];
        if(!defaultSetting)
        {
            throw new Error("Undefined setting: " + key);
        }
        this._default = defaultSetting;
    },
    /**
     * @field It is alias to default setting.
     * @type Number
     */
    get scale()
    {
        return this._default.scale;
    },
    /** @private */
    set scale(value)
    {
        throw new Error("scale property is readonly");
    },
    /**
     * @field It is alias to default setting.
     * @type Number
     */
    get offset()
    {
        return this._default.offset;
    },
    /** @private */
    set offset(value)
    {
        throw new Error("offset property is readonly");
    },
    /**
     * @field It is alias to default setting.
     * @type [Number, Number]
     */
    get logicalSize()
    {
        return this._default.logicalSize;
    },
    /** @private */
    set logicalSize(value)
    {
        throw new Error("logicalSize property is readonly");
    },

    /**
     * This method is alias to default setting.
     *
     * @param {Number} number Input value for calulation.
     * @returns {Number} Converted value.
     *
     * @see Service.Display.ScreenManager.ScreenSetting#convertNumber
     */
    convertNumber: function(number)
    {
        return this._default.convertNumber(number);
    },
    /**
     * This method is alias to default setting.
     * @param {Number[]} coordinate Input position
     * @returns {Number[]} Converted coordinate.
     * @see Service.Display.ScreenManager.ScreenSetting#convert
     */
    convert: function(coordinate, origin)
    {
        return this._default.convert(coordinate, origin);
    },
    /**
     * This method is alias to default setting.
     * @param {Object} rect Logical rectangle frame.
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point.
     * @returns {UI.ViewGeometry.Rect} Converted rect.
     * @see Service.Display.ScreenManager.ScreenSetting#convertRect
     */
    convertRect: function(rect, origin)
    {
        return this._default.convertRect(rect, origin);
    },
    /**
     * This method is alias to default setting.
     * @param {Object} rect Logical rectangle frame.
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point.
     * @returns {Service.Display.ScreenManager.Rect} Rect object similar to <code>UI.ViewGeometry.Rect</code>.
     * @see Service.Display.ScreenManager.ScreenSetting#createRect
     */
    createRect: function(rect, origin)
    {
        return this._default.createRect(rect, origin);
    },
    /**
     * This method is alias to default setting.
     * @returns {GL2.Node} Root node for GL2 nodes.
     * @see Service.Display.ScreenManager.ScreenSetting#getRootNode
     */
    getRootNode: function()
    {
        return this._default.getRootNode();
    },
    /**
     * This method is alias to default setting.
     * @param {Service.Display.ScreenManager#LetterBoxType|String} [type] Letter box type. Default is GL2. 
     * @see Service.Display.ScreenManager.ScreenSetting#showLetterBox
     */
    showLetterBox: function(type)
    {
        this._default.showLetterBox(type);
    },
    /**
     * This method is alias to default setting.
     * @param {Service.Display.ScreenManager#Origin} origin Opition parameter about origin point. It supports <code>Offset</code> only.
     * @returns {Service.Display.ScreenManager.Rect} Rect object similar to <code>UI.ViewGeometry.Rect</code>.
     * @see Service.Display.ScreenManager.ScreenSetting#getFullScreenRect
     */
    getFullScreenRect: function(origin)
    {
        return this._default.getFullScreenRect(origin);
    },
    /** @private */
    __onLoadData : function(data, param, callback)
    {
        if(data.orientation)
        {
            var func = 'set' + data.orientation;
            if(this[func])
            {
                this[func](callback);
            }
            else
            {
                this.setPortrait(callback);
            }

            this._registerJsonData(data);
            if (data.defaultScreen)
            {
                this.setDefault(data.defaultScreen);
            }
        }
        else
        {
            this._registerJsonData(data);
            if (data.defaultScreen)
            {
                this.setDefault(data.defaultScreen);
            }
            if (callback) {
                callback();
            }
        }
        return true;
    },
    /** @private */
    _clearLetterBox: function()
    {
        var i;
        for(i=0; i < this._letterboxes.length; ++i)
        {
            var node = this._letterboxes[i];
            node.destroy();
        }
        this._letterboxes = [];
    },
    /** @private */
    _appendLetterBoxGL2: function(node)
    {
        var Root = require('NGCore/Client/GL2/Root').Root;
        this._letterboxes.push(node);
        Root.addChild(node);
    },
    /** @private */
    _appendLetterBoxUI: function(view)
    {
        var Window = require('NGCore/Client/UI/Window').Window;
        this._letterboxes.push(view);
        Window.document.addChild(view);
    },
    /** @private */
    _registerJsonData : function(data)
    {
        // we need to convert the data rep into a rep we can use in the class
        if(data.screens)
        {
            var prop;
            for(prop in data.screens)
            {
                if(data.screens.hasOwnProperty(prop))
                {
                    data.screens[prop].name = prop;
                    this.register(data.screens[prop]);
                }
            }
        }
        else
        {
            console.log("<NGGO Screen> Screen data file is not formated in the correct style.");
        }
    },
    /** @private */
    _interruptCallback: function(newCallback)
    {
        this._callbackReplacement = newCallback;
    }
});

/** @private */
ScreenManager._initScreenSize = function()
{
    var Core = require('NGCore/Client/Core').Core;
    var height = Core.Capabilities.getScreenHeight();
    var width = Core.Capabilities.getScreenWidth();
    if (width > height)
    {
        // Tablet
        this._tablet = true;
        this._width = width;
        this._height = height;
    }
    else
    {
        this._width = height;
        this._height = width;
    }
};

/** @private */
ScreenManager._initRotation = function(callback, orientation, rotateDirection)
{
    var UI = require('NGCore/Client/UI').UI;
    var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;
    switch(rotateDirection)
    {
    case "LandscapeLeft":
        OrientationEmitter.setInterfaceOrientation(OrientationEmitter.Orientation.LandscapeLeft);
        break;
    case "LandscapeRight":
        OrientationEmitter.setInterfaceOrientation(OrientationEmitter.Orientation.LandscapeRight);
        break;
    default:
        break;
    }
    switch(orientation)
    {
    case "portrait":
        this._width = Math.min(UI.Window.outerWidth, UI.Window.outerHeight);
        this._height = Math.max(UI.Window.outerWidth, UI.Window.outerHeight);
        break;
    case "landscape":
        this._width = Math.max(UI.Window.outerWidth, UI.Window.outerHeight);
        this._height = Math.min(UI.Window.outerWidth, UI.Window.outerHeight);
        break;
    default:
        break;
    }

    if (!this._init)
    {
        this._callback = callback || function(){};
        var self = this;
        var glview = new UI.GLView(
        {
            frame : [0, 0, this._width, this._height],
            onLoad : function() {
                if (self._callbackReplacement)
                {
                    self._callbackReplacement(self._callback);
                }
                else
                {
                    self._callback();
                }
            }
        });
        glview.setActive(true);
        this._glview = glview;
        this._init = true;
    }
    this.register({type:"Fix", name:"physical"});
};

exports.ScreenManager = ScreenManager;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Data/PreferenceManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Data/PreferenceManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Data/PreferenceManager'] = exports; 
var __dirname = 'NGGo/Service/Data';
var __filename = 'NGGo/Service/Data/PreferenceManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
// Core Package
var Network     = require('NGCore/Client/Network').Network;
// NGGo Package
var ServerSync  = require('NGGo/Service/Data/ServerSync').ServerSync;
var Class       = require('NGGo/Foundation/Class').Class;

/** @private */
var Action = Class.subclass(
/** @lends Service.Data.PreferenceManager.Action.prototype */
{
    classname: "Action",
    initialize: function(key, listener, func) {
        this.key = key;
        this.listener = listener;
        this.func = func;
    },
    call: function(argument_list) {
        this.func.apply(this.listener, argument_list);
    }
});

exports.Action = Action;

exports.PreferenceManager = ServerSync.singleton(
/** @lends Service.Data.PreferenceManager.prototype */
{
    classname: "PreferenceManager",
    /**
     * @class The <code>PreferenceManager</code> class stores game parameters.
     * <br><br>
     * Game code can access these values and update, reset.
     * If you use <code>DebugMenu</code>, you can access/changes values from
     * the debug menu on the mobile device.
     * @borrows Foundation.Observable#addObserver
     * @borrows Foundation.Observable#deleteObserver
     * @borrows Foundation.Observable#deleteObservers
     * @borrows Foundation.Observable#countObservers
     * @borrows Foundation.Observable#notify
     * @constructs
     * @name Service.Data.PreferenceManager
     * @augments Core.Class
     */
    initialize: function()
    {
        this._isRemoteSource = false;
        this._items = {};
        this._source = undefined;
        this._defaults = {};
        this._actions = [];
    },
    /**
     * Loads the configuration from a flat file.
     * @param {String} filename File name of config file.
     * @param {Function} [callback] Callback function it is called when finish loading.
     * @name Service.Data.PreferenceManager.loadConfigFromFile
     */
    /**
     * Loads the configuration from a data set.
     * @param {String|Object} jsonData This is a JSON string or Object.
     * @name Service.Data.PreferenceManager.loadConfigFromData
     */
    /**
     * Sets default values from several data sources.
     * <br><br>
     * You can use following inputs:
     * <ul>
     * <li>JSON: set values from JSON object.</li>
     * <li>localfile: set values from text file.</li>
     * <li>http: set values from HTTP.</li>
     * </ul>
     * If type of input is JSON object, set it directly. If type of input
     * is string and starts with "http://", get over http. If type of input
     * is string and not starts with "http://", treats it as file path.
     * <br><br>
     * The data that <code>PreferenceManager</code> can hold is Number and Boolean
     * and String.
     * <br><br>
     * It can have hierarchy. If the all data is following:
     * <pre class="code">
     * {
     *     grandparent:
     *     {
     *         parent:
     *         {
     *             child: 100
     *         }
     *     }
     * }
     * </pre>
     * You can access the value "100" by the key "grandparent/parent/child".
     * <br><br>
     * After reading input, <code>callback</code> is called.
     * @param {String|Object} input Data source.
     * @param {Function} callback When the reading data is finished, it is called.
     */
    /**
     * Refresh all values from original data source.
     * <br><br>
     * If you set actions, these are kept.
     * @param {Function} [callback] When the reading data is finished, it is called.
     */
    update: function(callback)
    {
        if(this._isRemoteSource)
        {
            this._load(callback);
        }
        else
        {
            var key;
            for(key in this._defaults)
            {
                if(this._defaults.hasOwnProperty(key))
                {
                    this._set(key, this._defaults[key]);
                }
            }
            this._defaults = {};
            if(callback)
            {
                callback();
            }
        }
    },
    /**
     * Get data from PreferenceManager.
     * @param {String} key Data access key.
     * @returns {Number|Boolean|String} Stored data.
     */
    get: function(key)
    {
        if(key === "")
        {
            return this._items;
        }
        var searchResult = this._traverse(key);
        var parent = searchResult[0];
        var finalKey = searchResult[1];
        return parent[finalKey];
    },
    /**
     * Set data to PreferenceManager. If there is "onUpdate" action in same hierarcy,
     * it is called after setting values.
     * @param {String} key Data access key.
     * @param {Number|Boolean|String} value Actual data to store.
     */
    set: function(key, value)
    {
        var oldValue = this.get(key);
        if (oldValue === undefined)
        {
            throw new Error("PreferenceManager.set: unknown key '" + key + "'");
        }
        var valueType = typeof value;
        var oldValueType = typeof oldValue;
        if (valueType !== "number" && valueType !== "boolean" && valueType !== "string")
        {
            throw new Error("PreferenceManager.set: value must be number or boolean or string, but " + valueType);
        }
        else if (valueType !== oldValueType)
        {
            throw new Error("PreferenceManager.set: '" + key + "' only accept " + oldValueType);
        }
        if (this._defaults[key] === undefined)
        {
            this._defaults[key] = oldValue;
        }
        this._set(key, value);
        this._callOnUpdate(key);
    },

    /**
     * Checks whether the key is updated or not.
     * @param {String} key Data access key.
     * @returns {Boolean} The value is updated or not.
     */
    isChanged: function(key)
    {
        var oldValue = this._defaults[key];
        if (oldValue === undefined)
        {
            return false;
        }
        else
        {
            return this.get(key) !== oldValue;
        }
    },

    /**
     * Reset changed value to original data.
     * <br><br>
     * If there is "onUpdate" action in same hierarcy, it is called after setting values.
     * @param {String} key Data access key.
     * @returns {Number|Boolean|String} Original value.
     */
    reset: function(key)
    {
        var oldValue = this._defaults[key];
        if (oldValue === undefined)
        {
            return this.get(key);
        }
        else
        {
            this._set(key, oldValue);
            this._callOnUpdate(key);
            return oldValue;
        }
    },

    /**
     * Add action to PreferenceManager. In <code>DebugMenu</code>, actions are shown as button.
     * <br><br>
     * You can add any tweek actions to debug menu.
     * The action named "onUpdate" is special action. If you change the value of
     * PreferenceManager, then "onUpdate" action is called.
     * @param {String} key Action name(it is used as button label)
     * @param {Object} listener This is listener object. It becomes "this" in action method.
     * @param {Function} func Action function object.
     */
    addAction: function(key, listener, func)
    {
        var oldValue = this.get(key);
        var oldValueType = typeof oldValue;
        if (oldValue !== undefined && !(oldValue instanceof Action))
        {
            throw new Error("PreferenceManager.addAction: '" + key + "' is already used for " + oldValueType);
        }
        var action = new Action(key, listener, func);
        this._actions.push(action);
        this._set(key, action);
    },

    /**
     * Run action which is registered by "addAction".
     * @param {String} key Access key to action.
     */
    runAction: function(key)
    {
        var action = this.get(key);
        if (!(action instanceof Action))
        {
            throw new Error("PreferenceManager.runAction: '" + key + "' is not action");
        }
        action.call(arguments);
    },
    /**
     * Does a XHR request for a fresh copy of the Preference data file.
     */
    getLastestPreferenceConfig : function()
    {
        var request = new Network.XHR();
        var self = this;
        request.onreadystatechange = function()
        {
            if(this.readyState === 4)
            {
                console.log("<NGGO PreferenceManager: data changed");
                self.loadConfigFromData(this.responseText);
                self.notify("onPreferenceManagerChanged", self);
                // Now start polling again
                self._pollServerForChanges();
            }
        };

        request.open("GET", this.mDevelopServerURL + '/Preference', true);
        request.send(null);
    },
    /** @private */
    _traverse: function(key)
    {
        var parent = this._items;
        var keys = key.split("/");
        var i;
        for (i=0; i<keys.length-1; ++i)
        {
            if (parent[keys[i]] === undefined)
            {
                parent[keys[i]] = {};
            }
            parent = parent[keys[i]];
        }
        return [parent, keys.pop()];
    },

    /** @private */
    _callOnUpdate: function(key)
    {
        var index = key.lastIndexOf("/");
        var handler;
        if(index === -1)
        {
            handler = this.get("onUpdate");
        }
        else
        {
            handler = this.get(key.slice(0, index) + "/onUpdate");
        }
        if(handler instanceof Action)
        {
            handler.call();
        }
    },

    /** @private */
    _set: function(key, value)
    {
        var searchResult = this._traverse(key);
        var parent = searchResult[0];
        var finalKey = searchResult[1];
        parent[finalKey] = value;
    },

    /** @private */
    __onLoadData: function(data)
    {
        this._defaults = {};
        this._items = data;
        this._isRemoteSource = this.isRemote;
        var i;
        for(i=0; i<this._actions.length; ++i)
        {
            var action = this._actions[i];
            this._set(action.key, action);
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Data/JSONData'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Data/JSONData'] || {}; $MODULE_REGISTRY['NGGo/Service/Data/JSONData'] = exports; 
var __dirname = 'NGGo/Service/Data';
var __filename = 'NGGo/Service/Data/JSONData.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Mizumo Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Class       = require('NGCore/Client/Core/Class').Class;
var XHR         = require('NGCore/Client/Network/XHR').XHR;
var FileSystem  = require('NGCore/Client/Storage/FileSystem').FileSystem;
var NGGOError   = require('NGGo/Foundation/NGGOError').NGGOError;
var HTTPRequest = require('NGGo/Service/Network/HTTPRequest').HTTPRequest;

////////////////////////////////////////////////////////////////////////////////
exports.JSONData = Class.subclass(
/** @lends Service.Data.JSONData.prototype */
{
    classname: 'JSONData',
    /**
     * Error codes of <a href="Service.Data.JSONData.html"><code>JSONData</code></a>
     * @namespace ERROR
     */
    ERROR:
    {
        /** */
        NoError               :  0,
        /** */
        UnknownError          : -1,
        /** */
        Aborted               : -2,
        /** */
        NetworkError          :  1,
        /** */
        DataNotFound          :  2,
        /** */
        DataLoadError         :  3,
        /** */
        DataParseError        :  4
    },
    /**
     * @class JavaScript object wrapper class which can build from JSON data on remote, local, string JSON data and JavaScript object itself.
     * @constructor
     * @augments Core.Class
     * @name Service.Data.JSONData
     */
    initialize: function()
    {
        this._json      = {};
        this._error     = this.ERROR.NoError;
        this._errorText = "";
        this._isRemote  = false;
        this._req       = undefined;
        this._callback  = undefined;
    },
    /**
     * Aborts downloading JSON data from network. It works only when remote JSON data is specified.
     * @returns {Boolean} Aborted or not. If JSON data is not come from remote or all the data has already downloaded, it returns false.
     */
    abort: function()
    {
        if( this._isRemote && this._req )
        {
            this._req.onreadystatechange = undefined;
            this._req.abort();
            this._req = undefined;
            this._json = {};
            this._error = this.ERROR.Aborted;
            this._errorText = "JSON loading aborted";
            this. _callInitializeCallback( this._callback );
            return true;
        }
        return false;
    },
    /**
     * Loads JSON data to the object.
     * @param {String|Object} object Remote url( string or URI object ) or local file path of JSON data. It can also accespt JSON data text itself and JavaScript object.
     * @param {Function} [callback] callback function which called when the data load finished.
     */
    load: function(object, callback)
    {
        if( this._isPathRemote(object))
        {
            this._readRemoteJSONFile(object, callback);
        }
        else
        {
            if( typeof object === 'object' )
            {
                this._json = object;
                this._callInitializeCallback(callback);
            }
            else if( typeof object === 'string' )
            {
                // Trim of any white space just in case...
                object = object.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1");
                if(object[0] === '{')
                {
                    // We have json data just handle the data directly
                    try
                    {
                        this._json = JSON.parse(object);
                    }
                    catch (ex)
                    {
                        this._json = {};
                        this._error     = this.ERROR.DataParseError;
                        this._errorText = "JSON parse error";
                    }
                    this._callInitializeCallback(callback);
                }
                else
                {
                    // it is a file path so try and read it as such...
                    this._readLocalJSONFile(object, callback);
                }
            }
        }
    },
    // Accessor functions
    /**
     * @property {Object} data JSON data in the object.
     */
    get data()
    {
        return this._json;
    },
    set data(value)
    {
        this._json = value;
    },
    /**
     * @property {Boolean} isRemote It describe the data is come from remote URI. This property is read only.
     */
    get isRemote()
    {
        return this._isRemote;
    },
    set isRemote(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("JSONData: isRemote is read only property.");
        }
    },
    /** @private */
    _isPathRemote: function(path)
    {
        if( typeof path === 'object' && path.classname === 'URI' ){
            return true;
        }
        else if( typeof path === 'string' )
        {
            if( path.slice(0,7).toLowerCase() === "http://" ||
                path.slice(0,8).toLowerCase() === "https://" )
            {
                return true;
            }
        }
        return false;
    },
    /** @private */
    _readRemoteJSONFile: function(url, callback)
    {
        var req = new HTTPRequest();
        var that = this;
        req.addObserver(
            {
                onSuccess: function(res)
                {
                    that._onLoadJSONFile(url, callback, false, res.responseText);
                },
                onFailure: function(res)
                {
                    if( res.statusCode === 404 )
                    {
                        that._error = that.ERROR.DataNotFound;
                        that._errorText = "JSONFile file accsess: 404 File not found";
                        that._onLoadJSONFile(url, callback, true, "");
                    }
                    else
                    {
                        that._error = that.ERROR.NetworkError;
                        that._errorText = "JSONFile file accsess: status code: "+req.status;
                        that._onLoadJSONFile(url, callback, true ,"");
                    }
                }
            }
        );
        req.get(url);
        this._req = req;
        this._isRemote = true;
        this._callback = callback;
    },
    /** @private */
    _readLocalJSONFile: function(path, callback)
    {
        FileSystem.readFile( path, false, this._onLoadJSONFile.bind(this, path, callback));
    },
    /** @private */
    _onLoadJSONFile: function( path, callback, err, data )
    {
        this._req = null;
        this._callback = undefined;
        if( err )
        {
            if(this._error === this.ERROR.NoError && typeof err === 'string' )
            {
                this._error = this.ERROR.DataNotFound;
                this._errorText = err;
            }
        }
        else
        {
            try
            {
                this._json = JSON.parse(data);
            }
            catch (ex)
            {
                this._json = {};
                this._error     = this.ERROR.DataParseError;
                this._errorText = "JSON parse error";
            }
        }
        this._callInitializeCallback(callback);
    },
    /** @private */
    _callInitializeCallback: function( callback )
    {
        if( typeof callback === 'function' )
        {
            try
            {
                callback( this._buildErrorObject(), this );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
        }
    },
    /** @private */
    _buildErrorObject: function(){
        if( this._error === this.ERROR.NoError ){
            return undefined;
        }
        var e = new NGGOError(this._error,this._errorText);
        return e;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Network/MultiManifestManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Network/MultiManifestManager'] || {}; $MODULE_REGISTRY['NGGo/Service/Network/MultiManifestManager'] = exports; 
var __dirname = 'NGGo/Service/Network';
var __filename = 'NGGo/Service/Network/MultiManifestManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno Takaaki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc.  All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Class            = require('NGCore/Client/Core/Class').Class;
var FileSystem       = require('NGCore/Client/Storage/FileSystem').FileSystem;
var toMD5            = require('NGCore/Client/Core/toMD5').toMD5;
var DownloadManifest = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
var Capabilities     = require('NGCore/Client/Core/Capabilities').Capabilities;
var NGGOError        = require('NGGo/Foundation/NGGOError').NGGOError;
var JSONData         = require('NGGo/Service/Data/JSONData').JSONData;

var ERROR = {
    NoError               :  0,
    UnknownError          : -1,
    Aborted               : -2,
    NetworkError          :  1,
    ListNotFound          :  2,
    ListLoadError         :  3,
    ListParseError        :  4,
    ManifestDownloadError :  5,
    FileDownloadError     :  6,
    FileDeleteError       :  7,
    CacheFileSaveError    :  8,
    SDCardFullError       :  9
};

var STATUS = {
    Initialized          :  0,
    CacheLoading         :  1,
    ListDownloading      :  2,
    ManifestDownloading  :  3,
    FileDeleting         :  4,
    FileUpdating         :  5,
    Finished             :  6,
    Aborted              :  7
};

/** @private */
var Queue = Class.singleton(
{
    classname: "Queue",
    initialized: function(){
        this.clear();
    },
    set: function( jsonPath, progressCb, doneCb, options ){
        this._queue.push([jsonPath, progressCb, doneCb, options]);
    },
    clear: function(){
        this._queue = [];
    },
    get: function(){
        if( this._queue.length > 0 ){
            var res = this._queue.shift();
            return res;
        }
        return undefined;
    },
    hasProcess: function(){
        return !!this._queue.length;
    }
});

/** @private */
var Manifest = Class.subclass(
{
    classname: 'Manifest',
    initialize: function( object )
    {
        if( !object || typeof object !== 'object' )
        {
            object = {
                remoteUrl: "",
                localPath: "",
                manifestName: "",
                version: "",
                key: "",
                downloaded: false
            };
        }
        if( !object.remoteUrl )
        {
            object.remoteUrl = Capabilities.getContentUrl();
        }
        this.remoteUrl    = this._ensureTrailingSlashes(object.remoteUrl);
        this.localPath    = this._ensureTrailingSlashes(object.localPath);
        this.version      = object.version;
        this.manifestName = object.manifestName;
        this.downloaded   = object.downloaded || false;
        this.deleted      = false;
        if( this.downloaded && !this.version)
        {
            this.version = "NOVERSION";
        }
        this._setKey();
        this._downloadm   = null;
    },
    toHash: function()
    {
        return {
                remoteUrl: this.remoteUrl,
                localPath: this.localPath,
                manifestName: this.manifestName,
                version: this.version,
                key: this.key,
                downloaded: this.downloaded
        };
    },
    abort: function()
    {
        if( this._downloadm )
        {
            this._downloadm.abort();
        }
    },
    _ensureTrailingSlashes: function(path)
    {
        if( typeof path === 'string' ){
            return (path.match(/.*\/$/) || (!path)) ? path : path + '/';
        }else{
            return "";
        }
    },
    _setKey: function()
    {
        this.key = toMD5(this.remoteUrl+":"+this.localPath+":"+this.manifestName);
    },
    downloadFiles: function(progressCb, doneCb)
    {
        this._downloadm = new DownloadManifest();
        this._downloadm.start(this.remoteUrl, this.localPath, this.manifestName, progressCb, doneCb );
    },
    deleteFiles: function(doneCb)
    {
        var args = {
            doneCb       : doneCb,
            deletedCount : 0,
            errorCount   : 0,
            list         : []
        };
        this._abort = false;
        FileSystem.readFile ( this.localPath+this.manifestName,
                              this._onReadManifestForDelete.bind(this,args) );
    },
    _onReadManifestForDelete: function(args, err, data)
    {
        var i,j;
        if( err )
        {
            if( typeof args.doneCb === 'function' )
            {
                try
                {
                    args.doneCb(args.deletedCount, args.errorCount, args.list );
                }
                catch (ex)
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
            return;
        }
        var json;
        try
        {
            json = JSON.parse(data);
        } catch (ex2) {
            json = {};
        }
        args.count = 0;
        var list = [];
        for (i in json){
            if( json.hasOwnProperty(i))
            {
                list.push( this.localPath + i );
                args.count++;
            }
        }
        args.list = list;
        args.errorCount = 0;
        args.deletedCount = 0;
        for(j=0; j<args.count; j++ )
        {
            FileSystem.deleteFile(list[j], this._onDeleteFile.bind(this,args,list[j] ));
        }
    },
    _onDeleteFile: function(args, name, err)
    {
        if( err )
        {
            args.errorCount++;
        }
        args.deletedCount++;
        if( args.deletedCount >= args.count )
        {
            FileSystem.deleteFile(this.localPath+this.manifestName, this._onDeleteManifest.bind(this,args));
        }
    },
    _onDeleteManifest: function(args, error)
    {
        if( error )
        {
            args.errorCount++;
        }
        args.deletedCount++;
        if( args.errorCount === 0 )
        {
            this.deleted = true;
        }
        if( typeof args.doneCb === 'function' )
        {
            try
            {
                args.doneCb(args.deletedCount, args.errorCount, args.list );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
    }
});

/** @private */
var ManifestArray = Class.subclass(
{
    classname: "ManifestArray",
    initialize: function( array )
    {
        this._array = [];
        if( typeof array === "object" && array.length > 0 )
        {
            this._array = array;
        }
    },
    get: function(i){
        if( this._array.length > i ){
            return new Manifest(this._array[i]);
        }
        return undefined;
    },
    get length()
    {
        if( typeof this._array === 'object' && this._array.length > 0 )
        {
            return this._array.length;
        }
        else
        {
            return 0;
        }
    },
    set length(value){
        if( typeof NgLogW === 'function' )
        {
            NgLogW("ManifestArray: length is a read only property.");
        }
    }
});

/** @private */
var ManifestList = JSONData.subclass(
{
    classname: "ManifestList",
    get downloadNow()
    {
        if( !this.data )
        {
            return new ManifestArray();
        }
        if( typeof this.data['download-now'] === 'object' &&
            this.data['download-now'].length > 0 ){
            return new ManifestArray(this.data['download-now']);
        }
        return new ManifestArray();
    },
    set downloadNow(value){
        if( typeof NgLogW === 'function' )
        {
            NgLogW("Manifest: downloadNow is a read only property.");
        }
    },
    get downloadLater()
    {
        if( !this.data )
        {
            return new ManifestArray();
        }
        if( typeof this.data['download-later'] === 'object' &&
            this.data['download-later'].length > 0)
        {
            return new ManifestArray(this.data['download-later']);
        }
        return new ManifestArray();
    },
    set downloadLater(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("Manifest: downloadLater is a read only property.");
        }
    },
    get deleteList()
    {
        if( !this.data )
        {
            return new ManifestArray();
        }
        if( typeof this.data['delete'] === 'object' &&
            this.data['delete'].length > 0 )
        {
            return new ManifestArray(this.data['delete']);
        }
        return new ManifestArray();
    },
    set deleteList(value)
    {
        if( typeof NgLogW === 'function' )
        {
            NgLogW("Manifest: deleteList is a read only property.");
        }
    }
});

/** @private */
var ManifestCache = JSONData.subclass(
{
    classname: "ManifestCache",
    setDefault: function()
    {
        this.data = [];
    },
    generateDownloadList: function(object)
    {
        if( !object || object.classname !== 'ManifestList' ){
            return [];
        }
        var downloadList = [];
        var now = object.downloadNow;
        var nowLen = now.length;
        var downloadKey = {};
        var i = 0;
        var j = 0;
        var manifest;
        if( nowLen )
        {
            for( i=0; i<nowLen; i++ )
            {
                manifest = now.get(i);
                j = this._searchManifestByKey(manifest.key);
                if( j>-1)
                {
                    var cached = this.data[j];
                    if( !cached || !cached.downloaded ||
                        cached.version !== manifest.version )
                    {
                            downloadList.push(manifest);
                            downloadKey[manifest.key] = 1;
                    }
                }
                else
                {
                    this.data.push(manifest.toHash());
                    downloadList.push(manifest);
                    downloadKey[manifest.key] = 1;
                }
            }
        }
        var later = object.downloadLater;
        var laterLen = later.length;
        if( laterLen )
        {
            for( i=0; i<laterLen; i++ )
            {
                manifest = later.get(i);
                j = this._searchManifestByKey(manifest.key);
                if( j === -1)
                {
                    this.data.push(manifest.toHash());
                }
            }
        }
        if( downloadList.length > 0 )
        {
            var length = this.data.length;
            for(i=0;i<length;i++)
            {
                if( this.data[i] ){
                    manifest = new Manifest(this.data[i]);
                    if( manifest.manifestName && !manifest.downloaded && !downloadKey[manifest.key] )
                    {
                        downloadList.push(manifest);
                        break;
                    }
                }
            }
        }
        return downloadList;
    },
    generateDeleteList: function(object)
    {
        var i;
        if( !object || object.classname !== 'ManifestList' )
        {
            return [];
        }
        var deleteList = [];
        var del = object.deleteList;
        var delLen = del.length;
        if( delLen )
        {
            for( i=0; i<delLen; i++ )
            {
                var manifest = del.get(i);
                var j = this._searchManifestByKey(manifest.key);
                if( j !== -1)
                {
                    deleteList.push(manifest);
                }
            }
        }
        return deleteList;
    },
    updateCache: function(downloaded, deleted, path, cb)
    {
        var dwlen = downloaded.length;
        var i;
        var manifest;
        var j;
        for(i=0; i<dwlen; i++ )
        {
            manifest = new Manifest(downloaded[i]);
            j = this._searchManifestByKey(manifest.key);
            if( j === -1 )
            {
                var obj = manifest.toHash();
                this.data.push(obj);
            }else{
                this.data[j].downloaded = manifest.downloaded;
                this.data[j].version    = manifest.version;
            }
        }
        var dllen = deleted.length;
        for( i=0; i<dllen; i++ )
        {
            manifest = deleted[i];
            if( manifest.deleted )
            {
                j = this._searchManifestByKey(manifest.key);
                if( j !== -1 )
                {
                    this.data.splice(j,1);
                }
            }
        }
        FileSystem.writeFile( path, JSON.stringify(this.data),cb);
    },
    getCacheInfo: function( manifest ){
        var j = this._searchManifestByKey(manifest.key);
        if( j !== -1 )
        {
            return this.data[j];
        }
        return undefined;
    },
    _searchManifestByKey:function(key)
    {
        var i;
        if( typeof this.data !== 'object' || !this.data.length )
        {
            return -1;
        }
        var length = this.data.length;
        for(i=0;i<length;i++)
        {
            if(this.data[i]){
                var manifest = new Manifest(this.data[i]);
                if( manifest.key && manifest.key === key)
                {
                    return i;
                }
            }
        }
        return -1;
    }
});


exports.MultiManifestManager = Class.singleton(
/** @lends Service.Network.MultiManifestManager.prototype */
{
    classname: "MultiManifestManager",
    /**
     * Error codes of <a href="Service.Network.MultiManifestManager.html"><code>MultiManifestManager</code></a>.
     * @namespace
     */
    ERROR: {
        /** It works fine and no error */
        NoError               :  0,
        /** Something wrong but unknown */
        UnknownError          : -1,
        /** Operetion aborted */
        Aborted               : -2,
        /** Network error occured and cannot get the data */
        NetworkError          :  1,
        /** List didn't find and 404 error has occur */
        ListNotFound          :  2,
        /** Something trouble when loading a list */
        ListLoadError         :  3,
        /** List JSON is invalid */
        ListParseError        :  4,
        /** Some error had occur in Network.DownloadManifest */
        ManifestDownloadError :  5,
        /** Something trouble when downloading file */
        FileDownloadError     :  6,
        /** Something trouble when deleting file */
        FileDeleteError       :  7,
        /** Something trouble when saving cache file */
        CacheFileSaveError    :  8,
        /** SD Card is full */
        SDCardFullError       :  9
    },

    /**
     * Status codes of <a href="Service.Network.MultiManifestManager.html"><code>MultiManifestManager</code></a>.
     * @namespace
     */
    STATUS: {
        /** Module initialized but download process is not started yet. */
        Initialized          :  0,
        /** Loading cache from local JSON file */
        CacheLoading         :  1,
        /** Downloading manifest list */
        ListDownloading      :  2,
        /** Downloading manifest and asset files */
        ManifestDownloading  :  3,
        /** Deleting files */
        FileDeleting         :  4,
        /** Updating cache file */
        FileUpdating         :  5,
        /** Process finished */
        Finished             :  6,
        /** Process aborted */
        Aborted              :  7
    },

    /**
     * @class Singleton object which manage download histroy of multi manifest files.
     * @name Service.Network.MultiManifestManager
     * @augments Core.Class
     * @property {Service.Network.MultiManifestManager#STATUS} Status (readonly) Status code.
     * @constructs
     */
    initialize: function()
    {
        this.options = {
            cachefile: "DownloadManifestFile_Cache.json",
            maxAditionalDownloadFile: 1
        };
        Queue.clear();
        this.reset();
    },
    /**
     * Reset connection
     */
    reset: function(){
        this._status              = this.STATUS.Initialized;
        this._error               = this.ERROR.NoError;
        this._errorText           = "";
        this._jsonPath            = "";
        this._manifestListCache   = null;
        this._downloadList        = null;
        this._deleteList          = null;
        this._manifestlistObject  = null;
        this._manifestObject      = null;
        this._forceAbort          = false;
    },
    /**
     * Start to load manifest files.
     *
     * @param {String|Object} json Path for the manifest list. JSON object/File path/URL available.
     * @param {Function} [progressCb] Callback function which is called each asset file has been downloaded.
     * @param {Function} [doneCb] Callback function which is called the process have done.
     * @param {Object} [options] Object include option parameters
     * @param {String} [options.cachefile] Name of the cache file used for filename.
     * @param {Number} [options.maxAditionalDownloadFile] How many "later" manifest should be downloaded with the manifest which is needed immidietly.
     */
    start: function(json, progressCb, doneCb, options)
    {
        if( this._status !== this.STATUS.Initialized &&
            this._status !== this.STATUS.Finished &&
            this._status !== this.STATUS.Abort ){
            Queue.set( json, progressCb, doneCb, options );

            return;
        }
        this._start(json, progressCb, doneCb, options);
    },
    /**
     * Abort current loading process
     */
    abort: function()
    {
        switch(this._status){
        case this.STATUS.CacheLoading:
            this._forceAbort = true;
            break;
        case this.STATUS.ListDownloading:
            this._manifestlistObject.abort();
            this._forceAbort = true;
            break;
        case this.STATUS.ManifestDownloading:
            this._forceAbort = true;
            this._manifestObject.abort();
            this._onAbort(this._downloadArgs);
            break;
        case this.STATUS.FileDeleting:
            this._forceAbort = true;
            break;
        case this.STATUS.Initialized:
        case this.STATUS.Finished:
        case this.STATUS.Aborted:
            break;
        default:
            break;
        }
    },
    /**
     * Get paticular manifest file's version
     * @param {String} remoteUrl URI of the manifest file
     * @param {String} localPath Local path of downloaded manifest file
     * @param {String} manifestName File name of manifest file
     * @param {Function} [doneCb] Callback function which was invoked when the check finished
     * @param {Object} [options] Object includes option parameters.
     */
    getManifestStatus: function( remoteUrl, localPath, manifestName, doneCb, options )
    {
        var name;
        var merged_options = {};
        for( name in this.options )
        {
            if( this.options.hasOwnProperty(name))
            {
                merged_options[name] = ( options && options.hasOwnProperty(name)) ?
                    options[name] : this.options[name];
            }
        }
        this.reset();
        var args = {
            "remoteUrl"    : remoteUrl,
            "localPath"    : localPath,
            "manifestName" : manifestName,
            "doneCb"       : doneCb,
            "options"      : merged_options
        };
        var manifestcache = new ManifestCache();
        manifestcache.load( merged_options.cachefile,
                            this._onLoadCacheFileGetStatus.bind(this, args) );
    },
    get status()
    {
        return this._status;
    },
    set status(value){
        if( typeof NgLogW === 'function' )
        {
            NgLogW("Network.MultiManifestManager: status property is readonly !");
        }
    },

    /** @private */
    _start: function( jsonPath, progressCb, doneCb, options )
    {
        var name;
        var merged_options = {};
        for( name in this.options )
        {
            if( this.options.hasOwnProperty(name))
            {
                merged_options[name] = ( options && options.hasOwnProperty(name)) ?
                    options[name] : this.options[name];
            }
        }
        this.reset();
        this._jsonPath = jsonPath;
        var args = {
            "progressCb" : progressCb,
            "doneCb"     : doneCb,
            "options"    : merged_options
        };
        this._status = this.STATUS.CacheLoading;
        var manifestcache = new ManifestCache();
        manifestcache.load(merged_options.cachefile,
                           this._onLoadCacheFile.bind(this, args) );
    },
    /** @private */
    _onLoadCacheFileGetStatus: function( args, error, cache )
    {
        if( error )
        {
            cache.setDefault();
        }
        this._manifestListCache = cache;
        var manifest = new Manifest(
            {
                remoteUrl: args.remoteUrl,
                localPath: args.localPath,
                manifestName: args.manifestName
            });
        var c = cache.getCacheInfo( manifest );
        if( typeof c !== 'object' )
        {
            c = {
                downloaded: false,
                version: undefined
            };
        }
        if( typeof args.doneCb === 'function' )
        {
            try
            {
                args.doneCb( !!c.downloaded, c.version );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
    },
    /** @private */
    _onLoadCacheFile: function( args, error, cache )
    {
        if( error )
        {
            cache.setDefault();
        }
        this._manifestListCache = cache;
        if( this._forceAbort)
        {
            this._onAbort(args);
            return;
        }
        this._status = this.STATUS.ListDownloading;
        this._manifestlistObject = new ManifestList();
        this._manifestlistObject.load(this._jsonPath, this._onLoadManifestList.bind(this, args ));
    },
    /** @private */
    _onLoadManifestList: function( args, error, list )
    {
        if( this._forceAbort )
        {
            this._onAbort(args);
        }
        else if( error )
        {
            this._error = error.errorCode;
            this._errorText = error.errorText;
            this._finishWithFailure(args);
            return;
        }
        this._downloadList = this._manifestListCache.generateDownloadList(list);
        this._deleteList = this._manifestListCache.generateDeleteList(list);

        if( this._downloadList.length === 0 && this._deleteList.length === 0 )
        {
            this._finishWithSuccess(args, 0, 0);
            return;
        }
        if( this._downloadList.length > 0 )
        {
            this._downloadManifests(args);
        }
        else if( this._deleteList.length > 0 )
        {
            this._deleteManifests(args);
        }
        else
        {
            this._finishWithSuccess(args,[],[]);
        }
    },
    /** @private */
    _downloadManifests: function(args)
    {
        this._status = this.STATUS.ManifestDownloading;
        var params = {
            currentTarget: 0,
            total: []
        };
        this._manifestObject = null;
        this._downloadManifestRec(args, params, null, null );
    },
    /** @private */
    _downloadManifestRec: function( args, params, err, manifest )
    {
        if( err )
        {
            if( typeof err === 'string' && err.indexOf("SD card is full") >= 0 )
            {
                this._error = this.ERROR.SDCardFullError;
            }
            else
            {
                this._error = this.ERROR.FileDownloadError;
            }
            this._errorText = err;
            this._manifestListCache.updateCache(this._downloadList, this._deleteList,
                                                args.options.cachefile,
                                                this._onFinishSaveManifestCache.bind(this, args));
            return;
        }
        if( manifest )
        {
            manifest = this._downloadList[params.currentTarget];
            manifest.downloaded = true;
            params.currentTarget++;
            if( typeof args.progressCb === 'function' )
            {
                try
                {
                    args.progressCb( params.currentTarget,
                                     this._downloadList.length+this._deleteList.length,
                                     params.total[params.currentTarget],
                                     params.total[params.currentTarget],
                                     manifest.manifestName);
                }
                catch (ex)
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
        }
        if( this._downloadList.length <= params.currentTarget )
        {
            if( this._deleteList.length > 0 )
            {
                this._deleteManifests(args);
            }
            else
            {
                this._status = this.STATUS.FileUpdating;
                this._manifestListCache.updateCache(this._downloadList, this._deleteList,
                                                args.options.cachefile,
                                                this._onFinishSaveManifestCache.bind(this, args));
            }
            return;
        }
        var nextManifest =this._downloadList[params.currentTarget];
        this._manifestObject = nextManifest;
        this._downloadArgs = args;
        nextManifest.downloadFiles(
                        this._manifestProgressCb.bind(this,args,params),
                        this._downloadManifestRec.bind(this, args, params));
    },
    /** @private */
    _manifestProgressCb: function( args, params, cur, total )
    {
        params.total[params.currentTarget+1] = total;
        if( typeof args.progressCb === 'function' ){
            try
            {
                var manifest = this._downloadList[params.currentTarget];
                args.progressCb( params.currentTarget+1, this._downloadList.length+this._deleteList.length,
                                 cur, total, manifest.manifestName);
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
    },
    /** @private */
    _deleteManifests: function(args)
    {
        this._status = this.STATUS.FileDeleteing;
        var params = {
            currentTarget: 0
        };
        this._deleteManifestRec(args, params);
    },
    /** @private */
    _deleteManifestRec: function( args, params, deletedCount, errorCount, list )
    {
        if( list )
        {
            var manifest = this._deleteList[params.currentTarget];
            manifest.deleted = true;
            params.currentTarget++;
            if( typeof args.progressCb === 'function' )
            {
                try
                {
                    args.progressCb( this._downloadList.length + params.currentTarget,
                                     this._downloadList.length+this._deleteList.length, manifest.manifestName);
                }
                catch (ex)
                {
                    if( typeof NgLogException === 'function' )
                    {
                        NgLogException(ex);
                    }
                }
            }
        }
        if( this._deleteList.length <= params.currentTarget )
        {
            this._status = this.STATUS.FileUpdating;
            this._manifestListCache.updateCache(this._downloadList, this._deleteList,
                                                args.options.cachefile,
                                                this._onFinishSaveManifestCache.bind(this, args));
            return;
        }
        if( this._forceAbort )
        {
            this._status = this.STATUS.Aborted;
            this._manifestListCache.updateCache(this._downloadList, this._deleteList,
                                                args.options.cachefile,
                                                this._onFinishSaveManifestCache.bind(this, args));
            return;
        }
        var nextManifest = this._deleteList[params.currentTarget];
        this._manifestObject = nextManifest;
        this._downloadArgs = args;
        nextManifest.deleteFiles(this._deleteManifestRec.bind(this,args, params));
    },
    /** @private */
    _buildDownloadManifestArray: function()
    {
        var i;
        var ret = [];
        if( this._downloadList instanceof Array )
        {
            var len = this._downloadList.length;
            for( i=0; i<len; i++ )
            {
                if( this._downloadList[i].downloaded )
                {
                    ret.push(this._downloadList[i].manifestName);
                }
            }
        }
        return ret;
    },
    /** @private */
    _buildDeletedManifestArray: function()
    {
        var i;
        var ret = [];
        if( this._deleteList instanceof Array )
        {
            var len = this._deleteList.length;
            for( i=0; i<len; i++ )
            {
                if( this._deleteList[i].deleted )
                {
                    ret.push(this._deleteList[i].manifestName);
                }
            }
        }
        return ret;
    },
    /** @private */
    _onFinishSaveManifestCache: function(args, error)
    {
        if( this._status !== this.STATUS.Aborted )
        {
            this._status = this.STATUS.Finished;
        }
        if( error )
        {
            this._errorText = err;
            this._error = this.ERROR.CacheFileSaveError;
        }
        if( typeof args.doneCb === 'function' )
        {
            try
            {
                args.doneCb( this._buildErrorObject(), this._buildDownloadManifestArray(), this._buildDeletedManifestArray() );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' ){
                    NgLogException(ex);
                }
            }
        }

        if( Queue.hasProcess() )
        {
            this.start.apply(this, Queue.get());
        }
    },
    /** @private */
    _finishWithFailure: function( args )
    {
        if( this._status !== this.STATUS.Aborted )
        {
            this._status = this.STATUS.Finished;
        }
        if( typeof args.doneCb === "function" )
        {
            try
            {
                args.doneCb( this._buildErrorObject(), [], [] );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
        if( Queue.hasProcess() )
        {
            this.start.apply(this, Queue.get());
        }
    },
    /** @private */
    _finishWithSuccess: function( args, downloadedManifests, deletedManifests )
    {
        if( this._status !== this.STATUS.Aborted )
        {
            this._status = this.STATUS.Finished;
        }
        if( typeof downloadedManifests !== 'object' || !downloadedManifests.length )
        {
            downloadedManifests = [];
        }
        if( typeof deletedManifests !== 'object' || !deletedManifests.length )
        {
            deletedManifests = [];
        }
        if( typeof args.doneCb === "function" )
        {
            try
            {
                args.doneCb( undefined, downloadedManifests, deletedManifests );
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
        }
        if( Queue.hasProcess() )
        {
            this.start.apply(this, Queue.get());
        }
    },
    /** @private */
    _onAbort:function(args){
        this._error = this.ERROR.Aborted;
        this._errorText = "Download Aborted";
        if( this._status === this.STATUS.ManifestDownloading || this._status === this.STATUS.FileDeleting )
        {
            this._status = this.status.Aborted;
            this._manifestListCache.updateCache(
                this._downloadList, this._deleteList,
                this._downloadArgs.options.cachefile,
                this._onFinishSaveManifestCache.bind(this, this._downloadArgs));
        }
        else if( typeof args.doneCb === 'function' )
        {
            this._status = this.status.Aborted;
            try
            {
                args.doneCb( this._buildErrorObject(), [],[]);
            }
            catch (ex)
            {
                if( typeof NgLogException === 'function' )
                {
                    NgLogException(ex);
                }
            }
            if( Queue.hasProcess() )
            {
                this.start.apply(this, Queue.get());
            }
        }
    },
    /** @private */
    _buildErrorObject: function(){

        if( this._error === this.ERROR.NoError ){
            return undefined;
        }
        var e = new NGGOError(this._error, this._errorText);
        return e;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/FlowNetwork'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/FlowNetwork'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/FlowNetwork'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript';
var __filename = 'NGGo/Framework/FlowScript/FlowNetwork.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.FlowNetwork = Class.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "FlowNetwork",

    initialize : function()
    {
        this._components = {};
        this._networkOpen = false;
    },

    registerCloseCallback : function(callback)
    {
        this._callbackClose = callback;
    },

    registerOpenCallback : function(callback)
    {
        this._callbackOpen = callback;
    },

    open : function()
    {
        var component;
        this._openComponents = 0;
        this._networkOpen = true;
        for(component in this._components)
        {
            this._components[component].preOpen();
        }

        for(component in this._components)
        {
            this._components[component].open();
        }
        
        for(component in this._components)
        {
            this._components[component].postOpen();
            ++this._openComponents;
        }

        if(this._callbackOpen)
        {
            this._callbackOpen();
        }
    },

    close : function()
    {
        var component;
        for(component in this._components)
        {
            this._components[component].close();
        }
    },

    onComponentClosed : function(component)
    {
        --this._openComponents;
        if(0 === this._openComponents)
        {
            // We could add an observer here.  Could be cool....
            this._networkOpen = false;
            if(this._callbackClose)
            {
                this._callbackClose();
            }
        }
    }

}); // end of class Component
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/FlowScriptManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/FlowScriptManager'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/FlowScriptManager'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript';
var __filename = 'NGGo/Framework/FlowScript/FlowScriptManager.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Storage     = require('NGCore/Client/Storage').Storage;
var Network     = require('NGCore/Client/Network').Network;
var ServerSync  = require('NGGo/Service/Data/ServerSync').ServerSync;
var FlowNetwork = require('NGGo/Framework/FlowScript/FlowNetwork').FlowNetwork;

exports.FlowScriptManager = ServerSync.singleton(
/** @lends Framework.FlowScript.FlowScriptManager.prototype */
{
	/**
	 * Error code of <code>FlowScriptManager</code> class.
	 * @namespace error
	 */
    error:
    {
		/** */
        ERROR_NONE : 0,
		/** */
        ERROR_ARGUMENTS : 1,
		/** */
        ERROR_JSON_PARSE : 2,
		/** */
        ERROR_JSON_FORMAT : 3,
		/** */
        ERROR_ASSET_NOT_FOUND : 4,
        /** */
        ERROR_UNKNOWN_NETWORK_KEY : 5,
        /** */
        ERROR_INVALID_NETWORK : 6
    },

    initialize : function()
    {
        this._networkRecipes = {};
        this._networkComponents = {};
    },

    registerFlowNetwork : function(key, network)
    {
        var error = this.error.ERROR_NONE;
        if(key !== "" && key !== null && network !== null)
        {
            if(this._verifyNetworkRecipe(network))
            {
                if(network.info)
                {
                    delete network.info;
                }
                this._networkRecipes[key] = network;
            }
            else
            {
                error = this.error.ERROR_INVALID_NETWORK; 
            }
        }
        else
        {
            error = this.error.ERROR_ARGUMENTS;
        }
        
        return error;
    },

    registerComponent : function(key, component)
    {
        this._networkComponents[key] = component;
    },

    hasKey : function(key)
    {
        return this._networkComponents[key] !== undefined && this._networkComponents[key] !== null;
    },

    createFlowNetwork : function(key)
    {
        var networkRecipe = this._networkRecipes[key];
        if(networkRecipe)
        {
            return this._buildNetworkRecipe(networkRecipe);
        }

        return this.error.ERROR_UNKNOWN_NETWORK_KEY;
    },

    _verifyNetworkRecipe : function(networkRecipe)
    {
        return true;
    },

    _buildNetworkRecipe : function(networkRecipe)
    {
        // the recipe can hold visual data so we only care about the 
        var net = new FlowNetwork();
        
        // First, Construct all the components
        var components = networkRecipe.network.components;
        if(components)
        {
            for(var component in components)
            {
                if(components.hasOwnProperty(component))
                {
                    var numComp = parseInt(component, 10);
                    var comp = new this._networkComponents[components[component].type];
                    comp._iip = components[component].iip;
                    net._components[numComp] = comp;  
                }
            }

            // Now lets link up all objects
            var links = networkRecipe.network.links;
            if(links)
            {
                var len = links.length;
                for(var idx = 0; idx < len; ++idx)
                {
                    var link = links[idx];

                    var headID = parseInt(link.head.uuid, 10);
                    var tailID = parseInt(link.tail.uuid, 10);
                    
                    net._components[tailID].bind(   link.tail.port, 
                                                    net._components[headID],
                                                    link.head.port);
                }
            }
        }
        
        // The network is now ready!!!
        return net;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Component'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Component'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Component'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript';
var __filename = 'NGGo/Framework/FlowScript/Component.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.Component = Class.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "Component",
    
    /**
     * Constructor
     **/
    initialize : function(iip, network)
    {
        this._iip = iip;
        this._network = network;
        this._isOpen = false;
        this._outPorts = {};
    },

    bind : function(outPort, component, inPort)
    {
        if(undefined === this._outPorts[outPort])
        {
            this._outPorts[outPort] = [];
        }
        var message = {};
        message.port = inPort;
        message.receiver = component;

        this._outPorts[outPort].push(message); 
    },

    send : function(port, ip)
    {
        var receivers = this._outPorts[port];
        if(receivers)
        {
            var len = receivers.length || 0;
            if(len == 1)
            {
                receivers[0].receiver._onReceive(receivers[0].port, ip);
            }
            else
            {
                for(var idx = 0; idx < len; ++idx)
                {
                    var ipCopy = {};
                    // Lets make a shallow copy of the IP.
                    // WARNING.  You many not be happy with this behavior. And may want a deep copy
                    // you can do one of two things.  1) Subclass the Component and then use it as a base class
                    // for your components. 2) Create a new component that will take in an IP and do a deep copy
                    // and split it off
                    for(var property in ip)
                    {
                        ipCopy[property] = ip[property];
                    }
                    receivers[idx].receiver._onReceive(receivers[idx].port, ipCopy);
                }
            }
        }
    },

    preOpen : function()
    {
        this._onPreOpen();
    },

    /**
     * Open
     */
    open : function()
    {
        this._isOpen = true;
        this._onOpen();
    },
    
    postOpen : function()
    {
        this._onPostOpen();
    },

    /**
     * Close
     */
    close : function()
    {
        if(this._network)
        {
            var self = this;
            this._onClose(function()
            {
                self._isOpen = false;
                self._network.onComponentClosed(self);
            });
        }
    },
    
    // Must override
    _onPreOpen : function() {},
    _onOpen : function() {},
    _onPostOpen : function() {},
    _onClose : function(callback) {callback();},
    _onReceive : function(port, ip) {}


}); // end of class Component

exports.UUID = 
{
    COMPONENT_BASE : 0,

    COMPOSITE : 1,
    FILTER : 2,
    LOG : 3,
    MOTION_FACTORY : 4,
    SELECTOR : 5,
    SIMULATOR : 6,
    SPRITE_FACTORY : 7,
    CAMERA : 8,
    BLACKBOARD : 9,
    MOTION_PLAYER : 10,
    SOUND_EFFECT : 11,
    SONG_PLAYER : 12,
    FLOW_FACTORY : 13,
    GATE : 14,
    XHR : 15,
    SPRITE_ANIMATION : 16,
    ON_SCRIPT_START : 17,
    EXIT_SCRIPT : 18,
    SCREEN_MANAGER_COMPONENT : 19,
    PHYSICS_FACTORY : 20,

    NGGO_RESERVED_UUID_RANGE : 1000
};
//PHYSICS_FACTORY : 20,

exports.Component.factoryUUID = 0;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Camera'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Camera'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Camera'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Camera.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var PreferenceManager = require('NGGo/Service/Data/PreferenceManager').PreferenceManager;
var AssetManager = require('NGGo/Service/Data/AssetManager').AssetManager;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.Camera = Component.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "Selector",
   
    inPorts : 
    {
        ASSIGN_TOUCH_GENERATOR : 0
    },
    
    outPorts : 
    {
        PASS : 0
    },

    _onOpen : function()
    {
        var nodeName = PreferenceManager.get('camera_node');
        var cameraType = PreferenceManager.get('camera_type');
        this._Camera = new Camera(nodeName, cameraType);
    },

    _onReceive : function(port, ip)
    {
        switch(port)
        {
        case this.inPorts.ASSIGN_TOUCH_GENERATOR:
            if(ip && ip.sprite)
            {
                ip.sprite.setTouchCallback(this._Camera.onTouch);
            }
            break;
        default:
            break;
        }

        this.send(this.outPorts.PASS, ip);
    }

}); // end of class Component

exports.Camera.factoryUUID = UUID.CAMERA;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Filter'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Filter'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Filter'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Filter.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.Filter = Component.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "Filter",
    
    outPorts :
    {
        FILTER_YES : 0,
        FILTER_NO : 1
    },

    _onReceive : function(port, ip)
    {
        // Need to add check to make sure we actually have
        // the value defined
        if( this._iip && 
            this._iip.required && 
            ip[this._iip.required.value])
        {
            this.send(this.outPorts.FILTER_YES, ip);
        }
        else
        {
            this.send(this.outPorts.FILTER_NO, ip);
        }
    }

}); // end of class Component

exports.Filter.factoryUUID = UUID.FILTER;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Log'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Log'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Log'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Log.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.Log = Component.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "Log",

    _onReceive : function(port, ip)
    {
        // Need to add check to make sure we actually have
        // the value defined
        if(ip.log)
        {
            console.log(ip.log);
        }

        this.send(0, ip);
    }

}); // end of class Component

exports.Log.factoryUUID = UUID.LOG;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/Math/Vector2'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/Math/Vector2'] || {}; $MODULE_REGISTRY['NGGo/Foundation/Math/Vector2'] = exports; 
var __dirname = 'NGGo/Foundation/Math';
var __filename = 'NGGo/Foundation/Math/Vector2.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author    Shibukawa Yoshiki
 *  Website    http://www.ngmoco.com
 *  Copyright  2010, by ngmoco:) llc
 *             Unauthorized redistribution of source code is
 *             strictly prohibited. Violators will be prosecuted.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

var Vector2 = Class.subclass(
/** @lends Foundation.Math.Vector2.prototype */
{
    classname: "Vector2",

    /**
     * @class The <code>Vector2</code> class constructs objects that define 2D vector value
     * for the <i>x</i> and <i>y</i> components.
     * @constructs
     * There are four different calling style for <code>Vector2</code> objects.<br><br>
     * Set both compoenent values to 0.
     * <pre class="code">var vector = new Vector2();</pre>
     * <br><br>
     * Copy an existing vector.
     * <pre class="code">var vector = new Vector2(vector);</pre>
     * <br><br>
     * Specify a value for both components.
     * <pre class="code">var vector = new Vector2(1.0, 1.0);</pre>
     * <br><br>
     * Specify a value for both components via Array.
     * <pre class="code">var vector = new Vector2([1.0, 1.0]);</pre>
     * @name Foundation.Math.Vector2
     * @augments Core.Class
     * @param {Number} [x=0] The <i>x</i> component.
     * @param {Number} [y=0] The <i>y</i> component.
     */
    initialize: function(x, y)
    {
        if (y === undefined) {
            if (x === undefined) {
                x = 0;
                y = 0;
            } else if (x.length === 2) {
                y = x[1];
                x = x[0];
            } else {
                y = x.getY();
                x = x.getX();
            }
        }
        this.x = x;
        this.y = y;
    },
    /**
     * Duplicate this <code>Vector2</code>.
     * @returns {Foundation.Math.Vector2} A new vector with identical <i>x</i> and <i>y</i> components.
     */
    clone: function()
    {
        return new Vector2(this.x, this.y);
    },
    /**
     * Sets the value of this vector to the vector sum of itself and other <code>Vector2</code>.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Foundation.Math.Vector2} this object.
     */
    add: function( rhs )
    {
        this.x += rhs.x;
        this.y += rhs.y;
        return this;
    },
    /**
     * Sets the value of this vector to the vector sum of itself and other <code>Vector2</code> that is scaled.
     * @param {Foundation.Math.Vector2} rhs The other vector.
     * @param {Number} scale Scale value it is applied to <code>rhs</rhs>.
     * @returns {Foundation.Math.Vector2} This object.
     */
    scale_and_add: function( scale, rhs )
    {
        this.x += (rhs.x * scale);
        this.y += (rhs.y * scale);
        return this;
    },
    /**
     * Sets the value of this vector to the vector difference of itself and other <code>Vector2</code>.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Foundation.Math.Vector2} this object.
     */
    sub: function( rhs )
    {
        this.x -= rhs.x;
        this.y -= rhs.y;
        return this;
    },
    /**
     * Sets the value of this tuple to the scalar multiplication of itself.
     * @param {Number} s the scalar value.
     * @returns {Foundation.Math.Vector2} this object.
     */
    scale: function( s ) {
        this.x *= s;
        this.y *= s;
        return this;
    },
    /**
     * Normalize this <code>Vector2</code> in place.
     * @returns {Foundation.Math.Vector2} this object.
     */
    normalize: function() {
        var length = this.length;
        this.x /= length;
        this.y /= length;
        return this;
    },
    /**
     * Calcs distance between itself and other <code>Vector2</code>.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Number} the distance.
     */
    distance: function( rhs )
    {
        var x = rhs.x - this.x;
        var y = rhs.y - this.y;
        return Math.sqrt(x*x + y*y);
    },
    /**
     * Calcs squared distance between itself and other <code>Vector2</code>.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Number} the squared distance.
     */
    distanceSquared: function( rhs )
    {
        var x = rhs.x - this.x;
        var y = rhs.y - this.y;
        return x*x + y*y;
    },
    /**
     * Length of this <code>Vector2</code>.
     * @fieldOf Foundation.Math.Vector2.prototype
     * @type Number
     */
    get length()
    {
        var x = this.x;
        var y = this.y;
        return Math.sqrt(x * x + y * y);
    },
    /** @private */
    set length(value)
    {
        throw new Error("length property is readonly");
    },
    /**
     * Squared length of this <code>Vector2</code>.
     * @fieldOf Foundation.Math.Vector2.prototype
     * @type Number
     */
    get lengthSquared()
    {
        var x = this.x;
        var y = this.y;
        return x * x + y * y;
    },
    /** @private */
    set lengthSquared(value)
    {
        throw new Error("lengthSquared property is readonly");
    },
    /**
     * Sets the value of the middle points between itself and other object.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Foundation.Math.Vector2} this object.
     */
    middlePoint: function(rhs)
    {
        var t = 0.5;
        this.x += -this.x * t + rhs.x * t;
        this.y += -this.y * t + rhs.y * t;
        return this;
    },
    /**
     * Sets the value of the parametric middle points between itself and other object.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @param {Number} t the parameter.
     * @returns {Foundation.Math.Vector2} this object.
     */
    parametricPoint: function(rhs, t)
    {
        this.x += -this.x * t + rhs.x * t;
        this.y += -this.y * t + rhs.y * t;
        return this;
    },

    parametricEval : function(rhs, t)
    {
        return new Vector2(this.x - this.x * t + rhs.x * t, this.y - this.y * t + rhs.y * t);
    },

    /**
     * Returns value of the <i>x</i> component. It is the compatible method of <code>Core.Point</code>.
     * @returns {Number} <i>x</i> component.
     */
    getX: function()
    {
        return this.x;
    },
    /**
     * Returns value of the <i>y</i> component. It is the compatible method of <code>Core.Point</code>.
     * @returns {Number} <i>y</i> component.
     */
    getY: function()
    {
        return this.y;
    },
    /**
     * Computes the dot product of the this vector and other vector.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Number} Result value.
     */
    dotProduct: function(rhs)
    {
        return this.x * rhs.x + this.y * rhs.y;
    },
    /**
     * Computes the dot product of the this vector and other vector.
     * @param {Foundation.Math.Vector2} rhs the other vector.
     * @returns {Number} Result value.
     */
    crossProduct: function(rhs)
    {
        return this.x * rhs.y - this.y * rhs.x;
    },
    /**
     * Computes new <i>x</i> and <i>y</i> by transforming <code>Matrix2</code>
     * @param {Foundation.Math.Matrix2} matrix the transform Matrix.
     * @return {Foundation.Math.Vector2} it self.
     */
    transform: function(matrix)
    {
        var tx = this.x;
        this.x = matrix.m00 * tx + matrix.m01 * this.y + matrix.m02;
        this.y = matrix.m10 * tx + matrix.m11 * this.y + matrix.m12;
        return this;
    },

    isNaN: function()
    {
        return isNaN(this.x) || isNaN(this.y);
    },
    /**
     * Returns string presentation of <code>Vector2</code> object.
     * @return {String} String presentation of this object.
     */
    toString : function()
    {
        return "Foundation.Math.Vector2(" + this.x + ", " + this.y + ")";
    }
});

exports.Vector2 = Vector2;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Foundation/Math/Ops'] = function(){var exports = $MODULE_REGISTRY['NGGo/Foundation/Math/Ops'] || {}; $MODULE_REGISTRY['NGGo/Foundation/Math/Ops'] = exports; 
var __dirname = 'NGGo/Foundation/Math';
var __filename = 'NGGo/Foundation/Math/Ops.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/**
 * @name Foundation.Math.Ops
 * @class Set of basic utility operations to make my life a little easier.
 * <br><br>
 * Really this is just do a "Collision" test between a point an a box.
 * We should move this to Box2D or something faster....
 */
exports.Ops = {};

/**
 * Generates random number which is in [rangeMin, rangeMax).
 * <br><br>
 * If only <code>rangeMin</code> is passed, It runs like: <code>randomInt(0, rangeMin)</code>.
 * @name Foundation.Math.Ops.randomInt
 * @param {Number} rangeMin Minimum value.
 * @param {Number} rangeMax Maximum value, but results not includes this value it self.
 * @returns {Number} Result random number.
 */
exports.Ops.randomInt = function(rangeMin, rangeMax)
{
    if(rangeMax === undefined)
    {
        rangeMax = rangeMin;
        rangeMin = 0;
    }

    var range = rangeMax - rangeMin;
    return Math.floor(Math.random() * range) + rangeMin;
};

/**
 * Generates random number which is in [-1, +1]
 * <br><br>
 * @returns {Number} Result random number.
 */
exports.Ops.randomMinusOneToOne = function()
{
    return Math.random() * 2.0 - 1.0;
};

/**
 * Clamps the input value to the specified range.
 * <br><br>
 * If the value is not in the range between <code>nMin</code> and <code>nMax</code>, the result is set in this range.
 * @name Foundation.Math.Ops.clamp
 * @param {Number} nValue Input value.
 * @param {Number} nMin Minimum number of result.
 * @param {Number} nMax Maximum number of result.
 * @returns {Number} Result value.
 */
exports.Ops.clamp = function(nValue, nMin, nMax)
{
    return nValue < nMin ? nMin : nValue > nMax ? nMax : nValue ;
};

/**
 * Calculates the linear position for a motion tween object.
 * @name Foundation.Math.Ops.linearTween
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.linearTween = function(time, begin, change, duration)
{
    return change * time / duration + begin;
};

/**
 * Calculates the position for a motion tween object with ease in.
 * @name Foundation.Math.Ops.easeInQuad
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeInQuad = function(time, begin, change, duration)
{
    return change * (time /= duration) * time + begin;
};

/**
 * Calculates the position for a motion tween object with ease out.
 * @name Foundation.Math.Ops.easeOutQuad
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeOutQuad = function(time, begin, change, duration)
{
    return -change * (time /= duration) * (time - 2) + begin;
};

/**
 * Calculates the position for a motion tween object with exponential ease in.
 * @name Foundation.Math.Ops.easeInExpo
 * @param {Number} time that has elapsed
 * @param {Number} begin position
 * @param {Number} change in position so far
 * @param {Number} duration of the tween
 * @returns {Number} new potion
 */
exports.Ops.easeInExpo = function(time, begin, change, duration)
{
    return change * Math.pow(2, 10 * (time/duration - 1)) + begin;
};

/**
 * Calculates the position for a motion tween object with exponential ease out.
 * @name Foundation.Math.Ops.easeOutExpo
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeOutExpo = function(time, begin, change, duration)
{
    return change * (-Math.pow(2, -10 * time/duration) + 1) + begin;
};

/*
exports.Ops.easeInOutExpo = function(time, begin, change, duration)
{
    if ((time/=(duration*0.5)) < 1)
    {
        return change*0.5 * Math.pow(2, 10 * (time - 1)) + begin;
    }
    return change * 0.5 * (-Math.pow(2, -10 * --time) + 2) + begin;
*/
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/MotionController'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/MotionController'] || {}; $MODULE_REGISTRY['NGGo/Framework/MotionController'] = exports; 
var __dirname = 'NGGo/Framework';
var __filename = 'NGGo/Framework/MotionController.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;
var AnimationManager = require('NGGo/Framework/AnimationManager').AnimationManager;
var Vector2 = require('NGGo/Foundation/Math/Vector2').Vector2;
var Ops = require('NGGo/Foundation/Math/Ops').Ops;
var GL2 = require('NGCore/Client/GL2').GL2;

exports.MotionController = Core.MessageListener.subclass(
/** @lends Framework.MotionController.prototype */
{
    /**
     * @namespace state It is a enumaration of state of <code>MotionController</code> object.
	 */
    state :
	{
		/** */
		INIT : 0,
		/** */
		PLAYING : 1,
		/** */
		HALTED : 2,
		/** */
		PAUSED : 3,
		/** */
		COMPLETED : 4,
		/** */
		ERROR : 5
	},
    
    animationStyle : 
    {
        /** */
        NORMAL : 0,
        /** */ 
        INTERPOLATED : 1,
        /** */
        INTER_FRAME_INTERPOLATED : 2
    },
    
    /**
     * @class The <code>MotionController</code> is a object that actually executes the motion tween animation.
	 * @example
	 * var Dancer = Core.MessageListener.subclass(
	 * {
	 *     initialize: function()
	 *     {
	 *         this.sprite = new GL2.Sprite();
	 *         this.motion = new MotionController(sprite, PreferenceManger.get("motion"), this);
	 *         GL2.Root.addChild(this.sprite);
	 *         this.motion.play(true);
	 *     },
	 *     onMotionStateChange: function(controller)
	 *     {
	 *         if(controller.getState() == MotionController.state.COMPLETED)
	 *         {
	 *             this.motion.play(true);
	 *         }
	 *     }
	 * });
     *
	 * @constructs Constructor for the object.
     * @param {Object} sourceObj Object the source object play the animation on.
     * @param {String} motionName Name of the motion to play.
	 * @param {Object} observer If the state is changed, <code>onMotionStateChange()</code> method of this object is called.
	 * @name Framework.MotionController
	 * @augments Core.MessageListener
     *
     * @constructs Constructor for the the object
     * @param {Array} sourceArray Array of objects defined as { src : {gl2.node}, name : {string} }
     * @param {Object} observer Object that will get the callbacks for the system
	 * @name Framework.MotionController
	 * @augments Core.MessageListener
     */
    initialize : function()
    {
        var state = this.state.INIT;
        var motion;
		var motionIdx;
        var isSkewAnimationError;
        
        if (Object.prototype.toString.apply(arguments[0]) === '[object Array]')
        {   
            this.mMotionData = arguments[0];
            this.mObserver = arguments[1];
        }
        else
        {   
            // If not an array, let's create one from the information we took in
            this.mMotionData = [{ src : arguments[0], name : arguments[1] }];
            this.mObserver = arguments[2]; 
        }
        
        for(motionIdx = 0; motionIdx < this.mMotionData.length; ++motionIdx)
        {
            isSkewAnimationError = false;
            
            motion = AnimationManager.getMotionData(this.mMotionData[motionIdx].name);
            this.mMotionData[motionIdx].motion = motion;
            
            
            // Is the motion valid?
            if(motion)
            {
                this.style = this.animationStyle.INTERPOLATED;
                this.mMotionData[motionIdx].animationStyle = this.animationStyle.INTERPOLATED;
                this.mMotionData[motionIdx].timeBetweenFrames =
                    (1.0 / (1.0 * motion.source[0].frameRate)) * 1000;

                if(undefined === this.frameRate)
                {
                    this.frameRate =   (1.0 / (1.0 * motion.source[0].frameRate)) * 1000;
                }
                else if(this.frameRate != (1.0 / (1.0 * motion.source[0].frameRate)) * 1000)
                {
                    console.log("********** SHIT. you have variable framerates");
                }
                
                // Test for errors on animations that contain skew.
                // In order for skew to work correctly, the source obj must be of type primitive.
                if (this.getIsSkewAnimation(motion))
                {
                    if (this.mMotionData[motionIdx].src.classname === 'Body')
                    {
                        if (this.mMotionData[motionIdx].src.getGL2Node().classname !== 'Primitive')
                        {
                            isSkewAnimationError = true;
                        }
                    }
                    else
                    {
                        if (this.mMotionData[motionIdx].src.classname !== 'Primitive')
                        {
                            isSkewAnimationError = true;
                        }
                    }   
                }
                
                // If error exists, print out message and name of object
                if (isSkewAnimationError)
                {
                    console.log("Motion : " + this.mMotionData[motionIdx].name + " sourceObj is not a primitive. Skew operation will fail.");
                }
            }
            else
            {
                state = this.state.ERROR;
            }
        }
        
        this._setState(state);
    },
    
    /**
     * Returns animation style.
     * @param {Framework.MotionController.animationStyle} animationStyle The animationStyle to set.
     */
    setAnimationStyle : function(animationStyle)
    {
        this.style = animationStyle;
    },
    
    /**
     * Returns animation style.
     * @param {int} motionIdx The specific motion that is being tested.
     * @returns {Framework.MotionController.animationStyle} value
     */
    getAnimationStyle : function()
    {
        return this.style;
    },
    
    /**
     * Returns animation status.
     * @returns {Framework.MotionController.state} value
     */
    getState : function()
    {
        return this.mState;
    },
    
    /**
     * Returns boolean value depicting if the animation has skew changes
     * @param {obj} motion The specific motion that is being tested.
     * @returns bool value
     */
    getIsSkewAnimation : function(motion)
    {
        if (motion.Metadata !== undefined && 
            motion.Metadata[0]['isSkewAnimation'] !== undefined && 
            motion.Metadata[0]['isSkewAnimation'] === true)
        {
            return true;
        }

        return false;
    },
     
    /**
     * @param {int} keyFrame The keyFrame value of the callback that should be added.
     * @param {obj} obj The object that contains the callback function.
     * @param {int} motionIdx The motionIdx of the keyFrame value. Default value is 0.
     */
    addKeyFrameCallback: function(keyFrame, obj, motionIdx)
    {   
        if (motionIdx === undefined)
        {
            motionIdx = 0;
        }
        
        var callbackObj = {keyFrame: keyFrame, obj: obj};
        var motion = this.mMotionData[motionIdx];
        
        if (motion === undefined)
        {
            console.log("mMotionData object for index, " + motionIdx + ", does not exist.");
        }
        else
        {
            if (motion.callbacks === undefined)
                motion.callbacks = [];
        
            motion.callbacks.push(callbackObj);
        }
    },
    
    /**
     * @param {int} keyFrame The keyFrame value of the callback that should be removed.
     * @param {int} motionIdx The motionIdx of the keyFrame value. Default value is 0.
     */
    removeKeyFrameCallback: function(keyFrame, motionIdx)
    {
        if (motionIdx === undefined)
        {
            motionIdx = 0;
        }
            
        var obj = this.mMotionData[motionIdx];
        var callbackIdx;
        
        if (obj === undefined)
        {
            console.log("mMotionData object for index, " + motionIdx + ", does not exist.");
        }
        else
        {
            for (callbackIdx = 0; callbackIdx < obj.callbacks.length; ++callbackIdx)
            {
                if (obj.callbacks[callbackIdx].keyFrame === keyFrame)
                {
                    obj.callbacks.splice(callbackIdx, 1);
                    break;
                }
            }
        }
    },
     
    /**
     * Starts the Motion.  If the motion is already playing then it will do nothing.
     *
     * @param {Boolean} relative If this is true then the motions will be defaults as delta
     *                           movements.  If this is false then the motion will be defined as absolute position
     *                           updates
     */
    play : function(relative)
    {
        if( this.mState === this.state.INIT ||
            this.mState === this.state.HALTED ||
            this.mState ===  this.state.COMPLETED)
        {
            this._hop = false;
            var len = this.mMotionData.length;
			var idx;
            this.currentFrame = 0;

            for(idx = 0; idx < len; ++idx)
            {
                var obj = this.mMotionData[idx];
                if(relative)
                {
                    obj.startData = {};
                    var pos = obj.src.getPosition();
                    obj.startData.x = pos.getX();
                    obj.startData.y = pos.getY();
                }
                else
                {
                    obj.startData = {};
                    obj.startData.x = obj.motion.source[0].x;
                    obj.startData.y = obj.motion.source[0].y;
                }

                obj.startData.rotation = obj.motion.source[0].rotation || 0;
                obj.startData.scaleX = obj.motion.source[0].scaleX || 1;
                obj.startData.scaleY = obj.motion.source[0].scaleY || 1;
                
                // Skew data
                obj.startData.skewX = obj.motion.source[0].skewX || 0;
                obj.startData.skewY = obj.motion.source[0].skewY || 0;
                
                // Figure out if our node is a primitive
                var primitive = null;
                obj.startData.verts = null;
                
                if (obj.src.classname === 'Body')
                {
                    if (obj.src.getGL2Node().classname === 'Primitive')
                    {
                        primitive = obj.src.getGL2Node();
                    }
                }
                else
                {
                    if (obj.src.classname === 'Primitive')
                    {
                        primitive = obj.src;
                    }
                }
            
                // Store primitive vert data if possible
                if (primitive !== null)
                {
                    obj.startData.verts = new Array();
                    for(var i = 0; i < primitive.getVertexCount(); ++i)
                    {
                        obj.startData.verts.push(primitive.getVertex(i));
                    }
                }
            
                obj.startData.alpha = 1.0;

                obj.frameStart = {};
                obj.frameStart.x = obj.startData.x;
                obj.frameStart.y = obj.startData.y;

                
                // Start from the first keyFrame
                obj.keyFrame = 0;
                
                // Start from the first frame
                obj.currentFrame = 0;
                
                // Fire callback if possible
                if (obj.callbacks !== undefined)
                {
                    this._keyFrameCallback(obj.keyFrame, obj);
                }
            
                obj.state = this.state.PLAYING;
            }
            
            // Add this guy as an upate emitter
            Core.UpdateEmitter.addListener(this, this._OnUpdate);

            this._setState(this.state.PLAYING);
            this.mStartTime = Core.Time.getFrameTime();
        }
        else if(this.mState === this.state.PAUSED)
        {
            // Silly Rabbit .. you should have called resume, not play
            this.resume();
        }
    },

    /**
	 * Stops the playback of the motion.  If the motion is not playing the nothing will happen.
     */
    stop : function()
    {
        if(this.mState === this.state.PLAYING)
        {
            Core.UpdateEmitter.removeListener(this);
            this._setState(this.state.HALTED);
        }
    }, 
    
    /** @private */
    _keyFrameCallback: function(keyFrameIdx, obj)
    {
        var callbacksIdx;
        var callbackObj;
        var keyFrame;
        
        for (callbacksIdx = 0; callbacksIdx < obj.callbacks.length; ++callbacksIdx)
        {
            callbackObj = obj.callbacks[callbacksIdx];
            if (keyFrameIdx === callbackObj.keyFrame)
            {
                callbackObj.obj.onKeyFrameCallback(keyFrameIdx, obj.name);
            }
        }
    },
    
	/** @private */
    _setState : function(stateValue)
    {
        this.mState = stateValue;
        if(this.mObserver && this.mObserver.onMotionStateChange)
        {
            this.mObserver.onMotionStateChange(this);
        }
    },
    
    /** @private */
    _setSkew : function(motion, primitive, skewX, skewY)
    {
        var vertexIdx;
        for (vertexIdx = 0; vertexIdx < primitive.getVertexCount(); ++vertexIdx)
        {
			var vertex = primitive.getVertex(vertexIdx);
            var uv = vertex.getUV();
            
            var vertPosX = motion.startData.verts[vertexIdx].getPosition().getX();
            var vertPosY = motion.startData.verts[vertexIdx].getPosition().getY();
            
            var convertToRad = (Math.PI*2/360);
            var skewAngleX = skewX * convertToRad;
            var skewAngleY = skewY * convertToRad;
            
            var newVertPos = this._applyRotationRadians(vertPosX, vertPosY, skewAngleX, skewAngleY);

            var skewedVertex = new GL2.Primitive.Vertex([newVertPos.x, newVertPos.y],[uv.getX(),uv.getY()]);
            primitive.setVertex(vertexIdx, skewedVertex);
        }    
    },
    
    /** @private */
    _applyRotationRadians : function (posX, posY, angleX, angleY)
    {
        var sinX = Math.sin(angleX);
        var sinY = Math.sin(angleY);
        var cosX = Math.cos(angleX);
        var cosY = Math.cos(angleY);
        //
        var max00 = (cosX*cosY) + (sinX*-sinY);
        var max01 = (cosX*sinY) + (sinX*cosY);
        var max10 = (-sinX*cosY) + (cosX*-sinY);
        var max11 = (-sinX*sinY) + (cosX*cosY);
        
        var returnPos = {};
        returnPos.x = (posX*max00) - (posY*max01);
        returnPos.y = (posX*max10) + (posY*max11);

        return returnPos;
    },

    _doMotion : function(obj, frame, timeBetweenFrames)
    {
        var curKeyFrame = obj.motion.Keyframe[obj.keyFrame];
        var nextKeyFrame = obj.motion.Keyframe[obj.keyFrame + 1];
            
        var startX = curKeyFrame.x || 0.0;
        var startY = curKeyFrame.y || 0.0;
        var startFrame = curKeyFrame.index;

        var endX = nextKeyFrame.x || 0.0;
        var endY = nextKeyFrame.y || 0.0;
        var endFrame = nextKeyFrame.index;

        var time = (frame - startFrame) * timeBetweenFrames;
        var duration = (endFrame - startFrame) * timeBetweenFrames;
        var newX = 0;
        var newY = 0;

        var t = ((1.0 * frame) - startFrame) / (1.0 * (endFrame - startFrame));
            
        // Handle the motion delta
        if( curKeyFrame.ease < 0)
        {
            newX = Ops.easeInExpo(time, startX, endX - startX, duration);
            newY = Ops.easeInExpo(time, startY, endY - startY, duration);

            obj.src.setPosition(newX, newY);
        }
        else if(curKeyFrame.ease > 0)
        {
            newX = Ops.easeOutExpo(time, startX, endX - startX, duration);
            newY = Ops.easeOutExpo(time, startY, endY - startY, duration);

            obj.src.setPosition(newX, newY);
        }
        else
        { 
            // Stright linear interpolate
            var startVec = new Vector2(startX, startY);
            var endVec = new Vector2(endX, endY);
            var result = startVec.parametricEval(endVec, t);
            
            obj.pos_x = obj.startData.x + result.x;
            obj.pos_y = obj.startData.y + result.y;
        }
        
        // Now do the same for the rotation data
        var rotStart = curKeyFrame.rotation || 0;
        var rotEnd = nextKeyFrame.rotation || 0;
        var rot = rotStart - rotStart * t + rotEnd * t;
        obj.rot = rot + obj.startData.rotation;

        // Gather information for scaling blends
        var scaleStartX = curKeyFrame.scaleX || 1;
        var scaleEndX = nextKeyFrame.scaleX || 1;

        var scaleStartY = curKeyFrame.scaleY || 1;
        var scaleEndY = nextKeyFrame.scaleY || 1;

        var scaleX = obj.startData.scaleX * (scaleStartX - scaleStartX * t + scaleEndX * t);
        var scaleY = obj.startData.scaleY * (scaleStartY - scaleStartY * t + scaleEndY * t);
        
        // Gather information for alpha blends
        var alphaStart = curKeyFrame.alpha;
        if(undefined === alphaStart){ alphaStart = 1.0; }
        var alphaEnd = nextKeyFrame.alpha;
        if(undefined === alphaEnd){ alphaEnd = 1.0; }
        var alpha = alphaStart - alphaStart * t + alphaEnd * t;
        
        // Gather information for skew blends
        var skewStartX = curKeyFrame.skewX || 0;
        var skewEndX = nextKeyFrame.skewX || 0;

        var skewStartY = curKeyFrame.skewY || 0;
        var skewEndY = nextKeyFrame.skewY || 0;

        var skewX =  (skewStartX - skewStartX * t + skewEndX * t);
        var skewY =  (skewStartY - skewStartY * t + skewEndY * t);
        
        // Use gathered information, try to limit the number of if else cases inside of this loop
        if (obj.src.classname === 'Body')
        {
            obj.scale_x = scaleX;
            obj.scale_y = scaleY;
            obj.alpha = alpha;
            
            if (obj.src.getGL2Node().classname === 'Primitive')
            {
                obj.skewX = skewX;
                obj.skewY = skewY;
            }
        }
        else
        {
            obj.scale_x = scaleX;
            obj.scale_y = scaleY;
            obj.alpha = alpha;

            if (obj.src.classname === 'Primitive')
            {
                obj.skewX = skewX;
                obj.skewY = skewY;
            }
        }
    },
   
    _SetToLastFrame : function(obj)
    {
        var kf = obj.motion.Keyframe[obj.keyFrame];
        // Set any last keyframe position data
        var endOfAnimX = kf.x || 0.0;
        var endOfAnimY = kf.y || 0.0;
        obj.pos_x = obj.startData.x + endOfAnimX;
        obj.pos_y = obj.startData.y + endOfAnimY;

        var rotAnimEnd = kf.rotation || 0;
        obj.rot = rotAnimEnd + obj.startData.rotation;

        // Gather information for scaling blends
        var scaleAnimEndX = kf.scaleX || 1.0;
        var scaleAnimEndY = kf.scaleY || 1.0;
    
        // Gather inforamtion for skew blends
        var skewAnimEndX = kf.skewX || 0;
        var skewAnimEndY = kf.skewY || 0;


        // Gather information for alpha blends
        var frameAlpha = kf.alpha;
        if( frameAlpha === undefined) { frameAlpha = 1.0; }

        // Use gathered information, try to limit the number of if else cases inside the loop
        if (obj.src.classname === 'Body')
        {
            obj.scale_x = obj.startData.scaleX * scaleAnimEndX;
            obj.scale_y = obj.startData.scaleY * scaleAnimEndY;
            obj.alpha = frameAlpha;

            if (obj.src.getGL2Node().classname === 'Primitive')
            {
                obj.skewX = obj.startData.skewX * skewAnimEndX;
                obj.skewY = obj.startData.skewY * skewAnimEndY;
            }
        }
        else
        {
            obj.scale_x = obj.startData.scaleX * scaleAnimEndX;
            obj.scale_y = obj.startData.scaleY * scaleAnimEndY;
            obj.alpha = frameAlpha;

            if (obj.src.classname === 'Primitive')
            {
                obj.skewX = obj.startData.skewX * skewAnimEndX;
                obj.skewY = obj.startData.skewY * skewAnimEndY;
            }
        }
        obj.state = this.state.COMPLETED;
    },

    _OnUpdateFrame : function()
    {
        var len = this.mMotionData.length;
        var shouldExit = true;
        var idx;
            
        for(idx = 0; idx < len; ++idx)
        {
            var obj = this.mMotionData[idx];
            var keyFrameLen = obj.motion.Keyframe.length;
            if(obj.state === this.state.PLAYING)
            {
                shouldExit = false;

                // We Still have some frames to go
                if(obj.keyFrame < (keyFrameLen-1))
                {
                    if(this.currentFrame < obj.motion.Keyframe[obj.keyFrame + 1].index)
                    {
                        this._doMotion(obj, this.currentFrame, this.frameRate);
                    }
                    else
                    {
                        while(obj.keyFrame < (keyFrameLen - 1) && 
                              this.currentFrame > obj.motion.Keyframe[obj.keyFrame].index)
                        {
                            obj.keyFrame++;

                            // Fire callback if possible
                            if (obj.callbacks !== undefined)
                            {
                                this._keyFrameCallback(obj.keyFrame, obj);
                            }
                        }
                        if(obj.keyFrame < (keyFrameLen-1))
                        {
                            this._doMotion(obj, this.currentFrame, this.frameRate);
                        }
                        else
                        {
                            this._SetToLastFrame(obj);
                        }
                    }
                }
                else
                {
                    this._SetToLastFrame(obj);
                }
            }
        }
        if(shouldExit)
        {
            Core.UpdateEmitter.removeListener(this);
            this._setState(this.state.COMPLETED);
        }
    },

	/** @private */
    _OnUpdate : function()
    {
        if(this.mState === this.state.PLAYING)
        {
            var frameSkip = Math.floor((Core.Time.getFrameTime() - this.mStartTime) / this.frameRate ) - this.currentFrame;

            if(this.style === this.animationStyle.NORMAL && frameSkip > 0)
            {
                frameSkip = 1;
            }

            var idx = 0;
            if(0 === frameSkip &&
                this.style === this.animationStyle.INTER_FRAME_INTERPOLATED)
            {
                this._OnUpdateFrame();
            }

            for(idx = 0; idx < frameSkip && this.mState === this.state.PLAYING ; ++idx)
            {
                ++this.currentFrame;
                this._OnUpdateFrame();
            }

            var len = this.mMotionData.length;
            for(idx = 0; idx < len; ++idx)
            {
                var obj = this.mMotionData[idx];
                var pos = obj.src.getPosition();
                if(obj.pos_x !== undefined && obj.pos_y !== undefined &&
                   (obj.pos_x != pos.getX() || obj.pos_y != pos.getY()))
                {
                    obj.src.setPosition(obj.pos_x, obj.pos_y);
                }

                if(obj.rot !== undefined &&
                   obj.src.getRotation() != obj.rot)
                {
                    obj.src.setRotation(obj.rot);
                }

                if (obj.src.classname === 'Body')
                {
                    if(obj.scale_x !== undefined && obj.scale_y !== undefined &&
                        (obj.src.getGL2Node().getScale().getX() != obj.scale_x ||
                         obj.src.getGL2Node().getScale().getY() != obj.scale_y ))
                    {
                        obj.src.getGL2Node().setScale(obj.scale_x, obj.scale_y );
                    } 

                    if(obj.alpha !== undefined && 
                        obj.alpha != obj.src.getGL2Node().getAlpha())
                    {
                        obj.src.getGL2Node().setAlpha(obj.alpha);
                    }

                    if (obj.src.getGL2Node().classname === 'Primitive' && 
                        obj.skewX !== undefined && obj.skewY !== undefined )
                    {
                        this._setSkew(obj, obj.src.getGL2Node(), obj.skewX, obj.skewY);
                        obj.skewX = undefined;
                        obj.skewY = undefined;
                    }
                }
                else
                {
                    if(obj.scale_x !== undefined && obj.scale_y !== undefined &&
                        (obj.src.getScale().getX() != obj.scale_x ||
                         obj.src.getScale().getY() != obj.scale_y ))
                    {
                        obj.src.setScale(obj.scale_x, obj.scale_y );
                    } 
                    
                    if(obj.alpha !== undefined && 
                        obj.alpha != obj.src.getAlpha())
                    {
                        obj.src.setAlpha(obj.alpha);
                    }

                    if (obj.src.classname === 'Primitive' && 
                        obj.skewX !== undefined && obj.skewY !== undefined )
                    {
                        this._setSkew(obj, obj.src, obj.skewX, obj.skewY);
                        obj.skewX = undefined;
                        obj.skewY = undefined;
                    }
                }
            }
        }
    }
}); // end of class MotionController
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Motion'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Motion'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Motion'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Motion.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var MotionController = require('NGGo/Framework/MotionController').MotionController;

var MotionObject = Class.subclass(
{
    classname : "MotionObject",

    setCallbackObj : function(cb)
    {
        this.callbackObj = cb;
    },

    onMotionStateChange : function(controller)
    {
        if(controller.getState() === MotionController.state.COMPLETED && this.callbackObj)
        {
            this.callbackObj.onMotionStateComplete(this);
            console.log("Output");
        }
    }
});

////////////////////////////////////////////////////////////////////////////////
// Class MotionFactory
exports.MotionFactory = Component.subclass(
/** @lends Framework.FlowScript.MotionFactory.prototype */
{
    classname : "MotionFactory",
   
    outPorts : {
        MOTION : 0,
        ERROR : 1
    },

    _onReceive : function(port, ip)
    {
        var motionObj = new MotionObject();

        var motions = [ { src : ip.active, name : this._iip.required.name } ];
        var motion = new MotionController(motions, motionObj);
        
        motionObj.xMotion = motion;
        motionObj.xDef = motions;

        ip.active = motionObj;
        ip.motion = motionObj;

        this.send(this.outPorts.MOTION, ip);
    }
}); // end of class MotionFactory

exports.MotionFactory.factoryUUID = UUID.MOTION_FACTORY;

////////////////////////////////////////////////////////////////////////////////
// Class MotionPlayer
exports.MotionPlayer = Component.subclass(
/** @lends Framework.FlowScript.MotionPlayer.prototype */
{
    classname : "MotionPlayer",

    inPorts : {
        PLAY : 0,
        STOP : 1
    },

    outPorts : {
        OUT : 0,
        ON_MOTION_COMPLETE : 1,
        ERROR : 2
    },
    
    _onReceive : function(port, ip)
    {
        switch(port)
        {
            case this.inPorts.PLAY:
                ip.active.setCallbackObj(this);
                ip.active.xMotion.play(true);
                this.send(this.outPorts.OUT, ip);
                break;
            
            case this.inPorts.STOP:
                // Stop is not working at the moment
                this.send(this.outPorts.OUT, ip);
                break;

            default:
                this.send(this.outPorts.ERROR, ip);
                break;
        }
    },


    onMotionStateComplete : function(motion)
    {
        var ip = {};
        ip.active = motion;
        this.send(this.outPorts.ON_MOTION_COMPLETE, ip);
    }

}); // end of class MotionPlayer

exports.MotionPlayer.factoryUUID = UUID.MOTION_PLAYER;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Simulator'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Simulator'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Simulator'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Simulator.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class     = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var Core      = require('NGCore/Client/Core').Core;
var UUID      = require('NGGo/Framework/FlowScript/Component').UUID;

var _SimulatorUpdate = Core.MessageListener.subclass(
{
    initialize : function(listener)
    {
        this._listener = listener;
        Core.UpdateEmitter.addListener(this, this._OnUpdate);
    },

    _OnUpdate : function(delta)
    {
        this._listener._OnUpdate(delta);
    }
});

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.Simulator = Component.subclass(
/** @lends Framework.FlowScript.Components.Simulator.prototype */
{
    classname : "Simulator",

    outPorts :
    {
        SIMULATOR_TICK : 0,
        SIMULATOR_FIRST_TICK : 1
    },

    _onPostOpen : function()
    {
        this._updater = new _SimulatorUpdate(this);
        this._firstTick = true;
    },

    _OnUpdate : function(delta)
    {
        var ip = {};
        ip.delta = delta;
        if(this._firstTick)
        {
            ip.log = "First Tick of NGGo Simulator Module\n";
            this.send(this.outPorts.SIMULATOR_FIRST_TICK, ip);
            this._firstTick = false;
        }
        ip.log = "Created by NGGo Simulator Module\n";
        this.send(this.outPorts.SIMULATOR_TICK, ip);
    }
}); // end of class Component
exports.Simulator.factoryUUID = UUID.SIMULATOR;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/ActiveEffect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/ActiveEffect'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/ActiveEffect'] = exports; 
var __dirname = 'NGCore/Client/Audio';
var __filename = 'NGCore/Client/Audio/ActiveEffect.js';

var Core = require('NGCore/Client/Core').Core;

exports.ActiveEffect = Core.Class.subclass(
/** @lends Audio.ActiveEffect.prototype */
{
	/**
	 * @class The <code>ActiveEffect</code> class constructs objects that control 
	 * the reproduction of an audio effect. Audio effects in Mobage applications are captured as 
	 * <code>{@link Audio.Effect}</code> objects, which load data for an audio effect into memory. 
	 * This separation allows applications to manage effect data independently of effect 
	 * reproduction.
	 * <br /><br />
	 * You must specify the <code>{@link Audio.Effect}</code> object to reproduce when you
	 * instantiate the <code>ActiveEffect</code> object. After instantiation, you cannot change
	 * which <code>{@link Audio.Effect}</code> object is associated with the
	 * <code>ActiveEffect</code> object.
	 * <br /><br />
	 * <strong>Important</strong>: See <code>{@link Audio.Effect}</code> for information about the
	 * maximum size of audio resources.
	 * @example
	 * var effect = new Audio.Effect('some_effect.wav');
	 * var activeEffect = new Audio.ActiveEffect(effect);
	 * activeEffect.play();
	 * @constructs The default constructor. 	 
	 * @augments Core.Class
	 * @param {Audio.Effect} effect The <code>{@link Audio.Effect}</code> that this <code>ActiveEffect</code> object plays.
	 * @see Audio.Effect
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	initialize: function(effect)
	{
		this._volume  = 1.0;
		this._loops   = false;
		this._playing = false;
		this._paused  = false;

		this._playCompleteEmitter = new Core.MessageEmitter();

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._setEffect(effect);
	},
	
	/**
	 * Destroy this instance and releases resources on the backend.
	 * <b>Note:</b> This call does not automatically destroy the associated <code>{@link Audio.Effect}</code>.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		this.stop();
		this._effect = null;
		this._playCompleteEmitter.destroy();
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
	
	/**
	 * Return the volume level for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Number} The current volume level.
	 * @see Audio.ActiveEffect#setVolume
	 * @status iOS, Android, Flash, Test
	 * @since 1.0
	 */
	getVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the volume level for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * Calling this changes the volume even if an application is in the middle of reproducing an <code>{@link Audio.Effect}</code> object.
	 * The new volume level applies to any subsequent reproductions of the <code>{@link Audio.Effect}</code> object.
	 * @example Audio.ActiveEffect.setVolume(0.5);
	 * @param {Number} [volume=1] The new volume level. Supported values range between <code>(0-1)</code>. 
	 * @returns {this}
	 * @see Audio.ActiveEffect#getVolume
	 * @status iOS, Android, Flash
	 * @since 1.0
	 */
	setVolume: function(volume)
	{
		if (volume < 0.0) volume = 0.0;
		if (volume > 1.0) volume = 1.0;

		this._volume = volume;
		this._setVolumeSendGen(volume);
		return this;
	},
	
	/**
	 * Return the loop status for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if looping is enabled.
	 * @see Audio.ActiveEffect#setLoops
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getLoops: function()
	{
		return this._loops;
	},
	
	/**
	 * Set the loop state for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * A looped effect wraps seamlessly from begining to end.
	 * @example Audio.ActiveEffect.setLoops(true);
	 * @param {Boolean} loops Set as <code>true</code> to enable looping.
	 * @returns {this}
	 * @see Audio.ActiveEffect#getLoops
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setLoops: function(loops)
	{
		this._loops = loops;
		this._setLoopsSendGen(loops);
		return this;
	},
	
	/**
	 * Retrieve the <code>PlayComplete</code> emitter for the <code>{@link Audio.Effect}</code> this
	 * <code>ActiveEffect</code> is reproducing. The <code>PlayComplete</code> emitter notifies
	 * its listeners when reproduction of an <code>{@link Audio.Effect}</code> is complete, passing
	 * the <code>ActiveEffect</code> object to the listener.
	 * <br /><br />
	 * <strong>Note</strong>: An <code>{@link Audio.Effect}</code> that loops will not trigger the
	 * <code>PlayComplete</code> emitter.
	 * @example
	 * var AudioSample = Core.MessageListener.subclass({
	 *     initialize: function() {
	 *         this._effect = new Audio.Effect("path/to/effect");
	 *         this._activeEffect = new Audio.ActiveEffect(this._effect);
	 *     },
	 *     
	 *     addListener: function() {
	 *         this._activeEffect.getPlayCompleteEmitter().
	 *           addListener(this, this.onComplete.bind(this));
	 *     },
	 *
	 *     onComplete: function(activeEffect) {
	 *         activeEffect.getPlayCompleteEmitter().removeListener(this);
	 *         activeEffect.destroy();
	 *         this._activeEffect = null;
	 *         console.log("Play completed");
	 *     }
	 * });
	 * @returns {Core.MessageEmitter} The current state of the <code>PlayComplete</code> emitter.
	 * @status iOS, Flash, Test, FlashTested
	 * @since 1.0
	 */
	getPlayCompleteEmitter: function()
	{
		return this._playCompleteEmitter;
	},
	
	/**
	 * Return the play status of the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if this <code>ActiveEffect</code> is reproducing an <code>{@link Audio.Effect}</code>.
	 * @see Audio.ActiveEffect#play
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getIsPlaying: function()
	{
		return this._playing;
	},
	
	/**
	 * Return the pause status of the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if this <code>{@link Audio.Effect}</code> is in a paused state.
	 * @see Audio.ActiveEffect#pause
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getIsPaused: function()
	{
		return this._paused;
	},
	
	/**
	 * Begin reproducing an <code>{@link Audio.Effect}</code>.
	 * <ul>
	 * <li>If this <code>{@link Audio.Effect}</code> is new or in a stopped state,
	 * reproduction starts at the beginning.</li>
	 * <li>If this <code>{@link Audio.Effect}</code> is in a paused state, reproduction resumes from the previous position.</li>
	 * <li>If this <code>{@link Audio.Effect}</code> is playing, this call does nothing.</li>
	 * </ul>
	 * @see Audio.ActiveEffect#getIsPlaying
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	play: function()
	{
		this._playing = true;
		this._paused  = false;
		this._playSendGen( );
	},
	
	/**
	 * Pause reproduction of an <code>{@link Audio.Effect}</code>.
	 * <ul>
	 * <li>If this <code>ActiveEffect</code> is in the process of reproducing an <code>{@link Audio.Effect}</code>, this call pauses reproduction.</li>
	 * <li>If the <code>{@link Audio.Effect}</code> is in a stopped or paused state, this call does nothing.</li>
	 * </ul>
	 * <b>Note:</b> Calling this does not trigger the <code>Play Complete</code> emitter.
	 * @see Audio.ActiveEffect#getIsPaused
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	pause: function()
	{
		this._playing = false;
		this._paused  = true;
		this._pauseSendGen( );
	},
	
	/**
	 * Stop reprodution of an <code>{@link Audio.Effect}</code> object.
	 * <ul>
	 * <li>If this <code>ActiveEffect</code> is currently reproducing an <code>{@link Audio.Effect}</code> or the <code>{@link Audio.Effect}</code> is in a paused state, this call stops reproduction.</li>
	 * <li>If the <code>{@link Audio.Effect}</code> is in a stopped state, this call does nothing.</li>
	 * </ul>
	 * <b>Note:</b> Calling <code>stop()</code> does not trigger the <code>Play Complete</code> emitter.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	stop: function()
	{
		this._playing = false;
		this._paused  = false;
		this._stopSendGen( );
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 328,
	// Method create = -1
	// Method destroy = 2
	// Method setVolume = 3
	// Method setLoops = 4
	// Method play = 5
	// Method pause = 6
	// Method stop = 7
	// Method setEffect = 8
	// Method playComplete = 9
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 9:
					instance._playCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in ActiveEffect._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in ActiveEffect._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[328] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_playCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in ActiveEffect.playComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x148ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1480002, this );
	},
	
	/** @private */
	_setVolumeSendGen: function( volume )
	{
		Core.Proc.appendToCommandString( 0x1480003, this, [ +volume ] );
	},
	
	/** @private */
	_setLoopsSendGen: function( loops )
	{
		Core.Proc.appendToCommandString( 0x1480004, this, [ ( loops ? 1 : 0 ) ] );
	},
	
	/** @private */
	_playSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1480005, this );
	},
	
	/** @private */
	_pauseSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1480006, this );
	},
	
	/** @private */
	_stopSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1480007, this );
	},
	
	/** @private */
	_setEffectSendGen: function( effectId )
	{
		Core.Proc.appendToCommandString( 0x1480008, this, [ +effectId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setVolume: function( volume ) {}
	
	// setLoops: function( loops ) {}
	
	// play: function(  ) {}
	
	// pause: function(  ) {}
	
	// stop: function(  ) {}
	
	// setEffect: function( effectId ) {}
	
	// _playCompleteRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


	,
	_setEffect: function(effect)
	{
		this._effect  = effect;
		this._setEffectSendGen(this._effect.__objectRegistryId);
		return this;
	},

	_playCompleteRecv: function( cmd )
	{
		var msg = {};
		if(!this._playCompleteRecvGen(cmd, msg))
			return;

		this._playing = false;
		this._paused  = false;

		this._playCompleteEmitter.emit(this);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Diagnostics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Diagnostics'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Diagnostics'] = exports; 
var __dirname = 'NGCore/Client/Audio';
var __filename = 'NGCore/Client/Audio/Diagnostics.js';

////////////////////////////////////////////////////////////////////////////////
// Class Diagnostics
// Audio diagnostic emitter; collects info from Audio subsystem.
//
// Copyright (C) 2012 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////
    
//
// Create and export a DiagnosticEmitter for Audio.
//

exports.Diagnostics = Core.DiagnosticEmitter.singleton(
{
	classname: 'Audio_Diagnostics',

	/**
	 * @class The <code>Audio.Diagnostics</code> class provides detailed diagnostic information
	 * about classes in the <code>Audio</code> module. You can use this information to debug your
	 * app's use of the <code>Audio</code> module and learn more about the app's performance.
	 * <br /><br />
	 * The emitter emits an object of the form:
	 * <br /><br />
	 * <pre>
	 * {
	 *     name: "Audio",                       // The emitter's name
	 *     effects: {
	 *         count: {Number},                 // Total number of effects
	 *         effectPaths: {String[]}          // Paths to the effects
	 *     },
	 *     volume: {Number},                    // Audio volume, from 0 (muted) to 1 (full volume)
	 *     audio_update_time: {Timer}           // Time spent processing effects
	 *     audio_update_detached_time: {Timer}, // Time spent processing detached sounds
	 *     audio_update_music_time: {Timer},    // Time spent processing music
	 *     activeEffects: {
	 *         count: {Number}                  // Number of ActiveEffect objects
	 *     },
	 *     detachedSounds: {                    // Number of detached sounds
	 *         count: {Number}
	 *     },
	 *     music: {
	 *         filename: {String},              // Path to the background music file
	 *         isPlaying: {Boolean},            // Set to true if the background music is playing
	 *         volume: {Number},                // Background music volume, from 0 (muted) to 1 (full volume)
	 *         currentTime: {Number}            // Elapsed playback time, in milliseconds
	 *     },
	 *     totalMemory: {Number}                // Total memory, in bytes, used for music and effects
	 * }
	 * </pre>
	 * The <code>Timer</code> type is an object of the form:
	 * <br /><br />
	 * <pre>
	 * {
	 *     samples: {Number},   // Number of samples that were captured
	 *     average: {Number},   // Average time spent in the timed block
	 *     min: {Number},       // Minimum time spent in the timed block
	 *     max: {Number}        // Maximum time spent in the timed block
	 * }
	 * </pre>
	 * @name Audio.Diagnostics
	 * @constructs
	 * @augments Core.DiagnosticEmitter
	 * @singleton
	 * @since 1.8
	 */
	
	initialize: function($super)
	{
	$super('Audio');
	this._includeDetails = false;
	},

	/**
	 * @this Diagnostics
	 * @private
	 */
	includeDetails: function()
	{
		return this._includeDetails;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Device'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Device'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Device'] = exports; 
var __dirname = 'NGCore/Client/Audio';
var __filename = 'NGCore/Client/Audio/Device.js';

var Core = require('NGCore/Client/Core').Core;
var Diagnostics = require('NGCore/Client/Audio/Diagnostics').Diagnostics;

exports.Device = Core.Class.singleton(
/** @lends Audio.Device.prototype */
{
	classname: 'Device',

	/**
	 * @class The <code>Device</code> class constructs a singleton object that contains audio device properties.
	 * Applications can use <code>Device</code> objects to control global audio effects volume 
	 * and reproduce detached audio effects.
	 * @singleton
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @since 1.0
	 */
	 
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._volume = (Core.Capabilities.getPlatformOS().toLowerCase() == 'flash') ? 1.0 : undefined; // default value

		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var initialValues = KeyValueCache.global("Audio.Device.InitialValues");

		var self = this;
		initialValues.getItem("effectsVolume", {}, function(error, value) {
			if (error) {
				NgLogW('Audio.Device: failed in getting device volume: ' + error);
				self._volume = 1.0; // fallback to 1.0
			} else
				self._volume = parseFloat(value);
		});

		/** @private */
		this.resetEffectsRequests = {};
		/** @private */
		this.cbIdCounter = 1;

		/** @private */
		this.effectCount = 0;
		this.effectList = [];
		Diagnostics.pushCollector(this.collectDeviceInfo.bind(this));
	},
	
	/**
	 * Return the global sound effects volume for this <code>Device</code> object.
	 * @returns {Number} The current global sound effects volume.
	 * @see Audio.Device#setEffectsVolume	 
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	getEffectsVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the global sound effects volume for this <code>Device</code> object.
	 * Volume for each active effect multiplies
	 * by this value to produce a new volume level. 
	 * For example, if the global sound effects volume is set to 0.5, each active effect will play at half the volume set on the effect.
	 * @param {Number} [effectsVolume=1] The new volume for global sound effects. 
	 * Supported values range between <code>(0-1)</code>. 
	 * @example Audio.Device.setEffectsVolume(0.5);
	 * @returns {this}
	 * @see Audio.Device#getEffectsVolume
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @since 1.0
	 */
	setEffectsVolume: function(effectsVolume)
	{
		if (effectsVolume < 0.0) effectsVolume = 0.0;
		if (effectsVolume > 1.0) effectsVolume = 1.0;

		this._volume = effectsVolume;
		this._setEffectsVolumeSendGen(effectsVolume);
		return this;
	},
	
	/**
	 * Play an audio effect in a way that is completely detached from upstream or downstream processing.
	 * Using this call is a simple, high-level way to reproduce an audio effect.<br /><br />
	 * The specified audio effect is only reproduced once.
	 * There is no control over the effect volume or effect playback.
	 * Resource allocation automatically occurs on the backend when playback begins. Resources are automatically released when playback ends.	 
	 * The following code is an example of a <code>playDetached()</code> call.
	 * @example
	 * Audio.Device.playDetached('Content/explosion.wav');
	 * @param {String} path A relative directory path to the audio file.
	 * @returns {this}
	 * @deprecated Since version 1.7. This method will be removed in a future version of ngCore.
	 *		Calling this method can lead to poor performance on some Android devices.  Use the
	 *		{@link Audio.ActiveEffect} and {@link Audio.Effect} classes rather than this method.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	playDetached: function(path)
	{
		this._playDetachedSendGen( path );
		return this;
	},

	/**
	 * Reset all audio effects on a device running Android 2.3 or earlier. These versions of
	 * Android can load only 255 simultaneous effects. You must recreate all of the application's
	 * <code>ActiveEffect</code> objects after calling this method.
	 * <br /><br />
	 * On iOS, and on devices running later versions of Android, this method has no effect.
	 * <br /><br />
	 * <strong>Important</strong>: This method is synchronous, and calling this method can result in
	 * a noticeable delay in your application. Be sure to call the method at a time when the user
	 * will not notice the delay (for example, during a transition between levels).
	 * @name Audio.Device#resetEffects
	 * @function
	 * @returns {void}
	 * @status Android, Test, AndroidTested
	 * @since 1.7
	 */
	
	resetEffects: function( cb )
	{
		var cbId = 0;

		if (Core.Capabilities.getPlatformOS().toLowerCase() == 'android')
		{
			if (cb)
			{
				cbId = this.cbIdCounter++;
				this.resetEffectsRequests[ cbId ] = cb;
			}

			this._resetEffectsSendGen(cbId);
		}
		else if(typeof(cb) == 'function')
		{
			cb();
		}
		return this;
	},
	
	/**
	 * @private
	 */
	_resetEffectsCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._resetEffectsCbRecvGen(cmd, msg))
			return;

		var cbId = msg[ "callbackId" ];

		if ( !cbId )
		{
			//NgLogE ( "Audio Device command : No cbId" );
			return;
		}

		var cb = this.resetEffectsRequests[ cbId ];

		if ( !cb )
		{
			NgLogE ( "Audio Device command : No registered cb found..cbId is :" + cbId );
			return;
		}

		delete this.resetEffectsRequests[ cbId ];

		cb ( );
	},

	effectCreated: function(path)
	{
		this.effectCount++;
		this.effectList.push( path  );
	},

	effectDestroyed: function()
	{
		var index = this.effectList.indexOf(this._path);
		if(index >=0)
		{
			this.effectList.splice(index, 1);
		}
		this.effectCount--;
	},

	//Diagnostics collector
	collectDeviceInfo: function(type, interval)
	{
		var collectedInfo = { volume: this._volume };
		if(Diagnostics.includeDetails())
		{
			collectedInfo['effects'] = { count: this.effectCount, effectPaths: this.effectList };
		}
		else
		{
			collectedInfo['effects'] = { count: this.effectCount };
		}

		return collectedInfo;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 327,
	// Method create = -1
	// Method setEffectsVolume = 2
	// Method playDetached = 3
	// Method resetEffects = 4
	// Method resetEffectsCb = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._resetEffectsCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Device._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Device._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[327] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_resetEffectsCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Device.resetEffectsCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in Device.resetEffectsCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x147ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_setEffectsVolumeSendGen: function( effectsVolume )
	{
		Core.Proc.appendToCommandString( 0x1470002, this, [ +effectsVolume ] );
	},
	
	/** @private */
	_playDetachedSendGen: function( path )
	{
		Core.Proc.appendToCommandString( 0x1470003, this, [ Core.Proc.encodeString( path ) ] );
	},
	
	/** @private */
	_resetEffectsSendGen: function( callbackId )
	{
		Core.Proc.appendToCommandString( 0x1470004, this, [ +callbackId ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setEffectsVolume: function( effectsVolume ) {}
	
	// playDetached: function( path ) {}
	
	// resetEffects: function( callbackId ) {}
	
	// _resetEffectsCbRecv: function( cmd ) {}
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Effect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Effect'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Effect'] = exports; 
var __dirname = 'NGCore/Client/Audio';
var __filename = 'NGCore/Client/Audio/Effect.js';

var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Audio/Device').Device;

exports.Effect = Core.Class.subclass(
/** @lends Audio.Effect.prototype */
{
	/**
	 * @class The <code>Effect</code> class constructs objects for handling audio resources that comprise an audio effect.
	 * Instantiating these objects allocates resources on the backend.
	 * After creating an <code>Effect</code> object, applications can control reproduction through an <code>{@link Audio.ActiveEffect}</code> object.
	 * <br /><br />
	 * No more than 255 <code>Effect</code> objects can be played simultaneously. Additional <code>Effect</code> objects can be created, but they will not be played.
	 * <br /><br />
	 * <strong>Important</strong>: The audio resource for the <code>Effect</code> object must be
	 * no larger than 1 MB. If your application attempts to play a larger file, it will result in an
	 * error during playback. Take the following steps to minimize the size of your application's
	 * audio resources:
	 * <ul>
	 * <li>Limit the bit rate of your audio resources.</li>
	 * <li>Where possible, use mono audio resources rather than stereo.</li>
	 * <li>Where possible, limit the duration of your audio resources.</li>
	 * </ul>
	 * @example
	 * var effect = new Audio.Effect('Content/explosion.wav');
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @param {String} path A directory path that points to the audio file to load.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	initialize: function(path)
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._setPath(path);

		Device.effectCreated(path);
	},
	
	/**
	 * Destroy this instance and release resources on the backend.
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);

		Device.effectDestroyed();
	},
	
	/**
	 * Set a directory path to the audio file resource for this <code>Effect</code> object.
	 * @param {String} path The new directory path.
	 * @returns {this}
	 * @since 1.0
	 */
	_setPath: function(path)
	{
		this._path = path;
		this._setPathSendGen(path);
		return this;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	_classId: 326,
	// Method create = -1
	// Method destroy = 2
	// Method setPath = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Effect._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Effect._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[326] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x146ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1460002, this );
	},
	
	/** @private */
	_setPathSendGen: function( path )
	{
		Core.Proc.appendToCommandString( 0x1460003, this, [ Core.Proc.encodeString( path ) ] );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPath: function( path ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}



});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Music'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Music'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Music'] = exports; 
var __dirname = 'NGCore/Client/Audio';
var __filename = 'NGCore/Client/Audio/Music.js';

var Core = require('NGCore/Client/Core').Core;

exports.Music = Core.Class.singleton(
/** @lends Audio.Music.prototype */
{
	classname: 'Music',

	/**
	 * @class The <code>Music</code> class constructs a singleton object that provides control over reproduction
	 * of application background music.
	 * This object is constructed independently of <code>Device</code> objects because many devices
	 * already provide hardware-accelerated streaming and decode
	 * for a single background music track. Some
	 * devices gracefully mute a background music track
	 * if the user is playing a music track from their own library.
	 * @singleton
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @since 1.0
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._path    = null;
		this._playing = false;
		this._paused  = false;
		this._volume  = 1.0;
		this._currentTimeCode = 0;
		this._stateChangeEmitter = new Core.MessageEmitter();
		this._timeCodeEmitter    = new this._TimeCodeEmitter();
		this._updateListener     = new this._TimeCodeListener(this._timeCodeEmitter);
		Core.UpdateEmitter.addListener(this._updateListener, this._updateListener.onUpdate);
	},

	destroy: function()
	{
		Core.UpdateEmitter.removeListener(this._updateListener);
		this._stateChangeEmitter.destroy();
		this._timeCodeEmitter.destroy();
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Return the directory path to the background music track that the application is using.
	 * @returns {String} The directory path to a music track.
	 * @see Audio.Music#setPath
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getPath: function()
	{
		return this._path;
	},
	
	/**
	 * Set the directory path for the background music track that the application is using.<br /><br />
	 * <b>Note:</b> If the application is reproducing music when this is called, reproduction will stop.
	 * The application must call <code>play()</code> again to start reproduction of the new resource.<br /><br />
	 * The code in the following example sets a directory path to a music resource and plays that resource.
	 * @example
	 * Audio.Music.setPath('Content/music.mp3');
	 * Audio.Music.play();
	 * @param {string} path The new directory path to a music track.
	 * @see Audio.Music#getPath
	 * @see Audio.Music#play
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setPath: function(path)
	{
		if(path == null)
		{
			throw new Error('Audio.Music setPath(): no path was provided');
		}

		this._path = path;
		this._setPathSendGen(path);
	},
	
	/**
	 * Return the volume level used for reproduction of the application's background music track.
	 * @returns {Number} The current volume level.
	 * @see Audio.Music#setVolume
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the volume level used for reproduction of the application's background music track.
	 * This call instantly modifies the background music volume level.
	 * Any subsequent reproductions of background music will play at the specified volume.
	 * @example Audio.Music.setVolume(0.5);
	 * @param {Number} [volume=1] The new volume. Supported values range between <code>(0-1)</code>.
	 * @returns {this}
	 * @see Audio.Music#getVolume
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	setVolume: function(volume)
	{
		if (volume < 0.0) volume = 0.0;
		if (volume > 1.0) volume = 1.0;

		this._volume = volume;
		this._setVolumeSendGen(volume);
		return this;
	},
	
	/**
	 * Return the playback state of the background music track.
	 * @returns {Boolean} Returns <code>true</code> if an application is reproducing background music.
	 * @see Audio.Music#play
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getIsPlaying: function()
	{
		return this._playing;
	},
	
	/**
	 * Return the pause state of the background music track.
	 * @returns {Boolean} Returns <code>true</code> if an application is reproducing background music.
	 * @see Audio.Music#pause
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	getIsPaused: function()
	{
		return this._paused;
	},
	
	/**
	 * Begin playback of the background music track.
	 * <ul>	
	 * <li>If the background music track has not yet been played, or the application has stopped the background music track, 
	 * this call begins reproduction from the beginning.</li>
	 * <li>If the background music track is in a paused state, this call resumes reproduction from the previous position.</li>
	 * <li>If the background music track is currently playing, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#getIsPlaying
	 * @see Audio.Music#pause
	 * @see Audio.Music#stop
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	play: function()
	{
		this._playing = true;
		this._paused  = false;
		this._playSendGen( );
	},
	
	/**
	 * Pause playback of the background music track.
	 * <ul>
	 * <li>If an application is currently playing the background music track, this call pauses playback.</li>
	 * <li>If the background music track is in a paused or stopped state, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#getIsPaused
	 * @see Audio.Music#play
	 * @see Audio.Music#stop
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	pause: function()
	{
		this._playing = false;
		this._paused  = true;
		this._pauseSendGen( );
	},
	
	/**
	 * Stop playback of the background music track.
	 * <ul>
	 * <li>If the background music track is playing or in a paused state, this call stops playback.</li>
	 * <li>If the background music track is in a stopped state, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#play
	 * @see Audio.Music#pause
	 * @returns {void}
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested, FlashTested
	 * @since 1.0
	 */
	stop: function()
	{
		this._playing = false;
		this._paused  = false;
		this._stopSendGen( );
	},
	
	/**
	 * Indicate whether the background music track should be reproduced in a loop. By default,
	 * the background music track will loop until the application calls
	 * <code>{@link Audio.Music#pause}</code> or <code>{@link Audio.Music#stop}</code>.
	 * @param {Boolean} toLoop Set to <code>false</code> if the background music track should not be reproduced in a
	 *		loop.
	 * @returns {void}
	 * @see Audio.Music#pause
	 * @see Audio.Music#stop
	 * @since 1.6
	 */
	setLoop: function( toLoop )
	{
		this._setLoopSendGen(toLoop);
	},
	
	/**
	 * Retrieve the state change emitter for the background music track. The emitter's listeners
	 * will receive an enumerated value of <code>{@link Audio.Music#PlayState}</code> when the
	 * playback state changes.
	 * @returns {Core.MessageEmitter} The state change emitter for the background music track.
	 * @since 1.6
	 */
	getStateChangeEmitter: function()
	{
		return this._stateChangeEmitter;
	},

	/**
	 * Retrieve the time code emitter for the background music track. The emitter's listeners will
	 * receive the time code, in milliseconds, of the background music track.
	 * @returns {Core.MessageEmitter} The time code emitter for the background music track.
	 * @since 1.6
	 */
	getTimeCodeEmitter: function()
	{
		return this._timeCodeEmitter;
	},

	/**
	 * Retrieve the current time code (playback position) of the background music track.
	 * @returns {Number} The background music track's current time code, in milliseconds.
	 * @since 1.6
	 */
	getCurrentTimeCode: function()
	{
		return this._currentTimeCode;
	},
	
	
	/**
	 * Enumeration for the background music track's current playback state.
	 * @name PlayState
	 * @fieldOf Audio.Music#
	 * @since 1.6
	 */
	
	/**
	 * The music track is stopped.
	 * @name PlayState.Stop
	 * @fieldOf Audio.Music#
	 * @constant
	 * @since 1.6
	 */
	
	/**
	 * The music track is playing.
	 * @name PlayState.Play
	 * @fieldOf Audio.Music#
	 * @constant
	 * @since 1.6
	 */
	
	/**
	 * The music track is paused.
	 * @name PlayState.Pause
	 * @fieldOf Audio.Music#
	 * @constant
	 * @since 1.6
	 */
	

// {{?Wg Generated Code}}
	
	// Enums.
	PlayState:
	{ 
		Stop: 0,
		Play: 1,
		Pause: 2
	},
	
	///////
	// Class constants (for internal use only):
	_classId: 329,
	// Method create = -1
	// Method destroy = 2
	// Method setPath = 3
	// Method setVolume = 4
	// Method play = 5
	// Method pause = 6
	// Method stop = 7
	// Method playComplete = 8
	// Method updatePlayState = 9
	// Method updateTimeCode = 10
	// Method setLoop = 11
	// Method _startTimeCodeUpdating = 12
	// Method _stopTimeCodeUpdating = 13
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 8:
					instance._playCompleteRecv( cmd );
					break;
				case 9:
					instance._updatePlayStateRecv( cmd );
					break;
				case 10:
					instance._updateTimeCodeRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Music._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Music._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) === 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[329] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_playCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Music.playComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_updatePlayStateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Music.updatePlayState from command: " + cmd );
			return false;
		}
		
		obj[ "state" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "state" ] === undefined )
		{
			NgLogE("Could not parse state in Music.updatePlayState from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_updateTimeCodeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length !== 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Music.updateTimeCode from command: " + cmd );
			return false;
		}
		
		obj[ "elapsedMilliSecond" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "elapsedMilliSecond" ] === undefined )
		{
			NgLogE("Could not parse elapsedMilliSecond in Music.updateTimeCode from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( 0x149ffff, [ +__objectRegistryId ] );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1490002, this );
	},
	
	/** @private */
	_setPathSendGen: function( path )
	{
		Core.Proc.appendToCommandString( 0x1490003, this, [ Core.Proc.encodeString( path ) ] );
	},
	
	/** @private */
	_setVolumeSendGen: function( volume )
	{
		Core.Proc.appendToCommandString( 0x1490004, this, [ +volume ] );
	},
	
	/** @private */
	_playSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1490005, this );
	},
	
	/** @private */
	_pauseSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1490006, this );
	},
	
	/** @private */
	_stopSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x1490007, this );
	},
	
	/** @private */
	_setLoopSendGen: function( toLoop )
	{
		Core.Proc.appendToCommandString( 0x149000b, this, [ ( toLoop ? 1 : 0 ) ] );
	},
	
	/** @private */
	__startTimeCodeUpdatingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x149000c, this );
	},
	
	/** @private */
	__stopTimeCodeUpdatingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( 0x149000d, this );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPath: function( path ) {}
	
	// setVolume: function( volume ) {}
	
	// play: function(  ) {}
	
	// pause: function(  ) {}
	
	// stop: function(  ) {}
	
	// _playCompleteRecv: function( cmd ) {}
	// _updatePlayStateRecv: function( cmd ) {}
	// _updateTimeCodeRecv: function( cmd ) {}
	// setLoop: function( toLoop ) {}
	
	// _startTimeCodeUpdating: function(  ) {}
	
	// _stopTimeCodeUpdating: function(  ) {}
	
	
	0:0 // tame jslint/Closure Compiler for trailing comma.
// {{/Wg Generated Code}}


	,
	_playCompleteRecv: function( cmd )
	{
		var msg = {};
		if(!this._playCompleteRecvGen(cmd, msg))
			return;

		this._playing = false;
		this._paused  = false;
	},

	_updatePlayStateRecv: function( cmd )
	{
		if (this._stateChangeEmitter.getListenerCount() === 0)
			return;

		var msg = {};
		if(!this._updatePlayStateRecvGen(cmd, msg))
			return;

		this._stateChangeEmitter.emit(msg.state);
	},

	_updateTimeCodeRecv: function( cmd )
	{
		var msg = {};
		if(!this._updateTimeCodeRecvGen(cmd, msg))
			return;

		this._currentTimeCode = msg.elapsedMilliSecond;
	},

	_TimeCodeListener: Core.MessageListener.subclass({
		classname: '_TimeCodeListener',

        /**
         * @this _TimeCodeListener
         * @private
         */
		initialize: function(emitter)
		{
			this._emitter = emitter;
		},

        /**
         * @this _TimeCodeListener
         * @private
         */
		onUpdate: function()
		{
			var timeCode = exports.Music.getCurrentTimeCode();
			this._emitter.emit(timeCode);
		}
	}),

	_TimeCodeEmitter: Core.MessageEmitter.subclass({
		classname: '_timeCodeEmitter',

        /**
         * @this _timeCodeEmitter
         * @private
         */
		addListener: function($super, listener, func, priority) {
			if (this.getListenerCount() === 0)
				exports.Music.__startTimeCodeUpdatingSendGen();
			$super(listener, func, priority);
		},
        /**
         * @this _timeCodeEmitter
         * @private
         */
		removeListener: function($super, listener) {
			$super(listener);
			if (this.getListenerCount() === 0)
				exports.Music.__stopTimeCodeUpdatingSendGen();
		}
	})
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio'] = exports; 
var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Audio.js';

/**
 * <p>Classes and objects contained by the Audio module.</p>
 * @name Audio
 * @namespace Play music and sound effects.
 * @description <p>The Audio module is a collection of classes that support manipulation of audio effects in an application.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 *<ul>
 *<li><code>{@link Audio.ActiveEffect}</code>: Construct objects for controlling the reproduction of <code>Effect</code> objects.</li>
 *<li><code>{@link Audio.Device}</code>: A singleton object that controls device sound effects volume.</li>
 *<li><code>{@link Audio.Diagnostics}</code>: A singleton object that provides diagnostic information about the app's use of the <code>Audio</code> module.</li>
 *<li><code>{@link Audio.Effect}</code>: Construct objects that load sound resources into memory.</li>
 *<li><code>{@link Audio.Music}</code>: A singleton object that controls the reproduction of application background music.</li>
 *</ul>
 */
exports.Audio = {};

exports.Audio.__defineGetter__("ActiveEffect", function() {
	delete this.ActiveEffect;
	return this.ActiveEffect = require('NGCore/Client/Audio/ActiveEffect').ActiveEffect;
});
exports.Audio.__defineGetter__("Effect", function() {
	delete this.Effect;
	return this.Effect = require('NGCore/Client/Audio/Effect').Effect;
});
exports.Audio.__defineGetter__("Device", function() {
	delete this.Device;
	return this.Device = require('NGCore/Client/Audio/Device').Device;
});
exports.Audio.__defineGetter__("Music", function() {
	delete this.Music;
	return this.Music = require('NGCore/Client/Audio/Music').Music;
});
exports.Audio.__defineGetter__("Diagnostics", function() {
	delete this.Diagnostics;
	return this.Diagnostics = require('NGCore/Client/Audio/Diagnostics').Diagnostics;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/SoundEffect'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SoundEffect'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SoundEffect'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/SoundEffect.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @data:      2011-07-24 
*  @file:      Game.js
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var PreferenceManager = require('NGGo/Service/Data/PreferenceManager').PreferenceManager;
var AssetManager = require('NGGo/Service/Data/AssetManager').AssetManager;
var Audio = require('NGCore/Client/Audio').Audio;

var SoundEffectAdapter = Core.MessageListener.subclass(
{
    classname : "SoundEffectAdapter",

	onComplete: function(callback)
	{
        callback();
	}
});

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.SoundEffect = Component.subclass(
/** @lends Framework.FlowScript.SoundEffect.prototype */
{
    classname : "SoundEffect",
   
    inPorts :
    {
        PLAY_DEFINED_SONG : 0,
        PLAY_EVENT_SONG : 1
    },

    outPorts :
    {
        OUT : 0
    },

    _onReceive : function(port, ip)
    {
        
        switch(port)
        {
            case this.inPorts.PLAY_DEFINED_SONG:
            
                this._playEffect(AssetManager.getAssetForKey(this._iip.required.assetKey));
                
                break;
            case this.inPorts.PLAY_EVENT_SONG:
                
                this._playEffect(this._iip.required.assetPath);
                
                break;
            default:
                break;
        }

        this.send(this.outPorts.OUT, ip);
    },
    
    _playEffect : function(assetPath)
    {
        var self = this;
        this._activeEffect = new Audio.ActiveEffect(new Audio.Effect(assetPath));
        this._effectAdapter = new SoundEffectAdapter();
        
        this._activeEffect.getPlayCompleteEmitter().addListener(this._effectAdapter, 
            function()
            {
                return this.onComplete(self.playCompleteCallback);
            });
        
        this._activeEffect.play();
    },
    
    playCompleteCallback : function()
    {
        if (this._activeEffect)
        {
            this._activeEffect.destroy();
        }
    }

}); // end of class SoundEffect

exports.SoundEffect.factoryUUID = UUID.SOUND_EFFECT;

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/SongPlayer'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SongPlayer'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SongPlayer'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/SongPlayer.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @data:      2011-07-24 
*  @file:      Game.js
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var PreferenceManager = require('NGGo/Service/Data/PreferenceManager').PreferenceManager;
var AssetManager = require('NGGo/Service/Data/AssetManager').AssetManager;
var Audio = require('NGCore/Client/Audio').Audio;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.SongPlayer = Component.subclass(
/** @lends Framework.FlowScript.SongPlayer.prototype */
{
    classname : "SongPlayer",
   
    inPorts :
    {
        PLAY_DEFINED_SONG : 0,
        PLAY_EVENT_SONG : 1
    },

    outPorts :
    {
        OUT : 0,
        ON_SONG_COMPLETE : 1
    },

    _onReceive : function(port, ip)
    {
        switch(port)
        {
            case this.inPorts.PLAY_DEFINED_SONG:
                Audio.Music.setPath(AssetManager.getAssetForKey(this._iip.required.assetKey));
                Audio.Music.play();
                Audio.Music.setVolume(PreferenceManager.get('music_volume'));
                break;

            case this.inPorts.PLAY_EVENT_SONG:
                Audio.Music.setPath(this._iip.required.assetPath);
                Audio.Music.play();
                Audio.Music.setVolume(PreferenceManager.get('music_volume'));
                break;
            default:
                break;
        }

        this.send(this.outPorts.OUT, ip);
    }

}); // end of class SongPlayer

exports.SongPlayer.factoryUUID = UUID.SONG_PLAYER;

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteFactory'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteFactory'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteFactory'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/SpriteFactory.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var AssetManager = require('NGGo/Service/Data/AssetManager').AssetManager;
var SceneManager = require('NGGo/Service/Display/SceneManager').SceneManager;
var GL2 = require('NGCore/Client/GL2').GL2;

////////////////////////////////////////////////////////////////////////////////
// Class Component
exports.SpriteFactory = Component.subclass(
/** @lends Framework.FlowScript.Component.prototype */
{
    classname : "SpriteFactory",
   
    inPorts : 
    {
        IIP_DEFINED_SPRITE : 0,
        IP_GIVEN_SPRITE : 1
    },

    outPorts :
    {
        SPRITE : 0,
        ERROR : 1
    },

    _onReceive : function(port, ip)
    { 
        var sprite = new GL2.Sprite();

        // Process Optional Arguments
        var assetName = null;

        if(this._iip.optional.assetKey)
        {
            assetName = AssetManager.getAssetForKey(this._iip.optional.assetKey);
        }
        else if(this._iip.optional.assetPath)
        {
            assetName = this._iip.optional.assetPath;
        }

        if(assetName)
        {
            var anchor = [this._iip.optional.anchor_x || 0, this._iip.optional.anchor_x || 0];

            var u_start = this._iip.optional.u_start || 0;
            var u_end = this._iip.optional.u_end || 1;
            var v_start = this._iip.optional.v_start || 0;
            var v_end = this._iip.optional.v_end || 1;

            var size = [this._iip.optional.size_x || 100, this._iip.optional.size_y || 100];
            sprite.setImage(  assetName, size, anchor, [u_start, v_start, u_end, v_end]);
        }

        sprite.setPosition(this._iip.optional.pos_x || 0, this._iip.optional.pos_y || 0);
        sprite.setDepth(this._iip.optional.depth || 0);

        ip.active = sprite;
        
        // Process Required Arguments
        SceneManager.getNodeForKey(this._iip.required.parent).addChild(sprite);


        this.send(this.outPorts.SPRITE, ip);
    }

}); // end of class Component

exports.SpriteFactory.factoryUUID = UUID.SPRITE_FACTORY;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/BlackBoard'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/BlackBoard'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/BlackBoard'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/BlackBoard.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Globals
var _globalBlackBoard = {};

////////////////////////////////////////////////////////////////////////////////
// Class BlackBoard
exports.BlackBoard = Component.subclass(
/** @lends Framework.FlowScript.BlackBoard.prototype */
{
    classname : "BlackBoard",

    inPorts : 
    {
        STORE : 0,
        FETCH : 1,
        ERASE : 2,
        ERASE_ALL : 3,
        PRINT :4
    },

    outPorts :
    {
        OUT : 0,
        ERROR : 1
    },
    
    _onReceive : function(port, ip)
    {
        switch(port)
        {
            case this.inPorts.STORE:
                _globalBlackBoard[this._iip.required.write_property] = ip.active;
                this.send(this.outPorts.OUT, ip);
                break;
            case this.inPorts.FETCH:
                ip.active = _globalBlackBoard[this._iip.required.read_property];
                this.send(this.outPorts.OUT, ip);
                break;
            case this.inPorts.ERASE:
                ip.errors = ip.errors || "";
                ip.errors += "<ngGo BlackBoard> Erase not yet implemented";
                this.send(this.outPorts.ERROR, ip);
                break;
            case this.inPorts.ERASE_ALL:
                _globalBlackBoard = {};
                this.send(this.outPorts.OUT, ip);
                break;
            default:
                this.send(this.outPorts.ERROR, ip);
                break;
        }
    }
}); // end of class BlackBoard

exports.BlackBoard.factoryUUID = UUID.BLACKBOARD;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/FlowFactory'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/FlowFactory'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/FlowFactory'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/FlowFactory.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @data:      2011-07-24 
*  @file:      Game.js
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class       = require('NGGo/Foundation/Class').Class;
var Component   = require('NGGo/Framework/FlowScript/Component').Component;
var UUID        = require('NGGo/Framework/FlowScript/Component').UUID;
var Storage     = require('NGCore/Client/Storage').Storage;

////////////////////////////////////////////////////////////////////////////////
// Class FlowFactory
exports.FlowFactory = Component.subclass(
/** @lends Framework.FlowScript.FlowFactory.prototype */
{
    classname : "FlowFactory",
   
    inPorts :
    {
        OPEN_NETWORK : 0
    },

    outPorts :
    {
        ON_NETWORK_CLOSED : 1,
        ON_ERROR : 2
    },

    _onReceive : function(port, ip)
    {
        var script = this._iip.required.script;
        var self = this;
        // We only have one port for now so no switch
        if((script === "" || !script) && (typeof ip.active) === "string")
        {
            script = ip.active;
        }
        
        if(FlowScriptManager.hasKey(script))
        {
            ip.active = createFlowNetwork(script);
            ip.networkFlow = ip.active;
            ip.active.registerCloseCallback(function()
            {
                self.send(this.outPorts.ON_NETWORK_CLOSED, {});             
            });
            ip.active.Open();
        }
        else
        {
            Storage.FileSystem.readFile(script, false, function(err, data)
            {
                if(err)
                {
                    ip.error = "<Flow Factory> Could not load file";
                    self.send(this.outPorts.ON_ERROR, ip);
                }
                else
                {
                    try
                    {
                        var networkDef = JSON.parse(data);
                        FlowScriptManager.registerFlowNetwork(script, networkDef);
                        ip.active = createFlowNetwork(script);
                        ip.networkFlow = ip.active;
                        ip.active.RegisterCloseListener(function()
                        {
                            self.send(this.outPorts.ON_NETWORK_CLOSED, {});             
                        });
                        ip.active.Open();
                    }
                    catch(ex)
                    {
                        ip.error = "<Flow Factory> Could not parse Script file";
                        self.send(this.outPorts.ON_ERROR, ip);
                    }
                }
            });
        }
    }

}); // end of class FlowFactory

exports.FlowFactory.factoryUUID = UUID.FLOW_FACTORY;


; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/Gate'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Gate'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/Gate'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/Gate.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Class FlowFactory
exports.Gate = Component.subclass(
/** @lends Framework.FlowScript.Gate.prototype */
{
    classname : "Gate",
    
    inPorts : {
        IN : 0,
        ACTIVE_IN : 1
    },
    
    outPorts : {
        OUT : 0
    },

    _onPreOpen : function()
    {
        this._messageCount = 0;
    },

    _onReceive : function(port, ip)
    {
        if(this.inPorts.ACTIVE_IN == port)
        {
            this.head = ip.active;
        }

        ++this._messageCount;
        if(this._messageCount == this._iip.required.count)
        {
            if(this.head)
            {
                ip.active = this.head;
                delete this.head;
            }

            this.messageCount = 0;
            this.send(this.outPorts.OUT, ip);
        }
    }

}); // end of class Gate

exports.Gate.factoryUUID = UUID.GATE;

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/XHR'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/XHR'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/XHR'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/XHR.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

var XHR          = require('NGCore/Client/Network/XHR').XHR;
var NGGOError    = require('NGGo/Foundation/NGGOError').NGGOError;
var HTTPRequest  = require('NGGo/Service/Network/HTTPRequest').HTTPRequest;
var Observable   = require('NGGo/Foundation/Observable').Observable;

////////////////////////////////////////////////////////////////////////////////
// Class FlowFactory
exports.XHR = Component.subclass(
/** @lends Framework.FlowScript.XHR.prototype */
{
    classname : "XHR",
  
    inPorts : {
        SEND : 0
    },

    outPorts : {
        OUT : 0,
        ON_DATA_RECIEVED : 1,
        ON_ERROR_FILE_NOT_FOUND : 2,
        ON_ERROR_CONNECTION : 3
    },

    _onReceive : function(port, ip)
    {
        if(this._iip && this._iip.required && this._iip.required.server)
        {
            var url = this._iip.required.server;
            if(ip.serverURL)
            {
                url = this.serverURL;
            }

            if(this._iip.optional)
            {
                var first = true;
                for(var arg in this._iip.optional)
                {
                    if(first)
                    {
                        url +="?";
                    }
                    else
                    {
                        url +="&";
                    }
                    url += arg + "=" + this._iip.optional[arg];
                }
            }
            var req = new HTTPRequest();
            var self = this;
            req.adObserver({
                onSuccess: function(res)
                {
                    ip.active = res;
                    ip.networkResponse = res;
                    self.send(this.outPorts.ON_DATA_RECIEVED, ip); 
                },
                onFailure: function(res)
                {
                    if(res.statusCode === 404)
                    {
                        self.send(this.outPorts.ON_ERROR_FILE_NOT_FOUND, ip); 
                    }
                    else
                    {
                        self.send(this.outPorts.ON_ERROR_CONNECTION, ip); 
                    }
                }
            });
            req.get(url);
            this.send(this.outPorts.OUT, ip);
        }
    }
}); // end of class XHR

exports.XHR.factoryUUID = UUID.XHR;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteAnimation'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteAnimation'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/SpriteAnimation'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/SpriteAnimation.js';

////////////////////////////////////////////////////////////////////////////////
/**
*  @author:    Chris Jimison
*  Website:    http://www.ngmoco.com
*  Copyright:  2010, by ngmoco:) llc
*              Unauthorized redistribution of source code is 
*              strictly prohibited. Violators will be prosecuted.
* 
*  @brief:     
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var AnimationManager = require('NGGo/Framework/AnimationManager').AnimationManager;

////////////////////////////////////////////////////////////////////////////////
// Class SpriteAnimation
exports.SpriteAnimation = Component.subclass(
/** @lends Framework.FlowScript.SpriteAnimation.prototype */
{
    classname : "SpriteAnimation",
   

    _onReceive : function(port, ip)
    {
        ip.active.setAnimation( AnimationManager.getAnimationGL2( this._iip.required.group,
                                                                  this._iip.required.type), 0);
        this.send(0, ip);
    }

}); // end of class SpriteAnimation

exports.SpriteAnimation.factoryUUID = UUID.SPRITE_ANIMATION;

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/OnScriptStart'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/OnScriptStart'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/OnScriptStart'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/OnScriptStart.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Class BlackBoard
exports.OnScriptStart = Component.subclass(
/** @lends Framework.FlowScript.OnScriptStart.prototype */
{
    classname : "OnScriptStart",

    outPorts :
    {
        OUT : 0,
        ERROR : 1
    },
    
    _onPostOpen : function() 
    {
        var ip = {};
        ip.log = "<OnScriptStart> : IP Created on Post Open\n";
        this.send(this.outPorts.OUT, ip);    
    }
}); // end of class OnScriptStart

exports.OnScriptStart.factoryUUID = UUID.ON_SCRIPT_START;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/ExitScript'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/ExitScript'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/ExitScript'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/ExitScript.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;

////////////////////////////////////////////////////////////////////////////////
// Class BlackBoard
exports.ExitScript = Component.subclass(
/** @lends Framework.FlowScript.ExitScript.prototype */
{
    classname : "ExitScript",
    
    _onReceive : function(port, ip)
    {
        this._network.close();
    }
}); // end of class BlackBoard

exports.ExitScript.factoryUUID = UUID.EXIT_SCRIPT;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/ScreenManagerComponent'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/ScreenManagerComponent'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/ScreenManagerComponent'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/ScreenManagerComponent.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requires
var Class = require('NGGo/Foundation/Class').Class;
var Component = require('NGGo/Framework/FlowScript/Component').Component;
var UUID = require('NGGo/Framework/FlowScript/Component').UUID;
var ScreenManager = require('NGGo/Service/Display/ScreenManager').ScreenManager;

////////////////////////////////////////////////////////////////////////////////
// Class BlackBoard
exports.ScreenManagerComponent = Component.subclass(
/** @lends Framework.FlowScript.ScreenManagerComponent.prototype */
{
    classname : "ScreenManagerComponent",

    inPorts : 
    {
        ON_SET_LANDSCAPE : 0,
        ON_SET_PORTRAIT : 1
    },

    outPorts :
    {
        OUT : 0,
        ERROR : 1
    },
    
    _onReceive : function(port, ip)
    {
        var self = this;
        switch(port)
        {
            case this.inPorts.ON_SET_LANDSCAPE:
                ScreenManager.setLandscape(function(){
                    self.send(self.outPorts.OUT, ip);
                });
                break;
            case this.inPorts.ON_SET_PORTRAIT:
                ScreenManager.setPortrait(function(){
                    self.send(self.outPorts.OUT, ip);
                });
                break;
            default:
                this.send(this.outPorts.ERROR, ip);
                break;
        }
    }
}); // end of class ScreenManagerComponent

exports.ScreenManagerComponent.factoryUUID = UUID.SCREEN_MANAGER_COMPONENT;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/FlowScript/Components/NGGoComponents'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/NGGoComponents'] || {}; $MODULE_REGISTRY['NGGo/Framework/FlowScript/Components/NGGoComponents'] = exports; 
var __dirname = 'NGGo/Framework/FlowScript/Components';
var __filename = 'NGGo/Framework/FlowScript/Components/NGGoComponents.js';

// Commented out components were removed for 1.1 release.  Will be in 1.2

var FlowScriptManager       = require('NGGo/Framework/FlowScript/FlowScriptManager').FlowScriptManager;
var Camera                  = require('NGGo/Framework/FlowScript/Components/Camera').Camera;
//var Composite               = require_('./Composite').Composite;
var Filter                  = require('NGGo/Framework/FlowScript/Components/Filter').Filter;
var Log                     = require('NGGo/Framework/FlowScript/Components/Log').Log;
var MotionFactory           = require('NGGo/Framework/FlowScript/Components/Motion').MotionFactory;
var MotionPlayer            = require('NGGo/Framework/FlowScript/Components/Motion').MotionPlayer;
//var Selector                = require_('./Selector').Selector;
var Simulator               = require('NGGo/Framework/FlowScript/Components/Simulator').Simulator;
var SoundEffect             = require('NGGo/Framework/FlowScript/Components/SoundEffect').SoundEffect;
var SongPlayer              = require('NGGo/Framework/FlowScript/Components/SongPlayer').SongPlayer;
var SpriteFactory           = require('NGGo/Framework/FlowScript/Components/SpriteFactory').SpriteFactory;
var BlackBoard              = require('NGGo/Framework/FlowScript/Components/BlackBoard').BlackBoard;
var FlowFactory             = require('NGGo/Framework/FlowScript/Components/FlowFactory').FlowFactory;
var Gate                    = require('NGGo/Framework/FlowScript/Components/Gate').Gate;
var XHR                     = require('NGGo/Framework/FlowScript/Components/XHR').XHR;
var SpriteAnimation         = require('NGGo/Framework/FlowScript/Components/SpriteAnimation').SpriteAnimation;

var OnScriptStart           = require('NGGo/Framework/FlowScript/Components/OnScriptStart').OnScriptStart;
var ExitScript              = require('NGGo/Framework/FlowScript/Components/ExitScript').ExitScript;
var ScreenManagerComponent  = require('NGGo/Framework/FlowScript/Components/ScreenManagerComponent').ScreenManagerComponent;
//var PhysicsFactory          = require_('./PhysicsFactory').PhysicsFactory;

exports.NGGoComponents = {
    RegisterComponents : function()
    {
        //FlowScriptManager.registerComponent(Composite.factoryUUID, Composite);
        FlowScriptManager.registerComponent(Filter.factoryUUID, Filter);
        FlowScriptManager.registerComponent(Log.factoryUUID, Log);
        FlowScriptManager.registerComponent(MotionFactory.factoryUUID, MotionFactory);
        //FlowScriptManager.registerComponent(Selector.factoryUUID, Selector);
        FlowScriptManager.registerComponent(Simulator.factoryUUID, Simulator);
        FlowScriptManager.registerComponent(SpriteFactory.factoryUUID, SpriteFactory);
        FlowScriptManager.registerComponent(Camera.factoryUUID, Camera);
        FlowScriptManager.registerComponent(BlackBoard.factoryUUID, BlackBoard);
        FlowScriptManager.registerComponent(MotionPlayer.factoryUUID, MotionPlayer);
        FlowScriptManager.registerComponent(SoundEffect.factoryUUID, SoundEffect);
        FlowScriptManager.registerComponent(SongPlayer.factoryUUID, SongPlayer);
        FlowScriptManager.registerComponent(FlowFactory.factoryUUID, FlowFactory);
        FlowScriptManager.registerComponent(Gate.factoryUUID, Gate);
        FlowScriptManager.registerComponent(XHR.factoryUUID, XHR);
        FlowScriptManager.registerComponent(SpriteAnimation.factoryUUID, SpriteAnimation);
        
        FlowScriptManager.registerComponent(OnScriptStart.factoryUUID, OnScriptStart);
        FlowScriptManager.registerComponent(ExitScript.factoryUUID, ExitScript);
        FlowScriptManager.registerComponent(ScreenManagerComponent.factoryUUID, ScreenManagerComponent);
        //FlowScriptManager.registerComponent(PhysicsFactory.factoryUUID, PhysicsFactory);
    }
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/ConfigurationManager'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/ConfigurationManager'] || {}; $MODULE_REGISTRY['NGGo/Framework/ConfigurationManager'] = exports; 
var __dirname = 'NGGo/Framework';
var __filename = 'NGGo/Framework/ConfigurationManager.js';

///////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Chris Jimison
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core                = require('NGCore/Client/Core').Core;
var Storage             = require('NGCore/Client/Storage').Storage;

var AssetManager        = require('NGGo/Service/Data/AssetManager').AssetManager;
var SceneManager        = require('NGGo/Service/Display/SceneManager').SceneManager;
var AnimationManager    = require('NGGo/Framework/AnimationManager').AnimationManager;
var CameraManager       = require('NGGo/Service/Display/CameraManager').CameraManager;
var ScreenManager       = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var PreferenceManager   = require('NGGo/Service/Data/PreferenceManager').PreferenceManager;
var MultiManifestManager= require('NGGo/Service/Network/MultiManifestManager').MultiManifestManager;

var Class               = require('NGGo/Foundation/Class').Class;
var Observable          = require('NGGo/Foundation/Observable').Observable;
var NGGoComponents      = require('NGGo/Framework/FlowScript/Components/NGGoComponents').NGGoComponents;
var FlowScriptManager   = require('NGGo/Framework/FlowScript/FlowScriptManager').FlowScriptManager;

/** @private */
var KeyListenerForBack = Core.MessageListener.singleton(
{
    initialize: function()
    {
        Device.KeyEmitter.addListener(this, this.onUpdate);
    },

    onUpdate : function(keyEvent)
    {
        if (keyEvent.code === Device.KeyEmitter.Keycode.back && this.backCommand)
        {
            this.backCommand();
            return true;
        }
    }
});

////////////////////////////////////////////////////////////////////////////////

exports.ConfigurationManager = Class.singleton(
/** @lends Framework.ConfigurationManager.prototype */
{
    /**
     * @class The <code>ConfigurationManagement</code> defines how the ngGo engine will be initialized.
     * <br><br>
     * Given that some systems have interdependencies on other system things like order of initialization/execution become very important.
     * <ul>
     * <li><b>-</b> System initialization</li>
     * <li><b>-</b> ngGo server interaction</li>
     * </ul>
     * @constructs Constructor for the object.
     * @name Framework.ConfigurationManager
     * @augments Core.Class
     */
    initialize : function()
    {
        this.mConfigFile = './Config/default.json';
        this.mAssetManagerLoaded = false;
        this.mSceneManagerLoaded = false;
        this.mCameraManagerLoaded = false;
        this.mAnimationManagerLoaded = false;
    },

    /**
     * Sets config file name. This is used when <code>begin()</code> is called.
     * @param {String} filename Config file name.
     */
    setConfigFile : function(filename)
    {
        this.mConfigFile = filename;
    },

    /**
     * Starts up the Configuration Manager.
     * @param {Function} [callback] Callback funciton for when the setup is complete. function(err) is expected.
     */
    begin : function(callback)
    {
        var self = this;

        callback = callback || function(err){};

        var fs = Storage.FileSystem;
        // Step 1
        // Load the default.json file.  This will trigger off any additional updates require_d
        fs.readFile(this.mConfigFile, false, function(err, data)
        {
            if(err)
            {
                // Log the fact that we have a problem
                console.log("<NGGO> Error: Could not read the file " + this.mConfigFile);
                callback("Could not read file");
            }
            else
            {
                var config = null;
                // Lets try and parse the json
                try
                {
                    config = JSON.parse(data);
                }
                catch(ex)
                {
                    console.log("<NGGO> Error: Could not parse the JSON file " + this.mConfigFile);
                    callback("Could not parse the JSON file");
                }
                self.mConfig = config;
                self._loadScreen(callback);
            }
        });
    },

    /**
     * Sets callback function for <code>Back</code> key.
     * @param {Function} callback Callback function.
     */
    onBack : function(callback)
    {
        this.mOnBackCallback = callback;
    },

    /**
     * Calls the onBack callback handler externally.  This is good for things like buttons
     * that overload the on back behavior
     */
    callOnBack : function()
    {
        if(this.mOnBackCallback)
        {
            this.mOnBackCallback();
        }
    },

    /** @private */
    _loadScreen : function(callback)
    {
        var self = this;
        if(this.mConfig.Screen)
        {
            ScreenManager.loadConfigFromFile(this.mConfig.Screen, function(error)
            {
                if(error)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the ScreenManager");
                    self.notify("onConfigurationManagaerFailed", "ScreenManager");
                    callback("error loading screen");
                }
                else
                {
                    // $TODO this should be in the SceneDirector not the configuration manager
                    KeyListenerForBack.instantiate();
                    KeyListenerForBack.backCommand = this.mOnBackCallback;
                    self.mScreenLoaded = true;
                    
                    //setup development handling for ScreenManager
                    if (self.mConfig.development){
                        ScreenManager.setupDevelopment(self.mConfig.development, callback);
                    }
                    
                    self._loadMultiManifestManager(callback);
                }
            });
        }
        else
        {
            self._loadMultiManifestManager(callback);
        }
    },

    /** @private */
    _loadMultiManifestManager : function(callback)
    {
        var self = this;
        if(this.mConfig.MultiManifestManager)
        {
            MultiManifestManager.start(this.mConfig.MultiManifestManager,
                function(manifestIdx, inProgress, stillToGo, total, name)
                {
                    self.notify("onMultiManifestManagerProgress", manifestIdx, inProgress, stillToGo, total, name);
                },
                function(err, downloadList, deletedList)
                {
                    self.notify("onMultiManifestMangerProgress", err, downloadList, deletedList);
                }
            );
            self.mMultiManifestManagerLoaded = true;
            //setup development handling for MultiManifestManager
            if (self.mConfig.development){
                MultiManifestManager.setupDevelopment(self.mConfig.development, callback);
            }
            self._loadAssetMap(callback);
        }
        else
        {
            self._loadAssetMap(callback);
        }
    },

    /** @private */
    _loadAssetMap : function(callback)
    {
        var self = this;
        if(this.mConfig.AssetManager)
        {
            AssetManager.loadConfigFromFile(this.mConfig.AssetManager, function(err)
            {
                if(err)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the AssetManager");
                    self.notify("onConfigurationManagaerFailed", "AssetManager");
                    callback(err);
                }
                else
                {
                    self.mAssetManagerLoaded = true;
                    //setup development handling for AssetManager
                    if (self.mConfig.development){
                        AssetManager.setupDevelopment(self.mConfig.development, callback);
                    }
                    // Start up the scene manager if it exists
                    self._loadSceneManager(callback);
                }
            });
        }
        else
        {
            this._loadSceneManager(callback);
        }
    },

    /** @private */
    _loadSceneManager : function(callback)
    {
        var self = this;
        if(this.mConfig.SceneManager)
        {
            SceneManager.loadConfigFromFile(this.mConfig.SceneManager, function(err)
            {
                if(err)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the SceneManager");
                    self.notify("onConfigurationManagaerFailed", "SceneManager");
                    callback(err);
                }
                else
                {
                    self.mSceneManagerLoaded = true;
                    //setup development handling for SceneManager
                    if (self.mConfig.development){
                        SceneManager.setupDevelopment(self.mConfig.development, callback);
                    }
                    // Start up the scene manager if it exists
                    self._loadPreferenceManager(callback);
                }
            });
        }
        else
        {
            this._loadPreferenceManager(callback);
        }
    },

    /** @private */
    _loadPreferenceManager : function(callback)
    {
        var self = this;
        if(this.mConfig.PreferenceManager)
        {
            PreferenceManager.loadConfigFromFile(this.mConfig.PreferenceManager, function(err)
            {
                if(err)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the PreferenceManager");
                    self.notify("onConfigurationManagaerFailed", "PreferenceManager");
                    callback(err);
                }
                else
                {
                    self.mPreferenceManagerLoaded = true;
                    
                    //setup development handling for PreferenceManager
                    if (self.mConfig.development){
                        PreferenceManager.setupDevelopment(self.mConfig.development, callback);
                    }
                    
                    self._loadAnimationManager(callback);
                }
            });
        }
        else
        {
            self._loadAnimationManager(callback);
        }
    },

    /** @private */
    _loadAnimationManager : function(callback)
    {
        var self = this;
        if(this.mConfig.AnimationManager)
        {
            AnimationManager.loadConfigFromFile(this.mConfig.AnimationManager, function(err)
            {
                if(err)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the AnimationManager");
                    self.notify("onConfigurationManagaerFailed", "AnimationManager");
                    callback(err);
                }
                else
                {
                    self.mAnimationManagerLoaded = true; 
                    self._loadCameraManager(callback);
                }
            });
        }
        else
        {
            self._loadCameraManager(callback);
        }
    },

    /** @private */
    _loadCameraManager : function(callback)
    {
        var self = this;
        if(this.mConfig.CameraManager)
        {
            CameraManager.loadConfigFromFile(this.mConfig.CameraManager, function(err)
            {
                if(err)
                {
                    console.log("<NGGO> Error: ConfigurationManager could not load the CameraManager");
                    self.notify("onConfigurationManagaerFailed", "CameraManager");
                    callback(err);
                }
                else
                {
                    self.mCameraManagerLoaded = true;
                    
                    //setup development handling for CameraManager
                    if (self.mConfig.development){
                        CameraManager.setupDevelopment(self.mConfig.development, callback);
                    }
 
                    self.notify("onConfigurationManagaerSuccess", self);
                    self._loadFlowManager(callback);
                }
            });
        }
        else
        {
            self.notify("onConfigurationManagaerSuccess", self);
            self._loadFlowManager(callback);
        }
    },

    /** @private */
    _loadFlowManager : function(callback)
    {
        var self = this;
        if(this.mConfig.FlowManager)
        {

            Storage.FileSystem.readFile(this.mConfig.FlowManager, false, function(err, data)
            {
                if(err)
                {
                    console.log("<NGGO> Error: FlowManager failed to read file");
                    self.notify("onConfigurationManagaerFailed", "FlowManager");
                    callback(err);
                }
                else
                {
                    var networkDef = JSON.parse(data);
                    NGGoComponents.RegisterComponents();
                    FlowScriptManager.registerFlowNetwork("Main", networkDef);

                    FlowScriptManager.mainNetwork = FlowScriptManager.createFlowNetwork("Main");
                    FlowScriptManager.mainNetwork.open(); 
                    callback();
                }
            });
        }
        else
        {
            callback();
        }
    }
}, [Observable]);
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/Scene/SceneFactory'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/Scene/SceneFactory'] || {}; $MODULE_REGISTRY['NGGo/Framework/Scene/SceneFactory'] = exports; 
var __dirname = 'NGGo/Framework/Scene';
var __filename = 'NGGo/Framework/Scene/SceneFactory.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////
exports.SceneFactory = Class.singleton(
/** @lends Framework.Scene.SceneFactory.prototype */
{
    classname: 'SceneFactory',
    /**
     * @class This <code>SceneFactory</code> class returns Scene objects they are
     * needed in <code>SceneDirector</code>. In <code>SceneDirector</code>, you
     * can use actual instance of subclass of Scene class or string key which is
     * registered in this class.
     * @example // Use by object
     * SceneDirector.push(new TitleScene());
     * // Use by string key with SceneFactory
     * SceneFactory.register(TitleScene, "title");
     * SceneDirector.push("title");
     * @name Framework.Scene.SceneFactory
     * @constructs This is singleton class.
     * @augments Core.Class
     */
    initialize: function()
    {
        this._register = {};
    },
    /**
     * Register scene class. If the scene class has <code>sceneName</code> property,
     * you can omit <code>name</code> argument.
     * @param {Framework.Scene.Scene} scene Subclass of <code>Scene</code> class.
     * @param {String} name Scene name.
     */
    register: function(scene, name)
    {
        name = name || scene.sceneName;
        if(!name)
        {
            throw new Error("SceneDirector: Scene name is not available");
        }
        this._register[name] = scene;
    },
    /**
     * Returns actual Scene instance. if the parameter is string,
     * this method searchs from registered class and creates and returns the instance.
     * Else, this method returns input value.
     * @param {String|Framework.Scene.Scene} keyOrSceneObject Scene object or search key.
     * @returns {Framework.Scene.Scene|undefined} Found scene object. If object is not registered, returns <code>undefined</code>.
     */
    getSceneObject: function(keyOrSceneObject)
    {
        if (keyOrSceneObject instanceof String || typeof keyOrSceneObject === "string")
        {
            var sceneClass = this._register[keyOrSceneObject];
            if (sceneClass) {
                return new sceneClass();
            }
            return undefined;
        }
        return keyOrSceneObject;
    },
    /** @private
     *  only for unittest.
     */
    _clearAll: function()
    {
        this._register = {};
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/Scene/SceneDirector'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/Scene/SceneDirector'] || {}; $MODULE_REGISTRY['NGGo/Framework/Scene/SceneDirector'] = exports; 
var __dirname = 'NGGo/Framework/Scene';
var __filename = 'NGGo/Framework/Scene/SceneDirector.js';

///////////////////////////////////////////////////////////////////////////////
/**
 *  @author    Shibukawa Yoshiki
 *  Website    https://developer.mobage.com/
 *  Copyright  2011, by DeNA Co., Ltd
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Class = require('NGCore/Client/Core/Class').Class;
var SceneFactory = require('NGGo/Framework/Scene/SceneFactory').SceneFactory;


exports.SceneDirector = Class.singleton(
/** @lends Framework.Scene.SceneDirector.prototype */
{
    classname: 'SceneDirector',
    /** @private */
    _Status:
    {
        Normal: 0,
        Enter: 1,
        Exit: 2,
        PopToRoot: 4
    },
    /**
     * @class <code>SceneDirector</code> class is the framework of game structure.
     * Each game logic, parts are implemented in each scene, and these scenes are
     * assembled to create game.
     * Following parts become scene:
     * <ul>
     * <li>Full-screen Base Scene: title scene, setting scene, home scene, download screen.</li>
     * <li>Add-on Scene: store on home scene, friend list on social menu.</li>
     * <li>Dialog: confirmation dialog on store scene, result dialog on battle scene.</li>
     * </ul>
     * Scenes are created by extending <code>Scene</code> class, and initialize/destroy
     * codes are implemented in the event handler of the class.
     * Between scenes, you can use following transitions:
     * <ul>
     * <li>push: Adds new scene as child.</li>
     * <li>pop: Removes current scene and returns to parent.</li>
     * <li>transition: Remove current scene and goto new sibling scene.</li>
     * </ul>
     * @constructs Constructor for the object.
     * @name Framework.Scene.SceneDirector
     * @augments Core.Class
     */
    initialize: function()
    {
        this._sceneStack = [];
        this._reservedScenes = {};
        this._status = this._Status.Normal;
        this._reservedPush = undefined;
    },
    /**
     * Removes current scene and goto new sibling scene.
     * Parent scene is not changed and parent's event handler is not called.
     * Following event handler is called:
     * <ul>
     * <li>Old scene's <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code></li>
     * <li>New scnen's <code><a href="Framework.Scene.Scene.html#onEnter">onEnter()</a></code></li>
     * </ul>
     * This method is not available in <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code>
     * and <code><a href="#popToRoot">popToRoot()</a></code>.
     * @param {String|Framework.Scene.Scene} scene Scene object or string key for
     *       <code><a href="Framework.Scene.SceneFactory.html">SceneFactory</a></code>
     * @param {any} [option] This option is passed to event handlers.
     */
    transition: function(scene, option)
    {
        switch(this._status)
        {
        case this._Status.Exit:
            throw new Error("SceneDirector: Doesn't support transition() during onExit");
        case this._Status.PopToRoot | this._Status.Exit:
        case this._Status.PopToRoot | this._Status.Enter:
            throw new Error("SceneDirector: Doesn't support transition() during popToRoot()");
        }
        var sceneObj = SceneFactory.getSceneObject(scene);
        if (this._sceneStack.length === 0)
        {
            this.runScene(sceneObj, option);
            return;
        }
        var currentScene = this._sceneStack.pop();
        this._sceneStack.push(sceneObj);

        currentScene.onExit(sceneObj, option);
        sceneObj.onEnter(currentScene, option);
    },
    /**
     * Adds and transits to new child scene.
     * Following event handler is called:
     * <ul>
     * <li>Old scene's <code><a href="Framework.Scene.Scene.html#onPause">onPause()</a></code></li>
     * <li>New scnen's <code><a href="Framework.Scene.Scene.html#onEnter">onEnter()</a></code></li>
     * </ul>
     * This method is not available in <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code>
     * and <code><a href="#popToRoot">popToRoot()</a></code>.
     * @param {String|Framework.Scene.Scene} scene Scene object or string key for
     *     <code><a href="Framework.Scene.SceneFactory.html">SceneFactory</a></code>
     * @param {any} [option] This option is passed to event handlers.
     */
    push: function(scene, option)
    {
        switch(this._status)
        {
        case this._Status.Exit:
            throw new Error("SceneDirector: Doesn't support push() during onExit");
        case this._Status.PopToRoot | this._Status.Exit:
        case this._Status.PopToRoot | this._Status.Enter:
            throw new Error("SceneDirector: Doesn't support push() during popToRoot()");
        }
        var sceneObj = SceneFactory.getSceneObject(scene);
        var currentScene = this.currentScene;
        this._sceneStack.push(sceneObj);
        if(currentScene)
        {
            this._status = this._Status.Exit;
            currentScene.onPause(sceneObj, option);
            this._status = this._Status.Normal;
            sceneObj.onEnter(currentScene, option);
        }
        else
        {
            sceneObj.onEnter(null, option);
        }
    },
    /**
     * Removes current scene and returns to parent's scene.
     * Following event handler is called:
     * <ul>
     * <li>Old scene's <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code></li>
     * <li>New scnen's <code><a href="Framework.Scene.Scene.html#onResume">onResume()</a></code></li>
     * </ul>
     * This method is not available in <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code>.
     * @param {any} [option] This option is passed to event handlers.
     */
    pop: function(option)
    {
        var depth = this.depth;
        if (depth === 0)
        {
            throw new Error("SceneDirector: No more scene to pop is not exit.");
        }
        switch(this._status)
        {
        case this._Status.Exit:
        case this._Status.PopToRoot | this._Status.Exit:
            throw new Error("SceneDirector: Doesn't support pop() during onExit");
        }
        var reservedScenes = this._reservedScenes[depth-1];
        var currentScene = this._sceneStack.pop();
        var callback;
        if (reservedScenes !== undefined)
        {
            var nextReservedScene = reservedScenes[0].shift();
            option = reservedScenes[1];
            if (nextReservedScene !== undefined)
            {
                this._sceneStack.push(nextReservedScene);
                this._status = this._Status.Exit;
                currentScene.onExit(nextReservedScene, option);
                this._status = this._Status.Normal;
                nextReservedScene.onEnter(currentScene, option);
                return;
            }
            else
            {
                callback = reservedScenes[2];
                delete this._reservedScenes[depth-1];
            }
        }
        var nextScene = this.currentScene || null;
        this._status = this._Status.Exit;
        currentScene.onExit(nextScene, option);
        this._status = this._Status.Normal;
        if(nextScene)
        {
            nextScene.onResume(currentScene, option);
        }
        if(callback)
        {
            callback(option);
        }
    },
    /**
     * Removes stacked scene, but root scene is remained.
     * Following event handler is called:
     * <ul>
     * <li>All scene's <a href="Framework.Scene.Scene.html#onExit"><code>onExit()</code></a> except root scene's one</li>
     * <li>All scnen's <a href="Framework.Scene.Scene.html#onResume"><code>onResume()</code></a> except first scene's one</li>
     * </ul>
     * @param {Object} [option] This option is passed to event handlers.
     */
    popToRoot: function(option) {
        if (this._sceneStack.length < 2)
        {
            return;
        }
        while(this._sceneStack.length > 1)
        {
            var currentScene = this._sceneStack.pop();
            var nextScene    = this.currentScene;
            this._status = this._Status.PopToRoot | this._Status.Exit;
            currentScene.onExit(nextScene, option);
            this._status = this._Status.PopToRoot | this._Status.Enter;
            nextScene.onResume(currentScene, option);
        }
        this._status = this._Status.Normal;
    },
    /**
     * Run several scenes. Until this transitions are ended, parent's <code><a href="Framework.Scene.Scene.html#onResume">onResume()</a></code>
     * is not called. Between these scenes, <code>onEnter()</code> and <code><a href="Framework.Scene.Scene.html#onExit">onExit()</a></code>
     * are called.
     * @param {String|Framework.Scene.Scene[]} scenes This array of Scene objects or scene keys.
     * @param {Object} [option] It is passed to event handlers.
     * @param {Function} [callback] Callback function it is called all scenes are finished.
     */
    sequentialTransition: function(scenes, option, callback)
    {
        var firstscene = scenes.shift();
        if (scenes.length > 0)
        {
            this._reservedScenes[this.depth] = [scenes, option, callback];
        }
        if (firstscene)
        {
            this.push(firstscene, option);
        }
    },
    /**
     * It is active scene. If you change it, <code>transition()</code> is called.
     * @fieldOf Framework.Scene.SceneDirector
     * @type Framework.Scene.Scene
     */
    get currentScene()
    {
        return this._sceneStack[this._sceneStack.length - 1];
    },
    set currentScene(value)
    {
        this.transition(value);
    },
    /**
     * @field Current stacked scene number.
     * @type Number
     */
    get depth()
    {
        return this._sceneStack.length;
    },
    /** @private */
    set depth(value)
    {
        throw new Error("depth property is readonly");
    },
    /** @private
     *  only for unittest.
     */
    _clearAll: function()
    {
        this._sceneStack = [];
        this._reservedScenes = {};
        this._status = this._Status.Normal;
    }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Commands'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Commands'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Commands'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Commands.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Ihsan H.
 *  @co-author: Copied from NGCore - Command.js
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

var Commands = Class.singleton( /** @lends GLUI.Commands.prototype */
{
    /**
     * @name GLUI.Commands
     * @class 
     * @augments Core.Class
     */
    /** 
     * @field
     */
    classname: 'Commands',

    /**
     * @constructs
     */
    initialize: function ()
    {
    },

    // Enums.
    /** 
     * Enumeration for image fit modes.
     * Image Fit is always applied relative to view bounds *after* content insets are applied.
     * @namespace
     */
    FitMode:
    { /** The image content is not scaled at all. */
        None: 0,
        /** The image will be aspect-scaled to fit completely within the view. */
        Inside: 1,
        /** The image will be aspect-scaled to cover the entire view bounds. Clipping may occur. */
        Fill: 2,
        /** The image will be distorted to cover the exact view bounds. */
        Stretch: 3,
        /** The image will be aspect-scaled so its width matches the view bounds. Clipping may occur. */
        AspectWidth: 5,
        /** The image will be aspect-scaled so its height matches the view bounds. Clipping may occur. */
        AspectHeight: 6,
        /** The image will be scaled down to fit completely within the view, but not upscaled. */
        InsideNoUpscaling: 7
    },

    /** 
     * Enumeration for fontLocation
     * @namespace
     */
    FontLocation: { /** Use Default fonts. */
        Default: 0,
        /** Use System fonts. */
        System: 1,
        /** Use bundled fonts that ship with engine and available to all apps. */
        Bundled: 2,
        /** Use custom fonts that are loaded with app manifest. */
        Manifest: 3
    },

    /** 
     * Enumeration for supported units for dimensions.
     * Math.round() is your friend. Sending decimal pixel coordinates can result in unpredictable behavior on various platforms, but half- and quarter-pixels can be useful tools on iOS.
     * @namespace
     */
    Scaling:
    { 
        /** The native format, and the default for view bounds. No conversion will be performed. */
        Pixels: 0,
        /** Adjusted to roughly one typesetting point, downscaled from 72 to 160 dpi. */
        Points: 1,
        /** 1.0 represents 100% of the provided or implied size (usually a view width or height). */
        Unit: 2,
        /** A percentage of the provided or implied size (typically from 0 to 100). */
        Percent: 3,
        /** At this scale, the device's screen is always 320 units wide. */
        iPhone: 4
    },

    /** 
     * Enumeration for text font styles.
     * @namespace
     */
    FontStyle:
    { 
        /** * */
        Normal: 0,
        /** * */
        Bold: 1,
        /** * */
        Italic: 2,
        /** * */
        BoldItalic: 3
    },

    /** 
     * Flags for control / view states. Used in View and its subclasses.
     * When setting content and properties for states, the value with the highest id when AND'ed with the current state, but no additional bits, will be used.
     * @namespace
     */
    State:
    { 
        /** The view is in an unexceptional state. */
        Normal: 0x00,
        /** * */
        Focused: 0x01,
        /** * */
        Selected: 0x02,
        /** * */
        Pressed: 0x04,
        /** * */
        Checked: 0x08,
        /** * */
        Custom: 0x00FF0000,
        /** * */
        Disabled: 0x40000000
    },

    /** 
     * Enumeration for Enter Key Behavior in editable text fields.
     * @private
     */
    EnterKeyType:
    {
        /** * */
        Return: 0,
        /** * */
        Done: 1,
        /** * */
        Next: 2,
        /** * */
        Submit: 3,
        /** * */
        Go: 4,
        /** * */
        Search: 5,
        /** * */
        Send: 6
    },

    /** 
     * Enumeration for Input Types for editable text fields.
     * @private
     */
    InputType:
    {
        /** * */
        None: 0,
        /** * */
        TextWithCorrection: 1,
        /** * */
        Password: 2,
        /** * */
        Numeric: 4,
        /** * */
        Email: 5,
        /** * */
        URL: 6,
        /** * */
        Date: 7,
        /** * */
        ANDROID_LANDSCAPE_FULLSCREEN: 8
    },

    /** 
     * Arrangement of combinations of text and images for buttons. When stacked, the button rect will be divided proportionally into two rects that completely cover the button. Gravity will apply to the image and text within their rects.
     * @private
     */
    ButtonLayout:
    {
        /** The view is in an unexceptional state. */
        CenterTextOver: 0,
        /** * */
        StackImageLeft: 1,
        /** * */
        StackImageTop: 2,
        /** * */
        StackImageRight: 3,
        /** * */
        StackImageBottom: 4,
        /** * */
        CenterImageOver: 5
    },

    /** 
     * Describes what direction a user swiped during a swipe callback.
     * @see UI.AbstractView#setOnSwipe
     * @private
     */
    SwipeDirection:
    {
        /** * */
        Left: 1,
        /** * */
        Right: 2,
        /** * */
        Up: 3,
        /** * */
        Down: 4
    },

    _registerSettersForImage: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._setters['image'] = this._setImageProperty.bind("Normal");
        callee._setters['normalImage'] = this._setImageProperty.bind("Normal");
        callee._setters['focusedImage'] = this._setImageProperty.bind("Focused");
        callee._setters['selectedImage'] = this._setImageProperty.bind("Selected");
        callee._setters['pressedImage'] = this._setImageProperty.bind("Pressed");
        callee._setters['checkedImage'] = this._setImageProperty.bind("Checked");
        callee._setters['customImage'] = this._setImageProperty.bind("Custom");
        callee._setters['disabledImage'] = this._setImageProperty.bind("Disabled");

        callee._setters['imageFit'] = this._setImageFit;
        callee._setters['imageGravity'] = this._setImageGravity;

    },
    _registerGettersForImage: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._getters['image'] = this._getImageProperty.bind("Normal");
        callee._getters['normalImage'] = this._getImageProperty.bind("Normal");
        callee._getters['focusedImage'] = this._getImageProperty.bind("Focused");
        callee._getters['selectedImage'] = this._getImageProperty.bind("Selected");
        callee._getters['pressedImage'] = this._getImageProperty.bind("Pressed");
        callee._getters['checkedImage'] = this._getImageProperty.bind("Checked");
        callee._getters['customImage'] = this._getImageProperty.bind("Custom");
        callee._getters['disabledImage'] = this._getImageProperty.bind("Disabled");

        callee._getters['imageFit'] = this._getImageFit.bind(callee);
        callee._getters['imageGravity'] = this._getImageGravity.bind(callee);

    },
    _registerSettersForLabel: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._setters['text'] = this._setTextProperty.bind("Normal");
        callee._setters['normalText'] = this._setTextProperty.bind("Normal");
        callee._setters['focusedText'] = this._setTextProperty.bind("Focused");
        callee._setters['selectedText'] = this._setTextProperty.bind("Selected");
        callee._setters['pressedText'] = this._setTextProperty.bind("Pressed");
        callee._setters['checkedText'] = this._setTextProperty.bind("Checked");
        callee._setters['customText'] = this._setTextProperty.bind("Custom");
        callee._setters['disabledText'] = this._setTextProperty.bind("Disabled");

        callee._setters['textColor'] = this._setColorProperty.bind("Normal");
        callee._setters['normalTextColor'] = this._setColorProperty.bind("Normal");
        callee._setters['focusedTextColor'] = this._setColorProperty.bind("Focused");
        callee._setters['selectedTextColor'] = this._setColorProperty.bind("Selected");
        callee._setters['pressedTextColor'] = this._setColorProperty.bind("Pressed");
        callee._setters['checkedTextColor'] = this._setColorProperty.bind("Checked");
        callee._setters['customTextColor'] = this._setColorProperty.bind("Custom");
        callee._setters['disabledTextColor'] = this._setColorProperty.bind("Disabled");

        callee._setters['textShadow'] = this._setShadowProperty.bind("Normal");
        callee._setters['normalTextShadow'] = this._setShadowProperty.bind("Normal");
        callee._setters['focusedTextShadow'] = this._setShadowProperty.bind("Focused");
        callee._setters['selectedTextShadow'] = this._setShadowProperty.bind("Selected");
        callee._setters['pressedTextShadow'] = this._setShadowProperty.bind("Pressed");
        callee._setters['checkedTextShadow'] = this._setShadowProperty.bind("Checked");
        callee._setters['customTextShadow'] = this._setShadowProperty.bind("Custom");
        callee._setters['disabledTextShadow'] = this._setShadowProperty.bind("Disabled");

        callee._setters['textFont'] = this._setFontProperty.bind("Normal");
        callee._setters['normalTextFont'] = this._setFontProperty.bind("Normal");
        callee._setters['focusedTextFont'] = this._setFontProperty.bind("Focused");
        callee._setters['selectedTextFont'] = this._setFontProperty.bind("Selected");
        callee._setters['pressedTextFont'] = this._setFontProperty.bind("Pressed");
        callee._setters['checkedTextFont'] = this._setFontProperty.bind("Checked");
        callee._setters['customTextFont'] = this._setFontProperty.bind("Custom");
        callee._setters['disabledTextFont'] = this._setFontProperty.bind("Disabled");

        callee._setters['textSize'] = this._setTextSize.bind(callee);
        callee._setters['textGravity'] = this._setTextGravity.bind(callee);
        callee._setters['textInsets'] = this._setTextInsets.bind(callee);
        callee._setters['fontLocation'] = this._setFontLocation.bind(callee);

    },
    _registerGettersForLabel: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._getters['text'] = this._getTextProperty.bind("Normal");
        callee._getters['normalText'] = this._getTextProperty.bind("Normal");
        callee._getters['focusedText'] = this._getTextProperty.bind("Focused");
        callee._getters['selectedText'] = this._getTextProperty.bind("Selected");
        callee._getters['pressedText'] = this._getTextProperty.bind("Pressed");
        callee._getters['checkedText'] = this._getTextProperty.bind("Checked");
        callee._getters['customText'] = this._getTextProperty.bind("Custom");
        callee._getters['disabledText'] = this._getTextProperty.bind("Disabled");

        callee._getters['textColor'] = this._getColorProperty.bind("Normal");
        callee._getters['normalTextColor'] = this._getColorProperty.bind("Normal");
        callee._getters['focusedTextColor'] = this._getColorProperty.bind("Focused");
        callee._getters['selectedTextColor'] = this._getColorProperty.bind("Selected");
        callee._getters['pressedTextColor'] = this._getColorProperty.bind("Pressed");
        callee._getters['checkedTextColor'] = this._getColorProperty.bind("Checked");
        callee._getters['customTextColor'] = this._getColorProperty.bind("Custom");
        callee._getters['disabledTextColor'] = this._getColorProperty.bind("Disabled");

        callee._getters['textShadow'] = this._getShadowProperty.bind("Normal");
        callee._getters['normalTextShadow'] = this._getShadowProperty.bind("Normal");
        callee._getters['focusedTextShadow'] = this._getShadowProperty.bind("Focused");
        callee._getters['selectedTextShadow'] = this._getShadowProperty.bind("Selected");
        callee._getters['pressedTextShadow'] = this._getShadowProperty.bind("Pressed");
        callee._getters['checkedTextShadow'] = this._getShadowProperty.bind("Checked");
        callee._getters['customTextShadow'] = this._getShadowProperty.bind("Custom");
        callee._getters['disabledTextShadow'] = this._getShadowProperty.bind("Disabled");

        callee._getters['textFont'] = this._getFontProperty.bind("Normal");
        callee._getters['normalTextFont'] = this._getFontProperty.bind("Normal");
        callee._getters['focusedTextFont'] = this._getFontProperty.bind("Focused");
        callee._getters['selectedTextFont'] = this._getFontProperty.bind("Selected");
        callee._getters['pressedTextFont'] = this._getFontProperty.bind("Pressed");
        callee._getters['checkedTextFont'] = this._getFontProperty.bind("Checked");
        callee._getters['customTextFont'] = this._getFontProperty.bind("Custom");
        callee._getters['disabledTextFont'] = this._getFontProperty.bind("Disabled");

        callee._getters['textSize'] = this._getTextSize.bind(callee);
        callee._getters['textGravity'] = this._getTextGravity.bind(callee);
        callee._getters['textInsets'] = this._getTextInsets.bind(callee);
        callee._getters['fontLocation'] = this._getFontLocation.bind(callee);


    },

    _registerSettersForCellView: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._setters['title'] = this._setTitleProperty.bind("Normal");
        callee._setters['normalTitle'] = this._setTitleProperty.bind("Normal");
        callee._setters['focusedTitle'] = this._setTitleProperty.bind("Focused");
        callee._setters['selectedTitle'] = this._setTitleProperty.bind("Selected");
        callee._setters['pressedTitle'] = this._setTitleProperty.bind("Pressed");
        callee._setters['checkedTitle'] = this._setTitleProperty.bind("Checked");
        callee._setters['customTitle'] = this._setTitleProperty.bind("Custom");
        callee._setters['disabledTitle'] = this._setTitleProperty.bind("Disabled");

        callee._setters['titleColor'] = this._setTitleColorProperty.bind("Normal");
        callee._setters['normalTitleColor'] = this._setTitleColorProperty.bind("Normal");
        callee._setters['focusedTitleColor'] = this._setTitleColorProperty.bind("Focused");
        callee._setters['selectedTitleColor'] = this._setTitleColorProperty.bind("Selected");
        callee._setters['pressedTitleColor'] = this._setTitleColorProperty.bind("Pressed");
        callee._setters['checkedTitleColor'] = this._setTitleColorProperty.bind("Checked");
        callee._setters['customTitleColor'] = this._setTitleColorProperty.bind("Custom");
        callee._setters['disabledTitleColor'] = this._setTitleColorProperty.bind("Disabled");

        callee._setters['titleShadow'] = this._setTitleShadowProperty.bind("Normal");
        callee._setters['normalTitleShadow'] = this._setTitleShadowProperty.bind("Normal");
        callee._setters['focusedTitleShadow'] = this._setTitleShadowProperty.bind("Focused");
        callee._setters['selectedTitleShadow'] = this._setTitleShadowProperty.bind("Selected");
        callee._setters['pressedTitleShadow'] = this._setTitleShadowProperty.bind("Pressed");
        callee._setters['checkedTitleShadow'] = this._setTitleShadowProperty.bind("Checked");
        callee._setters['customTitleShadow'] = this._setTitleShadowProperty.bind("Custom");
        callee._setters['disabledTitleShadow'] = this._setTitleShadowProperty.bind("Disabled");

        callee._setters['titleFont'] = this._setTitleFontProperty.bind("Normal");
        callee._setters['normalTitleFont'] = this._setTitleFontProperty.bind("Normal");
        callee._setters['focusedTitleFont'] = this._setTitleFontProperty.bind("Focused");
        callee._setters['selectedTitleFont'] = this._setTitleFontProperty.bind("Selected");
        callee._setters['pressedTitleFont'] = this._setTitleFontProperty.bind("Pressed");
        callee._setters['checkedTitleFont'] = this._setTitleFontProperty.bind("Checked");
        callee._setters['customTitleFont'] = this._setTitleFontProperty.bind("Custom");
        callee._setters['disabledTitleFont'] = this._setTitleFontProperty.bind("Disabled");

        callee._setters['titleSize'] = this._setTitleSize.bind(callee);
        callee._setters['titleGravity'] = this._setTitleGravity.bind(callee);


        callee._setters['rightImage'] = this._setRightImageProperty.bind("Normal");
        callee._setters['normalRightImage'] = this._setRightImageProperty.bind("Normal");
        callee._setters['focusedRightImage'] = this._setRightImageProperty.bind("Focused");
        callee._setters['selectedRightImage'] = this._setRightImageProperty.bind("Selected");
        callee._setters['pressedRightImage'] = this._setRightImageProperty.bind("Pressed");
        callee._setters['checkedRightImage'] = this._setRightImageProperty.bind("Checked");
        callee._setters['customRightImage'] = this._setRightImageProperty.bind("Custom");
        callee._setters['disabledRightImage'] = this._setRightImageProperty.bind("Disabled");

        callee._setters['rightImageFit'] = this._setRightImageFit.bind(callee);
        callee._setters['rightImageGravity'] = this._setRightImageGravity.bind(callee);


    },
    _registerGettersForCellView: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._getters['title'] = this._getTitleProperty.bind("Normal");
        callee._getters['normalTitle'] = this._getTitleProperty.bind("Normal");
        callee._getters['focusedTitle'] = this._getTitleProperty.bind("Focused");
        callee._getters['selectedTitle'] = this._getTitleProperty.bind("Selected");
        callee._getters['pressedTitle'] = this._getTitleProperty.bind("Pressed");
        callee._getters['checkedTitle'] = this._getTitleProperty.bind("Checked");
        callee._getters['customTitle'] = this._getTitleProperty.bind("Custom");
        callee._getters['disabledTitle'] = this._getTitleProperty.bind("Disabled");

        callee._getters['titleColor'] = this._getTitleColorProperty.bind("Normal");
        callee._getters['normalTitleColor'] = this._getTitleColorProperty.bind("Normal");
        callee._getters['focusedTitleColor'] = this._getTitleColorProperty.bind("Focused");
        callee._getters['selectedTitleColor'] = this._getTitleColorProperty.bind("Selected");
        callee._getters['pressedTitleColor'] = this._getTitleColorProperty.bind("Pressed");
        callee._getters['checkedTitleColor'] = this._getTitleColorProperty.bind("Checked");
        callee._getters['customTitleColor'] = this._getTitleColorProperty.bind("Custom");
        callee._getters['disabledTitleColor'] = this._getTitleColorProperty.bind("Disabled");

        callee._getters['titleShadow'] = this._getTitleShadowProperty.bind("Normal");
        callee._getters['normalTitleShadow'] = this._getTitleShadowProperty.bind("Normal");
        callee._getters['focusedTitleShadow'] = this._getTitleShadowProperty.bind("Focused");
        callee._getters['selectedTitleShadow'] = this._getTitleShadowProperty.bind("Selected");
        callee._getters['pressedTitleShadow'] = this._getTitleShadowProperty.bind("Pressed");
        callee._getters['checkedTitleShadow'] = this._getTitleShadowProperty.bind("Checked");
        callee._getters['customTitleShadow'] = this._getTitleShadowProperty.bind("Custom");
        callee._getters['disabledTitleShadow'] = this._getTitleShadowProperty.bind("Disabled");

        callee._getters['titleFont'] = this._getTitleFontProperty.bind("Normal");
        callee._getters['normalTitleFont'] = this._getTitleFontProperty.bind("Normal");
        callee._getters['focusedTitleFont'] = this._getTitleFontProperty.bind("Focused");
        callee._getters['selectedTitleFont'] = this._getTitleFontProperty.bind("Selected");
        callee._getters['pressedTitleFont'] = this._getTitleFontProperty.bind("Pressed");
        callee._getters['checkedTitleFont'] = this._getTitleFontProperty.bind("Checked");
        callee._getters['customTitleFont'] = this._getTitleFontProperty.bind("Custom");
        callee._getters['disabledTitleFont'] = this._getTitleFontProperty.bind("Disabled");

        callee._getters['titleSize'] = this._getTitleSize.bind(callee);
        callee._getters['titleGravity'] = this._getTitleGravity.bind(callee);


        callee._getters['rightImage'] = this._getRightImageProperty.bind("Normal");
        callee._getters['normalRightImage'] = this._getRightImageProperty.bind("Normal");
        callee._getters['focusedRightImage'] = this._getRightImageProperty.bind("Focused");
        callee._getters['selectedRightImage'] = this._getRightImageProperty.bind("Selected");
        callee._getters['pressedRightImage'] = this._getRightImageProperty.bind("Pressed");
        callee._getters['checkedRightImage'] = this._getRightImageProperty.bind("Checked");
        callee._getters['customRightImage'] = this._getRightImageProperty.bind("Custom");
        callee._getters['disabledRightImage'] = this._getRightImageProperty.bind("Disabled");

        callee._getters['rightImageFit'] = this._getRightImageFit.bind(callee);
        callee._getters['rightImageGravity'] = this._getRightImageGravity.bind(callee);
    },

    _setImageProperty: function (callee, args)
    {
        var state = this;
        if (typeof args === 'string')
        {
            var url = args;
            args = {
                url: url,
                size: undefined
            };
        }
        else if (!args || !(args.hasOwnProperty("url")))
        {
            throw new Error("Too few arguments for " + state + "Image ");
        }
        if (!(args.size instanceof Array && args.size.length > 1))
        {
            args.size = [1, 1];
        }

        if (typeof args.url === 'string' && args.url.length > 1)
        {
            return callee.setImage(args.url, Commands.State[state], args.size);
        }
        else
        {
            throw new Error("Invalid arguments for image in setImage | _setNormalImage");
        }
    },
    _getImageProperty: function (callee)
    {
        var state = this;
        return callee.getImage(Commands.State[state] || 0);
    },

    _setTextProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "Text ");
        }
        return callee.setText(args, Commands.State[state]);
    },
    _setFontLocation: function (callee, args)
    {
        callee.setFontLocation(args);
    },
    _getTextProperty: function (callee)
    {
        var state = this;
        return callee.getText(Commands.State[state] || 0);
    },

    _setFontProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextFont ");
        }

        return callee.setTextFont(args, Commands.State[state]);
    },

    _getFontProperty: function (callee)
    {
        var state = this;
        return callee.getTextFont(Commands.State[state] || 0);
    },

    _setColorProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextColor ");
        }
        return callee.setTextColor(args, Commands.State[state]);
    },

    _getColorProperty: function (callee)
    {
        var state = this;
        return callee.getTextColor(Commands.State[state] || 0);
    },

    _setShadowProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextShadow");
        }

        return callee.setTextShadow(args, Commands.State[state]);
    },
    _getShadowProperty: function (callee, state)
    {
        return callee.getTextShadow(Commands.State[state] || 0);
    },

    _setRightImageProperty: function (callee, args)
    {
        var state = this;
        if (!args || !(args.hasOwnProperty("url") && args.hasOwnProperty("size")))
        {
            throw new Error("Too few arguments for " + state + "RightImage ");
        }

        if (typeof args.url === 'string' && args.url.length > 1 && args.size instanceof Array && args.size.length > 1)
        {
            return callee.setRightImage(args.url, Commands.State[state], args.size);
        }
        else
        {
            throw new Error("Invalid arguments for image in setImage | _setNormalRightImage");
        }
    },
    _getRightImageProperty: function (callee)
    {
        var state = this;
        return callee.getRightImage(Commands.State[state] || 0);
    },

    _setImageFit: function (callee, args)
    {
        if (callee.setImageFit)
        {
            return callee.setImageFit(args);
        }
        return undefined;
    },
    _setImageGravity: function (callee, args)
    {
        if (callee.setImageGravity)
        {
            return callee.setImageGravity(args);
        }
        return undefined;
    },

    _getImageFit: function (callee, args)
    {
        if (callee.getImageFit)
        {
            return callee.getImageFit(args);
        }
        return undefined;
    },
    _getImageGravity: function (callee, args)
    {
        if (callee.getImageGravity)
        {
            return callee.getImageGravity(args);
        }
        return undefined;
    },


    _setTextSize: function (callee, args)
    {
        if (callee.setTextSize)
        {
            return callee.setTextSize(args);
        }
        return undefined;
    },

    _setTextGravity: function (callee, args)
    {
        if (callee.setTextGravity)
        {
            return callee.setTextGravity(args);
        }
        return undefined;
    },

    _setTextInsets: function (callee, args)
    {
        if (callee.setTextInsets)
        {
            return callee.setTextInsets(args);
        }
        return undefined;
    },

    _getTextSize: function (callee, args)
    {
        if (callee.getTextSize)
        {
            return callee.getTextSize(args);
        }
        return undefined;
    },
    _getTextGravity: function (callee, args)
    {
        if (callee.getTextGravity)
        {
            return callee.getTextGravity(args);
        }
        return undefined;
    },
    _getTextInsets: function (callee)
    {
        if (callee.getTextInsets)
        {
            return callee.getTextInsets();
        }
        return undefined;
    },
    _getFontLocation: function (callee)
    {
        if (callee.getFontLocation)
        {
            return callee.getFontLocation();
        }
        return undefined;
    },
    _setTitleSize: function (callee, args)
    {
        if (callee.setTitleSize)
        {
            return callee.setTitleSize(args);
        }
        return undefined;
    },
    _setTitleGravity: function (callee, args)
    {
        if (callee.setTitleGravity)
        {
            return callee.setTitleGravity(args);
        }
        return undefined;
    },

    _setRightImageFit: function (callee, args)
    {
        if (callee.setRightImageFit)
        {
            return callee.setRightImageFit(args);
        }
        return undefined;
    },
    _setRightImageGravity: function (callee, args)
    {
        if (callee.setRightImageGravity)
        {
            return callee.setRightImageGravity(args);
        }
        return undefined;
    },

    _getTitleSize: function (callee, args)
    {
        if (callee.setTitleSize)
        {
            return callee.setTitleSize(args);
        }
        return undefined;
    },
    _getTitleGravity: function (callee, args)
    {
        if (callee.getTitleGavity)
        {
            return callee.getTitleGavity(args);
        }
        return undefined;
    },

    _getRightImageFit: function (callee, args)
    {
        if (callee.getRightImageFit)
        {
            return callee.getRightImageFit(args);
        }
        return undefined;
    },
    _getRightImageGravity: function (callee, args)
    {
        if (callee.getRightImageGravity)
        {
            return callee.getRightImageGravity(args);
        }
        return undefined;
    },

    _setTitleProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "Title ");
        }
        return callee.setTitle(args, Commands.State[state]);
    },
    _getTitleProperty: function (callee)
    {
        var state = this;
        return callee.getTitle(Commands.State[state] || 0);
    },

    _setTitleFontProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleFont ");
        }

        return callee.setTitleFont(args, Commands.State[state]);
    },

    _getTitleFontProperty: function (callee)
    {
        var state = this;
        return callee.getTitleFont(Commands.State[state] || 0);
    },

    _setTitleColorProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleColor ");
        }
        return callee.setTitleColor(args, Commands.State[state]);
    },

    _getTitleColorProperty: function (callee)
    {
        var state = this;
        return callee.getTitleColor(Commands.State[state] || 0);
    },

    _setTitleShadowProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleShadow");
        }

        return callee.setTitleShadow(args, Commands.State[state]);
    },
    _getTitleShadowProperty: function (callee)
    {
        var state = this;
        return callee.getTitleShadow(Commands.State[state] || Commands.State.Normal);
    }


});

exports.Commands = Commands;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/ViewGeometry'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/ViewGeometry'] || {}; $MODULE_REGISTRY['NGGo/GLUI/ViewGeometry'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/ViewGeometry.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil Mahmood
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Commands = require('NGGo/GLUI/Commands').Commands;

/**
 * <p>Classes and objects contained by the <code>ViewGeometry</code> class.</p>
 * @name UI.ViewGeometry
 * @namespace
 * @description <p>The <code>ViewGeometry</code> class is a collection of classes and objects that control spatial components for UI views.
 * Derived classes from <code>ViewGeometry</code> include:</p>
 * <ul>
 * <li><code>{@link GLUI.ViewGeometry.Rect}</code></li>
 * <li><code>{@link GLUI.ViewGeometry.Scale}</code></li>
 * </ul>
 * <p><code>ViewGeometry</code> utilizes the following enumerated constants:</p>
 * <ul>
 * <li><code>{@link GLUI.ViewGeometry.FitMode}</code></li>
 * <li><code>{@link GLUI.ViewGeometry.Gravity}</code></li>
 * </ul>
 */

exports.FitModes = Commands.FitMode;
/**
 * @name GLUI.ViewGeometry.FitMode
 * @class Enumeration for image fit modes in a view.
 * @see GLUI.Commands#FitMode
 */

exports.Gravity = {
    /**
     * @name GLUI.ViewGeometry.Gravity
     * @class Enumeration for image gravity in a view.
     */
    /**
     * Center of gravity is the top-left corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopLeft: [0.0, 0.0],
    /**
     * Center of gravity is the top-center portion of the image.
     * @fieldOf GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopCenter: [0.5, 0.0],
    /**
     * Center of gravity is the top-right corner of the image.
     * @fieldOf GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopRight: [1.0, 0.0],
    /**
     * Center of gravity is the left side of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Left: [0.0, 0.5],
    /**
     * Center of gravity is the center of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Center: [0.5, 0.5],
    /**
     * Center of gravity is the right side of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Right: [1.0, 0.5],
    /**
     * Center of gravity is the bottom-left corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomLeft: [0.0, 1.0],
    /**
     * Center of gravity is the bottom-center portion of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomCenter: [0.5, 1.0],
    /**
     * Center of gravity is the bottom-right corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomRight: [1.0, 1.0]
};

var Scale = Class.singleton( /** @lends GLUI.ViewGeometry.Scale.prototype */
{
    /**
     * @name GLUI.ViewGeometry.Scale
     * @class The <code>Scale</code> class constructs objects that handle view geometry for different scales of measurement.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function ()
    {
        var screenUnits = Capabilities.getScreenUnits();
        this.iOSConversion = screenUnits;
        this.pointConversion = this.iOSConversion * 160 / 72;
    },
    Pixels: Commands.Scaling.Pixels,
    Points: Commands.Scaling.Points,
    Unit: Commands.Scaling.Unit,
    Percent: Commands.Scaling.Percent,
    iPhone: Commands.Scaling.iPhone,
    pointConversion: 1.0,
    iOSConversion: 1.0,
    /**
     * Retrieve the supported measurement scale from the device.
     * @param {Number} units The unit of measure.
     * @param {Number} size The screen size of the device.
     * @returns The current screen dimension supported by the device.
     */
    getScale: function (units, size)
    {
        switch (+units)
        {
        case this.Points:
            return this.pointConversion;
        case this.Unit:
            return size;
        case this.Percent:
            return size / 100;
        case this.iPhone:
            return this.iOSConversion;
        }
        return 1.0;
    }
});

var Rect = Class.subclass( /** @lends GLUI.ViewGeometry.Rect.prototype */
{
    /**
     * @name GLUI.ViewGeometry.Rect
     * @class <code>Rect</code> constructs rectangle objects for use as positionable elements in the user interface.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function (arg0)
    {
        if (arg0 instanceof this.constructor)
        {
            // Another Rect
            this.x = arg0.x;
            this.y = arg0.y;
            this.w = arg0.w;
            this.h = arg0.h;
        }
        else if (arg0 instanceof Array)
        {
            if (arguments.length === 2 && arguments[0].length >= 2 && arguments[1] instanceof Array && arguments[1].length >= 2)
            {
                this.x = arguments[0][0];
                this.y = arguments[0][1];
                this.w = arguments[1][0];
                this.h = arguments[1][1];
            }
            else if (arguments.length === 1 && arg0.length >= 4)
            {
                this.x = arg0[0];
                this.y = arg0[1];
                this.w = arg0[2];
                this.h = arg0[3];
            }
            else
            {
                console.log("UI.ViewGeometry.Rect initialized with unparseable Array(s)");
            }
        }
        else if (arguments.length === 4)
        {
            this.x = arguments[0];
            this.y = arguments[1];
            this.w = arguments[2];
            this.h = arguments[3];
        }
        return this;
    },
    /**
     * @returns {Boolean} Returns <code>true</code> if any component value is undefined, NaN, or the value indicates this rect has an area of 0 (<i>width</i> * <i>height</i>).
     */
    isEmpty: function ()
    {
        return (this.w * this.h <= 0) || isNaN(this.x) || isNaN(this.y) || isNaN(this.w) || isNaN(this.h);
    },
    /**
     * Copy the component values of this <code>Rect</code>
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> with identical component values.
     */
    copy: function ()
    {
        return new(this).constructor(this);
    },
    /**
     * Copy the component values of this <code>Rect</code>
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> with identical component values.
     */
    array: function ()
    {
        return [this.x, this.y, this.w, this.h];
    },
    /**
     * Set the dimensions of this <code>Rect</code> as an inset.
     * @example var imageRect = null;
     * var remainingRect = rect.copy();
     * ...
     * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
     * @param {Number} t The size for the top of the rectangle.
     * @param {Number} r The size for the right side of the rectangle.
     * @param {Number} b The size for the bottom of the rectangle.
     * @param {Number} l The size for the left side of the rectangle.
     * @param {GLUI.ViewGeometry.Scale} units The unit of measure for the rectangle.
     * @returns {GLUI.ViewGeometry.Rect} This function returns <code>this</code> to support method invocation chaining.
     */
    inset: function (t, r, b, l, units)
    {
        if (arguments.length > 4)
        {
            var xScale = Scale.getScale(units, this.w);
            var yScale = Scale.getScale(units, this.h);
            t = Math.floor(t * yScale);
            r = Math.floor(r * xScale);
            b = Math.floor(b * yScale);
            l = Math.floor(l * xScale);
        }
        if (arguments.length < 2)
        {
            r = t;
        }
        if (arguments.length < 4)
        {
            b = t;
            l = r;
        }
        this.y += t;
        this.h -= t + b;
        this.x += l;
        this.w -= l + r;
        return this;
    },
    /**
     *  Create and return a new <code>Rect</code> representing the top (if positive) or bottom (if negative).
     *  Destructively modifies this Rect, removing the new rect area from the receiver.
     * @example var topPart = rect.inset(10).sliceVertical(50, GLUI.Scale.Percent);
     * @param {Number} height The new rect height.
     * @param {GLUI.ViewGeometry.Scale} [units] The scale of measurement.
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
     * @see GLUI.ViewGeometry.Rect#sliceHorizontal
     */
    sliceVertical: function (height, units)
    {
        if (arguments.length > 1)
        {
            height = Math.floor(height * Scale.getScale(units, this.h));
        }
        var newRect = this.copy();
        if (height < 0)
        {
            // Return the bottom area...
            newRect.h = -height;
            this.h += height;
            newRect.y += this.h;
        }
        else
        {
            newRect.h = height;
            this.y += height;
            this.h -= height;
        }
        return newRect;
    },
    /**
     *  Create and return a new <code>Rect</code> representing the left (if positive) or right (if negative).
     *  Destructively modifies this Rect, removing the new rect area from the receiver.
     * @example var imageRect = null;
     * var remainingRect = rect.copy();
     * ...
     * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
     * @param {Number} width The new rect width.
     * @param {UI.ViewGeometry.Scale} [units] The scale of measurement.
     * @returns {UI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
     * @see UI.ViewGeometry.Rect#sliceVertical
     */
    sliceHorizontal: function (width, units)
    {
        if (arguments.length > 1)
        {
            width = Math.floor(width * Scale.getScale(units, this.w));
        }

        var newRect = this.copy();
        if (width < 0)
        {
            newRect.w = -width;
            this.w += width;
            newRect.x += this.w;
        }
        else
        {
            newRect.w = width;
            this.x += width;
            this.w -= width;
        }
        return newRect;
    },
    toString: function ()
    {
        return "Rect: {" + this.array().join(',') + "}";
    },
    /**
     * Retrieve an array of component values for this <code>Rect</code> with rows and columns redistributed evenly.
     * @returns {Array (Number)}
     * @param {Number} rows The rect rows.
     * @param {Number} columns The rect columns.
     * @param {String} flat A one-dimensional array (left to right, top to bottom).
     */
    getGrid: function (rows, columns, flat)
    {
        var i,j;
        flat = (flat === true);
        var cellW = Math.floor(this.w / columns);
        var cellH = Math.floor(this.h / rows);
        var rowSet = [];
        for (i = 0; i < rows; i++)
        {
            var colSet = [];
            for (j = 0; j < columns; j++)
            {
                var r = new this.constructor(this.x + j * cellW, this.y + i * cellH, cellW, cellH);
                (flat ? rowSet : colSet).push(r);
            }
            if (!flat)
            {
                rowSet.push(colSet);
            }
        }
        return rowSet;
    }
});

exports.Scale = Scale;
exports.Rect = Rect;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Element'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Element'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Element'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Element.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Jabbar M.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

exports.Element = Class.subclass( /** @lends GLUI.Element.prototype */
{
    classname: 'Element',
    _setters: [],
    _getters: [],
    /**
     * @class The <code>Element</code> class is a base class for derived classes that manage object properties and handle user interface events.<br><br>
     * <b>Caution!:</b> This base class is not exported in the GLUI module. Do not access it or subclass it at runtime.
     * Derived classes from <code>Element</code> include:
     * <div class="ul">
     * <li>{@link GLUI.AbstractView}</li>
     * <li>{@link GLUI.ListViewSection}</li>
     * </div>
     * @constructs The default constructor.
     * @param {String} properties
     * @augments Core.Class
     */
    initialize: function ()
    {
        this._internalGLObject = null;
        this._onLoadCallBack = null;
        this._onUnloadCallBack = null;
        this.__retainCount = 0; //by default ngcore uses 0, will be used by listview.
        this._registerSetters(); //to be implemented by the derived classes
        this._registerGetters(); //to be implemented by the derived classes
    },
    /**
     * @private
     * @name GLUI.Element#setOnLoad
     * @description Set a function to call when the <code>load</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @param {Function} loadCallback The new functoin to call.<br><br><b>Note:</b> The <code>load</code> event is disabled
     * if the value of this parameter is not a function.
     * @example function() {
     *  onLoad.loaded = true;
     * };
     * @see GLUI.Element#event:getOnLoad
     */
    setOnLoad: function (onLoadCallBack)
    {
        this._onLoadCallBack = onLoadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#getOnUnload
     * @description Retrieve the function to call when the <code>unload</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @returns {Function} The current function to call.
     * @see GLUI.Element#event:setOnUnload
     */
    getOnUnload: function ()
    {
        return this._onUnloadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#getOnLoad
     * @description Retrieve the function to call when the <code>load</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @returns {Function} The current function to call.
     * @see GLUI.Element#event:setOnLoad
     */
    getOnLoad: function ()
    {
        return this._onLoadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#setOnUnload
     * @description Set a function to call when the <code>unload</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @param {Function} unloadCallback The new functoin to call.<br><br><b>Note:</b> The <code>unload</code> event is disabled
     * if the value of this parameter is not a function.
     * @example function() {
     *  onUnload.unloaded = true;
     * };
     * @see GLUI.Element#event:getOnUnload
     */
    setOnUnload: function (onUnloadCallback)
    {
        this._onUnloadCallBack = onUnloadCallback;
    },
    /**
     * Set the property value for each specified key. Property values are passed in as key/value pairs.
     * @param {Object} dict A dictionary of property key/value pairs.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttribute
     * @status Android, Test
     */
    setAttributes: function (dict)
    {
        var key;
        for (key in dict)
        {
            if (dict.hasOwnProperty(key))
            {
                this.setAttribute(key, dict[key]);
            }
        }
        return this;
    },
    /**
     * Retrieve property values for each specified key.
     * @param {String} list A list of property keywords.
     * @returns {Object} A list of key/value pairs.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#setAttribute,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    getAttributes: function (list)
    {
        var i, accessor;
        var output = {};
        if (list instanceof Array)
        {
            for (i = 0; i < list.length; i++)
            {
                var key = list[i];
                var methodName = this._getters[key];
                if (typeof methodName === 'function')
                {
                    output[key] = this._getters[key](this);
                }
            }
        }
        else
        {
            for (accessor in this._getters)
            {
                if (this._getters.hasOwnProperty(accessor))
                {
                    output[accessor] = this._getters[accessor](this);
                }
            }
        }
        return output;
    },
    /**
     * Retrieve the property value of the given key.
     * @param {String} key The property keyword.
     * @returns {String} The current property value.
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttribute,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    getAttribute: function (key)
    {
        var getter = this._getters[key];
        if (typeof getter === 'function')
        {
            return getter(this, key);
        }
        else
        {
            console.log("Getter for '" + key + "' not found for " + this.classname);
            return undefined;
        }
    },
    /**
     * Set the property value for the given key.
     * @example var glView = new GLUI.GLView
     * ...
     * glView.setAttribute('normalImage', {url:'./Content/example.png', size:[120, 30] });
     * @param {String} key The property keyword.
     * @param {String} value The new property value.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    setAttribute: function (key, value)
    {
        var myFunction = this._setters[key];
        if (myFunction)
        {
            myFunction(this, value);
        }
        else
        {
            console.log("Setter for '" + key + "' not found for " + this.classname);
        }
        return this;
    },
    retain: function ()
    { //will be used by listview.
        if (this.__retainCount)
        {
            ++this.__retainCount;
        }
        else
        {
            this.__retainCount = 1;
        }
        return this;
    },
    release: function ()
    { //will be used by listview.
        if (--this.__retainCount === 0)
        {
            this.destroy();
        }
    },
    retainCount: function ()
    { //will be used by listview.
        return this.__retainCount;
    },
    /**
     * @function
     * @description Destroy this instance and release resources on the backend.
     * @status Android, Test
     */
    destroy: function ($super)
    {
        if (this._internalGLObject)
        {
            this._internalGLObject.destroy();
            this._internalGLObject = null;
        }
        this.__retainCount = 0;
        //this._setters = null; //SETTERS ARE AT CLASS LEVEL
        //this._getters = null; //GETTERS ARE AT CLASS LEVEL
        this._onLoadCallBack = null;
        this._onUnloadCallBack = null;
        if ($super)
        {
            $super();
        }
    },
    /**
     * @private
     * */
    getGLObject: function ()
    {
        if (this._parentNode)
        {
            return this._parentNode;
        }
        else
        {
            return this._internalGLObject;
        }
    },
    _registerSetters: function ()
    {
        //must be written by derived classes
    },
    _registerGetters: function ()
    {
        //must be written by derived classes
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Util'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Util'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Util'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Util.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan S.
 *  @co-author: Shamas S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Node = require('NGCore/Client/GL2/Node').Node;
var Primitive = require('NGCore/Client/GL2/Primitive').Primitive;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Root = require('NGCore/Client/GL2/Root').Root;
var Core = require('NGCore/Client/Core').Core;
var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Util = {
    getAnchor: function (sprite)
    {
        return sprite._animation.getFrame(0).getAnchor();
    },
    TouchFilter: Core.MessageListener.subclass(
    {
        classname: 'TouchFilter',
        initialize: function (touchId)
        {
            this.target = new TouchTarget();
            this.target.setAnchor([0, 0]);
            this.trackingId = touchId;
            this.ignoreFingers = [];
            this.shouldDestroy = false;
            var orientation = OrientationEmitter.getInterfaceOrientation();
            var w = Core.Capabilities.getScreenWidth();
            var h = Core.Capabilities.getScreenHeight();
            if ((orientation === OrientationEmitter.Orientation.Portrait) || (orientation === OrientationEmitter.Orientation.PortraitUpsideDown))
            {
                this.target.setSize(w, h);
            }
            else
            {
                this.target.setSize(h, w);
            }
            this.target.getTouchEmitter().addListener(this, this.onTouch);
            this.target.setDepth(65535);
            Root.addChild(this.target);
        },
        destroy: function ($super)
        {
            Root.removeChild(this.target);
            this.target.destroy();
            $super();
        },
        setDestroyFlag: function ()
        {
            this.shouldDestroy = true;
            if (this.isValidTouch())
            {
                this.destroy();
            }
        },
        onTouch: function (touch)
        {
            var touchId = touch.getId();
            if (touchId === this.trackingId)
            {
                console.log("<NGGo> Error: Invalid input at GLUIUtil.TouchFilter.onTouch()");
                console.log("<NGGo> touchId: " + touchId);
                console.log("<NGGo> this.trackingId: " + this.trackingId);
                this.destroy();
                return true;
            }
            switch (touch.getAction())
            {
            case touch.Action.Start:
                if (!this.shouldDestroy)
                {
                    this.ignoreFingers.push(touch.getId());
                }
                break;
            case touch.Action.End:
                var index = this.ignoreFingers.indexOf(touch.getId());
                if (index !== -1)
                {
                    this.ignoreFingers.splice(index, 1);
                }
                if (this.shouldDestroy)
                {
                    this.destroy();
                }
                break;
            default:
                break;
            }
            return true;
        },
        isValidTouch: function ()
        {
            if (this.ignoreFingers.length === 0)
            {
                return true;
            }
            return false;
        }
    }),
    Rectangle: Node.subclass(
    {
        classname: 'Rectangle',
        initialize: function ()
        {
            this.setChildrenDepthGrouped(true);
            this._color = null;
            this._size = null;
            this._primitive = null;
        },
        setFrame: function (frame)
        {
            frame = new Core.Rect(frame);
            this.setPosition(frame.getOrigin());
            this._size = frame.getSize();
            this._updateBox();
        },
        destroy: function ()
        {
            if (this._primitive)
            {
                this._primitive.destroy();
                this._primitive = null;
            }
            this._color = null;
            this._size = null;
        },
        setColor: function (color)
        {
            this._color = new Core.Color(color);
            this._updateBox();
        },
        _updateBox: function ()
        {
            if (!this._size || !this._color)
            {
                return;
            }
            if (this._primitive !== null)
            {
                this.removeChild(this._primitive);
                this._primitive.destroy();
            }
            var p = new Primitive();
            p.setColor(this._color);
            var w = this._size.getWidth();
            var h = this._size.getHeight();
            p.setType(Primitive.Type.TriangleFan);
            var v = [];
            v.push(new Primitive.Vertex([0, 0], [0, 0]));
            v.push(new Primitive.Vertex([w, 0], [0, 0]));
            v.push(new Primitive.Vertex([w, h], [0, 0]));
            v.push(new Primitive.Vertex([0, h], [0, 0]));
            p.spliceVertexes.apply(p, ([0, 0]).concat(v));
            this._primitive = p;
            this.addChild(this._primitive);
        }
    }),
    makePrimitive: function (x, y, w, h, color1, color2, color3, color4)
    {
        if (arguments.length <= 6)
        {
            color3 = color2 || color1;
            color4 = color2 || color1;
            color2 = color1;
        }
        var p = new Primitive();
        p.setType(Primitive.Type.TriangleStrip);
        p.pushVertex(new Primitive.Vertex([0, 0], [0, 0], color1));
        p.pushVertex(new Primitive.Vertex([w, 0], [1, 0], color2));
        p.pushVertex(new Primitive.Vertex([0, h], [0, 1], color3));
        p.pushVertex(new Primitive.Vertex([w, h], [1, 1], color4));
        p.setPosition(x, y);
        return p;
    },
    hexToARGB: function (color)
    {
        if (color === null || color === undefined)
        {
            // empty color string
            return [0, 0, 0, 0];
        }
        if ((isNaN("0x" + color)))
        {
            throw new Error('Expecting a color value but found ' + typeof (color));
        }
        var n = color.length;
        var A = 1,
            R = 0,
            G = 0,
            B = 0;
        switch (n)
        {
        case 2:
            A = 1;
            R = color.charAt(0);
            R = R + color.charAt(1);
            B = R;
            G = R;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 3:
            A = 1;
            R = color.charAt(0);
            G = color.charAt(1);
            B = color.charAt(2);
            R = R + R;
            G = G + G;
            B = B + B;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 4:
            A = color.charAt(0);
            R = color.charAt(1);
            G = color.charAt(2);
            B = color.charAt(3);
            A = A + A;
            R = R + R;
            G = G + G;
            B = B + B;
            A = parseInt(A, 16) / 255.0;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 6:
            A = 1;
            R = color.substring(0, 2);
            G = color.substring(2, 4);
            B = color.substring(4, 6);
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 8:
            A = color.substring(0, 2);
            R = color.substring(2, 4);
            G = color.substring(4, 6);
            B = color.substring(6, 8);
            A = parseInt(A, 16) / 255.0;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        default:
            if (n > 8)
            {
                console.log('Exception: Hex String exceeds allowed precision');
            }
            A = 1;
            R = 0;
            G = 0;
            B = 0;
            break;
        }
        return [A, R, G, B];
    },
    getOrientationSreenHeight: function ()
    {
        if (OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.Portrait || OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.PortraitUpsideDown)
        {
            return Capabilities.getScreenHeight();
        }
        else
        {
            return Capabilities.getScreenWidth();
        }
    },
    getOrientationSreenWidth: function ()
    {
        if (OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.LandscapeLeft || OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.LandscapeRight)
        {
            return Capabilities.getScreenWidth();
        }
        else
        {
            return Capabilities.getScreenHeight();
        }
    }
};
exports.Util = Util;; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/AbstractView'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/AbstractView'] || {}; $MODULE_REGISTRY['NGGo/GLUI/AbstractView'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/AbstractView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Gohar A., Taha S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
//Only Elemenet require_ should be here, rest should be within their respective methods, this will decrease the global overhead of the application.
var Color = require('NGCore/Client/Core/Color').Color;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var Point = require('NGCore/Client/Core/Point').Point;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var Node = require('NGCore/Client/GL2/Node').Node;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Element = require('NGGo/GLUI/Element').Element;
var Rect = require('NGGo/GLUI/ViewGeometry').Rect;
var UIRect = require('NGCore/Client/UI/ViewGeometry').Rect;
var Commands = require('NGGo/GLUI/Commands').Commands;
var Util = require('NGGo/GLUI/Util').Util;
exports.AbstractView = Element.subclass( /** @lends GLUI.AbstractView.prototype */
{
    classname: 'AbstractView',
    /**
     * @class The <code>AbstractView</code> class is a base class for derived classes that handle and manage GLUI views.<br><br>
     * <b>Caution!:</b> This base class is not exported in the GLUI module. Do not access it or subclass it at runtime.
     * Derived classes from <code>AbstractView</code> include:
     * <div class="ul">
     * <li>{@link GLUI.Button}</li>
     * <li>{@link GLUI.CellView}</li>
     * <li>{@link GLUI.CheckBox}</li>
     * <li>{@link GLUI.Image}</li>
     * <li>{@link GLUI.Label}</li>
     * <li>{@link GLUI.View}</li>
     * </div>
     * @constructs The default constructor.
     * @augments GLUI.Element
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     */
    initialize: function ($super)
    {
        $super();
        this._frame = [0, 0, 0, 0];
        this._target = null;
        this._anchor = null;
        this._fitMode = null;
        this._messageListener = null;
        this._clickCallBack = null;
        this._state = Commands.State.Normal;
        this._images = [];
        this._parent = null;
        this._position = null;
        this._alpha = 1.0;
        this.__bgAlpha = 1.0;
        this.__internalAlpha = 1.0;
        this.__ARGB = [];
        this._backgroundColor = null;
        this._parentNode = null;
        this._bgPrimitive = null;
        this._enabled = true;
        this._visible = true;
        this._parentEnabled = true;
        this._parentVisible = true;
        this._isPressed = false;
        this._clickable = true;
        this._isParentScrollView = false;
        this._OS = Capabilities.getPlatformOS().toLowerCase();
        this._hasMovedOutside = false;
        this._bgColorAlreadySet = false;
        this._gradient = [];
    },
    /**
     * @name GLUI.AbstractView#setAlpha
     * @function
     * @description Set the value of the <code>alpha</code> property. This property defines the level of alpha composting for a specified object when rendered.
     * @example this._node.setAlpha(1);
     * @param {Number} decimal Alpha value ranging between <code>(0.0-1.0)</code>.
     * @see GLUI.AbstractView#getAlpha
     * @type Float
     * @status Flash, Android
     */
    setAlpha: function (alphaValue)
    {
        if (isNaN(alphaValue))
        {
            throw new Error('Wrong arguments for \'alphaValue\' in setAlpha(alphaValue)');
        }
        this._alpha = alphaValue;
        this._updateAlpha();
        return this;
    },
    /**
     * @name GLUI.AbstractView#getAlpha
     * @function
     * @description Retrieve the value of the <code>alpha</code> property.
     * @returns {Number} Alpha value ranging between </code>(0.0-1.0)</code>.
     * @see GLUI.AbstractView#setAlpha
     * @type Float
     * @status Flash, Android
     */
    getAlpha: function ()
    {
        return this._alpha;
    },
    /**
     * @name GLUI.AbstractView#setFrame
     * @function
     * @description Set the value of the <code>frame</code> property. This property defines the size of <code>frame</code> objects.
     * @example var back = new GLUI.Button();
     * ...
     * back.setFrame([10, 10, 64, 64]);
     * @param {Array (Number), Rect} frame This parameter will pass in values in one of two ways:
     * <div class="ul">
     * <li>Single array containing the above four values.</li>
     * <li>A rect specifying the frame (see <code>{@link GLUI.ViewGeometry.Rect}</code>).</li>
     * </div>
     * @see UI.AbstractView#getFrame
     * @function
     */
    setFrame: function (frame)
    {
        if (frame instanceof Array)
        {
            frame = frame.slice(); //frame is okay.
        }
        else if (frame instanceof Rect || frame instanceof UIRect)
        {
            frame = frame.array();
        }
        else if (arguments && arguments.length >= 4)
        {
            frame = [arguments[0], arguments[1], arguments[2], arguments[3]];
        }
        else
        {
            throw new Error('Frame is not an array [x, y, w, h] in setFrame(frame) :: ' + this.classname);
        }
        if (frame.length < 4 || isNaN(frame[0]) || isNaN(frame[1]) || isNaN(frame[2]) || isNaN(frame[3]))
        {
            throw new Error('Length of frame is less than 4. Expected [x, y, w, h]  in setFrame(frame) in AbstractView.js');
        }
        this.__setFrame(frame);
    },
    /**
     * @private
     */
    __setFrame: function (frame)
    {
        //__setFrame method now implements the FRAME, and $super hierarchy should be followed upto AbstractView.
        //setFrame only splits the supplied arguments.
        this._frame = frame;
        this._position = [frame[0], frame[1]];
        this.getGLObject().setPosition(this._frame[0], this._frame[1]);
        if (this._backgroundColor)
        {
            this.__fillBackgroundColor();
        }
        if (this._target && this._target !== 1)
        {
            this.__setTouchableArea();
        }
    },
    /**
     * @name GLUI.AbstractView#getFrame
     * @description Retrieve the value of the <code>frame</code> property.
     * @returns {Array} An array of [x, y, w, h] for the frame of the object.
     * @see GLUI.AbstractView#setFrame
     * @function
     */
    getFrame: function ()
    {
        if (this._frame === null || this._frame === undefined)
        {
            return undefined;
        }
        else
        {
            return [this._frame[0], this._frame[1], this._frame[2], this._frame[3]];
        }
    },
    /**
     * @name GLUI.AbstractView#setOnClick
     * @description Set a function to call when the <code>click</code> event occurs. Do not use object.onClick = function() as that will not set up touch target for GLUI object.
     * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The <code>click</code> callback is set to empty if the value of this parameter is not a function.
     * @example button.setOnClick(function() { console.log(this.classname + "is clicked");});
     * @see GLUI.AbstractView#event:getOnClick
     * @event
     */
    setOnClick: function (clickCallback)
    {
        if (typeof (clickCallback) !== "function")
        {
            if (clickCallback === "undefined" || clickCallback === null)
            {
                clickCallback = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnClick expects (), (null), (function) but received " + clickCallback.type);
            }
        }
        this._clickCallBack = clickCallback;
        if (this._frame && !this._target)
        {
            this._setUpTouchTarget();
        }
    },
    /**
     * @name GLUI.AbstractView#getOnClick
     * @description Retrieve a function to call when the <code>click</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnClick
     * @event
     */
    getOnClick: function ()
    {
        return this._clickCallBack;
    },
    /**
     * Set view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    setState: function (flags)
    {
        this._state = flags;
        this._updateView();
    },
    /**
     * Get view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    getState: function ()
    {
        return this._state;
    },
    /**
     * Add a new view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    addState: function (flags)
    {
        this.setState(this._state | flags);
    },
    /**
     * Clear the view state and set view state flags to the default value.
     * @function
     * @example this.clearState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#addState
     */
    clearState: function (flags)
    {
        this.setState(this._state & ~flags);
    },
    /**
     * @name GLUI.AbstractView#setVisible
     * @description Set the visibility for this object.
     * @example SomeView = new GLUI.View();
     * ...
     * SomeView.setVisible(false);
     * @function
     * @param {boolean} <code>true</code> if this object is visible, <code>false</code> otherwise.
     * @see GLUI.AbstractView#getVisible
     */
    setVisible: function (boolValue)
    {
        if ((boolValue === true) || (boolValue === false))
        {
            this._visible = boolValue;
            this.getGLObject().setVisible(boolValue);
            this._setVisible(this._visible, true);
        }
        else
        {
            throw new Error('Expecting boolean value but found ' + typeof (boolValue) + ' for setVisible(boolValue)');
        }
    },
    /**
     * @name GLUI.AbstractView#getVisible
     * @description Retrieve the state of visibility for this object.
     * @function
     * @returns {boolean} Returns <code>true</code> if this object is visible.
     * @see GLUI.AbstractView#setVisible
     */
    getVisible: function ()
    {
        return this.getGLObject().getVisible();
    },
    /**
     * @name GLUI.AbstractView#setEnabled
     * @description Set the value for the <code>enabled</code> property. This property defines an object as active or inactive.
     * <br /><b>Note:</b> Object [state] is also set to GLUI.Commands.State.Disabled if setEnabled(false) is called. And cleared if setEnabled(true) is called.
     * @param {Boolean} enabled Set as <code>true</code> if this view state is enabled.
     * @see GLUI.AbstractView#getEnabled
     * @function
     */
    setEnabled: function (enabled)
    {
        if ((enabled === true) || (enabled === false))
        {
            this._enabled = enabled;
            if (enabled)
            {
                this.clearState(Commands.State.Disabled);
            }
            else
            {
                this.addState(Commands.State.Disabled);
            }
            this._setEnabled(this._enabled, true);
        }
        else
        {
            throw new Error('Expecting boolean value but found ' + typeof (enabled) + ' for setEnabled(enabled)');
        }
        return this;
    },
    /**
     * @name GLUI.AbstractView#getEnabled
     * @description Retrieve the value of the <code>enabled</code> property.
     * @returns {Boolean} Returns <code>true</code> if this view state is enabled.
     * @see GLUI.AbstractView#setEnabled
     * @function
     */
    getEnabled: function ()
    {
        return this._enabled;
    },
    /**
     * @name GLUI.AbstractView#setBackgroundColor
     * @description Set the value for the <code>backgroundColor</code> property. This property defines the color of the background for an object when rendered.
     * @example SomeView = new GLUI.View();
     * ...
     * SomeView.setBackgroundColor("FF000000");
     * @param {String} backgroundColor The new background color.
     * @see UI.AbstractView#getBackgroundColor
     * @type Color
     * @function
     */
    setBackgroundColor: function (color)
    {
        var container = this._internalGLObject.getParent();
        if (!this._parentNode)
        {
            this._parentNode = new Node();
        }
        if (!this._backgroundColor && container)
        {
            container.removeChild(this._internalGLObject);
            container.addChild(this._parentNode);
        }
        this.__ARGB = Util.hexToARGB(color);
        this._backgroundColor = color;
        if (!this._bgPrimitive)
        {
            this._bgColorAlreadySet = false;
            this._bgPrimitive = new Util.Rectangle();
        }
        if (!this._frame)
        {
            this._frame = [0, 0, 0, 0];
        }
        this.__fillBackgroundColor();
        this._updateAlpha();
        this.getGLObject().setVisible(this._visible);
        this._internalGLObject.setVisible(true);
        this.getGLObject().setVisible(this._visible);
        return this;
    },
    /**
     * @name GLUI.AbstractView#getBackgroundColor
     * @description Retrieve the value of the <code>backgroundColor</code> property.
     * @returns {String} The current background color.
     * @see GLUI.AbstractView#setBackgroundColor
     * @function
     */
    getBackgroundColor: function ()
    {
        return this._backgroundColor;
    },
    /**
     * @name GLUI.AbstractView#setGradient
     * @description Set the value of the <code>background</code> property using the first set of colors.
     * @example label.setGradient({
     *  gradient: ['FFFF8000 0.0', 'FF703300 1.0']
     * }, UI.State.Selected);
     * [corners] and [gradient] are not fully supported for GLUI elements. A plain background will be applied.
     * <br /><b>Note: </b> This property will tamper with the backgound property, as gradients are not supported in GLUI.
     * @param {Object} gradient The new gradient.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @see GLUI.AbstractView#getGradient
     * @function
     */
    setGradient: function (flags, state)
    {
        if (state === undefined)
        {
            state = Commands.State.Normal;
        }
        this._gradient[state + ''] = flags;
        this._updateView();
    },
    /**
     * @name GLUI.AbstractView#getGradient
     * @description Retrieve the value of the <code>gradient</code> property for a view state.
     * gradient is supported as a plain color background.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @returns {Object} The current gradient.
     * @see GLUI.AbstractView#setGradient
     * @function
     */
    getGradient: function (state)
    {
        if (state === undefined)
        {
            state = Commands.State.Normal;
        }
        return this._gradient[state];
    },
    /**
     * Add a node at the specified index to the specified parent node.
     * @example var myParent = new GLUI.View({
     *  ...
     * });
     * var childNode = new GLUI.View({
     *  ...
     * });
     * ...
     * childNode.addToParent(myParent);
     * @function
     * @param {Object} parentNode The parent node.
     * @param {Number} [index] The parent node index location. Index reflects the depth (z-index) of a node in that view.
     * @see GLUI.AbstractView#getParent,
     * @see GLUI.AbstractView#removeFromParent
     */
    addToParent: function (parentNode, index)
    {
        parentNode.addChild(this, index);
        this._parent = parentNode;
    },
    /**
     * Remove a node from the parent node.
     * @example childNode.removeFromParent(myParent);
     * @function
     * @returns {Element} This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.AbstractView#getParent,
     * @see GLUI.AbstractView#addToParent
     */
    removeFromParent: function ()
    {
        if (this._parent && this._parent.removeChild && this._parent instanceof Element)
        {
            this._parent.removeChild(this);
            this._parent = null;
        }
        return this;
    },
    /**
     * @function
     * @description Retrieve the parent node for this view.
     * @returns Returns the parent if this view is a child of another element. Otherwise, returns undefined.
     * @see GLUI.AbstractView#addToParent,
     * @see GLUI.AbstractView#removeFromParent
     */
    getParent: function ()
    {
        return this._parent;
    },
    /**
     * Retrieve the root node for this object.
     * @function
     * @returns Returns the root node if this is a child node. Otherwise, returns undefined.
     */
    getRoot: function ()
    {
        var retParent;
        var child = this;
        while (child._parent)
        {
            retParent = child._parent;
            child = child._parent;
        }
        return retParent;
    },
    /**
     * @function
     * @description Swallow touches, and will not let the touches to pass below the node. Useful for implementing Alert Dialogs. Works similar to setBlockTouchEvents, internal implementation is different from UI.setBlockTouchEvents.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     */
    swallowTouches: function (booleanValue)
    {
        if (booleanValue === true || booleanValue === undefined || booleanValue === null)
        {
            if (!this._clickCallBack)
            {
                this.setOnClick(function ()
                {});
            }
            else
            {
                this._setUpTouchTarget();
            }
        }
        else
        {
            if (this._target instanceof TouchTarget)
            {
                this._target.destroy();
                this._target = null;
            }
        }
        return this;
    },
    destroy: function ($super)
    {
        if (this._parent)
        {
            this.removeFromParent();
            this._parent = null;
        }
        if (this._target && this._target !== 1)
        {
            this._target.destroy();
        }
        this._target = null;
        if (this._messageListener)
        {
            this._messageListener.destroy();
            this._messageListener = null;
        }
        if (this._bgPrimitive)
        {
            this._bgPrimitive.destroy();
            this._bgPrimitive = null;
        }
        if (this._parentNode)
        {
            this._parentNode.destroy();
            this._parentNode = null;
        }
        this._clickCallBack = null;
        this._alpha = null;
        this.__bgAlpha = null;
        this.__internalAlpha = null;
        this._frame = null;
        this._hasMovedOutside = null;
        this._anchor = null;
        this._fitMode = null;
        this._clickCallBack = null;
        this._state = null;
        if (this._images)
        {
            this._images.length = 0;
            this._images = null;
        }
        this._position = null;
        this._alpha = null;
        this.__bgAlpha = null;
        this.__internalAlpha = null;
        if (this.__ARGB)
        {
            this.__ARGB.length = 0;
            this.__ARGB = null;
        }
        this._enabled = null;
        this._parentEnabled = null;
        this._parentVisible = null;
        this._isPressed = null;
        this._isParentScrollView = null;
        this._OS = null;
        this._bgColorAlreadySet = null;
        this._backgroundColor = null;
        this._visible = null;
        this._clickable = null;
        $super();
    },
    /** @private */
    _updateView: function ()
    {
        //override this in the derived classes.
        var gradient = this._gradient[this._state];
        if (typeof gradient === 'object' && gradient.gradient instanceof Array)
        {
            var spc = gradient.gradient[0].indexOf(" ");
            if (spc > 0)
            {
                var color = gradient.gradient[0].substring(0, spc);
                this.setBackgroundColor(color);
            }
        }
    },
    _setUpTouchTarget: function ()
    {
        if (this._frame)
        {
            if (this._messageListener)
            {
                this._messageListener.destroy();
            }
            this._messageListener = new MessageListener();
            if (!this._target)
            {
                this._target = new TouchTarget();
            }
            this.__setTouchableArea();
            this._target.getTouchEmitter().addListener(this._messageListener, this._touchReceivedCallBack.bind(this));
            if (!this._backgroundColor)
            {
                var color = "00000000"; //transparent color
                this.setBackgroundColor(color); //this will create a parentNode with transparent area if no bg color is provided
            }
            this.getGLObject().addChild(this._target);
        }
    },
    __setTouchableArea: function ()
    {
        this._target.setAnchor(0, 0);
        this._target.setSize(this._frame[2], this._frame[3]);
        this._target.setPosition(0, 0);
        this._target.setDepth(-2);
    },
    _giveTouchesToChildren: function (touch, array)
    {
        var i = 0;
        if (array && array.length > 0)
        {
            for (i = array.length - 1; i >= 0; i--)
            {
                if (array[i]._isTouchInFrame(touch) && array[i]._enabled && array[i]._visible && array[i]._clickable)
                {
                    var retInstance = array[i]._touchReceivedCallBack(touch, true);
                    if (retInstance)
                    {
                        return retInstance;
                    }
                }
            }
        }
        return null;
    },
    _isTouchInFrame: function (touch)
    {
        if (!this._frame)
        {
            return false;
        }
        var position = touch.getPosition();
        var x = position.getX();
        var y = position.getY();
        var objStartPosition = this.getGLObject().localToScreen(new Vector(0, 0));
        var objMaxPosition = this.getGLObject().localToScreen(new Vector(this._frame[2], this._frame[3]));
        var xmin = objStartPosition.getX();
        var xmax = objMaxPosition.getX();
        var ymin = objStartPosition.getY();
        var ymax = objMaxPosition.getY();
        if (y >= ymin && y < ymax && x >= xmin && x < xmax)
        {
            return true;
        }
        else
        {
            return false;
        }
    },
    _touchReceivedCallBack: function (touch, isDelegating)
    {
        if ((touch.getId() !== 1 && this._OS === "android"))
        {
            if (isDelegating)
            {
                return null;
            }
            return true;
        }
        if (isDelegating === undefined || isDelegating === null)
        {
            isDelegating = false;
        }
        else if (isDelegating && this._children && this._children.length > 0)
        {
            var retInstance = this._giveTouchesToChildren(touch, this._children);
            if (retInstance)
            {
                return retInstance;
            }
        }
        switch (touch.getAction())
        {
            case touch.Action.Start:
                if (this._clickCallBack && this._isTouchInFrame(touch) && this._enabled && this._visible && this._parentEnabled && this._parentVisible && !(this.getState() & Commands.State.Disabled) && this._clickable)
                {
                    if (this.getState() & Commands.State.Pressed)
                    {
                        this._isPressed = true;
                    }
                    this.addState(Commands.State.Pressed);
                    this._hasMovedOutside = false;
                    if (isDelegating)
                    {
                        return this;
                    }
                    return true;
                }
                else
                {
                    return false;
                }
            case touch.Action.End:
                if (!this._isPressed)
                {
                    this.clearState(Commands.State.Pressed);
                }
                if (this._isTouchInFrame(touch) && this._enabled && this._visible && this._parentEnabled && this._parentVisible && !(this.getState() & Commands.State.Disabled) && !this._hasMovedOutside)
                {
                    this._click();
                    if (this._endTap)
                    {
                        this._endTap();
                    }
                }
                this._isPressed = false;
                this._hasMovedOutside = false;
                break;
            case touch.Action.Move:
                if (isDelegating) //here lower sensitivity of press
                {
                    if (!this._isPressed)
                    {
                        this.clearState(Commands.State.Pressed);
                    }
                    this._pressed = false;
                    this._hasMovedOutside = false;
                    return true;
                }
                else if (!this._isTouchInFrame(touch))
                {
                    this._hasMovedOutside = true;
                    if (!this._isPressed)
                    {
                        this.clearState(Commands.State.Pressed);
                    }
                }
                break;
            }
            return false;
    },
    _click: function ()
    {
        if (this._clickCallBack)
        {
            this._clickCallBack();
        }
    },
    _setClickable: function (clickable)
    {
        this._clickable = clickable;
    },
    _getClickable: function ()
    {
        return this._clickable;
    },
    _setVisible: function (visible, isSelf)
    {
        var i;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                this._children[i]._setVisible(visible, false);
            }
        }
        if (!isSelf)
        {
            this._parentVisible = visible;
        }
    },
    _setEnabled: function (enabled, isSelf)
    {
        if (this._children)
        {
            var i = 0;
            for (i = 0; i < this._children.length; i++)
            {
                this._children[i]._setEnabled(enabled, false);
            }
        }
        if (!isSelf)
        {
            this._parentEnabled = enabled;
        }
    },
    __fillBackgroundColor: function ()
    {
        this._bgPrimitive.setFrame([0, 0, this._frame[2], this._frame[3]]);
        this._bgPrimitive.setDepth(-1);
        this._parentNode.setPosition(this._frame[0], this._frame[1]);
        this.__bgAlpha = this.__ARGB[0];
        this._bgPrimitive.setColor(new Color(this.__ARGB[1], this.__ARGB[2], this.__ARGB[3]));
        if (!this._bgColorAlreadySet)
        {
            var parentPosition = this._parentNode.getPosition();
            var internalPosition = this._internalGLObject.getPosition();
            this._internalGLObject.setPosition(internalPosition.getX() - parentPosition.getX(), internalPosition.getY() - parentPosition.getY());
            this._internalGLObject.setDepth(0);
            this._parentNode.addChild(this._bgPrimitive);
            this._parentNode.addChild(this._internalGLObject);
            this._bgColorAlreadySet = true;
        }
        if (this._updateDepth)
        {
            this._updateDepth();
        }
    },
    _updateAlpha: function ()
    {
        var internalValue = 0;
        var bgValue = 0;
        internalValue = this.__internalAlpha * this._alpha;
        this._internalGLObject.setAlpha(internalValue);
        if (this._parentNode)
        {
            bgValue = this.__bgAlpha * this._alpha;
            this._bgPrimitive.setAlpha(bgValue);
        }
    },
    _endTap: function ()
    {
        //override in child classes;
    },
    _getInternalGLObjectPosition: function ()
    {
        var parentPosX = 0;
        var parentPosY = 0;
        if (this._parentNode)
        {
            var parentPosition = this._parentNode.getPosition();
            parentPosX = parentPosition.getX();
            parentPosY = parentPosition.getY();
        }
        //var internalPosition = this._internalGLObject.getPosition();
        var posX = -parentPosX;
        var posY = -parentPosY;
        posX += this._frame[0] + (this._frame[2] * this._anchor[0]);
        posY += this._frame[1] + (this._frame[3] * this._anchor[1]);
        return new Point(posX, posY);
    },
    /** @private */
    _registerSetters: function ($super)
    {
        $super();
        this._setters['alpha'] = this._setAlphaProperty;
        this._setters['frame'] = this._setFrameProperty;
        this._setters['onClick'] = this._setOnClickProperty;
        this._setters['visible'] = this._setVisibleProperty;
        this._setters['enabled'] = this._setEnabledProperty;
        this._setters['backgroundColor'] = this._setBackgroundColorProperty;
        this._setters['state'] = this._setStateProperty;
        this._setters['gradient'] = this._setGradientProperty;
    },
    /** @private */
    _registerGetters: function ($super)
    {
        $super();
        this._getters['alpha'] = this._getAlphaProperty;
        this._getters['frame'] = this._getFrameProperty;
        this._getters['onClick'] = this._getOnClickProperty;
        this._getters['visible'] = this._getVisibleProperty;
        this._getters['enabled'] = this._getEnabledProperty;
        this._getters['backgroundColor'] = this._getBackgroundColorProperty;
        this._getters['state'] = this._getStateProperty;
        this._getters['gradient'] = this._getGradientProperty;
    },
    /** @private */
    __setTouchableFalse: function ()
    {
        var i = 0;
        if (this._parentNode)
        {
            this._parentNode.setTouchable(false);
        }
        if (this._internalGLObject)
        {
            this._internalGLObject.setTouchable(false);
        }
        this._isParentScrollView = true;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                this._children[i].__setTouchableFalse();
            }
        }
    },
    /** @private */
    __setTouchableTrue: function ()
    {
        var i = 0;
        if (this._parentNode)
        {
            this._parentNode.setTouchable(true);
        }
        if (this._internalGLObject)
        {
            this._internalGLObject.setTouchable(true);
        }
        this._isParentScrollView = false;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                this._children[i].__setTouchableTrue();
            }
        }
    },
    /** @private Property accessors*/
    _setAlphaProperty: function (callee, args)
    {
       return callee.setAlpha(args);
    },
    _setFrameProperty: function (callee, args)
    {
       return callee.setFrame(args);
    },
    _setOnClickProperty: function (callee, args)
    {
       return callee.setOnClick(args);
    },
    _setVisibleProperty: function (callee, args)
    {
       return callee.setVisible(args);
    },
    _setEnabledProperty: function (callee, args)
    {
       return callee.setEnabled(args);
    },
    _setBackgroundColorProperty: function (callee, args)
    {
       return callee.setBackgroundColor(args);
    },
    _setStateProperty: function (callee, args)
    {
       return callee.setState(args);
    },
    _setGradientProperty: function (callee, args)
    {
       return callee.setGradient(args);
    },
    _getAlphaProperty: function (callee, args)
    {
       return callee.getAlpha(args);
    },
    _getFrameProperty: function (callee, args)
    {
       return callee.getFrame(args);
    },
    _getOnClickProperty: function (callee, args)
    {
       return callee.getOnClick(args);
    },
    _getVisibleProperty: function (callee, args)
    {
       return callee.getVisible(args);
    },
    _getEnabledProperty: function (callee, args)
    {
       return callee.getEnabled(args);
    },
    _getBackgroundColorProperty: function (callee, args)
    {
       return callee.getBackgroundColor(args);
    },
    _getStateProperty: function (callee, args)
    {
       return callee.getState(args);
    },
    _getGradientProperty: function (callee, args)
    {
       return callee.getGradient(args);
    },
    /////////////// Empty Functions /////////////////
    /**
     * @name GLUI.AbstractView#getOnAppear
     * @description Retrieve the function to call when the <code>appear</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnAppear
     * @event
     * @status Android, Flash, Test
     */
    getOnAppear: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getOnAppear() in ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#getOnDisappear
     * @description Retrieve the function to call when the <code>disappear</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnDisappear
     * @event
     * @status Android, Flash, Test
     */
    getOnDisappear: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getOnDisappear() ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#getOnLongPress
     * @description Retrieve the function to call when a <code>tap and hold</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnLongPress
     * @event
     * @status Android, Flash, Test
     */
    getOnLongPress: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getOnLongPress() ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#getOnSwipe
     * @description Retrieve the function to call when the <code>swipe</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnSwipe
     * @event
     * @status Android, Flash, Test
     */
    getOnSwipe: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getOnSwipe() ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#setOnAppear
     * @description Set a function to call when the <code>appear</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Function} appearCallback The new callback function. <br><br><b>Note:</b> The <code>appear</code> event is disabled if the value of this parameter is not a function.
     * @example function() { onAppear.appear = true; };
     * @see GLUI.AbstractView#event:getOnAppear
     * @event
     * @status Android, Flash, Test
     */
    setOnAppear: function (appearCallback)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setOnAppear(appearCallback) ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#setOnDisappear
     * @description Set a function to call when the <code>disappear</code> event occurs.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Function} disappearCallback The new callback function. <br><br><b>Note:</b> The <code>disappear</code> event is disabled if the value of this parameter is not a function.
     * @example function() { onDisappear.disappear = true; };
     * @see GLUI.AbstractView#event:getOnDisappear
     * @event
     * @status Android, Flash, Test
     */
    setOnDisappear: function (disappearCallback)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setOnDisappear(disappearCallback) ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#setOnLongPress
     * @description Set a function to call when a user taps and holds on a view.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The event is disabled if the value of this parameter is not a function.
     * @example function() { onLongPress.longpress = true; };
     * @see GLUI.AbstractView#event:getOnLongPress
     * @event
     * @status Android, Flash, Test
     */
    setOnLongPress: function (clickCallback)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setOnLongPress(clickCallback) ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#setOnSwipe
     * @description Set a function to call when a swipe event occurs. This is when the user swipes a finger across this view, like how you indicate a "delete row" request on a table view. The function gets the GLUI.Commands.SwipeDirection from the first parameter.direction.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The <code>swipe</code> event is disabled if the value of this parameter is not a function.
     * @example view.setOnSwipe( function(params) { NgLogD("swipe code "+params.direction); });
     * @see GLUI.AbstractView#event:getOnSwipe
     * @event
     * @status Android, Flash, Test
     */
    setOnSwipe: function (clickCallback)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setOnSwipe(clickCallback) ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#getBlockTouchEvents
     * @description Retrieve the value of the <code>blockTouchEvents</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Object} The current value of <code>blockTouchEvents.</code>
     * @see GLUI.AbstractView#setBlockTouchEvents
     * @function
     * @status Android, Flash, Test
     */
    getBlockTouchEvents: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getBlockTouchEvents() ' + this.classname);
    },
    /**
     * @name GLUI.AbstractView#setBlockTouchEvents
     * @description Set the value of the <code>blockTouchEvents</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} blockTouchEvents The new value for <code>blockTouchEvents.</code>
     * @see GLUI.AbstractView#getBlockTouchEvents
     * @function
     * @status Android, Flash, Test
     */
    setBlockTouchEvents: function (blockTouchEvents)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  setBlockTouchEvents(blockTouchEvents) ' + this.classname);
    },
    get onclick()
    {
        //enables property get mode :  var a = object.onclick;
        return this.getOnClick();
    },
    set onclick(value)
    {
        //enables property set mode : object.onclick = function() {};
        this.setOnClick(value);
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Sprite'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Sprite'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Sprite'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Sprite.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Copied from DnLib.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/*
 * URLSprite - extend GL2.Sprite to be able to use URL instead of file path
 *
 */
var Sprite = require('NGCore/Client/GL2/Sprite').Sprite;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var DownloadFile = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;
var UI = require('NGCore/Client/UI').UI;

var $_lock = {};
var $_queue = {};
/** @private
 * This ENTIRE CLASS is private.
 */
var URLSprite = Sprite.subclass( /** @lends GLUI.URLSprite.prototype */
{
    "classname": 'URLSprite',
    /**
     * @class The <code>URLSprite</code> class inherits GL2.Sprite and add the image downloading function.
     * (see <code><a href="GL2.Sprite.html">GL2.Sprite</a></code>).
     * It also has caching mechanism to decrease network trafic.
     **/
    "_default_options": {
        "cache": true,
        "directory": "urlsprite",
        "localcachetime": 3600,
        "cachesize": 100,
        "forceResize": true
    },
    /**
     * @ignore
     * @constructs The default constructor.
     **/
    initialize: function (options)
    {
        var name;
        this.options = {};
        if (!options)
        {
            options = {};
        }
        for (name in this._default_options)
        {
            if (this._default_options.hasOwnProperty(name))
            {
                this.options[name] = options.hasOwnProperty(name) ? options[name] : this._default_options[name];
            }
        }
        this.tempfiles = {};

    },
    destroy: function ($super)
    {
        var file;
        for (file in this.tempfiles)
        {
            if (this.tempfiles.hasOwnProperty(file))
            {
                FileSystem.deleteFile(file);
            }
        }
        $super();
    },
    /**
     * Download a image and set it for this <code>Sprite</code>.
     * It has same interface as GL2.Sprite but it can use URL instead of local image path.
     * It can accept local image path and at that time, it's behaviour is totally same as GL2.Sprite's setImage method.
     * @param {String} image URL or the directory path to an image referenced by a frame.
     * @param {Core.Size} [size] The size of the image to display (in pixels).
     * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
     * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     **/
    setImage: function ($super, image, size, anchor, uvs)
    {
        if (!image)
        {
            return this;
        }
        if (image.slice(0, 7).toLowerCase() !== "http://" && image.slice(0, 8).toLowerCase() !== "https://")
        {
            return $super(image, size, anchor, uvs);
        }
        var url = image;
        var args = {
            _super: $super,
            url: url,
            name: toMD5(url) + this._extractExstension(url),
            size: size,
            anchor: anchor,
            uvs: uvs,
            addpath: "",
            forceResize: this.options.forceResize
        };

        if (!this.options.cache)
        {
            var time = new Date();
            args.addpath = "nocache/" + Math.floor(Math.random() * 100) + time.getTime();
        }
        if (!$_queue[this.options.directory])
        {
            $_queue[this.options.directory] = [];
        }
        if ($_lock[this.options.directory])
        {
            $_queue[this.options.directory].push(this._setImageInternal.bind(this, args));
        }
        else
        {
            $_lock[this.options.directory] = 1;
            this._setImageInternal(args);
        }
        return this;
    },
    $unlock: function (directory)
    {
        $_lock[directory] = 0;
        $_queue[directory] = [];
    },
    _extractExstension: function (url)
    {
        var qpos = url.indexOf("?");
        if (qpos > -1)
        {
            url = url.slice(0, qpos);
        }
        var filepos = url.lastIndexOf("/");
        if (filepos > -1)
        {
            url = url.slice(filepos + 1);
        }
        var dotpos = url.lastIndexOf(".");
        if (dotpos === -1)
        {
            return "";
        }
        var extension = url.slice(dotpos).toLowerCase();
        if (extension === ".jpeg")
        {
            extension = ".jpg";
        }
        return extension;
    },
    _setImageInternal: function (args, cache)
    {
        if (this.options.cache)
        {
            if (cache)
            {
                this._checkCacheData(args, undefined, undefined, cache);
            }
            else
            {
                this._setImageWithCache(args);
            }
        }
        else
        {
            this._fetchImage(args, [], -1);
        }
    },
    _searchCache: function (cache, name)
    {
        var i;
        var length = cache.length;
        for (i = 0; i < length; i++)
        {
            if (cache[i].name === name)
            {
                return i;
            }
        }
        return -1;
    },
    _setImageWithCache: function (args)
    {
        FileSystem.readFile(
            this.options.directory + "-urlsprite.json", false, this._checkCacheData.bind(this, args));
    },
    _checkCacheData: function (args, error, value, obj)
    {
        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._fetchImage(args, cache, i);
        }
        else
        {
            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._fetchImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateCacheData(args, cache);
            }
        }
    },
    _updateCacheData: function (args, cache)
    {
        var i;
        var length = cache.length;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishUpdateCacheData.bind(this, args));
        }
    },
    _finishUpdateCacheData: function (args, error, key)
    {
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _fetchImage: function (args, cache, i, epoch)
    {
        var request = new DownloadFile();
        var resizePrefix = (args.forceResize) ? "original_" : "";
        var filepath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;

        var headers = [];
        request.start(filepath, "GET", args.url, headers, this._finishFetchImage.bind(this, args, cache, i, request));
    },
    _finishFetchImage: function (args, cache, i, request, statuscode, filesignature)
    {
        if (statuscode === 200)
        {
            var imagePath = "./" + this.options.directory + "/" + args.addpath + args.name;
            var that = this;
            var _showAndUpdateCache = function ()
                {
                    args._super(imagePath, args.size, args.anchor, args.uvs);
                    if (that.options.cache)
                    {
                        that._addCacheData(args, cache, i);
                    }
                    else
                    {
                        that._unlockDirectory(args);
                    }
                };
            if (args.forceResize)
            {
                var _getPowerdBy2Size = function (originalSize)
                    {
                        var imageSize = 2;
                        while (true)
                        {
                            if (originalSize < 2)
                            {
                                return (imageSize > 1024) ? 1024 : imageSize;
                            }
                            originalSize /= 2;
                            imageSize *= 2;
                        }
                    };
                var x = _getPowerdBy2Size(args.size[0]);
                var y = _getPowerdBy2Size(args.size[1]);
                var resizeSize = (x > y) ? x : y;
                var resizePrefix = (args.forceResize) ? "original_" : "";
                var tmpImagePath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;
                UI.compositeImages(resizeSize, resizeSize, imagePath, [
                {
                    image: tmpImagePath,
                    fit: UI.FitMode.Stretch}], function (event)
                {

                    FileSystem.deleteFile(tmpImagePath);
                    _showAndUpdateCache();
                });
            }
            else
            {
                _showAndUpdateCache();
            }
        }
        else if (statuscode === 304 && this.options.cache)
        {
            args._super("./" + this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
            this._unlockDirectory(args);
        }
        else
        {
            this._unlockDirectory(args);
        }
    },
    _unlockDirectory: function (args)
    {
        this.tempfiles["./" + this.options.directory + "/" + args.addpath + args.name] = 1;
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _addCacheData: function (args, cache, i)
    {
        if (!(cache instanceof Array))
        {
            cache = [];
        }
        var now = new Date();
        var cachedata = {
            "name": args.name,
            "epoch": now.getTime()
        };
        if (i > -1)
        {
            if (cache[i].name !== args.name)
            {
                i = this._searchCache(cache, args.name);
            }
            if (i > -1)
            {
                cache.splice(i, 1);
            }
        }
        cache.unshift(cachedata);
        this._updateCacheData(args, cache);
    }
});
/** @private
 *  This ENTIRE CLASS is private.
 */
var UISprite = URLSprite.subclass( /** @lends GLUI.UISprite.prototype */
{
    "classname": 'UISprite',
    /**
     * @class The <code>UISprite</code> class inherits URLSprite and adds conversion for local images to fit GL2 requirements.
     * It also has caching mechanism to decrease reconversion overhead on each access.
     **/
    "_default_options": {
        "cache": true,
        "directory": "uisprite",
        "localcachetime": 3600,
        "cachesize": 1024,
        "forceResize": true
    },
    _manifestCache: null,
    _urlImageCache: null,

    /**
     * @ignore
     * @constructs The default constructor.
     **/
    initialize: function ($super, options)
    {
        $super(options);
    },

    destroy: function ($super)
    {
        $super();
    },
    /**
     * Download a image and set it for this <code>Sprite</code>.
     * It has same interface as URLSprite but it can also convert local images.
     * It can accept local image path and at that time, it's behaviour is totally same as GL2.Sprite's setImage method.
     * @param {String} image URL or the directory path to an image referenced by a frame.
     * @param {Core.Size} [size] The size of the image to display (in pixels).
     * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
     * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     **/
    setImage: function ($super, image, size, anchor, uvs)
    {
        var now;
        if (!image)
        {
            return this;
        }
        var imagePath = image;
        if (!size || size.length < 2 || !size[0] || size[1])
        {
            size = [128, 128];
        }
        var hashedName = toMD5(imagePath + size[0] + size[1]) + this._extractFileExstension(imagePath);

        var cachedata = null;
        if (image.slice(0, 7).toLowerCase() === "http://" || image.slice(0, 8).toLowerCase() === "https://")
        {
            if (this.options.cache && this._urlImageCache)
            {
                var i = this._searchCache(this._urlImageCache, hashedName);
                now = 0;
                if (i > -1)
                {
                    now = new Date();
                    if (this._urlImageCache[i].epoch + this.options.localcachetime * 1000 >= now.getTime())
                    {
                        cachedata = this._urlImageCache[i];
                        $super(this.options.directory + "/" + hashedName, size, anchor, uvs);
                        return this;
                    }
                }
            }
            return $super(image, size, anchor, uvs);
        }

        if (this.options.cache && this._manifestCache)
        {
            var j = this._searchCache(this._manifestCache, hashedName);
            if (j > -1)
            {
                now = new Date();
                if (this._manifestCache[j].epoch + this.options.localcachetime * 1000 >= now.getTime())
                {
                    cachedata = this._manifestCache[j];
                    $super(this.options.directory + "/" + hashedName, size, anchor, uvs);
                    return this;
                }
            }
        }

        var args = {
            _super: $super,
            imagePath: imagePath,
            name: hashedName,
            size: size,
            anchor: anchor,
            uvs: uvs,
            addpath: "",
            forceResize: this.options.forceResize
        };

        if (!this.options.cache)
        {
            var time = new Date();
            args.addpath = "nocache/" + Math.floor(Math.random() * 100) + time.getTime();
        }
        if (!$_queue[this.options.directory])
        {
            $_queue[this.options.directory] = [];
        }
        if ($_lock[this.options.directory])
        {
            $_queue[this.options.directory].push(this._setImageInternalFile.bind(this, args));
        }
        else
        {
            $_lock[this.options.directory] = 1;
            this._setImageInternalFile(args);
        }
        return this;
    },

    $setDefaultCacheMode: function (boolVal)
    {
        UISprite._default_options.cache = boolVal;
    },
    $getDefaultCacheMode: function ()
    {
        return UISprite._default_options.cache;
    },

    $setDefaultDirectory: function (directoryPath)
    {
        if (typeof (directoryPath) !== 'string')
        {
            directoryPath = 'urlimages';
        }
        UISprite._default_options.directory = directoryPath;
    },
    $getDefaultDirectory: function ()
    {
        return this._default_options.directory;
    },


    //        "_default_options" : {
    //      "cache"          : true,
    //      "directory"      : "urlimages",
    //      "localcachetime" : 3600,
    //      "cachesize"      : 1024,
    //      "forceResize"    : true
    //private Methods
    _extractFileExstension: function (imageName)
    {
        var filepos = imageName.lastIndexOf("/");
        if (filepos > -1)
        {
            imageName = imageName.slice(filepos + 1);
        }
        var dotpos = imageName.lastIndexOf(".");
        if (dotpos === -1)
        {
            return "";
        }
        var extension = imageName.slice(dotpos).toLowerCase();
        if (extension === ".jpeg")
        {
            extension = ".jpg";
        }
        return extension;
    },
    _setImageInternalFile: function (args, cache)
    {
        if (this.options.cache)
        {
            if (cache)
            {
                this._checkFileCacheData(args, undefined, undefined, cache);
            }
            else
            {
                this._setImageFileWithCache(args);
            }
        }
        else
        {
            this._resizeImage(args, [], -1);
        }
    },
    _setImageFileWithCache: function (args)
    {
        FileSystem.readFile(
        this.options.directory + "-urlsprite.json", false, this._checkFileCacheData.bind(this, args));
    },
    _checkFileCacheData: function (args, error, value, obj)
    {
        var self = this;
        var _createFolderForImages = function ()
            {
                //create default conversion output directory
                FileSystem.writeFile("./" + self.options.directory + "/.emptyfile", null, false, null);

                //create a converstion output directory for noncached images
                FileSystem.writeFile("./" + self.options.directory + "/nocache/.emptyfile", null, false, null);
            };

        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            _createFolderForImages();
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
            this._manifestCache = cache;
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._resizeImage(args, cache, i);
        }
        else
        {

            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._resizeImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateFileCacheData(args, cache);
            }
        }
    },
    _updateFileCacheData: function (args, cache)
    {
        var i;
        this._manifestCache = cache;
        var length = cache.length;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishFileUpdateCacheData.bind(this, args));
        }
    },
    _finishFileUpdateCacheData: function (args, error, key)
    {
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _resizeImage: function (args, cache, i, epoch)
    {
        var resizePrefix = (args.forceResize) ? "original_" : "";
        var saveAsPath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;
        this._startResizingImage(args.imagePath, saveAsPath, args, cache, i);
    },
    _startResizingImage: function (srcFile, dstFile, args, cache, i)
    {
        var imagePath = "./" + this.options.directory + "/" + args.addpath + args.name;
        var that = this;
        var _showAndUpdateCache = function ()
            {
                args._super(imagePath, args.size, args.anchor, args.uvs);
                if (that.options.cache)
                {
                    that._addFileCacheData(args, cache, i);
                }
                else
                {
                    that._unlockDirectory(args);
                }
            };
        if (args.forceResize)
        {
            var _getPowerdBy2Size = function (originalSize)
                {
                    var imageSize = 2;
                    while (true)
                    {
                        if (originalSize < 2)
                        {
                            return (imageSize > 1024) ? 1024 : imageSize;
                        }
                        originalSize /= 2;
                        imageSize *= 2;
                    }
                };
            var x = _getPowerdBy2Size(args.size[0]);
            var y = _getPowerdBy2Size(args.size[1]);
            var resizeSize = (x > y) ? x : y;

            UI.compositeImages(resizeSize, resizeSize, imagePath, [
            {
                image: srcFile,
                fit: UI.FitMode.Stretch}], function (event)
            {
                _showAndUpdateCache();
            });
        }
        else
        {
            _showAndUpdateCache();
        }
        this._unlockDirectory(args);
    },
    _addFileCacheData: function (args, cache, i)
    {
        if (!(cache instanceof Array))
        {
            cache = [];
        }
        var now = new Date();
        var cachedata = {
            "name": args.name,
            "epoch": now.getTime()
        };
        if (i > -1)
        {
            if (cache[i].name !== args.name)
            {
                i = this._searchCache(cache, args.name);
            }
            if (i > -1)
            {
                cache.splice(i, 1);
            }
        }
        cache.unshift(cachedata);
        this._updateFileCacheData(args, cache);
    },
    _checkCacheData: function (args, error, value, obj)
    {
        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
            this._urlImageCache = cache;
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._fetchImage(args, cache, i);
        }
        else
        {
            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._fetchImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateCacheData(args, cache);
            }
        }
    },
    _updateCacheData: function (args, cache)
    {
        var i;
        var length = cache.length;
        this._urlImageCache = cache;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishUpdateCacheData.bind(this, args));
        }
    }
});

exports.URLSprite = URLSprite;
exports.UISprite = UISprite;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Image'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Image'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Image'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Image.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Gohar A.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var Point = require('NGCore/Client/Core/Point').Point;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var Sprite = require('NGGo/GLUI/Sprite').URLSprite; //for now using url sprite, when this is fixed, we'll use Sprite - which can convert files on disk to power of two.
var Commands = require('NGGo/GLUI/Commands').Commands;
var Util = require('NGGo/GLUI/Util').Util;

var Image = AbstractView.subclass(
/** @lends GLUI.Image.prototype */
{
    classname: 'Image',
    /**
     * @name GLUI.Image
     * @class The <code>Image</code> class constructs objects that control the location and size of images used in the user interface.
     * @constructs
     * @augments GLUI.AbstractView
     */
    initialize: function ($super, properties)
    {
        $super();
        this._internalGLObject = new Sprite();
        this._internalGLObject.setScale(1, 1);
        this._imageSpriteSize = [64, 64];
        this._imageGravity = [0.5, 0.5];
        this._imageURL = null;
        this._fitMode = Commands.FitMode.Inside;
        this._anchor = [0.5, 0.5];
        this.__scaledImageSize = [0, 0];
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    /**
     * @name GLUI.Image#setImage
     * @description Set an image URL for a view state. This property defines a remote image resource to use in arbitrary contexts.
     * <br /><b>Note: </b> Images must be in powers of two and/or mentioned under <code>"textures":</code> key in manifests.
     * <br />URL is also supported, and the image will be converted to power of two.
     * <br />Local image auto conversion will be supported later.
     * @example var someSprite = new GLUI.Image();
     * ...
     * someSprite.setImage('./Content/mySprite.png', GLUI.State.Normal, [w, h]);
     * someSprite.setImage('http://www.example.com/somepicture80x92.png', GLUI.State.Normal, [200, 110]);
     * @see GLUI.Image#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.State} [flags=GLUI.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {Array} imageSize an array for the size of image. [w, h]
     * @status iOS, Android, Test
     * @function
     */
    setImage: function (imageURL, flags, imageSize)
    {
        var errorMsg = null;
        if(typeof(imageURL) === 'object')
        {
            var url = null;
            var size = [0, 0];
            if(imageURL.hasOwnProperty('url'))
            {
                url = imageURL.url;
            }
            else
            {
                errorMsg = "Image URL is not correct in " + this.classname + ".setImage Method";
                throw new Error(errorMsg);
            }
            if(imageURL.hasOwnProperty('size'))
            {
                size = imageURL.size;
            }
            imageURL = url;
            imageSize = size;
        }
        errorMsg = null;
        if (!imageURL || typeof imageURL !== 'string')
        {
            errorMsg = "Image URL is not correct in " + this.classname + ".setImage Method";
            throw new Error(errorMsg);
        }
        try
        {
            this._imageSpriteSize = (imageSize && imageSize.length === 2) ? imageSize : [0, 0];
            flags = (typeof (flags) === 'number') ? flags : Commands.State.Normal;
            this._images[String(flags)] = [imageURL, this._imageSpriteSize];
            this._updateView();
        }
        catch (exception)
        {
            errorMsg = [];
            errorMsg.push("Exception: setImage()");
            errorMsg.push(exception);
            errorMsg.push(this.classname);
            errorMsg.join();
            throw new Error(errorMsg);
        }
        return this;
    },
    /**
     * @name GLUI.Image#setImageFit
     * @description Set the value of the <code>imageFit</code> property.
     * This property defines the scaling of bitmap images to fit within the bounds of a control
     *
     * @example var splashGraphic = new GLUI.Image();
     * ...
     * splashGraphic.setImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.Image#getImageFit
     * @function
     * @status Android, Test
     */
    setImageFit: function (FitMode)
    {
        this._fitMode = FitMode;
        var glObject = this._internalGLObject;
        glObject.setScale(1, 1);
        switch (FitMode)
        {
        case Commands.FitMode.None:
            this._handleNoneMode(glObject);
            break;
        case Commands.FitMode.Inside:
            this._handleInsideMode(glObject);
            break;
        case Commands.FitMode.Fill:
            this._handleFillMode(glObject);
            break;
        case Commands.FitMode.Stretch:
            this._handleStretchMode(glObject);
            break;
        case Commands.FitMode.AspectWidth:
            this._handleAspectWidthMode(glObject);
            break;
        case Commands.FitMode.AspectHeight:
            this._handleAspectHeightMode(glObject);
            break;
        case Commands.FitMode.InsideNoUpscaling:
            this._handleInsideNoUpscalingMode(glObject);
            break;
        default:
            //setting to none -- which is default UI.Image behavior
            this.setImageFit(Commands.FitMode.None);
            return this;
        }
        var glPosition = this._getInternalGLObjectPosition();
        var posX = glPosition.getX();
        var posY = glPosition.getY();
        glObject.setPosition([posX, posY]);

        return this;
    },
    /**
     * @name GLUI.Image#getImage
     * @description Retrieve the <code>image</code> URL for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current image URL for the specified view state..
     * @see GLUI.Image#setImage
     * @status Android, Test
     * @function
     */
    getImage: function (flags)
    {
        var state = this._getEffectiveState(flags);
        var value = this._images[String(state)];
        if (value !== null && value !== undefined)
        {
            return value[0];
        }
        else
        {
            return undefined;
        }
    },
    /**
     * @name GLUI.Image#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.Image#setImageFit
     * @function
     * @status Android, Test
     */
    getImageFit: function ()
    {
        return this._fitMode;
    },
    /**
     * @name GLUI.Image#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area. Gravity values supported are: value-from-[0.0, 0.0] to [1.0, 1.0]
     * @example var splashGraphic = new GLUI.Image();
     * ...
     * splashGraphic.setImageGravity([0.5, 0.0]);
     * @param {Number} imageGravity The new value for <code>imageGravity</code> expressed as two floats.
     * @see GLUI.Image#getImageGravity
     * @function
     * @status Android, Test
     */
    setImageGravity: function(imageGravity)
    {
        if(arguments)
        {
        if(arguments.length >=2)
        {
            imageGravity = [arguments[0], arguments[1]];
        }
        this.__setImageGravity(imageGravity);
        }
        else
        {
        throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    /**
    @private
    */
    __setImageGravity: function (imageGravity)
    {
        imageGravity = (imageGravity && imageGravity.length === 2 && !isNaN(imageGravity[0]) && !isNaN(imageGravity[1])) ? [imageGravity[0], imageGravity[1]] : [0.5, 0.5];
        this._imageGravity = imageGravity;
        this._anchor = imageGravity;
        this._adjustImageGravity();
        this.setImageFit(this.getImageFit());
        return this;
    },
    /**
     * @name GLUI.Image#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code> expressed as two floats.
     * @see GLUI.Image#setImageGravity
     * @function
     * @status Android, Test
     */
    getImageGravity: function ()
    {
        return [this._imageGravity[0], this._imageGravity[1]];
    },
    __setFrame: function ($super, frame)
    {
        $super(frame);
        if (this._imageSpriteSize)
        {
            this.setImageFit(this.getImageFit());
        }
        this._updateView();
    },
    destroy: function ($super)
    {
        this.__scaledImageSize = null;
        this._imageSpriteSize = null;
        this._imageURL = null;
        this._imageGravity = null;
        $super();
    },
    /**
     * @private
     */
    _adjustImageGravity: function ()
    {
        if (this.getImageFit() === Commands.FitMode.None || this.getImageFit() === Commands.FitMode.Inside)
        {
            var glObject = this._internalGLObject;
            var currImageGravity = this.getImageGravity();
            currImageGravity = (currImageGravity) ? currImageGravity : [0.5, 0.5];
            var gravityX = currImageGravity[0];
            var gravityY = currImageGravity[1];
            var currScale = glObject.getScale();
            currScale = (currScale) ? currScale : new Point(1, 1);
            var scaleX = currScale.getX();
            var scaleY = currScale.getY();
            var currSize = this._imageSpriteSize;
            currSize = (currSize) ? currSize : [0, 0];
            var sizeX = currSize[0];
            var sizeY = currSize[1];
            var currFrame = this.getFrame();
            currFrame = (currFrame) ? currFrame : [0, 0, 0, 0];
            var frameX = currFrame[2];
            var frameY = currFrame[3];
            var currAnchor = this._anchor;
            currAnchor = (currAnchor) ? currAnchor : [0.5, 0.5];
            var anchorX = currAnchor[0];
            var anchorY = currAnchor[1];
            var pos = [];
            pos[0] = (gravityX * frameX) - (scaleX * sizeX) * (gravityX - anchorX);
            pos[1] = (gravityY * frameY) - (scaleY * sizeY) * (gravityY - anchorY);
            glObject.setPosition(pos);
        }
        else
        {
            return;
        }
    },
    /**
     * @private
     */
    _updateView: function ()
    {
        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if (!this._frame || (this._frame && this._frame.length < 4))
        {
            this._frame = [0, 0, 0, 0];
        }
        if (!this._images[String(Commands.State.Normal)] || !this._frame[2] || !this._frame[3])
        {
            return;
        }
        var currentState = this._state;
        var nextState = this._getEffectiveState(currentState);
        var nextImage = this._images[String(nextState)];
        if (!nextImage || nextImage.length === 0)
        {
            nextImage = this._images[String(Commands.State.Normal)];
        }
        if (nextImage !== null)
        {
            this._imageURL = nextImage[0];
            this._imageSpriteSize = nextImage[1];
            this.setImageFit(this._fitMode);
        }
    },
    /**
     * @private
     */
    _handleNoneMode: function (glObject)
    {
        var currImageGrav = this.getImageGravity();
        var anchor = new Point(currImageGrav);
        var rectX = 0;
        var rectY = 0;
        var x = 0;
        var y = 0;
        if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            glObject.setImage(this._imageURL, this._imageSpriteSize, anchor);
        }
        else if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] <= this._imageSpriteSize[1])
        {
            rectY = this._frame[3] / this._imageSpriteSize[1];
            y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0], this._frame[3]], anchor, [0, y, 1, rectY]);
        }
        else if (this._frame[2] <= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            rectX = this._frame[2] / this._imageSpriteSize[0];
            x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._imageSpriteSize[1]], anchor, [x, 0, rectX, 1]);
        }
        else
        {
            rectX = this._frame[2] / this._imageSpriteSize[0];
            rectY = this._frame[3] / this._imageSpriteSize[1];
            x = (1 - rectX) * currImageGrav[0];
            y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], anchor, [x, y, rectX, rectY]);
        }
    },
    /**
     * @private
     */
    _handleInsideMode: function (glObject)
    {
        var tempSize = new Vector(this._frame[2] / this._imageSpriteSize[0], this._frame[3] / this._imageSpriteSize[1]);
        var x = tempSize.getX();
        var y = tempSize.getY();
        glObject.setImage(this._imageURL, this._imageSpriteSize, this._anchor);
        if (x <= y)
        {
            glObject.setScale(x, x);
        }
        else
        {
            glObject.setScale(y, y);
        }
    },
    /**
     * @private
     */
    _handleFillMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        var currImageGrav = this.getImageGravity();
        if (diffX >= diffY)
        {
            var rectY = this._frame[3] / this._frame[2];
            var y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [0, y, 1, rectY]);
        }
        else
        {
            var rectX = this._frame[2] / this._frame[3];
            var x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [x, 0, rectX, 1]);
        }
    },
    /**
     * @private
     */
    _handleStretchMode: function (glObject)
    {
        glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor);
    },
    /**
     * @private
     */
    _handleAspectWidthMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        if (diffX >= diffY)
        {
            var rectY = this._frame[3] / this._frame[2];
            var currImageGrav = this.getImageGravity();
            var y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [0, y, 1, rectY]);
        }
        else
        {
            var scaleX = this._frame[2] / this._imageSpriteSize[0];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0] * scaleX, this._imageSpriteSize[1] * scaleX], this._anchor);
        }
    },
    /**
     * @private
     */
    _handleAspectHeightMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        if (diffY >= diffX)
        {
            var rectX = this._frame[2] / this._frame[3];
            var currImageGrav = this.getImageGravity();
            var x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [x, 0, rectX, 1]);
            this.__scaledImageSize = [this._frame[2], this._frame[3]];
        }
        else
        {
            var scaleY = this._frame[3] / this._imageSpriteSize[1];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0] * scaleY, this._imageSpriteSize[1] * scaleY], this._anchor);
            this.__scaledImageSize = [this._imageSpriteSize[0] * scaleY, this._imageSpriteSize[1] * scaleY];
        }
    },

    /**
     * @private
     * */
    _handleInsideNoUpscalingMode: function (glObject)
    {
        if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            this.setImageFit(Commands.FitMode.None);
        }
        else
        {
            this.setImageFit(Commands.FitMode.Inside);

        }
    },
    /**
     * @private
     */
    _getEffectiveState: function (flags)
    {
        var currentState = flags;
        var nextState = null;
        if (currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if (currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if (currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if (currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if (currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if (currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     * @private
     */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForImage(this);
    },
    /**
     * @private
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForImage(this);
    },
    /**
     * @private
     */
    ___getSpriteSizeForCheckBox: function ()
    {
        return this.__scaledImageSize;
    },
    /////////// Empty Functions ////////////
    /**
     * @name GLUI.Image#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.Commands.State} [ flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>
     * @see GLUI.Image#setImageBorder
     * @status Android, Test
     * @function
     */
    getImageBorder: function (flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder(flags) in Image');
    },

    /**
     * @name GLUI.Image#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>
     * @see GLUI.Image#setImageTransform
     * @status Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() in Image');
    },

    /**
     * @name GLUI.Image#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder.</code>.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The UI view state.
     * @see GLUI.Image#getImageBorder
     * @status Android, Test
     * @function
     */
    setImageBorder: function (imageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) in Image');
    },

    /**
     * @name GLUI.Image#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var splashGraphic = new UI.Image();
     * ...
     * splashGraphic.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.Image#getImageTransform
     * @status Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in Image');
    }
});

exports.Image = Image;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/View'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/View'] || {}; $MODULE_REGISTRY['NGGo/GLUI/View'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/View.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Shamas S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Node = require('NGCore/Client/GL2/Node').Node;
var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo/GLUI/Commands').Commands;
var Image = require('NGGo/GLUI/Image').Image;

exports.View = AbstractView.subclass( /** @lends GLUI.View.prototype */
{
    type: 'View',
    classname: 'View',
    /**  
     * @class The <code>View</code> class is a base class for derived classes that handle application views. Derived classes from <code>View</code> include:
     * <div class="ul">
     * <li>{@link GLUI.ScrollView}</li>
     * <li>{@link GLUI.Button}</li>
     * <li>{@link GLUI.CellView}</li>
     * </div>
     * @constructs The default constructor. 
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments GLUI.AbstractView
     */
    initialize: function ($super, properties)
    {
        $super();
        this._children = [];
        this._internalGLObject = new Node();
        this._sprite = null;
        this._imageURL = null;
        this._imageObject = null;
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },

    __setFrame: function ($super, frame)
    {
        $super(frame); //after this step, this._frame will have a valid frame - exception handling done with super. 
        this.getGLObject().setPosition(this._frame[0], this._frame[1]);
        this._adjustFrameForBgImage();
    },
    setAnchor: function (anchor)
    {
        this._anchor = anchor;
    },
    /**
     * Add a child node to this <code>View</code> at the specified index.
     * Index is treated as Depth (z-index) of the child too.
     * @example var mainView = new UI.View();
     * ...
     * var errorView = new UI.View();
     * ...
     * mainView.addChild(errorView);
     * @param {GLUI.AbstractView} childNode The child which should be a derived class of GLUI.AbstractView to add.
     * @param {Number} index The specified index.
     * @throws {"message:" + this.type + ".addChild: " + childNode + " is not a view!"} Specified child is not an instance of Abstract View.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.View#removeChild
     * @status Android, Test
     */

    addChild: function (childNode, index)
    {

        if (childNode instanceof AbstractView)
        {
            if (childNode._parent)
            {
                childNode.removeFromParent();
            }
            if (this._children)
            {
                if ((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            // Must populate parent before setting visibility
            childNode._parent = this;
            childNode._setEnabled(this._enabled, false);
            childNode._setVisible(this._visible, false);
            if (this._isParentScrollView)
            {
                childNode.__setTouchableFalse();
            }

        }
        else
        {
            var errorMsg = [];
            errorMsg.push("message:");
            errorMsg.push(this.type);
            errorMsg.push(".addChild: ");
            errorMsg.push(childNode);
            errorMsg.push(" is not a view!");

            throw new Error(errorMsg.join());
        }

        this._internalGLObject.addChild(childNode.getGLObject());
        this._updateDepth();
        return this;
    },
    /**
     * Remove a child from this <code>View</code>.
     * @example mainView.removeChild(errorView);
     * @param {GLUI.AbstractView} childNode The child node to remove.
     * @throws {"message:" + this.type + ".addChild: " + childNode + " is not a view!"} Specified child is not an instance of Abstract View.
     * @returns The child node that was removed.
     * @see GLUI.View#addChild
     * @status Android, Test
     */
    removeChild: function (childNode)
    {
        if (childNode instanceof AbstractView)
        {
            var nodeIndex = this._children.indexOf(childNode);
            if (nodeIndex !== -1)
            {
                this._children.splice(nodeIndex, 1);
            }
            this._internalGLObject.removeChild(childNode.getGLObject());
            childNode._parent = null;
            childNode._setEnabled(true, false);
            childNode._setVisible(true, false);
            if (this._isParentScrollView)
            {
                childNode.__setTouchableTrue();
            }
            this._updateDepth();
        }
        else
        {
            var errorMsg = [];
            errorMsg.push("message:");
            errorMsg.push(this.type);
            errorMsg.push(".addChild: ");
            errorMsg.push(childNode);
            errorMsg.push(" is not a view!");

            throw new Error(errorMsg.join());
        }
        return childNode;
    },
    /**
     * Retrieve a count of the child nodes attached to this <code>View</code>.
     * @return {Number} The current number of child nodes.
     * @status Android, Flash
     */
    getChildCount: function ()
    {
        return this._children.length;
    },
    /**
     * @function
     * @return {Array} A copy of array containing children (sub-views) of a View.
     */
    getChildren: function ()
    {
        return this._children.slice(); //using slice, it is returning the copy instead of original reference
    },

    /**
     * @name GLUI.View#setImage
     * @description Set an image URL for a view state. This property defines a remote image resource to use in arbitrary contexts.
     * <br /><b>Note: </b> Images must be in powers of two and/or mentioned under <code>"textures":</code> key in manifests.
     * <br />URL is also supported, and the image will be converted to power of two.
     * <br />Local image auto conversion will be supported later.
     * @example var someSprite = new GLUI.View();        
     * someSprite.setImage('./Content/mySprite.png', GLUI.State.Normal, [w, h]);
     * someSprite.setImage('http://www.example.com/somepicture80x92.png', GLUI.State.Normal, [200, 110]);
     * @see GLUI.View#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.State} [flags=GLUI.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {Array} imageSize an array for the size of image. [w, h]
     * @status iOS, Android, Test
     * @function 
     */
    setImage: function (imageURL, flags, imageSize)
    {
        if (!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject._setClickable(false);
        }
        this._adjustFrameForBgImage();
        this._imageObject.setImage(imageURL, flags, imageSize);

    },
    /**
     * @name GLUI.View#getImage
     * @description Retrieve the <code>image</code> URL for a view state.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @returns {String} The current image URL for the specified view state.
     * @see GLUI.View#setImage
     * @status Android, Flash, Test
     * @function
     */
    getImage: function (flags)
    {
        if (this._imageObject)
        {
            var val = this._imageObject.getImage(flags);
            return val;
        }
        else
        {
            return undefined;
        }
    },
    /**
     * @name GLUI.View#setImageFit
     * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
     * @example var someSprite = new GLUI.View();
     * ...
     * someSprite.setImageFit(GLUI.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.View#getImageFit
     * @function
     */
    setImageFit: function (fitMode)
    {
        if (this._imageObject)
        {
            this._imageObject.setImageFit(fitMode);
        }
    },
    /**
     * @name GLUI.View#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.View#setImageFit
     * @function
     * @status 
     */
    getImageFit: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageFit();
        }
        
        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.View#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
     * @example var someSprite = new GLUI.View();
     * ...
     * someSprite.setImageGravity([0.5, 0.0]);
     * @param {Number} imageGravity The new value for <code>imageGravity</code> (expressed as two floats). Currently clipping is not supported for values greater than 1.0 or less than 0.0
     * @see GLUI.View#getImageGravity
     * @function
     * @status iOS, Android, Test
     */
    setImageGravity: function (imageGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                imageGravity = [arguments[0], arguments[1]];
            }
    
            this.__setImageGravity(imageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    
    /**
        @private
        */
    __setImageGravity: function (imageGravity)
    {
        imageGravity = (imageGravity && imageGravity.length === 2 && !isNaN(imageGravity[0]) && !isNaN(imageGravity[1])) ? [imageGravity[0], imageGravity[1]] : [0.5, 0.5];
    
        if (this._imageObject)
        {
            this._imageObject._imageGravity = imageGravity;
            this._imageObject._anchor = imageGravity;
            this._imageObject._adjustImageGravity();
            this._imageObject.setImageFit(this.getImageFit());
        }
    },
    /**
     * @name GLUI.View#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code> (expressed as two floats).
     * @see GLUI.View#setImageGravity
     * @function
     * @status Android, Flash, Test
     */
    getImageGravity: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageGravity();
        }
        return undefined;
    },

    /*private methods*/

    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForImage(this);
    },

    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForImage(this);
    },
    _updateDepth: function ()
    {
        var i;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                if (this._children[i])
                {
                    this._children[i].getGLObject().setDepth(i + 1);
                }
            }
        }
    },

    _updateView: function ($super)
    {
        $super();
        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if (this._imageObject)
        {
            this._imageObject.setState(this._state);
        }
    },

    _adjustFrameForBgImage: function ()
    {
        if (this._imageObject)
        {
            var frameForBgImage = [0, 0, this._frame[2], this._frame[3]]; //hence it is a child node of view, its position should be 0, 0 locally as this is a background.
            this._imageObject.setFrame(frameForBgImage);
        }
    },
    _removeAllChildren: function()
    {
        if (this._children && this.removeChild)
        {
            while(this._children.length)
            {
                this.removeChild(this._children[0]);
            }
        }
    },
    destroy: function ($super)
    {
        this._removeAllChildren();
        if (this._sprite)
        {
            this._sprite.destroy();
            this._sprite = null;
        }
        if (this._children)
        {
            delete this._children;
            this._children = null;
        }

        if (this._imageObject)
        {
            this._imageObject.destroy();
            this._imageObject = null;
        }
        this._imageURL = null;

        $super();
    },
    ///////////// Empty Functions/////////////

    /**
     * @name GLUI.View#layoutSubviews
     * @description Override this for custom view subclass layout code.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @function
     * @status Android, Flash, Test
     */
    layoutSubviews: function(){
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: layoutSubviews() ' + this.classname);
    },
    
    /**
     * @name GLUI.View#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>
     * @see GLUI.View#setImageBorder
     * @function
     * @status Android, Flash, Test
     */ 
    getImageBorder: function(){
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder() ' + this.classname);
    },
    
    /**
     * @name GLUI.View#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder</code>.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @see GLUI.View#getImageBorder
     * @function
     * @status Android, Flash, Test
     */ 
    setImageBorder: function(imageBorder, flags){
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) ' + this.classname);
    },
    
    /**
     * @name GLUI.View#getStyle
     * @description Retrieve the style for this <code>View.</code>
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {GLUI.Style} The current <code>View</code> style.
     * @see GLUI.View#setStyle
     * @function
     * @status Android, Flash, Test
     */
    getStyle: function(){
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getStyle() ' + this.classname);
    },
    
    /**
     * @name GLUI.View#setStyle
     * @description Set the style for this <code>View.</code> This call allows custom view objects to process and update their styles more easily.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.Style} style The new  <code>View</code> style.
     * @see GLUI.View#getStyle
     * @function
     * @status Android, Flash, Test
     */
    setStyle: function(style){
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setStyle(style) ' + this.classname);
    }   
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Label'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Label'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Label'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Label.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan H.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo/GLUI/Commands').Commands;
var Util = require('NGGo/GLUI/Util').Util;
var Text = require('NGCore/Client/GL2/Text').Text;

exports.Label = AbstractView.subclass(
{ /** @lends GLUI.Label.prototype */
    classname: 'Label',
    /**
     * @name GLUI.Label
     * @class The <code>Label</code> class constructs objects for managing strings that are used as application labels. 
     * These objects include access to a wide range of attributes for manipulating the look and feel of application labels.
     * @constructs
     * @augments GLUI.AbstractView
     */


    initialize: function (properties)
    {
        this._internalGLObject = new Text();
        this._internalGLObject.setAnchor(0, 0);
        this._internalGLObject.setColor(0, 0, 0);
        this._internalGLObject.setOverflowMode(Text.OverflowMode.Multiline);
        this._textInset = [0, 0, 0, 0];
        this._shadowValues = [];
        this._textSize = null;
        this._colors = [];
        this._texts = [];
        this._fonts = [];
        this._shadow = null;
        this._textGravity = null;
        this._fontLocation = 0;
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },


    /**
     * @name GLUI.Label#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>text</code>.
     * @see GLUI.Label#setText
     * @function
     * @status Android, Test
     *
     */
    getText: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._texts[state + ''];
    },
    /**
     * @name GLUI.Label#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textColor</code>.
     * @see GLUI.Label#setTextColor
     * @status Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._colors[state + ''];
    },
    /**
     * @name GLUI.Label#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code>.
     * @see GLUI.Label#setTextFont
     * @status Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._fonts[state + ''];
    },
    /**
     * @name GLUI.Label#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property for this <code>Label</code>.
     * @returns {Number} The current value of <code>textSize</code>.
     * @see GLUI.Label#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._textSize;
    },
    /**
     * @name GLUI.Label#setTextInsets
     * @description Set the value of the <code>textInsets</code> property for this <code>Label</code>. This property defines the viewable area of a text string when applying gravity.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextInsets(0, 0, 0, 64);
     * @param {Number, Array (Number)} textInsets The new value for <code>textInsets</code>. Set as individual components or a single array of components.
     * @see GLUI.Label#getTextInsets
     * @status Android, Test
     * @function
     */

    setTextInsets: function (textInsets)
    {
        if (arguments)
        {
            if (arguments.length >= 4)
            {
                textInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }

            this.__setTextInsets(textInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTextInsets in " + this.classname);
        }
    },
    /**
     * @private
     * @status Android
     */
    __setTextInsets: function (textInset)
    {
        if (textInset.length < 4)
        {
            throw new Error('Too few arguments for \'textInset\' in setTextInsets(textInset)');
        }
		if (isNaN(textInset[0]) || isNaN(textInset[1]) || isNaN(textInset[2]) || isNaN(textInset[3]))
        {
            throw new Error('Wrong arguments for \'textInset\' in setTextInsets(textInset)');
        }
        this._textInset = [textInset[0], textInset[1],textInset[2], textInset[3]];
        var bgColor = this.getBackgroundColor();
        if (!bgColor)
        {
            this.setBackgroundColor("00000000");
        }
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.Label#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property for this <code>Label</code>.
     * @returns {Number, Array (Number)} The current value of <code>textInsets</code>.
     * @see GLUI.Label#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return [this._textInset[0], this._textInset[1], this._textInset[2], this._textInset[3]];
    },

    /*
     * @private
     */
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._renderView();
    },
    /**
     * @name GLUI.Label#setText
     * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setText("Friends List");
     * @param {String} text The new value for <code>text</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getText
     * @status Android,Test
     * @function
     */
    setText: function (text, flags)
    {
        var state = this._getFinalState(flags);
        this._texts[state + ''] = text;
        var curState = this._getCurrentState();
        var curText = this._texts[curState + ''];
        this._internalGLObject.setText(curText);
        this._updateShadow();
        return this;
    },


    /**
     * @name GLUI.Label#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string for a label in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextColor('FFFF');
     * @param {String} textColor The new value for <code>textColor</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextColor
     * @status Android, Test
     * @function
     */
    setTextColor: function (color, flags)
    {
        var state = this._getFinalState(flags);
        this._colors[state + ''] = color;
        var curState = this._getCurrentState();
        var currentColor = this._colors[curState + ''];
        var rgbValue = Util.hexToARGB(currentColor);
        this.__internalAlpha = rgbValue[0];
        this._internalGLObject.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
        this._updateAlpha();
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (font, flags)
    {
        var state = this._getFinalState(flags);
        this._fonts[state + ''] = font;
        var curState = this._getCurrentState();
        var currentFont = this._fonts[curState + ''];
        this._internalGLObject.setFontFamily(currentFont);
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>Label</code> node.
     * @example var label = new GLUI.Label();
     * ...
     * label.setFontLocation(0);
     * @param {GLUI.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.Label#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function (fontLocation)
    {
        if (fontLocation === null || fontLocation === undefined)
        {
            return;
        }
        this._fontLocation = Text.FontLocation.Default;
        switch (fontLocation)
        {
        case 1:
            this._fontLocation = Text.FontLocation.System;
            break;
        case 2:
            this._fontLocation = Text.FontLocation.Bundled;
            break;
        case 3:
            this._fontLocation = Text.FontLocation.Manifest;
            break;
        }
        this._internalGLObject.setFontLocation(this._fontLocation);
        if (this._shadow)
        {
            this._shadow.setFontLocation(this._fontLocation);
        }

    },

    /**
     * @name GLUI.Label#setTextSize
     * @description Set the value of the <code>textSize</code> property for this <code>Label</code>. This property defines the size of text strings for a label.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextSize(24);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.Label#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (size)
    {
        if (isNaN(size))
        {
            throw new Error('Expecting number but found ' + typeof (size) + ' for setTextSize(size)');
        }
        this._textSize = size;
        if (this._internalGLObject)
        {
            this._internalGLObject.setFontSize(this._textSize);
        }
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setTextGravity
     * @description Set the value of the <code>textGravity</code> property for this <code>Label</code>. This property defines how a text string is positioned within a viewable area.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextGravity([1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.Label#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                textGravity = [arguments[0], arguments[1]];
            }

            this.__setTextGravity(textGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTextGravity in " + this.classname);
        }
    },
    /**
     * @private
     * @status Android
     */
    __setTextGravity: function (textGravity)
    {
        if (textGravity.length < 2)
        {
            throw new Error('Too few arguments for \'textGravity\' in setTextGravity(textGravity)');
        }
        if (isNaN(textGravity[0]) && isNaN(textGravity[1]))
        {
            throw new Error('Wrong arguments for \'textGravity\' in setTextGravity(textGravity)');
        }
        var gravityX = null;
        var gravityY = null;
        if (textGravity[0] < 0.5)
        {
            gravityX = 0;
        }
        else if (textGravity[0] > 0.5)
        {
            gravityX = 2;
        }
        else
        {
            gravityX = 1;
        }
        if (textGravity[1] < 0.5)
        {
            gravityY = 0;
        }
        else if (textGravity[1] > 0.5)
        {
            gravityY = 2;
        }
        else
        {
            gravityY = 1;
        }
        this._textGravity = [textGravity[0], textGravity[1]];
        this._internalGLObject.setHorizontalAlign(gravityX);
        this._internalGLObject.setVerticalAlign(gravityY);
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property for this <code>Label</code>.
     * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.Label#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        if (this._textGravity === null || this._textGravity === undefined)
        {
            return this._textGravity;
        }
        else
        {
            return [this._textGravity[0], this._textGravity[1]];
        }
    },
    /**
     * @name GLUI.Label#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on labels in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextShadow("FF00 0.2");
     * @param {String} textShadow The new value for <code>textShadow</code>.
     * @param {GLUI.Commands.State} [flags=UI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextShadow
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        if (textShadow === undefined || textShadow === null)
        {
            console.log("Wrong number of arguments for shadow");
            return this;
        }
        var params = textShadow.split(" ");
        if (params.length < 2)
        {
            console.log("Wrong number of arguments for shadow");
            return this;
        }
        if (isNaN("0x" + params[0]) || isNaN(params[1]))
        {
            console.log(params[0], params[1]);
            console.log("Invalid Parameters for arguments for setTextShadow()");
            return this;
        }
        var state = this._getFinalState(flags);
        this._shadowValues[state + ''] = textShadow;
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code>.
     * @see GLUI.Label#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._shadowValues[state + ''];
    },
    /**
     * @name GLUI.Label#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>Label</code> node.
     * @example var label = new GLUI.Label();
     * ...
     * label.getFontLocation();
    * @see GLUI.Label#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function ()
    {
        return this._fontLocation;
    },
    /**
     * @private
     **/
    destroy: function ($super)
    {
        if (this._colors)
        {
            this._colors.length = 0;
            this._colors = null;
        }
        if (this._texts)
        {
            this._texts.length = 0;
            this._texts = null;
        }
        if (this._fonts)
        {
            this._fonts.length = 0;
            this._fonts = null;
        }
        if (this._shadowValues)
        {
            this._shadowValues.length = 0;
            this._shadowValues = null;
        }
        if (this._textGravity)
        {
            this._textGravity.length = 0;
            this._textGravity = null;
        }
        if (this._textInset)
        {
            this._textInset.length = 0;
            this._textInset = null;
        }
        if( this._shadow )
        {
            this._shadow.destroy();
            this._shadow = null;
        }
        this._textSize = null;

        $super();
    },

    /**
     * @private
     * */
    setVisible: function ($super, value)
    {
        $super(value);
        if (this._parentNode)
        {
            this._parentNode.setVisible(value);
        }
        this._internalGLObject.setVisible(value);
    },
    /**
     *
     * @private
     * @status Android
     */
    __fillBackgroundColor: function ($super)
    {
        $super();
        this._internalGLObject.setPosition(0, 0);
    },
    /**
     *
     * @private
     * @status Android
     */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForLabel(this);
    },
    /**
     *
     * @private
     * @status Android
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
    },
    /**
     *
     * @private
     * @status Android
     */
    _getFinalState: function (flags)
    {
        var currentState = flags;
        var nextState = null;
        if (currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if (currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if (currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if (currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if (currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if (currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     *
     * @private
     * @status Android
     */
    _getCurrentState: function ()
    {
        var currentState = this._state;
        var nextState = null;
        if (currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if (currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if (currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if (currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if (currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if (currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     *
     * @private
     * @status Android
     */
    _updateView: function ($super)
    {
        $super();
        var curState = this._getCurrentState();
        var currentColor = this._colors[curState + ''];
        if (currentColor === undefined || currentColor === null)
        {
            currentColor = this._colors[Commands.State.Normal + ''];
            var rgbValue = Util.hexToARGB(currentColor);
            if (currentColor === undefined || currentColor === null)
            {
                this.__internalAlpha = 1.0;
                this._internalGLObject.setColor(0, 0, 0);
            }
            else
            {
                this.__internalAlpha = rgbValue[0];
                this._internalGLObject.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
            }
            this._updateAlpha();
        }
        else
        {
            this.setTextColor(currentColor, curState);
        }
        var currentFont = this._fonts[curState + ''];
        if (currentFont === undefined)
        {
            currentFont = this._fonts[Commands.State.Normal + ''];
            this._internalGLObject.setFontFamily(currentFont);
        }
        else
        {
            this.setTextFont(currentFont, curState);
        }
        var currentText = this._texts[curState + ''];
        if (currentText === undefined)
        {
            currentText = this._texts[Commands.State.Normal + ''];
            this._internalGLObject.setText(currentText);
        }
        else
        {
            this.setText(currentText, curState);
        }
        this._updateShadow();
    },
    /**
     *
     * @private
     * @status Android
     */
    _updateShadow: function ()
    {
        var curState = this._getCurrentState();
        var currentShadow = this._shadowValues[curState + ''];
        if (currentShadow === undefined || currentShadow === null)
        {
            currentShadow = this._shadowValues[Commands.State.Normal + ''];
        }
        if (currentShadow === undefined || currentShadow === null)
        {
            if (this._shadow)
            {
                this.getGLObject().removeChild(this._shadow);
                this._shadow.destroy();
                this._shadow = null;
            }
            return;
        }
        if (!this._shadow)
        {
            var bgColor = this.getBackgroundColor();
            if (bgColor)
            {
                this.setBackgroundColor(bgColor);
            }
            else
            {
                this.setBackgroundColor("00000000");
            }
            this._shadow = new Text();
            this.getGLObject().addChild(this._shadow);
            this._shadow.setAnchor(0, 0);
            this._shadow.setDepth(this._internalGLObject.getDepth() - 1);
        }
        var params = currentShadow.split(" ");
        var opacity = params[1];
        var txt = this.getText(curState);
        if (txt === undefined || currentShadow === null)
        {
            txt = this.getText(Commands.State.Normal);
        }
        var font = this.getTextFont(curState);
        if (font === undefined || currentShadow === null)
        {
            font = this.getTextFont(Commands.State.Normal);
        }
        this._shadow.setText(txt);
        this._shadow.setFontSize(this.getTextSize());
        var rgbValue = Util.hexToARGB(params[0]);
        this._shadow.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
        this._shadow.setFontLocation(this._fontLocation);
        this._shadow.setFontFamily(font);
        this._shadow.setSize(this._frame[2], this._frame[3]);
        var Position = this._internalGLObject.getPosition();
        var shift    = /\{\s*([\-\d]+)\s*,\s*([\-\d]+)\s*\}/.exec(currentShadow) || [undefined, 3, 3]; // [dummy, shift-x, shift-y]
        this._shadow.setPosition(Position.getX() + ~~shift[1], Position.getY() + ~~shift[2]);
        var gravityX = this._internalGLObject.getHorizontalAlign();
        var gravityY = this._internalGLObject.getVerticalAlign();
        this._shadow.setHorizontalAlign(gravityX);
        this._shadow.setVerticalAlign(gravityY);
        this._shadow.setAlpha(opacity);
    },
    /**
     *
     * @private
     * @status Android
     */
    _renderView: function ()
    {
        var top = this._textInset[0];
        var right = this._textInset[1];
        var bottom = this._textInset[2];
        var left = this._textInset[3];
        var xTop = this._frame[0];
        var yTop = this._frame[1];
        if (this._parentNode)
        {
            xTop = yTop = 0;
        }
        if (right > this._frame[2] / 2)
        {
            right = this._frame[2] / 2;
        }
        this._updateShadow();
        this._internalGLObject.setPosition(xTop + left - right / 4, yTop + top - bottom / 4);
        this._internalGLObject.setSize(this._frame[2] - right - left, this._frame[3] - bottom - top);
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Button'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Button'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Button'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Button.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Taha S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Size = require('NGCore/Client/Core/Size').Size;
var Commands = require('NGGo/GLUI/Commands').Commands;
var View = require('NGGo/GLUI/View').View;
var Label = require('NGGo/GLUI/Label').Label;
var Util = require('NGGo/GLUI/Util').Util;

exports._unbindButtons = [];
exports._activeButton = undefined;
var Button = View.subclass(
/** @lends GLUI.Button.prototype */
{
    classname: "Button",
    /**
     * @name GLUI.Button
     * @class The <code>Button</code> class constructs objects that are used as application buttons.
     * @augments GLUI.View
     */
    initialize: function ($super, properties, cleanView)
    {
        $super();
        this._text = new Label();
        this._text._setClickable(false);
        this._text.setTextGravity([0.5, 0.5]);
        this.addChild(this._text);
        this.setAttributes(properties);
        if (this.addChild && !cleanView)
        {
            delete this.addChild;
            this.addChild = undefined;
        }
        if (this.removeChild && !cleanView)
        {
            delete this.removeChild;
            this.removeChild = undefined;
        }
        if (this.getChildren && !cleanView)
        {
            delete this.getChildren;
            this.getChildren = undefined;
        }
        if (this.getChildrenCount && !cleanView)
        {
            delete this.getChildrenCount;
            this.getChildrenCount = undefined;
        }
        return this;
    },
    /**
     * @name GLUI.Button#setTextInsets
     * @description Set the value of the <code>textInsets</code> property.
     * This property defines the viewable area of a text string when applying gravity.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextInsets([0, 0, 0, 64]);
     * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
     * @see GLUI.Button#getTextInsets
     * @status Android, Test
     * @function
     */
    setTextInsets: function (insets)
    {
        return this._text.setTextInsets(insets);
    },
    /**
     * @name GLUI.Button#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property.
     * @returns {Array (Number)} The curent value for <code>textInsets</code>.
     * @see GLUI.Button#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return this._text.getTextInsets();
    },
    /**
     * @name GLUI.Button#setText
     * @description Set the value of the <code>text</code> property for a view state.
     * This property defines a text string to use as a label for a button in different
     * view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setText("More information");
     * @see GLUI.Button#getText
     * @param {String} text The new value for <code>text</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status iOS, Android, Flash, Test
     * @function
     */
    setText: function (text, flags)
    {
        this._text.setText(text, flags || Commands.State.Normal);
        return this;
    },
    /**
     * @name GLUI.Button#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state.
     *  This property defines the color of a text string used as a label on a
     * button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextColor('FFFFFF');
     * @see GLUI.Button#getTextColor
     * @param {String} textColor The new value for <code>textColor</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commonds.State.Normal] The GLUI view state.
     * @status  Android, Test
     * @function
     */
    setTextColor: function (textColor, flags)
    {
        this._text.setTextColor(textColor, flags);
        return this;
    },
    /**
     * @name GLUI.Button#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Button#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (textFont, flags)
    {
        this._text.setTextFont(textFont, flags);
        return this;
    },
    /**
     * @name GLUI.Button#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>Button</code> node.
     * @example var button = new GLUI.Button();
     * ...
     * button.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.Button#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function(fontLocation){
        this._text.setFontLocation(fontLocation);
        return this;
    },
     /**
     * @name GLUI.Button#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>Button</code> node.
     * @example var button = new GLUI.Button();
     * ...
     * button.getFontLocation();
     * @see GLUI.Button#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function(){
        return this._text.getFontLocation();
    },
    /**
     * @name GLUI.Button#setTextSize
     * @description Set the value of the <code>textSize</code> property. This property defines the text size of labels for a button.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextSize(24);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.Button#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (textSize)
    {
        this._text.setTextSize(textSize);
        return this;
    },
    /**
     * @name GLUI.Button#setTextGravity
     * @description Set the value of the <code>textGravity</code> property. This property defines how a text string for a button is positioned within a viewable area.
     * @example var infoButton = new UI.Button();
     * ...
     * infoButton.setTextGravity([0.1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.Button#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        this._text.setTextGravity(textGravity);
        return this;
    },
    /**
     * @name GLUI.Button#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on text strings for a button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextShadow("FF00 0.2");
     * @see GLUI.Button#getTextShadow
     * @param {String} textShadow The new value for <code>textShadow</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        this._text.setTextShadow(textShadow, flags);
    },
    /**
     * @name GLUI.Button#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>text</code> in the specified view state..
     * @see GLUI.Button#setText
     * @status Android, Test
     * @function
     */
    getText: function (flags)
    {
        return this._text.getText(flags);
    },
    /**
     * @name UI.Button#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {UI.State} [flags=UI.State.Normal] The UI view state.
     * @returns {String} The current value of <code>textColor</code> in the specified view state..
     * @see UI.Button#setTextColor
     * @status  Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        return this._text.getTextColor(flags);
    },
    /**
     * @name GLUI.Button#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property.
     * @returns {Number} The current value for <code>textSize</code>.
     * @see GLUI.Button#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._text.getTextSize();
    },
    /**
     * @name GLUI.Button#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code> in the specified view state.
     * @see GLUI.Button#setTextFont
     * @status  Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        return this._text.getTextFont(flags);
    },
    /**
     * @name GLUI.Button#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property.
     * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.Button#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        return this._text.getTextGravity();
    },
    /**
     * @name GLUI.Button#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code> in the specified view state..
     * @see GLUI.Button#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        return this._text.getTextShadow(flags);
    },
    setState: function ($super, flags)
    {
        $super(flags);
        this._text.setState(flags);
    },
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._text.setFrame([0, 0, this._frame[2], this._frame[3]]);
        if (!this.getOnClick())
        {
            this.setOnClick(function ()
            {});
        }
        this._updateDepth();
    },
    destroy: function ($super)
    {
        if (this._text)
        {
            this._text.destroy();
            this._text = null;
        }
        $super();
    },
    /**
     * @private
     * */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @private
     * */
    _renderView: function ()
    {
        this._text.setState(this.getState());
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForLabel(this);
        this._setters.visible = this.setVisible.bind(this);
    },
    /**
     * @private
     * */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
        this._getters.visible = this.getVisible.bind(this);
    },
    /////////// Empty Functions /////////////////
    /**
     * @name GLUI.Button#setImageInsets
     * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var backButton = new UI.Button();
     * ...
     * backButton.setImageInset([10,10,10,10]);
     * @param {Number|Array (Number)} imageInsets The new value for <code>imageInsets.</code> Set as insets or an array of insets (expressed as floats).
     * @see GLUI.Button#getImageInsets
     * @status  Android, Test
     * @function
     */
    setImageInsets: function (imageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageInsets(imageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.Button#getImageInsets
     * @description Retrieve the value of the <code>imageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number|Array (Number)} The current value of <code>imageInsets.</code>
     * @see GLUI.Button#setImageInsets
     * @status  Android, Test
     * @function
     */
    getImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageInsets() in Button');
    },

    /**
     * @name GLUI.Button#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for an image used as a button.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var button = new UI.Button()
     * ...
     * button.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.Button#getImageTransform
     * @status  Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in ' + this.classname);
    },

    /**
     * @name GLUI.Button#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>
     * @see GLUI.Button#setImageTransform
     * @status  Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() in ' + this.classname);
    }
});

exports.Button = Button;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/CheckBox'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/CheckBox'] || {}; $MODULE_REGISTRY['NGGo/GLUI/CheckBox'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/CheckBox.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K.
 *  @co-author: Ihsan H.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Size = require('NGCore/Client/Core/Size').Size;
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Commands = require('NGGo/GLUI/Commands').Commands;
var View = require('NGGo/GLUI/View').View;
var Label = require('NGGo/GLUI/Label').Label;
var Image = require('NGGo/GLUI/Image').Image;
var Button = require('NGGo/GLUI/Button').Button;

exports.CheckBox = Button.subclass( /** @lends GLUI.CheckBox.prototype */
{
    classname: "CheckBox",
    /**
     * @class The <code>CheckBox</code> class constructs objects that handle the state of application checkboxes.
     * @constructs The default constructor.
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments GLUI.Button
     */
    initialize: function ($super, properties)
    {
        $super();
        this._text.setTextGravity([0.5, 0.5]);
        this._spriteSize = [64, 64];
        this._unregisterProperties();
        if (properties)
        {
            this.setAttributes(properties);
        }
    },
    destroy: function ($super)
    {
        this._spriteSize = null;
        $super();
    },
    __setFrame: function ($super, frame)
    {
        frame = [frame[0] + 4, frame[1] + 4, frame[2] - 4, frame[3] - 4]; //adding default insets for checkbox;
        $super(frame);
        this._renderView();
    },
    /**
     * @name GLUI.CheckBox#setImage
     * @description Set an image URL for a view state. This defines how a checkbox appears for specific conditions. For example,
     * set different images for a checkbox in the default state and when the checkbox is checked.
     * @example var gameCheck = new GLUI.CheckBox();
     * ...
     * gameCheck.setImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [0,0,1,1]);
     * @see GLUI.CheckBox#getImage
     * @param {String} imageURL The new image URL. Note:please make sure that the textures are in powers of two (square powers recommended)
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @param {uvs} incase you're using portion of a single texture file.
     * @status Android, Test
     * @function
     */
    setImage: function ($super, imageURL, flags, imageSize)
    {
        if (!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject._setClickable(false);
            this._imageObject.setImageFit(Commands.FitMode.AspectHeight);
            this._imageObject.setImageGravity([0, 0]);
        }
        if (!imageSize || imageSize.length < 2)
        {
            if (this._frame[3] > 0)
            {
                var x = this._frame[2];
                var y = this._frame[3];
                imageSize = [x, y];
            }
            else
            {
                imageSize = this._spriteSize;
            }
        }
        this._imageObject.setImage(imageURL, flags, [imageSize[0], imageSize[1]]);
        this._adjustFrameForText();
        this._renderView();
    },
    /**
     * @name GLUI.CheckBox#setChecked
     * @description Set whether this <code>CheckBox</code> is "checked".
     * @example var gameCheck = new GLUI.CheckBox();
     * ...
     * gameCheck.setChecked(true);
     * @param {Boolean} checked Set as <code>true</code> if this <code>CheckBox</code> is "checked".
     * @see GLUI.CheckBox#getChecked
     * @status  Android
     * @function
     */
    setChecked: function (checked)
    {
        if (checked)
        {
            this.addState(Commands.State.Checked);
        }
        else
        {
            this.clearState(Commands.State.Checked);
        }
    },
    /**
     * @name GLUI.CheckBox#getChecked
     * @description Retrieve whether this <code>CheckBox</code> is currently "checked".
     * @returns {Boolean} Returns <code>true</code> if this <code>CheckBox</code> is currently "checked".
     * @see GLUI.CheckBox#setChecked
     * @status  Android
     * @function
     */
    getChecked: function ()
    {
        return (this._state & Commands.State.Checked) ? true : false;
    },
    /**
     * @name GLUI.CheckBox#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>CheckBox</code> node.
     * @example var box = new GLUI.CheckBox();
     * ...
     * box.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.CheckBox#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function(fontLocation){
        this._text.setFontLocation(fontLocation);
        return this;
    },
     /**
     * @name GLUI.CheckBox#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>CheckBox</code> node.
     * @example var box = new GLUI.CheckBox();
     * ...
     * box.getFontLocation();
     * @see GLUI.CheckBox#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function(){
        return this._text.getFontLocation();
    },

    /**
     * @private
     * */
    _unregisterProperties: function ()
    {
        var i;
        var unsupportedProperties = ['imageFit', 'imageGravity'];
        for (i = 0; i < unsupportedProperties.length; i++)
        {
            var propertyName = unsupportedProperties[i];
            var methodName = propertyName.slice();
            methodName[0] = propertyName[0].toUpperCase();
            var setterName = 'set' + methodName;
            var getterName = 'get' + methodName;
            //deleting setter method
            if (this[setterName] !== null)
            {
                delete this[setterName];
                this[setterName] = null;
            }
            //deleting getter method
            if (this[getterName] !== null)
            {
                delete this[getterName];
                this[getterName] = null;
            }
            //deleting setters property
            if (this._setters[propertyName])
            {
                this._setters[propertyName] = null;
                delete this._setters[propertyName];
            }
            //deleting getter property
            if (this._getters[propertyName])
            {
                this._getters[propertyName] = null;
                delete this._getters[propertyName];
            }
        }
        if (this.getChildrenCount)
        {
            delete this.getChildrenCount;
            this.getChildrenCount = undefined;
        }
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.checked = this.setChecked.bind(this);
    },
    /**
     * @private
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters.checked = this.getChecked.bind(this);
    },
    /**
     * @private
     * */
    _adjustFrameForText: function ()
    {
        var size = this.__getImageSize();
        var w = size.getWidth();
        var h = size.getHeight();
        //      var h = this._frame[3] || this._spriteSize[1];
        this._spriteSize = [w, h];
        var x = w + 5;
        var y = this._text.getGLObject().getPosition().getY();
        w = (this._frame[2] > x) ? this._frame[2] - x : 0;
        var frame = [x, y, w, h];
        if (w < 1)
        {
            this._text.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._text.setVisible(true);
        }
        this._text.setFrame(frame);
    },
    /**
     * @private
     * */
    __getImageSize: function ()
    {
        var w = 64;
        var h = 64;
        if (this._imageObject)
        {
            var size = this._imageObject.___getSpriteSizeForCheckBox();
            w = size[0];
            h = size[1];
        }
        return new Size(w, h);
    },
    /**
     * @private
     * */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @private
     * */
    _renderView: function ($super)
    {
        $super();
        this._text.setState(this.getState());
        this._adjustFrameForBgImage();
        this._adjustFrameForText();
    },
    /**
     * @private
     * */
    _endTap: function ($super)
    {
        $super();
        if (this._state & Commands.State.Checked)
        {
            this.clearState(Commands.State.Checked);
        }
        else
        {
            this.addState(Commands.State.Checked);
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/CellView'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/CellView'] || {}; $MODULE_REGISTRY['NGGo/GLUI/CellView'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/CellView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan H.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Size = require('NGCore/Client/Core/Size').Size;
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Commands = require('NGGo/GLUI/Commands').Commands;
var View = require('NGGo/GLUI/View').View;
var Label = require('NGGo/GLUI/Label').Label;
var Image = require('NGGo/GLUI/Image').Image;

exports.CellView = View.subclass( /** @lends GLUI.CellView.prototype */
{
    classname: "CellView",
    /**
     * @class The <code>CellView</code> class constructs objects that handle cell views in an application. For example, a cell in a scrolling list.
     * These objects are rendered with images on the left and right, and two text areas (title and text) stacked vertically in the middle.
     * @name GLUI.CellView
     * @augments GLUI.View
     */
    initialize: function ($super, properties)
    {
        $super();
        this._rightImage = null;
        this._text = new Label();
        this._text._setClickable(false);
        this._text.setTextGravity([0, 0.5]);
        this.addChild(this._text);
        this._text.setBackgroundColor("00000000");
        this._spriteSize = [64, 64];
        this._title = null;
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    destroy: function ($super)
    {
        if (this._rightImage)
        {
            this._rightImage.destroy();
            this._rightImage = null;
        }
        if (this._title)
        {
            this._title.destroy();
            this._title = null;
        }
        this._spriteSize = null;
        if (this._text)
        {
            this._text.destroy();
            this._text = null;
        }
        $super();
    },
/**
    @private
    */
    __setFrame: function ($super, frame)
    {
        this._text.setFrame([0, 0, this._frame[2], this._frame[3]]);
        if (!this.getOnClick())
        {
            this.setOnClick(function ()
            {});
        }
        $super(frame);
        this._updateDepth();
        this._renderView();
    },
    /**
     * @name GLUI.CellView#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>CellView</code> node.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.CellView#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function (aFontLocation)
    {
        this._text.setFontLocation(aFontLocation);
        if (this._title)
        {
            this._title.setFontLocation(aFontLocation);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>CellView</code> node.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.getFontLocation();
     * @see GLUI.CellView#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function ()
    {
        return this._text.getFontLocation();
    },
    /** 
     * @name GLUI.CellView#setImage
     * @description Set an image URL for a view state. This property defines how an image appears for specific conditions. For example,
     * set one image for the default view state and another image for a view state with focus.
     * @example var splashGraphic = new GLUI.CellView();
     * ...
     * splashGraphic.setImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [100,100]);
     * @see GLUI.CellView#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {imageSize} dimension of the GLTexture - this is important as GL requires dimension while applying imageFit properties.
     * @status  Android, Test
     * @function
     */
    setImage: function ($super, imageURL, flags, imageSize)
    {
        this.__setterCalledForImageObject();
        if (!imageSize || imageSize.length < 2)
        {
            if (this._frame[3] > 0)
            {
                var x = this._frame[2];
                var y = this._frame[3];
                imageSize = [x, y];
            }
            else
            {
                imageSize = this._spriteSize;
            }
        }
        this._imageObject.setImage(imageURL, flags, imageSize);
        this._renderView();
    },
    /**
     * @name GLUI.CellView#setImageFit
     * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control
     * @example background.setImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.CellView#getImageFit
     * @status Android, Test
     * @function
     */
    setImageFit: function (FitMode)
    {
        this.__setterCalledForImageObject();
        if (this._imageObject)
        {
            this._imageObject.setImageFit(FitMode);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
     * @example background.setImageGravity([0.5, 0.0]);
     * @param {Array(Number)} imageGravity The new value for <code>imageGravity</code> (expressed as two floats).
     * @see GLUI.CellView#getImageGravity
     * @function
     * @status Android, Test
     */
    setImageGravity: function (imageGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                imageGravity = [arguments[0], arguments[1]];
            }
            this._imageObject.__setImageGravity(imageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    /**
    @private
    */
    __setImageGravity: function (imageGravity)
    {
        this.__setterCalledForImageObject();
        if (this._imageObject)
        {
            this._imageObject.setImageFit(this.getImageFit());
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.CellView#setImageFit
     * @status Android, Test
     * @function
     */
    getImageFit: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageFit();
        }
        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.CellView#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code>
     * @see GLUI.CellView#setImageGravity
     * @status Android, Test
     * @function
     */
    getImageGravity: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageGravity();
        }

        return [0.5, 0.5];
    },
    setState: function ($super, flags)
    {
        $super(flags);
        this._text.setState(flags);
        if (this._title)
        {
            this._title.setState(this.getState());
        }
        if (this._rightImage)
        {
            this._rightImage.setState(this.getState());
        }
    },
    /**
     * @name GLUI.CellView#getRightImage
     * @description Retrieve the value of the <code>rightImage</code> property in the specified view state.
     * @returns {String} The current value of <code>rightImage</code>.
     * @function
     * @see GLUI.CellView#setRightImage
     * @status Android, Test
     */
    getRightImage: function (flags)
    {
        if (this._rightImage)
        {
            return this._rightImage.getImage(flags);
        }

        return undefined;
    },
    /**
     * @name GLUI.CellView#getRightImageFit
     * @description Retrieve the value of the <code>rightImageFit</code> property.
     * @returns {Number} The current value of <code>rightImageFit</code>.
     * @status Android, Test
     * @see GLUI.CellView#setRightImageFit
     * @function
     */
    getRightImageFit: function ()
    {
        if (this._rightImage)
        {
            return this._rightImage.getImageFit();
        }

        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.CellView#getRightImageGravity
     * @description Retrieve the value of the <code>rightImageGravity</code> property.
     * @returns {Number} The current value of <code>rightImageGravity</code>.
     * @function
     * @status Android, Test
     * @see GLUI.CellView#setRightImageGravity
     */
    getRightImageGravity: function ()
    {
        if (this._rightImage)
        {
            return this._rightImage.getImageGravity();
        }

        return [0.5, 0.5];
    },
    /**
     * @name GLUI.CellView#getTitle
     * @description Retrieve the value of the <code>title</code> property in a view state.
     * @returns {String} The current value of <code>title</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @function
     * @see GLUI.CellView#setTitle
     */
    getTitle: function (flags)
    {
        if (this._title)
        {
            return this._title.getText(flags);
        }
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleColor
     * @description Retrieve the value of the <code>titleColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>titleColor</code>.
     * @see GLUI.CellView#setTitleColor
     * @status Android, Test
     * @function
     */
    getTitleColor: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextColor(flags);
        }
        
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleFont  
     * @description Retrieve the value of the <code>titleFont</code> property in a view state. 
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The UI view state.
     * @returns {String} The current value of <code>titleFont</code>.
     * @function
     * @see GLUI.CellView#setTitleFont
     * @status Android, Test
     */
    getTitleFont: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextFont(flags);
        }
        
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleGravity
     * @description Retrieve the value of the <code>titleGravity</code> property. 
     * @returns {Array (Number)} The current value of <code>titleGravity</code>.
     * @see GLUI.CellView#setTitleGravity
     * @function
     * @status Android, Test
     */
    getTitleGravity: function ()
    {
        if (this._title)
        {
            return this._title.getTextGravity();
        }

        return [0.5, 0.5];
    },
    /**
     * @name GLUI.CellView#getTitleInsets
     * @description Retrieve the value of the <code>titleInsets</code> property.
     * @returns {Array (Number)} The current value of <code>titleInsets</code>.
     * @see GLUI.CellView#setTitleInsets
     * @status Android, Test
     * @function
     */
    getTitleInsets: function ()
    {
        if (this._title)
        {
            return this._title.getTextInsets();
        }

        return [0, 0, 0, 0];
    },
    /**
     * @name GLUI.CellView#getTitleShadow
     * @description Retrieve the value of the <code>titleShadow</code> property in a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>titleShadow</code>.
     * @see GLUI.CellView#setTitleShadow
     * @function
     * @status Android, Test
     */
    getTitleShadow: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextShadow(flags);
        }

        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleSize
     * @description Retrieve the value of the <code>titleSize</code> property.
     * @returns {Number} The current value of <code>titleSize</code>.
     * @see GLUI.CellView#setTitleSize
     * @function
     * @status Android, Test
     */
    getTitleSize: function ()
    {
        if (this._title)
        {
            return this._title.getTextSize();
        }
        return undefined;
    },
    /**
     * @name GLUI.CellView#setRightImage
     * @description Set an image URL for a view state. This property defines how an image appears for specific conditions. For example,
     * set one image for the default view state and another image for a view state with focus.
     * @example var splashGraphic = new GLUI.CellView();
     * ...
     * splashGraphic.setRightImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [100,100]);
     * @see GLUI.CellView#getRightImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {imageSize} dimension of the GLTexture - this is important as GL requires dimension while applying imageFit properties.
     * @status  Android, Test
     * @function
     */
    setRightImage: function (imageURL, flags, imageSize)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        this._rightImage.setImage(imageURL, flags, imageSize);
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.CellView#setRightImageFit
     * @description Set the value of the <code>rightImageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control
     * @example closureIcon = new GLUI.CellView();
     * ...
     * closureIcon.setRightImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} rightImageFit The new value for <code>rightImageFit</code>.
     * @status Android, Test
     * @see GLUI.CellView#getRightImageFit
     * @function
     */
    setRightImageFit: function (rightImageFit)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        this._rightImage.setImageFit(rightImageFit);
        return this;
    },
    /**
     * @name GLUI.CellView#setRightImageGravity
     * @description Set the value of the <code>rightImageGravity</code> property. This property defines how a image for a control is positioned within a viewable area.
     * @example var closureIcon = new GLUI.CellView();
     * ...
     * closureIcon.setRightImageGravity([0.5, 0]);
     * @param {Number} rightImageGravity The new value for <code>rightImageGravity</code>.
     * @function
     * @status Android, Test
     * @see GLUI.CellView#getRightImageGravity
     */
    setRightImageGravity: function (rightImageGravity)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                rightImageGravity = [arguments[0], arguments[1]];
            }
            this._rightImage.__setImageGravity(rightImageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setRightImageGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTitle
     * @description Set the value of the <code>title</code> property for a view state. This property defines the title string for a view in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitle('Game of Foo');
     * @param {String} title The new value for <code>title</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @see GLUI.CellView#getTitle
     * @function
     */
    setTitle: function (title, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setText(title, flags);
        this._title.setTextGravity([0, 0.5]);
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.CellView#setText
     * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label in the specified view state.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setText("Friends List");
     * @param {String} text The new value for <code>text</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getText
     * @status Android,Test
     * @function
     */
    setText: function (text, flags)
    {
        this._text.setText(text, flags || Commands.State.Normal);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string for a label in the specified view state.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextColor('FFFF');
     * @param {String} textColor The new value for <code>textColor</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextColor
     * @status Android, Test
     * @function
     */
    setTextColor: function (textColor, flags)
    {
        this._text.setTextColor(textColor, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a cellView.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (textFont, flags)
    {
        this._text.setTextFont(textFont, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextSize
     * @description Set the value of the <code>textSize</code> property for this <code>CellView</code>. This property defines the size of text strings for a view.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextGravity([1, 0.5]);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.CellView#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (textSize)
    {
        this._text.setTextSize(textSize);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextGravity
     * @description Set the value of the <code>textGravity</code> property for this <code>CellView</code>. This property defines how a text string is positioned within a viewable area.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextGravity([0.1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.CellView#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                textGravity = [arguments[0], arguments[1]];
            }
            this._text.__setTextGravity(textGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTextGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on on text strings in this view.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextShadow("FF00 0.2");
     * @param {String} textShadow The new value for <code>textShadow</code>.
     * @param {GLUI.Commands.State} [flags=UI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextShadow
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        this._text.setTextShadow(textShadow, flags);
    },
    /**
     * @name GLUI.CellView#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>text</code>.
     * @see GLUI.CellView#setText
     * @status Android, Test
     * @function
     */
    getText: function (flags)
    {
        return this._text.getText(flags);
    },
    /**
     * @name GLUI.CellView#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textColor</code>.
     * @see GLUI.CellView#setTextColor
     * @status Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        return this._text.getTextColor(flags);
    },
    /**
     * @name GLUI.CellView#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property for this <code>CellView</code>.
     * @returns {Number} The current value of <code>textSize</code>.
     * @see GLUI.CellView#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._text.getTextSize();
    },
    /**
     * @name GLUI.CellView#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code>.
     * @see GLUI.CellView#setTextFont
     * @status Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        return this._text.getTextFont(flags);
    },
    /**
     * @name GLUI.CellView#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property for this <code>CellView</code>.
     * @returns {Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.CellView#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        return this._text.getTextGravity();
    },
    /**
     * @name GLUI.CellView#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code>.
     * @see GLUI.CellView#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        return this._text.getTextShadow(flags);
    },
    /**
     * @name GLUI.CellView#setTitleColor
     * @description Set the value of the <code>titleColor</code> property for a view state. This property defines the title string color for the <code>CellView</code> object in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleColor("FFFF0000");
     * @param {String} titleColor The new value for <code>titleColor</code>.
     * @param {UI.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTitleColor
     * @function 
     * @status Android, Test
     */
    setTitleColor: function (titleColor, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextColor(titleColor, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleFont
     * @description Set the value of the <code>titleFont</code> property in a view state. This property defines the title string font for cell view labels in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleFont(myFont);
     * @param {String} titleFont The new value for <code>titleFont</code>.
     * @param {UI.State} [flags=UI.State.Normal] The UI view state.
     * @function
     * @see UI.CellView#getTitleFont
     * @status iOS, Android, Test
     */
    setTitleFont: function (titleFont, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextFont(titleFont, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleGravity
     * @description Set the value of the <code>titleGravity</code> property. This property defines how a title string is positioned within a viewable area.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleGravity([0.5, 0.0]);
     * @param {Array (Number)} titleGravity The new value for <code>titleGravity</code>.
     * @see GLUI.CellView#getTitleGravity
     * @status Android, Test
     * @function
     */
    setTitleGravity: function (titleGravity)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                titleGravity = [arguments[0], arguments[1]];
            }
            this._title.__setTextGravity(titleGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTitleGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleInsets
     * @description Set the value of the <code>titleInsets</code> property. This property defines the viewable area of a title string when applying gravity.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleInsets([10,10,10,10]);
     * @param {Array (Number)} titleInsets The new value for <code>textInsets</code>.
     * @function
     * @see GLUI.CellView#getTitleInsets
     * @status Android, Test
     */
    setTitleInsets: function (titleInsets)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        if (arguments)
        {
            if (arguments.length >= 4)
            {
                titleInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            this._title.__setTextInsets(titleInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTitleInsets in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTextInsets
     * @description Set the value of the <code>textInsets</code> property. This property defines the viewable area of a text string when applying gravity.
     * @example var cellText = new GLUI.CellView()
     * ...
     * cellText.setTextInsets([10,10,10,10]);
     * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
     * @see GLUI.CellView#getTextInsets
     * @status Android, Test
     * @function
     */
    setTextInsets: function (textInsets)
    {
        if (arguments)
        {
            if (arguments.length >= 4)
            {
                textInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            this._text.__setTextInsets(textInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTextInsets in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property.
     * @returns {Array (Number)} The curent value for <code>textInsets</code>.
     * @see GLUI.CellView#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return this._text.getTextInsets();
    },
    /**
     * @name GLUI.CellView#setTitleShadow
     * @description Set the value of the <code>titleShadow</code> property in a view state. This property defines the amount of text shadowing used for title strings in a cell view.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleShadow('FFCCCCFF 0.2');
     * @param {String} titleShadow The new value for <code>titleShadow</code>.
     * @param {UI.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @see GLUI.CellView#getTitleShadow
     * @function
     */
    setTitleShadow: function (titleShadow, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextShadow(titleShadow, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleSize
     * @description Set the value of the <code>titleSize</code> property. This property defines the text size of title strings in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleSize(32);
     * @param {Number} titleSize The new value for <code>textSize</code>.
     * @function
     * @see GLUI.CellView#getTitleSize
     * @status Android, Test
     */
    setTitleSize: function (titleSize)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextSize(titleSize);
        return this;
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _makeTitle: function ()
    {
        this._title = new Label();
        this._title.setFontLocation(this._text.getFontLocation());
        this._title._clickable = false;
        this.addChild(this._title);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _makeRightImage: function ()
    {
        this._rightImage = new Image();
        this._rightImage._clickable = false;
        this.addChild(this._rightImage);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.visible = this.setVisible.bind(this);
        Commands._registerSettersForLabel(this);
        Commands._registerSettersForCellView(this);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
        this._getters.visible = this.getVisible.bind(this);
        Commands._registerGettersForCellView(this);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    __setterCalledForImageObject: function ()
    {
        if (!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject._clickable = false;
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject.setImageFit(Commands.FitMode.AspectHeight);
            this._imageObject.setImageGravity([0, 0.5]);
        }
        return this._imageObject;
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForText: function ()
    {
        var imageWidth = 0;
        if (!this._frame)
        {
            return;
        }
        if (this._imageObject)
        {
            var size = this.__getImageSize();
            imageWidth = size.getWidth();
        }
        var x = imageWidth;
        var w = this._frame[2] - imageWidth;
        var h = this._frame[3] / 2;
        var frame = [x, h, w, h];
        this._text.setFrame(frame);
        if (w < 1)
        {
            this._text.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._text.setVisible(true);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForRightImage: function ()
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            return;
        }
        var frame = [this._frame[2] - 50, 0, 50, this._frame[3]];
        this._rightImage.setFrame(frame);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForBgImage: function ()
    {
        if (this._imageObject)
        {
            var frameForBgImage = [0, 0, this._frame[2], this._frame[3]]; //hence it is a child node of view, its position should be 0, 0 locally as this is a background.
            this._imageObject.setFrame(frameForBgImage);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForTitle: function ()
    {
        var imageWidth = 0;
        if (!this._frame || !this._title)
        {
            return;
        }
        if (this._imageObject)
        {
            var size = this.__getImageSize();
            imageWidth = size.getWidth();
        }
        var x = imageWidth;
        var y = 0;
        var w = this._frame[2] - imageWidth;
        var h = this._frame[3] / 2;
        var frame = [x, y, w, h];
        this._title.setFrame(frame);
        if (w < 1)
        {
            this._title.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._title.setVisible(true);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    __getImageSize: function ()
    {
        var w = 1;
        var h = 1;
        if (this._imageObject)
        {
            var size = this._imageObject.___getSpriteSizeForCheckBox();
            w = size[0];
            h = size[1];
        }
        return new Size(w, h);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _renderView: function ()
    {
        this._text.setState(this.getState());
        this._adjustFrameForBgImage();
        this._adjustFrameForText();
        this._adjustFrameForTitle();
        this._adjustFrameForRightImage();
        if (this._title)
        {
            this._title.setState(this.getState());
        }
        if (this._rightImage)
        {
            this._rightImage.setState(this.getState());
        }
    },
    ////////////Empty Functions /////////////
    /**
     * @name GLUI.CellView#setImageInsets
     * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example background.setImageInsets([10,10,10,10]);
     * @param {Number|Array (Number)} imageInsets The new value for <code>imageInsets.</code>. Set as insets or an array of insets (float).
     * @see GLUI.CellView#getImageInsets
     * @status Android, Test
     * @function
     */
    setImageInsets: function (imageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageInsets(imageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#getImageInsets
     * @description Retrieve the value of the <code>imageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number|Array (Number)} The current value of <code>imageInsets.</code>.
     * @see GLUI.CellView#setImageInsets
     * @status Android, Test
     * @function
     */
    getImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageInsets() in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#setRightImageInsets
     * @description Set the value of the <code>rightImageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example closureIcon.setRightImageInsets([10,10,10,10]);
     * @param {Array (Number)} rightImageInsets The new value for <code>rightImageInsets.</code>. Set as floats (t, r, b, l).
     * @see GLUI.CellView#getRightImageInsets
     * @status Android, Test
     * @function
     */
    setRightImageInsets: function (rightImageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageInsets(rightImageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#getRightImageInsets
     * @description Retrieve the value of the <code>rightImageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>rightImageInsets.</code>.
     * @see GLUI.CellView#setRightImageInsets
     * @status Android, Test
     * @function
     */
    getRightImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageInsets() in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder.</code>.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getImageBorder
     * @status Android, Test
     * @function
     */
    setImageBorder: function (imageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) in ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images used with a cell view.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example background.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.CellView#getImageTransform
     * @status Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setRightImageBorder
     * @description Set the value of the <code>rightImageBorder</code> property in the specified view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} rightImageBorder The new value for <code>rightImageBorder.</code>
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI View state.
     * @see GLUI.CellView#getRightImageBorder
     * @status Android, Test
     * @function
     */
    setRightImageBorder: function (rightImageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageBorder(rightImageBorder, flags) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setRightImageTransform
     * @description Set the value of the <code>rightImageTransform</code> property. This property defines data compression for images used with right image objects.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var closureIcon = new UI.CellView();
     * ...
     * closureIcon.setRightImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} rightImageTransform The new value for <code>rightImageTransform.</code> Set as six floats (a, b, c, d, tx, ty).
     * @see GLUI.CellView#getRightImageTransform
     * @status Android, Test
     * @function
     */
    setRightImageTransform: function (rightImageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageTransform(rightImageTransform) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>.
     * @see GLUI.CellView#setImageBorder
     * @status Android, Test
     * @function
     */
    getImageBorder: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder() ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>.
     * @see GLUI.CellView#setImageTransform
     * @status Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getRightImageBorder
     * @description Retrieve the value of the <code>rightImageBorder</code> property in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>rightImageBorder.</code>.
     * @see GLUI.CellView#setRightImageBorder
     * @status Android, Test
     * @function
     */
    getRightImageBorder: function (flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageBorder(flags) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getRightImageTransform
     * @description Retrieve the value of the <code>rightImageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>rightImageTransform.</code>.
     * @see GLUI.CellView#setRightImageTransform
     * @status Android, Test
     * @function
     */
    getRightImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageTransform() ' + this.classname);
    }

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/WindowLayer'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/WindowLayer'] || {}; $MODULE_REGISTRY['NGGo/GLUI/WindowLayer'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/WindowLayer.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizunou T.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Element = require('NGGo/GLUI/Element').Element;
var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var Root = require('NGCore/Client/GL2/Root').Root;

/** @private
 *  This ENTIRE CLASS is private.
 */
exports.WindowLayer = Element.subclass( /** @lends GLUI.WindowLayer.prototype */
{
    'type': 'WindowLayer',
    initialize: function ($super, props)
    {
        this._children = [];
        this._visible = true;
    },
    getRoot: function ()
    {
        return this;
    },
    getParent: function ()
    {
        return undefined;
    },

    getGLObject: function ()
    {
        return Root;
    },
    addChild: function (childNode, index)
    {
        if (childNode instanceof AbstractView)
        {
            if (childNode._parent)
            {
                childNode.removeFromParent();
            }
            if (this._children)
            {

                if ((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            childNode._parent = this;
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not an Instance of AbstractView!");
        }
        try
        {
            Root.addChild(childNode.getGLObject());
            childNode._parent = this;
            this._updateDepth();
        }
        catch (ex)
        {
            throw new Error(ex);
        }
    },
    _updateDepth: function ()
    {
        var i;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                if (this._children[i])
                {
                    this._children[i].getGLObject().setDepth(i + 1);
                }
            }
        }
    },
    removeChild: function (childNode)
    {
        try
        {
            var nodeIndex = this._children.indexOf(childNode);
            if (nodeIndex !== -1)
            {
                this._children.splice(nodeIndex, 1);
            }
            Root.removeChild(childNode.getGLObject());
            childNode._parent = null;
            this._updateDepth();

        }
        catch (ex)
        {
            throw new Error(ex);
        }
    },
    getChildCount: function ()
    {
        return this._children.length;
    },
    getChildren: function ()
    {
        return this._children.slice();
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/ScrollView'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/ScrollView'] || {}; $MODULE_REGISTRY['NGGo/GLUI/ScrollView'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/ScrollView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Jabbar M.
 *  @co-author: Taha S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Size = require('NGCore/Client/Core/Size').Size;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Point = require('NGCore/Client/Core/Point').Point;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Node = require('NGCore/Client/GL2/Node').Node;
var Util = require('NGGo/GLUI/Util').Util;
var View = require('NGGo/GLUI/View').View;
var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var WindowLayer = require('NGGo/GLUI/WindowLayer').WindowLayer;
/** @private
 *class not to be accessed from out side
 *
 */
var Scrollbar = Util.Rectangle.subclass( /** @lends Scrollbar.prototype */
{
    initialize: function ($super)
    {
        $super();
        this.setColor([0.5, 0.5, 0.5]);
        this.setAlpha(0);
        this.setDepth(65535);
    },
    updateSize: function (mode, frame, contentSize)
    {
        var f_width = frame.getSize().getWidth();
        var f_height = frame.getSize().getHeight();
        var c_width = contentSize.getWidth();
        var c_height = contentSize.getHeight();
        if (mode === exports.ScrollView.ScrollDirection.Horizontal)
        {
            this.setFrame([0, f_height - 5, f_width * (f_width / c_width), 5]);
        }
        else
        {
            this.setFrame([f_width - 5, 0, 5, f_height * (f_height / c_height)]);
        }
        this.mode = mode;
        this.frameSize = new Size([f_width, f_height]);
        this.contentSize = new Size([c_width, c_height]);
    },
    updateAlpha: function (momentum)
    {
        if (momentum.x === 0 && momentum.y === 0)
        {
            var alpha = this.getAlpha();
            if (alpha === 0)
            {
                return;
            }
            else
            {
                alpha -= 0.03;
                if (alpha < 0.01)
                {
                    alpha = 0;
                }
                this.setAlpha(alpha);
            }
        }
    },
    updatePosition: function (new_x, new_y)
    {
        this.setAlpha(1);
        if (!this.mode)
        {
            return;
        }
        var f_width = this.frameSize.getWidth();
        var f_height = this.frameSize.getHeight();
        var c_width = this.contentSize.getWidth();
        var c_height = this.contentSize.getHeight();
        if (this.mode === exports.ScrollView.ScrollDirection.Horizontal)
        {
            this.setPosition(-f_width * (new_x / c_width), f_height - 5);
        }
        else
        {
            this.setPosition(f_width - 5, -f_height * (new_y / c_height));
        }
    }
});
/** @private
 *class not to be accessed from out side
 *
 */
var DragListener = MessageListener.subclass( /** @lends DragListener.prototype */
{
    classname: 'DragListener',
    DRAGTHRESHOLD: 15,
    initialize: function (listview)
    {
        this._touch = null;
        this.listview = listview;
        this._target = new TouchTarget();
        this._target.getTouchEmitter().addListener(this, this.onTouch);
        this._clickChild = null;
    },
    getTarget: function ()
    {
        return this._target;
    },
    onTouch: function (touch)
    {
        switch (touch.getAction())
        {
        case touch.Action.Start:
            if (this._touch)
            {
                return false;
            }
            this._touch = {
                id: touch.getId(),
                sx: touch.getPosition().getX(),
                sy: touch.getPosition().getY(),
                x: touch.getPosition().getX(),
                y: touch.getPosition().getY(),
                lx: touch.getPosition().getX(),
                ly: touch.getPosition().getY(),
                dx: 0,
                dy: 0
            };
            this._clickChild = this.listview._giveTouchesToChildren(touch, this.listview._visibleArray);
            if (!this._clickChild instanceof AbstractView)
            {
                this._clickChild = null;
            }
            return true;
        case touch.Action.End:
            if (this._touch.id !== touch.getId())
            {
                return false;
            }
            this.listview._endTap();
            this._touch = null;
            if (this._clickChild)
            {
                this._clickChild._touchReceivedCallBack(touch);
                this._clickChild = null;
            }
            break;
        case touch.Action.Move:
            if (this._touch.id !== touch.getId() || this.listview._scrollLock)
            {
                return false;
            }
            var pos = touch.getPosition();
            if (this._touch === null || pos === undefined)
            {
                break;
            }
            this._touch.x = pos.getX();
            this._touch.y = pos.getY();
            var moveDis = Math.sqrt(Math.pow(this._touch.x - this._touch.lx, 2) + Math.pow(this._touch.y - this._touch.ly, 2));
            if (moveDis <= this.DRAGTHRESHOLD)
            {
                break;
            }
            this._touch.dx += this._touch.x - this._touch.lx;
            this._touch.dy += this._touch.y - this._touch.ly;
            this._touch.lx = this._touch.x;
            this._touch.ly = this._touch.y;
            if (this.listview.getOnScroll())
            {
                this.listview._onScrollCallBack();
            }
            if (this._clickChild)
            {
                if (this._clickChild._touchReceivedCallBack(touch, true))
                {
                    this._clickChild = null;
                }
            }
            break;
        default:
            break;
        }
        return false;
    },
    onUpdate: function ()
    {
        var count = 0;
        var delta = {
            x: 0,
            y: 0
        };
        if (this._touch)
        {
            delta.x += this._touch.dx;
            delta.y += this._touch.dy;
            this._touch.dx = this._touch.dy = 0;
            ++count;
        }
        if (count > 1)
        {
            delta.x /= count;
            delta.y /= count;
        }
        this.listview._onUpdate(delta);
    },
    hasTouch: function ()
    {
        return (this._touch !== null);
    },
    __addDragListenerToUpdateEmitter: function ()
    {
        UpdateEmitter.addListener(this, this.onUpdate);
    },
    destroy: function ($super)
    {
        if (this._target)
        {
            this._target.destroy();
            this._target = null;
        }
        this._touch = null;
        this.listview = null;
        this._clickChild = null;
        $super();
    }
});
exports.ScrollView = View.subclass( /** @lends GLUI.ScrollView.prototype */
{
    classname: 'ScrollView',
    /**
     * @class The <code>ScrollView</code> class constructs objects that handle views in a scrolling list (see <code>{@link GLUI.ListView}</code>). 
     * You can define these views as scrolling vertically or horizontially.<br><br>
     * <b>Note:</b> Android devices can only scroll in one direction at a time.
     * @name GLUI.ScrollView
     * @augments GLUI.View
     */
    ScrollDirection: {
        Horizontal: 1,
        Vertical: 2
    },
    /**
     * @constructs The default constructor.
     * @augments GLUI.View
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     */
    initialize: function ($super, properties)
    {
        $super();
        this._myFrame = new Rect();
        this._contentSize = new Size();
        this._userFrame = null;
        this._content = new Node();
        this._scrollPosition = [0, 0];
        this._internalGLObject.addChild(this._content);
        this._content.setDepth(1);
        this._feeling = {
            friction: 0.90,
            smoothingFactor: 0.5,
            stretchDecay: 0.65,
            rangeFactor: 0.5
        };
        this.setScrollDirection(this.ScrollDirection.Vertical);
        this._momentum = {
            x: 0,
            y: 0
        };
        this._visibleArray = [];
        this._buttons = [];
        this._scrollbar = new Scrollbar();
        this._needUpdateView = false;
        this._internalGLObject.addChild(this._scrollbar);
        this._target = 1;
        this.setAttributes(properties);
    },
    /**
     * Add a child node to this <code>ScrollView</code> at the specified index.
     * @example var scrollView = new GLUI.ScrollView();
     * ...
     * var childView = new UI.View();
     * ...
     * scrollView.addChild(childView);
     * @param {GL2.Node} childNode The child node to add.
     * @param {Number} index The specified index.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @throws {this.type + ".addChild: " + childNode + " is not a view!"} Specified node is not attached to a scrollView.
     * @see GLUI.ScrollView#removeChild
     * @status Android, Test
     * @private 
     */
    addChild: function (childNode, index)
    {
        if (childNode instanceof AbstractView)
        {
            if (childNode._parent)
            {
                childNode.removeFromParent();
            }
            if (this._children)
            {
                if ((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            // Must populate parent before setting visibility
            childNode._parent = this;
            childNode._setEnabled(this._enabled, false);
            childNode._setVisible(this._visible, false);
            childNode.__setTouchableFalse();
            this._needUpdateView = true;
            this._updateDepth();
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not a view!");
        }
        this._content.addChild(childNode.getGLObject());
        this._updateDepth();
        return this;
    },
    /**
     * Remove a child node from this <code>scrollView</code>.
     * @example scrollView.removeChild(ChildView);
     * @param {GL2.Node} childNode The child node to remove.
     * @throws Any Exception occured with {Node.js} while removing a child node.
     * @see GLUI.ScrollView#addChild
     * @status Android, Test
     * @private 
     */
    removeChild: function (childNode)
    {
        try
        {
            var nodeIndex = this._children.indexOf(childNode);
            if (nodeIndex !== -1)
            {
                this._children.splice(nodeIndex, 1);
            }
            this._content.removeChild(childNode.getGLObject());
            childNode._parent = null;
            childNode._setEnabled(true, false);
            childNode._setVisible(true, false);
            childNode.__setTouchableTrue();
            this._needUpdateView = true;
            this._updateDepth();
        }
        catch (ex)
        {
            throw new Error(ex);
        }
    },
    /**
     * @name GLUI.ScrollView#setFrame
     * @function 
     * @description Set the value of the <code>frame</code> property. This property defines the size of ViewAble area of the ScrollView.
     * @example var scrollView = new GLUI.ScrollView();
     * ...
     * scrollView.setFrame([10, 10, 64, 64]);
     * @param {Number, Array (Number), Object} arg0 This parameter will pass in values in one of three ways:
     * <div class="ul">
     * <li>Four float values (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>).</li>
     * <li>Single array containing the above four values.</li>
     * <li>A rect specifying the frame (see <code>{@link UI.ViewGeometry.Rect}</code>).</li>
     * </div>
     * <b>Note:</b>  we also change the Width/Height to full Screen Width/Height based on ScrollDirection.
     * @see GLUI.ScrollVIew#getFrame
     * @private
     */
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._userFrame = this._frame;
        this._evaluateScrollDirection();
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            if (frame[0] > 0)
            {
                console.log("Clipping is not supported for GLUI.ScrollView, Horizontal recommended frame is: [0,y,w,h] provided frame: " + JSON.stringify(frame));
            }
            this._frame = [this._frame[0], this._frame[1], /*Util.getOrientationSreenWidth()*/ this._frame[2], this._frame[3]];
        }
        else
        {
            if (frame[1] > 0)
            {
                console.log("Clipping is not supported for GLUI.ScrollView, Vertical recommended frame is: [x,0,w,h] provided frame: " + JSON.stringify(frame));
            }
            this._frame = [this._frame[0], this._frame[1], this._frame[2], this._frame[3] /*, Util.getOrientationSreenHeight()*/ ];
        }
        this._myFrame = new Rect(this._frame);
        var origin = this._myFrame.getOrigin();
        var size = this._myFrame.getSize();
        this.getGLObject().setPosition(origin.getX(), origin.getY());
        if (this._touchTarget)
        {
            this._internalGLObject.removeChild(this._touchTarget);
            this._touchTarget = null;
        }
        if (this._dragger)
        {
            this._dragger.destroy();
            this._dragger = null;
        }
        this._dragger = new DragListener(this);
        this._dragger.__addDragListenerToUpdateEmitter();
        this._touchTarget = this._dragger.getTarget();
        this._touchTarget.setSize(size);
        this._touchTarget.setPosition(0, 0);
        this._touchTarget.setDepth(2);
        this._internalGLObject.addChild(this._touchTarget);
        this._updateScrollBar();
    },
    /**
     * @name GLUI.ScrollView#getFrame
     * @description Retrieve the value of the <code>frame</code> property set by user.
     * @param {Number, Array (Number)} frame Individual components or a component array (<i>x</i>,<i>y</i>,<i>w</i>,<i>h</i>).
     * @see GLUI.ScrollView#setFrame
     * @private
     */
    getFrame: function ()
    {
        return this._userFrame;
    },
    /**
     * @name GLUI.ScrollView#setContentSize
     * @description Set the value for the <code>contentSize</code> property. This property defines the size of a scroll area.
     * @example var dialog = {
     *  width: screen.width * sizeRate.width / 100,
     *  height: screen.height * sizeRate.height / 100
     * };
     * ...
     * this.scrollView.setContentSize([dialog.width, 600]);
     * @params {Number, Array (Number, String)} Individual components or a component array.
     * @see GLUI.ScrollView#getContentSize
     * @function
     * @status Android, Test
     */
    setContentSize: function (contentSize)
    {
        if (contentSize instanceof Size)
        {
            contentSize = [contentSize.getWidth(), contentSize.getHeight()];
        }
        if (contentSize.length === 2)
        {
            if (isNaN(contentSize[0]) || isNaN(contentSize[1]))
            {
                throw new Error(this.classname + 'contentSize() expects numeric Array. getting [' + typeof (contentSize[0]) + ',' + typeof (contentSize[1]) + ']');
            }
            else
            {
                this._contentSizeArray = contentSize;
                this._setContentSize();
                this._evaluateScrollDirection();
            }
        }
        else
        {
            throw new Error(this.classname + 'contentSize() expects Array(2) or Core.Size(). eg [1200,300] or new Core.Size(200,1000)');
        }
    },
    /**
     * @name GLUI.ScrollView#getContentSize
     * @description Retrieve the value of the <code>contentSize</code> property.
     * @returns {Number, Array (Number, String)} The current value of <code>contentSize</code>.
     * @see GLUI.ScrollView#setContentSize
     * @function
     * @status Android, Test
     */
    getContentSize: function ()
    {
        return this._contentSizeArray;
    },
    /**
     * @name GLUI.ScrollView#setOnScroll
     * @description Set a function to call when the <code>scroll</code> event occurs.
     * @param {Function} scrollCallback The new callback function.<br><br>
     * <b>Note:</b> The <code>pageevent</code> event is disabled if the value of this parameter is not a function.
     * @see GLUI.ScrollView#event:getOnScroll
     * @event
     * @status Android, Test
     */
    /**
     * @name GLUI.ScrollView#getOnScroll
     * @description Retrieve the function to call when the <code>scroll</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.ScrollView#event:setOnScroll
     * @event
     * @status Android, Test
     */
    setOnScroll: function (onScrollCallBack)
    {
        if (typeof (onScrollCallBack) === "function")
        {
            this._onScrollCallBack = onScrollCallBack;
        }
    },
    getOnScroll: function ()
    {
        return this._onScrollCallBack;
    },
    /**
     * @name GLUI.ScrollView#setScrollPosition
     * @description Set the value for the <code>scrollPosition</code> property.
     * @example var hscroller = new GLUI.ScrollView();
     * ...
     * hscroller.setScrollPosition([0.5,0]);
     * @param {Number, Array (Number)} Individual components or a component array.
     * @see GLUI.ScrollView#getScrollPosition
     * @function
     * @status Android, Test
     */
    setScrollPosition: function (vector)
    {
        if (arguments && arguments.length === 1)
        {
            vector = new Vector(vector);
        }
        else if (arguments.length === 2)
        {
            vector = new Vector(arguments[0], arguments[1]);
        }
        else
        {
            throw new Error("Too many or too few arguments for setScrollPosition | " + typeof (vector) + this.classname);
        }
        if (vector.getX() === undefined || vector.getX() === null || vector.getY() === undefined || vector.getY() === null)
        {
            return;
        }
        //var h_upper = 0;
        var h_lower = this._myFrame.getSize().getWidth() - this._contentSize.getWidth();
        if (h_lower > -1)
        {
            h_lower = -1;
        }
        //var v_upper = 0;
        var v_lower = this._myFrame.getSize().getHeight() - this._contentSize.getHeight();
        if (v_lower > -1)
        {
            v_lower = -1;
        }
        //var new_x = this._content.getPosition().getX();
        //var new_y = this._content.getPosition().getY();
/*if (this._scroll == this.ScrollDirection.Horizontal) {
            new_x = -1*(h_lower/2 + (h_upper - h_lower) * vector.getX());
        } else {
            new_y = -1*(v_lower/2 + (v_upper - v_lower) * vector.getY());
        }*/
        this._content.setPosition(-vector.getX(), -vector.getY());
        this._scrollPosition = [vector.getX(), vector.getY()];
    },
    /**
     * @name GLUI.ScrollView#getScrollPosition
     * @description Retrieve the value of the <code>scrollPosition</code> property.
     * @returns {Number, Array (Number)} The current value of <code>scrollPosition</code>.
     * @see GLUI.ScrollView#setScrollPosition
     * @function
     * @status Android, Test
     */
    getScrollPosition: function ()
    {
        return this._scrollPosition;
    },
    destroy: function ($super)
    {
        this._removeAllChildren();
        this._userFrame = null;
        this._myFrame = null;
        this._contentSize = null;
        if (this._visibleArray !== null)
        {
            this._visibleArray.length = 0;
            this._visibleArray = null;
        }
        if (this._buttons !== null)
        {
            this._buttons.length = 0;
            this._buttons = null;
        }
        if (this._feeling !== null)
        {
            this._feeling.length = 0;
            this._feeling = null;
        }
        this._scrollbar.destroy();
        this._scrollbar = null;
        this._content.destroy();
        this._content = null;
        if (this._touchTarget)
        {
            this._internalGLObject.removeChild(this._touchTarget);
            this._touchTarget = null;
        }
        if (this._dragger)
        {
            this._dragger.destroy();
            this._dragger = null;
        }
        this._needUpdateView = null;
        this._scrollPosition = null;
        this._momentum = null;
        $super();
    },
    /** @private */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.contentSize = this.setContentSize.bind(this);
        this._setters.scroll = this.setOnScroll.bind(this);
        this._setters.scrollPosition = this.setScrollPosition.bind(this);
    },
    _registerGetters: function ($super)
    {
        $super();
        this._getters.contentSize = this.getContentSize.bind(this);
        this._getters.scroll = this.getOnScroll.bind(this);
        this._getters.scrollPosition = this.getScrollPosition.bind(this);
    },
    _updateScrollingView: function ()
    {
        var i;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                var listItem = this._children[i];
                var itemIndex = this._visibleArray.indexOf(listItem);
                if (this._isInsideScreen(listItem))
                {
                    if (itemIndex === -1)
                    {
                        this._visibleArray.push(listItem);
                    }
                }
                else
                {
                    if (itemIndex !== -1)
                    {
                        this._visibleArray.splice(itemIndex, 1);
                    }
                }
            }
        }
    },
    _isInsideScreen: function (listItem)
    {
        var screenWidth = Capabilities.getScreenWidth();
        var screenHeight = Capabilities.getScreenHeight();
        var frame = listItem.getFrame();
        var x = listItem.getGLObject().getPosition().getX();
        var y = listItem.getGLObject().getPosition().getY();
        var itemWidth = frame[2];
        var itemHeight = frame[3];
        var convertedPos = this._content.localToScreen(new Point(x, y));
        if (convertedPos === null || convertedPos === undefined)
        {
            return undefined;
        }
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            if ((convertedPos.getX() >= 0 && convertedPos.getX() <= screenWidth) || (convertedPos.getX() < 0 && convertedPos.getX() + itemWidth > 0))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            if ((convertedPos.getY() >= 0 && convertedPos.getY() <= screenHeight) || (convertedPos.getY() < 0 && convertedPos.getY() + itemHeight > 0))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    },
    setScrollFeeling: function (feeling)
    {
        var key;
        for (key in this._feeling)
        {
            if (this._feeling.hasOwnProperty(key))
            {
                this._feeling[key] = feeling[key] || this._feeling[key];
            }
        }
    },
    setScrollDirection: function (dir)
    {
        switch (dir)
        {
        case this.ScrollDirection.Horizontal:
            this._scroll = dir;
            if (this._scrollPosition[1] > 0)
            {
                this._content.setPosition(this._scrollPosition[0], this._scrollPosition[1]);
            }
            break;
        case this.ScrollDirection.Vertical:
            this._scroll = dir;
            this._content.setPosition(this._scrollPosition[0], this._scrollPosition[1]);
            break;
        default:
            break;
        }
    },
    getScrollDirection: function ()
    {
        return this._scroll;
    },
    setScrollLock: function (lock)
    {
        this._scrollLock = lock;
    },
    getScrollLock: function ()
    {
        return this._scrollLock;
    },
    _setContentSize: function ()
    {
        if (this._contentSizeArray)
        {
            this._contentSize.setWidth(this._contentSizeArray[0]);
            this._contentSize.setHeight(this._contentSizeArray[1]);
        }
        else
        {
            this._contentSize.setHeight(0);
            this._contentSize.setWidth(0);
        }
        this._updateScrollBar();
    },
    _evaluateScrollDirection: function ()
    {
        if (!this._userFrame || !this._contentSizeArray)
        {
            return;
        }
        if ((this._contentSizeArray[0] / this._userFrame[2]) > (this._contentSizeArray[1] / this._userFrame[3]))
        {
            this.setScrollDirection(this.ScrollDirection.Horizontal);
        }
        else if ((this._contentSizeArray[0] / this._userFrame[2]) > (this._contentSizeArray[1] / this._userFrame[3]))
        {
            this.setScrollDirection(this.ScrollDirection.Vertical);
        }
        this._updateScrollBar();
    },
    _updateScrollBar: function ()
    {
        this._scrollbar.updateSize(this._scroll, this._myFrame, this._contentSize);
    },
    _endTap: function ()
    {
        if (this._clickCallBack)
        {
            this._clickCallBack();
        }
    },
    _applyRange: function (position, delta, lower, upper)
    {
        if (delta === 0)
        {
            return position;
        }
        if (delta > 0)
        {
            if (position < lower)
            {
                position += delta * this._feeling.rangeFactor;
                if (position >= lower)
                {
                    delta = (position - lower) / this._feeling.rangeFactor;
                    position = lower;
                }
                else
                {
                    return position;
                }
            }
            //If we're inside our bounds, apply the delta
            if (position < upper)
            {
                //if the delta will place us out of range, apply it and save the remainder.
                if (position + delta > upper)
                {
                    delta -= (upper - position);
                    position = upper;
                    delta *= this._feeling.rangeFactor;
                }
            }
            //We're out of range, so only apply by range factor.
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        //Handle negative delta; same thing, just bounds reversed.
        else if (delta < 0)
        {
            if (position > upper)
            {
                position += delta * this._feeling.rangeFactor;
                if (position <= upper)
                {
                    delta = (position - upper) / this._feeling.rangeFactor;
                    position = upper;
                }
                else
                {
                    return position;
                }
            }
            if (position > lower)
            {
                if (position + delta < lower)
                {
                    delta -= (lower - position);
                    position = lower;
                    delta *= this._feeling.rangeFactor;
                }
            }
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        return position + delta;
    },
    _onUpdate: function (delta)
    {
        var theRoot = null;
        if (this._needUpdateView)
        {
            theRoot = this.getRoot();
        }
        if (theRoot && theRoot.type === "document")
        {
            this._updateScrollingView();
            this._needUpdateView = false;
        }
        //addcontentsize check
        var sf = this._feeling.smoothingFactor;
        var hasTouch = this._dragger.hasTouch();
        //Our ranges are negative because we push the origin up/left from the start position.
        var h_upper = 0;
        var h_lower = this._myFrame.getSize().getWidth() - this._contentSize.getWidth();
        if (h_lower > -1)
        {
            h_lower = -1;
        }
        var v_upper = 0;
        var v_lower = this._myFrame.getSize().getHeight() - this._contentSize.getHeight();
        if (v_lower > -1)
        {
            v_lower = -1;
        }
        var new_x = this._content.getPosition().getX();
        var new_y = this._content.getPosition().getY();
        //if we're in bounds and we have no movement, don't bother updating
        if (delta.x === 0 && delta.y === 0)
        {
            if (this._momentum.x === 0 && this._momentum.y === 0)
            {
                if (hasTouch || ((new_x >= h_lower) && (new_x <= h_upper) && (new_y >= v_lower) && (new_y <= h_upper)))
                {
                    this._scrollbar.updatePosition(this._scrollPosition);
                    this._scrollbar.updateAlpha(this._momentum);
                    return;
                }
            }
        }
        //If we have touches accumulate momentum
        if (hasTouch)
        {
            //Use exponential smoothing to approximate the current momentum
            this._momentum.x = sf * delta.x + (1 - sf) * this._momentum.x;
            this._momentum.y = sf * delta.y + (1 - sf) * this._momentum.y;
        }
        //Otherwise, consume the momentum.
        else
        {
            if (this.getOnScroll())
            {
                this._onScrollCallBack();
            }
            delta.x += this._momentum.x;
            delta.y += this._momentum.y;
            //Apply friction, stop if we're below a small threshold.
            this._momentum.x *= this._feeling.friction;
            this._momentum.y *= this._feeling.friction;
            if (this._momentum.x < 1 && this._momentum.x > -1)
            {
                this._momentum.x = 0;
            }
            if (this._momentum.y < 1 && this._momentum.y > -1)
            {
                this._momentum.y = 0;
            }
        }
        //Handle any deltas
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            new_x = this._applyRange(new_x, delta.x, h_lower, h_upper);
        }
        else
        {
            new_y = this._applyRange(new_y, delta.y, v_lower, v_upper);
        }
        //Without touches to anchor us, we should slide back into range.
        if (!hasTouch)
        {
            if (new_x < h_lower)
            {
                new_x = h_lower - (h_lower - new_x) * this._feeling.stretchDecay;
                if (h_lower - new_x < 1)
                {
                    new_x = h_lower;
                }
            }
            else if (new_x > h_upper)
            {
                new_x = h_upper + (new_x - h_upper) * this._feeling.stretchDecay;
                if (new_x - h_upper < 1)
                {
                    new_x = h_upper;
                }
            }
            if (new_y < v_lower)
            {
                new_y = v_lower - (v_lower - new_y) * this._feeling.stretchDecay;
                if (v_lower - new_y < 1)
                {
                    new_y = v_lower;
                }
            }
            else if (new_y > h_upper)
            {
                new_y = v_upper + (new_y - v_upper) * this._feeling.stretchDecay;
                if (new_y - v_upper < 1)
                {
                    new_y = v_upper;
                }
            }
        }
        this._content.setPosition(new_x, new_y);
        this._myCurrPos = this._content.getPosition();
        this._scrollPosition = [Math.floor(-new_x), Math.floor(-new_y)];
        this._scrollbar.updatePosition(new_x, new_y);
        this._updateScrollingView();
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/ListView'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/ListView'] || {}; $MODULE_REGISTRY['NGGo/GLUI/ListView'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/ListView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var GLUIUtil = require('NGGo/GLUI/Util').Util;
var View = require('NGGo/GLUI/View').View;
var ScrollView = require('NGGo/GLUI/ScrollView').ScrollView;
exports.ListView = ScrollView.subclass( /** @lends GLUI.ListView.prototype */
{
    classname: 'ListView',
    /**
     * @class The <code>ListView</code> class constructs objects that contain <code>{@link GLUI.ListViewItem}</code> and <code>{@link GLUI.ListViewSection}</code> objects.
     * These objects handle and render scrolling lists in an application.
     * A <code>ListView</code> object can contain potentially thousands of items,
     * in sections, that use a pool of reusable views to display content.
     * @name GLUI.ListView
     * @constructs
     * @augments GLUI.ScrollView
     */
    ScrollDirection: {
        Horizontal: 1,
        Vertical: 2
    },
    initialize: function (properties)
    {
        this._myFrame = null;
        this._reusableViewsPool = [];
        this._viewsPool = [];
        this._completeItemsList = null;
        this._isSetSection = false;
        if (properties)
        {
            this.setAttributes(properties);
        }
    },
    /**
     * @name GLUI.ListView#setSections
     * @description Set the list of sections that this <code>ListView</code> contains.
     * @example var sections = [];
     * var section = new GLUI.ListViewSection;
     * ...
     * var items = [];
     * for(news in News)
     * {
     *  var item = new ListItem.ListItem();
     *  item.game = News[news];
     *  items.push(item);
     * }
     *
     * section.setItems(items);
     * sections.push(section);
     *
     * gameNews.setSections(sections);
     * @param {Object} newSections A new aray of section IDs.
     * @see GLUI.ListView#getSections
     * @function
     * @status  Android
     */
    setSections: function (sectArray)
    {
        this._momentum = {
            x: 0,
            y: 0
        };
        this.setScrollPosition([0, 0]);
        if (!this._myFrame)
        {
            throw new Error("ListView expects setFrame([x,y,w,h]) to be called before setSections(sections)");
        }
        if (sectArray instanceof Array)
        {
            this._sectionsArray = sectArray;
            this._isSetSection = true;
        }
        else
        {
            throw new Error(this.classname + "expects Array in setSections(), getting object of " + sectArray.type);
        }
    },
    /**
     * @name GLUI.ListView#getSections
     * @description Retrieve all contained sections by this <code>ListView</code>.
     * @returns {Object} The current section list as an array of section IDs.
     * @param {}
     * @see GLUI.ListView#setSections
     * @function
     * @status Android
     */
    getSections: function ()
    {
        return this._sectionsArray;
    },
    /**
     * @name GLUI.ListView#reloadData
     * @description Clear this <code>ListView</code> and reload all list data.
     * @see GLUI.ListViewItem,
     * @see GLUI.ListViewSection
     * @status Javascript, Android, Flash
     * @function
     */
    reloadData: function ()
    {
        var i = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            this._sectionsArray[i].flush();
        }
        this.setSections(this._sectionsArray);
    },
    /**
     * @name GLUI.ListView#setHeader
     * @description Set the value for the <code>header</code> property. This string is used as a header for the <code>ListView</code>.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var section = new GLUI.ListViewSection;
     * ...
     * friendHeader.setHeader('This is a header');
     * @param {String} header The new header.
     * @see GLUI.ListView#getHeader
     * @function
     * @status  Android
     */
    setHeader: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  setHeader()  in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#getHeader
     * @description Retrieve the value of the <code>header</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current header.
     * @see GLUI.ListView#setHeader
     * @function
     * @status Android
     */
    getHeader: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  getHeader() in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#setFooter
     * @description Set the value for the <code>footer</code> This string is used as a footer for the <code>ListView.</code>
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var section = new GLUI.ListViewSection;
     * ...
     * friendHeader.setFooter('This is a footer');
     * @param {String} footer The new footer.
     * @see GLUI.ListView#getFooter
     * @function
     * @status  Android
     */
    setFooter: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  setFooter() in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#getFooter
     * @description Retrieve the value of the <code>footer</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current footer.
     * @see GLUI.ListView#setFooter
     * @function
     * @status Android
     */
    getFooter: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  getFooter() in ' + this.classname);
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters['sections'] = this.setSections.bind(this);
    },
    /**
     * @private 
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters['sections'] = this.getSections.bind(this);
    },
    /**
     * @private
     * @status Android
     * */
    _flushSection: function (sectionObject)
    {
        var indexOfSection = this._sectionsArray.indexOf(sectionObject);
        if (indexOfSection < 0)
        {
            return;
        }
        var indexedSection = this._sectionsArray[indexOfSection];
        var sectionItemsArray = indexedSection.getItems();
        var i = 0;
        for (i = 0; i < sectionItemsArray.length; i++)
        {
            var sectionItem = sectionItemsArray[i];
            if (sectionItem._glView)
            {
                this._addToReUsableViewsArray(sectionItem._glView, sectionItem._reusableID);
            }
        }
    },
    /**
     * @private
     * @status Android
     */
    _evaluateItemPositions: function ()
    {
        var i = 0;
        var itemObject = null;
        if (this._completeItemsList)
        {
            for (i = 0; i < this._completeItemsList.length; i++)
            {
                itemObject = this._completeItemsList[i];
                if (itemObject._glView)
                {
                    this._addToReUsableViewsArray(itemObject._glView, itemObject._reusableID);
                }
            }
        }
        this._completeItemsList = [];
        var startingPos = 0;
        var currentPos = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            var indexedSectArray = this._sectionsArray[i];
            indexedSectArray._parentListView = this;
            indexedSectArray._updateHeight();
            var j = 0;
            var itemsArray = indexedSectArray.getItems();
            var titleView = indexedSectArray.getTitleView();
            var titleWidthHeight = 0;
            if (titleView)
            {
                if (this._scroll === this.ScrollDirection.Horizontal)
                {
                    if (titleView.getFrame())
                    {
                        if (!indexedSectArray._isOnTop)
                        {
                            titleView.setFrame([currentPos, 0, titleView._frame[2], this._frame[3]]);
                        }
                        titleView._prevPos = new Vector(currentPos, 0);
                        indexedSectArray._startingPos = currentPos;
                        titleWidthHeight = titleView._frame[2];
                    }
                }
                else
                {
                    if (titleView.getFrame())
                    {
                        if (!indexedSectArray._isOnTop)
                        {
                            titleView.setFrame([0, currentPos, this._frame[2], titleView._frame[3]]);
                        }
                        titleView._prevPos = new Core.Vector(0, currentPos);
                        indexedSectArray._startingPos = currentPos;
                        titleWidthHeight = titleView._frame[3];
                    }
                }
                if (!indexedSectArray._isOnTop)
                {
                    this.addChild(titleView);
                }
                titleView.getGLObject().setDepth(1000);
            }
            currentPos += titleWidthHeight;
            for (j = 0; j < itemsArray.length; j++)
            {
                itemObject = itemsArray[j];
                this._completeItemsList.push(itemObject);
                var posVect = null;
                if (this._scroll === this.ScrollDirection.Horizontal)
                {
                    posVect = new Core.Vector(currentPos, 0);
                    itemObject._locationVector = posVect;
                    itemObject._scrollDirection = this._scroll;
                    itemObject._effectiveMeasure = this._frame[3];
                    if (indexedSectArray._rowHeightWidth > 0)
                    {
                        currentPos += indexedSectArray._rowHeightWidth;
                    }
                    else
                    {
                        currentPos += itemObject.getHeight();
                    }
                }
                else
                {
                    posVect = new Core.Vector(0, currentPos);
                    itemObject._locationVector = posVect;
                    itemObject._scrollDirection = this._scroll;
                    itemObject._effectiveMeasure = this._frame[2];
                    if (indexedSectArray._rowHeightWidth > 0)
                    {
                        currentPos += indexedSectArray._rowHeightWidth;
                    }
                    else
                    {
                        currentPos += itemObject.getHeight();
                    }
                }
            }
            indexedSectArray._endingPos = currentPos;
        }
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            this.setContentSize([currentPos - startingPos, this._frame[3]]);
        }
        else
        {
            this.setContentSize([this._frame[2], currentPos - startingPos]);
        }
        this._scrollbar.updateSize(this._scroll, this._myFrame, this._contentSize);
        this._evaluateMarginalLimits();
        this._updateListItems();
        this._updateSectionTitles();
    },
    /**
     * @private
     * @status  Android
     */
    _sortArray: function (arg1, arg2)
    {
        return (arg2._rowHeight - arg1._rowHeight);
    },
    /**
     * @private
     * @status  Android
     */
    _evaluateMarginalLimits: function ()
    {
        if (!this._frame || !this._completeItemsList)
        {
            return;
        }
        var lengthArray = this._completeItemsList.slice(0);
        lengthArray.sort(this._sortArray);
        var margin = 0;
        if (lengthArray.length >= 1)
        {
            margin = lengthArray[0]._rowHeight;
        }
        var origin = this._myFrame.getOrigin();
        var size = this._myFrame.getSize();
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            this._leftTopLimit = origin.getX() - (2 * margin);
            this._rightBottLimit = origin.getX() + size.getWidth() + (2 * margin);
        }
        else if (this._scroll === this.ScrollDirection.Vertical)
        {
            this._leftTopLimit = origin.getY() - (2 * margin);
            this._rightBottLimit = origin.getY() + size.getHeight() + (2 * margin);
        }
    },
    /**
     * @private
     * @status Android
     */
    _updateListItems: function ()
    {
        var i;
        if (!this._completeItemsList)
        {
            return;
        }
        for (i = 0; i < this._completeItemsList.length; i++)
        {
            var listItem = this._completeItemsList[i];
            if (this._isInsideScreen(listItem))
            {
                if (!listItem._glView)
                {
                    var reusableGLView = this._fetchFromReUsableArray(listItem);
                    if (reusableGLView)
                    {
                        listItem.__onSetView(reusableGLView);
                        this._addToVisibleViews(reusableGLView);
                        reusableGLView.setFrame([listItem._locationVector.getX(), listItem._locationVector.getY(), reusableGLView._frame[2], reusableGLView._frame[3]]);
                        reusableGLView.setVisible(true);
                        reusableGLView._listItem = listItem;
                        listItem._glView = reusableGLView;
                    }
                }
            }
            else
            {
                if (listItem._glView)
                {
                    this._removeFromVisibleViews(listItem._glView);
                    this._addToReUsableViewsArray(listItem._glView, listItem._reusableID);
                }
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToVisibleViews: function (glView)
    {
        var itemIndex = this._visibleArray.indexOf(glView);
        if (itemIndex === -1)
        {
            this._visibleArray.push(glView);
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _removeFromVisibleViews: function (glView)
    {
        var itemIndex = this._visibleArray.indexOf(glView);
        if (itemIndex !== -1)
        {
            this._visibleArray.splice(itemIndex, 1);
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _updateSectionTitles: function ()
    {
        if (!this._sectionsArray)
        {
            return;
        }
        var i = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            var indexedSection = this._sectionsArray[i];
            var titleView = indexedSection.getTitleView();
            if (titleView)
            {
                var titlePos = this._content.localToScreen(titleView._prevPos);
                var endPos = this._content.localToScreen(new Vector(0, indexedSection._endingPos - titleView._frame[3]));
                if (!titlePos || !endPos)
                {
                    return;
                }
                if (!indexedSection._isOnTop && Math.round(titlePos.getY()) < this._frame[1])
                {
                    this.removeChild(titleView);
                    titleView.getGLObject().setDepth(1000);
                    titleView.setFrame([0, 0, this._frame[2], titleView._frame[3]]);
                    this._internalGLObject.addChild(titleView.getGLObject());
                    indexedSection._isOnTop = true;
                }
                else if (indexedSection._isOnTop && Math.round(titlePos.getY()) > this._frame[1])
                {
                    indexedSection._isOnTop = false;
                    this._internalGLObject.removeChild(titleView.getGLObject());
                    this.addChild(titleView);
                    titleView.getGLObject().setDepth(1000);
                    titleView.setFrame([titleView._prevPos.getX(), titleView._prevPos.getY(), this._frame[2], titleView._frame[3]]);
                }
                if (indexedSection._isOnTop && (endPos.getY() > this._frame[1] - 150 && endPos.getY() < this._frame[1] + 100))
                {
                    var pos = this._internalGLObject.screenToLocal(endPos);
                    if (pos.getY() < -titleView._frame[3])
                    {
                        pos.setY(-titleView._frame[3]);
                    }
                    else if (pos.getY() > 0)
                    {
                        pos.setY(0);
                    }
                    titleView.setFrame([pos.getX(), pos.getY(), this._frame[2], titleView._frame[3]]);
                }
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _evaluateScrollDirection: function ()
    {
        this.setScrollDirection(this.ScrollDirection.Vertical);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _onUpdate: function ($super, delta)
    {
        var theRoot = null;
        if (this._isSetSection)
        {
            theRoot = this.getRoot();
        }
        if (theRoot && theRoot.type === "document")
        {
            this._evaluateItemPositions();
            this._isSetSection = false;
        }
        $super(delta);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _updateScrollingView: function ()
    {
        this._updateListItems();
        this._updateSectionTitles();
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _isInsideScreen: function (listItem)
    {
        var listItemPos = listItem._locationVector;
        var convertedPos = this._content.localToScreen(listItemPos);
        if (convertedPos === null || convertedPos === undefined)
        {
            return false;
        }
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            if (convertedPos.getX() > this._leftTopLimit && convertedPos.getX() < this._rightBottLimit)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            if (convertedPos.getY() > this._leftTopLimit && convertedPos.getY() < this._rightBottLimit)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToReUsableViewsArray: function (glView, index)
    {
        if (glView)
        {
            var requiredReusableArray = this._reusableViewsPool[index];
            requiredReusableArray.push(glView);
            glView.setVisible(false);
            glView._listItem._glView = null;
            glView._listItem = null;
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToViewsPool: function (view, index)
    {
        var viewsArray = this._viewsPool[index];
        if (!viewsArray)
        {
            this._viewsPool[index] = [];
            viewsArray = this._viewsPool[index];
        }
        viewsArray.push(view);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _fetchFromReUsableArray: function (listItem)
    {
        var i;
        var newReusableView = null;
        var requiredReusableArray = this._reusableViewsPool[listItem._reusableID];
        if (!requiredReusableArray)
        {
            this._reusableViewsPool[listItem._reusableID] = [];
            requiredReusableArray = this._reusableViewsPool[listItem._reusableID];
            newReusableView = listItem._onCreateView();
            newReusableView.getGLObject().setDepth(10);
            this.addChild(newReusableView);
            this._addToViewsPool(newReusableView, listItem._reusableID);
            return newReusableView;
        }
        if (requiredReusableArray.length > 0)
        {
            var returnView = requiredReusableArray.pop();
            returnView.setVisible(true);
            return returnView;
        }
        else
        {
            var viewsArray = this._viewsPool[listItem._reusableID];
            for (i = 0; i < viewsArray.length; i++)
            {
                var glView = viewsArray[i];
                var convertedPos = this._content.localToScreen(glView.getGLObject().getPosition().clone());
                if (convertedPos.getX() < this._leftTopLimit || convertedPos.getX() > this._rightBottLimit)
                {
                    this._addToReUsableViewsArray(glView, listItem._reusableID);
                }
            }
        }
        // check again if we have been able to round up some available views..
        if (this._reusableViewsArray && this._reusableViewsArray.length > 0)
        {
            return this._reusableViewsArray.pop();
        }
        else
        {
            newReusableView = listItem._onCreateView();
            newReusableView.getGLObject().setDepth(10);
            this.addChild(newReusableView);
            this._addToViewsPool(newReusableView, listItem._reusableID);
            return newReusableView;
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    destroy: function ()
    {
        var key;
        var j, i = 0;
        if (this._sectionsArray)
        {
            for (i = 0; i < this._sectionsArray.length; i++)
            {
                var indexedSection = this._sectionsArray[i];
                var titleView = indexedSection.getTitleView();
                if (titleView)
                {
                    titleView._prevPos = null;
                }
                indexedSection._parentListView = null;
                indexedSection._startingPos = null;
                indexedSection._endingPos = null;
            }
            this._sectionsArray = null;
        }
        if (this._completeItemsList)
        {
            for (i = 0; i < this._completeItemsList.length; i++)
            {
                this._completeItemsList[i]._locationVector = null;
                this._completeItemsList[i]._scrollDirection = 0;
                this._completeItemsList[i]._effectiveMeasure = 0;
                this._completeItemsList[i]._glView = null;
                this._completeItemsList[i]._rowHeight = 0;
            }
            this._completeItemsList.length = 0;
            this._completeItemsList = null;
        }
        if (this._viewsPool)
        {
            for (key in this._viewsPool)
            {
                if (this._viewsPool.hasOwnProperty(key))
                {
                    var individualArr = this._viewsPool[key];
                    for (j = 0; j < individualArr.length; j++)
                    {
                        individualArr[j]._listItem = null;
                        individualArr[j].destroy();
                    }
                }
            }
            this._viewsPool.length = 0;
            this._viewsPool = null;
        }
        if (this._reusableViewsPool)
        {
            this._reusableViewsPool.length = 0;
            this._reusableViewsPool = null;
        }
        this._isSetSection = null;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/ListViewSection'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/ListViewSection'] || {}; $MODULE_REGISTRY['NGGo/GLUI/ListViewSection'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/ListViewSection.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S.
 *  @co-author: Taha S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Element = require('NGGo/GLUI/Element').Element;
exports.ListViewSection = Element.subclass( /** @lends GLUI.ListViewSection.prototype */
{
    classname: 'ListViewSection',
    'type': 'listview-section',
    /**
     * @class The <code>ListViewSection</code> class constructs objects that contain <code>ListViewItem</code> objects. 
     * These objects are rendered as individual sections of a scrolling list (see <code>{@link GLUI.ListView}</code>).
     * @name GLUI.ListViewSection
     * @constructs
     * @augments GLUI.Element
     */
    initialize: function ()
    {
        this._items = [];
        this._rowHeightWidth = 0;
        this._titleView = null;
        this._parentListView = null;
    },
    /**
     * @name GLUI.ListViewSection#setItems
     * @description Set the value for the <code>items</code> property.
     * Setting this updates the visual state of the <code>listView</code> if the section is in a <code>listView</code> that is visible.
     * @param {UI.ListViewItem} items The new <code>ListView</code> items.
     * @see UI.ListViewSection#getItems
     * @status Android, Test
     * @function
     */
    setItems: function (items)
    {
        if (items instanceof Array)
        {
            this._items = items; //not creating a deep copy here.
            if (this._parentListView)
            {
                this._parentListView.reloadData();
                //this._updateHeight();     //this will not be called now, listView calls it.
            }
        }
        else
        {
            throw new Error(this.classname + ' setItems() expects an array, getting ' + items.type);
        }
    },
    /**
     * @name GLUI.ListViewSection#setRowHeight
     * @description Set the value for the <code>rowHeight</code> property.
     * @param {Number} rowHeight The new row height.
     * @see GLUI.ListViewSection#getRowHeight
     * @status Android, Test
     * @function
     */
    setRowHeight: function (height)
    {
        if (isNaN(height))
        {
            throw new Error('Expecting number value but found ' + typeof (height) + ' for setRowHeight(height)');
        }
        else if (height === 0)
        {
            throw new Error('Cannot set row height of section = 0');
        }
        else
        {
            this._rowHeightWidth = height;
            //this._updateHeight();     //this will not be called now, listView calls it.
        }
    },
    /**
     * @name GLUI.ListViewSection#getTitleView
     * @description 
     * @see GLUI.ListViewSection#setTitleView
     * @status Android, Test
     * @function
     */
    getTitleView: function ()
    {
        return this._titleView;
    },
    /**
     * @name GLUI.ListViewSection#setTitleView
     * @description Sets the object for <code>title</code> property.
     * @param {View} The GLUI.View object that is to be set as the Section Title View
     * @see GLUI.ListViewSection#getTitleView
     * @function
     */
    setTitleView: function (titleView)
    {
        this._titleView = titleView;
    },
    /**
     * @name GLUI.ListViewSection#setYPosition
     * @description Set the value for the <code>yPosition</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Number}  yPosition The new position for y.
     * @see GLUI.ListViewSection#getYPosition
     * @function
     */
    setYPosition: function ()
    {
        //to be implemented
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: setYPosition() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getYPosition
     * @description Retrieve the value of the <code>yPosition</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number} The current position of y.
     * @see GLUI.ListViewSection#setYPosition
     * @function
     */
    getYPosition: function ()
    {
        //to be implemented
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: getYPosition() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getItems
     * @description Retrieve the value of the <code>items</code> property.
     * @returns {GLUI.ListViewItem} The current <code>ListView</code> items.
     * @see UI.ListViewSection#setItems
     * @status Android, Test
     * @function
     */
    getItems: function ()
    {
        return this._items;
    },
    /**
     * @name GLUI.ListViewSection#getRowHeight
     * @description Retrieve the value of the <code>rowHeight</code> property.
     * @returns {Number} The current row height.
     * @see GLUI.ListViewSection#setRowHeight
     * @status Android, Test
     * @function
     */
    getRowHeight: function ()
    {
        return this._rowHeightWidth;
    },
    /**
     * @name GLUI.ListViewSection#flush
     * @description Reset the visible range for this <code>ListViewSection</code>.
     * @function
     * @status Android, Test
     */
    flush: function ()
    {
        if (this._parentListView)
        {
            this._parentListView._flushSection(this);
        }
    },
    /**
     * @private 
     * */
    destroy: function ()
    {
        this._items = null;
        this._rowHeightWidth = null;
        this._titleView = null;
        this._parentListView = null;
    },
    /**
     * @private 
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters['items'] = this.setItems.bind(this);
        this._setters['rowHeight'] = this.setRowHeight.bind(this);
        this._setters['titleView'] = this.setTitleView.bind(this);
    },
    /**
     * @private 
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters['items'] = this.getItems.bind(this);
        this._getters['rowHeight'] = this.getRowHeight.bind(this);
        this._getters['titleView'] = this.getTitleView.bind(this);
    },
    /**
     * @private 
     * */
    _updateHeight: function ()
    {
        var i = 0;
        if (this._items)
        {
            for (i = 0; i < this._items.length; i++)
            {
                this._items[i]._setRowHeight(this._rowHeightWidth);
            }
        }
    },
    ////////// Empty Functions //////////////
    /**
     * @name GLUI.ListViewSection#setTitle
     * @description Set the value for the <code>title</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {String} title The new section title.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state. 
     * @see GLUI.ListViewSection#getTitle
     * @function
     */
    setTitle: function ()
    {
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: setTitle() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getTitle
     * @description Retrieve the value of the <code>title</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current section title.
     * @see GLUI.ListViewSection#setTitle
     * @function
     */
    getTitle: function ()
    {
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: getTitle() ' + this.classname);
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/ListViewItem'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/ListViewItem'] || {}; $MODULE_REGISTRY['NGGo/GLUI/ListViewItem'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/ListViewItem.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Taha S.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Class = require('NGCore/Client/Core/Class').Class;
var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
exports.ListViewItem = Class.subclass( /** @lends GLUI.ListViewItem.prototype */
{
    classname: 'ListViewItem',
    /**
     * @class The <code>ListViewItem</code> class constructs objects that contain data for individual items in a scrolling list (see <code>{@link GLUI.ListView}</code>).
     * @name GLUI.ListViewItem
     * @constructs The default constructor.
     * @augments Core.Class
     */
    _setters: [],
    _getters: [],
    initialize: function (reusableID)
    {
        if (reusableID === undefined)
        {
            this._reusableID = "rid";
        }
        else if (reusableID === "rid")
        {
            throw new Error("Trying to assign reserved ID \"rid\" as Reuse ID");
        }
        else
        {
            this._reusableID = reusableID;
        }
        this._onSetViewCallBack = null;
        this._scrollDirection = 0;
        this._effectiveMeasure = 0;
        this._rowHeight = 0;
        this._heightWidth = 0;
        this._glView = null;
        this._registerSetters();
        this._registerGetters();
        return this;
    },
    /**
     * @name GLUI.ListViewItem#setOnCreateView
     * @description Set the callback for the <code>onCreateView</code> event.
     * This event must return a newly created view that displays the data type represented by the item.
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnCreateView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onCreateView = newFn;
        }
    },
    /**
     * @name GLUI.ListViewItem#setOnReleaseView
     * @description Set the callback for the <code>onReleaseView</code> event. This event occurs when the view is set to <code>null</code>.
     * Use this to remove uncommon view states or clean up the view when necessary.
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnReleaseView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onReleaseView = newFn;
        }
    },
    /**
     * @name GLUI.ListViewItem#setOnSetView
     * @description Set the callback for the <code>onSetView</code> event. When this event occurs, the item puts any relevant visual state / data into <code>newView</code>.
     * This transfer should occur before the item is visible to the user:
     * <pre class="code">onSetView(newView)</pre>
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnSetView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onSetView = newFn;
        }
    },
    /**
     * @private
     * @status Android
     */
    getOnCreateView: function ()
    {
        return this._onCreateView;
    },
    /**
     * @private
     * @status Android
     */
    getOnReleaseView: function ()
    {
        return this._onReleaseView;
    },
    /**
     * @private
     * @status Android
     */
    getOnSetView: function ()
    {
        return this._onSetViewCallBack;
    },
    /**
     * @name GLUI.ListViewItem#getHeight
     * @description Get the current height of the ListViewItem.
     * <pre class="code">getHeight()</pre>
     * This should occur before the item is visible to the user.
     * @returns {Number} The height of this ListViewItem.
     * @function
     * @status Android, Test
     */
    getHeight: function ()
    {
        return this._heightWidth;
    },
    /**
     * @name GLUI.ListViewItem#setHeight
     * @description Set the height of the current ListViewItem in pixels.
     * <pre class="code">setHeight(Number)</pre>
     * This should occur before the item is visible to the user.
     * This setting is only used when the item's ListViewSection has height = -1
     * @param {Number} height The height of the current ListViewItem in pixels.
     * @function
     * @status Android, Test
     */
    setHeight: function (height)
    {
        if (isNaN(height))
        {
            throw new Error('Expecting number value but found ' + typeof (height) + ' for setHeight(height)');
        }
        else if (height === 0)
        {
            throw new Error('Cannot set height of item = 0');
        }
        else
        {
            if (height > 0)
            {
                this._heightWidth = height;
            }
        }
    },
    /**
     * @name GLUI.ListViewItem#getCurrentView
     * @description Retrieve the current view attached to this <code>ListViewItem</code>.
     * @returns {GLUI.View} The current <code>ListViewItem</code> view.
     * @function
     * @status Android, Test
     */
    getCurrentView: function ()
    {
        return this._glView;
    },
    destroy: function ()
    {
        this._scrollDirection = null;
        this._effectiveMeasure = null;
        this._rowHeight = null;
        this._reusableID = null;
        this._glView = null;
        this._heightWidth = null;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _registerSetters: function ()
    {
        this._setters.onCreateView = this.setOnCreateView.bind(this);
        this._setters.onReleaseView = this.setOnReleaseView.bind(this);
        this._setters.onSetView = this.setOnSetView.bind(this);
        this._setters.height = this.setHeight.bind(this);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _registerGetters: function ()
    {
        this._getters.onCreateView = this.getOnCreateView.bind(this);
        this._getters.onReleaseView = this.getOnReleaseView.bind(this);
        this._getters.onSetView = this.getOnSetView.bind(this);
        this._getters.height = this.getHeight.bind(this);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _onCreateView: function ()
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    _onSetView: function ()
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    __onSetView: function (newView)
    {
        if (this._rowHeight === 0)
        {
            throw new Error('Missing Row Height of Section');
        }
        if (newView && newView instanceof AbstractView)
        {
            var width = 0;
            var height = 0;
            if (this._scrollDirection === 1)
            {
                height = this._effectiveMeasure;
                width = this._rowHeight;
            }
            else
            {
                width = this._effectiveMeasure;
                height = this._rowHeight;
            }
            newView.setFrame([0, 0, width, height]);
        }
        this._glView = newView;
        this._onSetView(newView);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _onReleaseView: function (oldView)
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    _setRowHeight: function (rowHeight)
    {
        if (rowHeight < 0)
        {
            this._rowHeight = this._heightWidth;
        }
        else
        {
            this._rowHeight = rowHeight;
        }
    },
    /**
     * @function
     * @private
     * @status Android
     */
    setAttributes: function (dict)
    {
        var key;
        for (key in dict)
        {
            if (dict.hasOwnProperty(key))
            {
                this.setAttribute(key, dict[key]);
            }
        }
        return this;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    getAttributes: function (list)
    {
        var i, accessor;
        var output = {};
        if (list instanceof Array)
        {
            for (i = 0; i < list.length; i++)
            {
                var key = list[i];
                var methodName = this._getters[key];
                if (typeof methodName === 'function')
                {
                    output[key] = this._getters[key](this);
                }
            }
        }
        else
        {
            for (accessor in this._getters)
            {
                if (this._getters.hasOwnProperty(accessor))
                {
                    output[accessor] = this._getters[accessor](this);
                }
            }
        }
        return output;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    getAttribute: function (key)
    {
        var getter = this._getters[key];
        if (typeof getter === 'function')
        {
            return getter(this, key);
        }
        else
        {
            console.log("Getter for '" + key + "' not found for " + this.classname);
            return undefined;
        }
    },
    /**
     * @function
     * @private
     * @status Android
     */
    setAttribute: function (key, value)
    {
        var myFunction = this._setters[key];
        if (myFunction)
        {
            myFunction(this, value);
        }
        else
        {
            console.log("Setter for '" + key + "' not found for " + this.classname);
        }
        return this;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Spinner'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Spinner'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Spinner'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Spinner.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil M.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Node = require('NGCore/Client/GL2/Node').Node;
var AbstractView = require('NGGo/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo/GLUI/Commands').Commands;
var Sprite = require('NGGo/GLUI/Sprite').URLSprite;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;

exports.Spinner = AbstractView.subclass(
{
    classname: 'Spinner',
    initialize: function ($super, properties)
    {
        $super();
        this._internalGLObject = new Sprite();
        this._internalGLObject.setScale(1, 1);
        this._imageSpriteSize = [32, 32];
        this._imageURL = null;
        this._fitMode = Commands.FitMode.Stretch;
        this._anchor = [0.5, 0.5];

        if(properties)
        {
            if(properties.hasOwnProperty('imageURL'))
            {
                this._imageURL = properties.imageURL;
            }

            this.setAttributes(properties);
        }

        if(this._imageURL)
        {
            this.setImage(this._imageURL);
            this._setImageFit();
        }

        this._angle = 30;
        this._flag = 0;
        this._listener = new Core.MessageListener();
        UpdateEmitter.addListener(this._listener, this._onUpdate.bind(this));

        return this;
    },

    setFrame: function ($super, frame)
    {
        $super(frame);
        if (this._imageSpriteSize)
        {
            this._setImageFit();
        }
        this._updateView();
    },

    setImage: function (imageURL) //size is imageSize
    {
        var errorMsg;
        if (!imageURL || typeof imageURL !== 'string')
        {
            errorMsg = "Image URL is not correct in " + this.classname + "setImage Method";
            throw new Error(errorMsg);
        }

        try
        {
            this._images[Commands.State.Normal + ''] = [imageURL, this._imageSpriteSize];
            this._updateView();
        }
        catch (exception)
        {
            errorMsg = [];
            errorMsg.push("Exception: setImage()");
            errorMsg.push(exception);
            errorMsg.push(this.classname);
            errorMsg.join();

            throw new Error(errorMsg);
        }
        return this;
    },

    _setImageFit: function ()
    {
        this._fitMode = Commands.FitMode.Stretch;
        var glObject = this._internalGLObject;
        glObject.setScale(1, 1);

        glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor);

        var glPosition = this._getInternalGLObjectPosition();

        var posX = glPosition.getX();
        var posY = glPosition.getY();

        glObject.setPosition([posX, posY]);
        return this;
    },

    _updateView: function ()
    {

        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if (!this._frame || (this._frame && this._frame.length < 4))
        {
            this._frame = [0, 0, 0, 0];
        }

        if (!this._images[Commands.State.Normal + ''] || !this._frame[2] || !this._frame[3])
        {
            return;
        }

        var nextState = (this._state)?this._state:Commands.State.Normal;

        var nextImage = this._images[nextState + ''];
        if (!nextImage || nextImage.length === 0)
        {
            nextImage = this._images[Commands.State.Normal + ''];
        }

        if (nextImage !== null)
        {
            this._imageURL = nextImage[0];
            this._imageSpriteSize = nextImage[1];
            this._setImageFit();
        }
    },

    _onUpdate: function ()
    {
        if(this._flag === 0)
        {
            this._internalGLObject.setRotation(this._angle);
            this._angle = (this._angle + 30)%360;
        }
        this._flag = (this._flag+1)%4;
    },

    destroy: function ($super)
    {
        UpdateEmitter.removeListener(this._listener);
        this._listener.destroy();
        this._imageSpriteSize.length = 0;
        this._imageSpriteSize = null;
        this._imageURL = null;
        $super();
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/Window'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/Window'] || {}; $MODULE_REGISTRY['NGGo/GLUI/Window'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/Window.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno T.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class           = require('NGCore/Client/Core/Class').Class;
var Capabilities    = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UICommands      = require('NGCore/Client/UI/Commands').Commands;
var LayoutEmitter   = require('NGCore/Client/Device/LayoutEmitter').LayoutEmitter;
var Device          = require('NGCore/Client/Device').Device;
var Root            = require('NGCore/Client/GL2/Root').Root;
var Rect            = require('NGGo/GLUI/ViewGeometry').Rect;
var Commands        = require('NGGo/GLUI/Commands').Commands;
var WindowLayer     = require('NGGo/GLUI/WindowLayer').WindowLayer;

var Window = Class.singleton( /** @lends GLUI.Window.prototype */
{
    classname: 'Window',
    _outerWidth: 0,
    _outerHeight: 0,
    _width: 0,
    _height: 0,

    /**
     * @class The <code>Window</code> class constructs a singleton object that manages application access to GLUI.<br><br>
     * <b>Note:</b> An application should never directly allocate a singleton.
     * @name GLUI.Window
     * @augments Core.Class
     * @see GLUI.Window#document
     * @constructs The default constructor.
     */
    initialize: function ()
    {
        if (!this._outerWidth || !this._outerHeight)
        {
            this.setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
        }
        if (!this._width || !this._height)
        {
            this._setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
        }
        Commands.instantiate();
        var LayoutListener = MessageListener.subclass(
        {
            initialize: function ()
            {
                Device.LayoutEmitter.addListener(this, this.onUpdate);
            },
            onUpdate: function (layout)
            {
                Window._setWidthAndHeight(layout.width, layout.height);
            }
        });
        var layout = null;
        layout = new LayoutListener();

    },

    setStatusBarHidden: function (value)
    {
        UICommands.setStatusBarHidden(value);
        this._outerHeight = Capabilities.getScreenHeight() - (value ? 0 : (Capabilities.getStatusBarHeight() || 0));
    },
    log: function (object)
    {
        console.log(object.toString());
    },
    /**
     * Return the available screen width, with respect to orientation and system status bars.
     * @returns {Number} The currently available width in pixels that can be drawn to.
     * @type Number
     * @status Android, Flash
     */
    getWidth: function ()
    {
        return this._width;
    },
    /**
     * Return the available screen height, with respect to orientation and system status bars.
     * @returns {Number} The currently available height in pixels that can be drawn to.
     * @type Number
     * @status Android, Flash
     */
    getHeight: function ()
    {
        return this._height;
    },
    getOuterWidth: function ()
    {
        return this._outerWidth;
    },
    getOuterHeight: function ()
    {
        return this._outerHeight;
    },
    getFrame: function ()
    {
        return new Rect(0, 0, this._width, this._height);
    },
    destroy: function ()
    {},
    document: WindowLayer.singleton(
    {
        'type': 'document',
        'classname': 'WindowLayer'
    }),
    _layers: {},
    _getLayer: function (level)
    {
        if( !this._layers[level] )
        {
            this._layers[level] = new WindowLayer(
        {
            'level': level || 0
                });
        }
        return this._layers[level];
    }
});

Window.__defineGetter__("outerWidth", function ()
{
    return this.getOuterWidth();
});
Window.__defineGetter__("outerHeight", function ()
{
    return this.getOuterHeight();
});
Window._setWidthAndHeight = function (width, height)
{
    this._width = width;
    this._height = height;
};
Window.setWidthAndHeight = function (width, height)
{
    this._outerWidth = width;
    this._outerHeight = height;
};

exports.Window = Window;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/NavController'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/NavController'] || {}; $MODULE_REGISTRY['NGGo/GLUI/NavController'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/NavController.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Awais M.
 *  @co-author: Harris K.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Core = require("NGCore/Client/Core").Core;
var KeyEmitter = require("NGCore/Client/Device/KeyEmitter").KeyEmitter;
var Device = require("NGCore/Client/Device").Device;
var Capabilities = require("NGCore/Client/Core/Capabilities").Capabilities;
var View = require("NGGo/GLUI/View").View;
var Button = require("NGGo/GLUI/Button").Button;
var Window = require("NGGo/GLUI/Window").Window;
var GL2 = require("NGCore/Client/GL2").GL2; /** @private */

function getAnalyticsName(item)
{
    if (item && item.hasOwnProperty("analyticsName"))
    {
        return item.analyticsName || undefined; // If NULL, return undefined.
    }
    return undefined;
} /** @private */
var NavKeyListener = Core.MessageListener.subclass(
{
    classname: "GLUI_NavController_KeyListener"
});
var MovingAnimation = Core.MessageListener.subclass(
{
    classname: 'MovingAnimation',
    /** @private */
    initialize: function ()
    {},
    startAnimate: function (spriteNode, destination, duration, rem, callBackFunc)
    {
        this._callBackFunc = callBackFunc;
        this._rem = rem;
        this._initialPosition = spriteNode.getPosition();
        this._spriteNode = spriteNode;
        this._destination = destination;
        Core.UpdateEmitter.addListener(this, this._setPosition);
        var deltaVector = new Core.Vector();
        deltaVector.setX(this._destination.getX() - this._initialPosition.getX());
        deltaVector.setY(this._destination.getY() - this._initialPosition.getY());
        this._deltaVector = deltaVector;
        var now = Core.Time.getFrameTime();
        this._mStartTime = now;
        this._mStopTime = now + duration;
        this._mDuration = duration;
    },
    /** @private */
    _setPosition: function (delta)
    {
        var now = Core.Time.getFrameTime();
        if (now > this._mStopTime)
        {
            this._spriteNode.setPosition(this._destination.getX(), this._destination.getY());
            if (this._rem)
            {
                if (typeof this._callBackFunc === 'function')
                {
                    this._callBackFunc();
                }
                Core.UpdateEmitter.removeListener(this, this._setPosition);
                this.destroy();
            }
        }
        else
        {
            var slice = delta / this._mDuration;
            var newLocation = new Core.Vector();
            newLocation.setX(this._initialPosition.getX() + (this._deltaVector.getX() * slice));
            newLocation.setY(this._initialPosition.getY() + this._deltaVector.getY() * slice);
            this._spriteNode.setPosition(newLocation.getX(), newLocation.getY());
        }
    },
    /** @private */
    destroy: function ($super)
    {
        $super();
    }
});
exports.NavController = View.subclass( /** @lends GLUI.NavController.prototype */
{
    classname: 'NavController',
    /**
     * @class The <code>NavController</code> class constructs objects that define application navigation components.
     * @constructs The default constructor.
     * @augments Core.Class
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     */
    initialize: function ($super, properties)
    {
        $super(properties);
        this.navStack = [];
        var isAndroid = Capabilities.getPlatformOS() === 'Android';
        if (isAndroid)
        {
            //If it is an android device, do not use graphical Back button.
            this._useGraphicalBackButton = false;
            //Instead add a listener for Device Back button.
            this.keyListener = new NavKeyListener();
            KeyEmitter.addListener(this.keyListener, this.onKeyPressed.bind(this));
        }
        else
        {
            this._useGraphicalBackButton = true;
        }
        this._nodeForMovement = null;
        this._previousView = null;
        this._backButton = null;
        this._mAnimation = null;
    },
    /**
     * Turn on the onscreen <b>Back</b> button. Applications designed for iOS should always provide the <b>Back</b> button
     * and integrate it into the application UI (calling <code>{@link GLUI.NavController#back}</code> when pressed).<br><br>
     * <b>Note:</b> This is turned off by default for applcations designed for Android because Android devices contain a hardware <b>Back</b> button.
     * @param {Boolean} shallUse Set as <code>true</code> to enable the onscreen <b>Back</b> button.
     * @function
     * @status Javascript, Android, Flash
     */
    setUseBackButton: function (shallUse)
    {
        this._useGraphicalBackButton = (shallUse) ? true : false;
        if (shallUse)
        {
            this._createBackButton();
        }
        else
        {
            if (this._backButton)
            {
                this._backButton.removeFromParent();
            }
        }
    },
    /**
     * Reset the stack for this <code>NavController</code>.
     * @param {String} fromButton The button to reset.
     * @status Javascript, Android, Flash
     */
    clear: function (fromButton)
    {
        return this.backToView(undefined);
    },
    /**
     * @private
     * @status Javascript, Android, Flash, Test
     */
    logNavEvent: function (from, to, via)
    {
        var toName = getAnalyticsName(to);
        var fromName = getAnalyticsName(from);
        var viaName = getAnalyticsName(via);
        if (fromName || toName)
        {
            Core.Analytics._getPipe().navigationEvent(fromName, toName, viaName);
        }
    },
    /**
     * Retrieve the top view from the nav stack of this <code>NavController</code>.
     * @returns {Object} The top view in the nav stack
     * @status Javascript, Android, Flash
     * @function
     */
    getTopView: function ()
    {
        //for stack implementation, the last item is at the top of the stack, so we are accessing the last index of the navStack
        return (this.navStack.length > 0) ? this.navStack[(this.navStack.length - 1)] : undefined;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    navStackDepth: function ()
    {
        return this.navStack.length;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    depthOfView: function (targetView)
    {
        //private method, so there is no need to check targetView type here.
        var targetIndex = this.navStack.indexOf(targetView);
        if (targetIndex === -1)
        {
            return -1;
        }
        return this.navStack.length - targetIndex - 1;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    viewAtDepth: function (targetDepth)
    {
        if (targetDepth >= this.navStack.length)
        {
            return null;
        }
        return this.navStack[this.navStack.length - targetDepth - 1];
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    removeDeepView: function (targetView)
    {
        var targetIndex = this.navStack.indexOf(targetView);
        if (targetIndex === -1)
        {
            console.log("NavController: trying to remove a nonexistent view from the nav stack!");
            return;
        }
        this.navStack.splice(targetIndex, 1);
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     * @function
     */
    _viewTransition: function (fromView, toView, back, buttonRef)
    {
        var myFrame = this.getFrame();
        var w = myFrame[2];
        var h = myFrame[3];
        if (this._nodeForMovement === null)
        {
            this._nodeForMovement = new GL2.Node();
        }
        else
        {
            this._nodeForMovement.destroy();
            this._nodeForMovement = new GL2.Node();
        }
        this._internalGLObject.addChild(this._nodeForMovement);
        if (fromView)
        {
            fromView.setFrame([0, 0, w, h]);
            this._previousView = fromView;
            this._nodeForMovement.addChild(fromView.getGLObject());
        }
        if (toView)
        {
            toView.setFrame([(back ? -w : w), 0, w, h]);
            this._nodeForMovement.addChild(toView.getGLObject());
        }
        if (this._mAnimation !== null)
        {
            this._mAnimation.destroy();
            this._mAnimation = null;
        }
        if (this._mAnimation === null)
        {
            this._mAnimation = new MovingAnimation();
            this._mAnimation.startAnimate(this._nodeForMovement, (new Core.Vector((back ? w : -w), 0)), 350, true, this._transComplete.bind(this));
        }
        this.logNavEvent(fromView, toView, buttonRef);
        this._createBackButton();
    },
    _transComplete: function ()
    {
        if (this._previousView !== null)
        {
            this._previousView.removeFromParent();
        }
    },
    /**
     * Retrieve removed views in the reverse order they were removed.
     * @example var page = new NavPage({...});
     *
     * var controller = new GLUI.NavController({...});
     *
     * NavPage.navController = controller;
     * controller.forwardToView(page);
     * @param {String} destView The destination view for this navigation component.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript,, Android, Flash
     * @see GLUI.NavController#backToView
     */
    forwardToView: function (destView, fromButton)
    {
        var currentView = this.getTopView();
        if (destView && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPush === "function" && this._delegate.navControllerShouldPush(this, destView))))
        {
            this.navStack.push(destView);
            this._viewTransition(currentView, destView, false, fromButton);
        }
    },
    /**
     * Set back navigation for this <code>NavController</code>.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript, Android, Flash
     * @see GLUI.NavController#forward
     */
    back: function (fromButton)
    {
        var removed = this.navStack.pop();
        if (!(removed && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPop === "function" && this._delegate.navControllerShouldPop(this, removed)))))
        {
            return null;
        }
        this._viewTransition(removed, this.getTopView(), true, fromButton);
        return removed;
    },
    /**
     * Retrieve removed views in the order they were removed.
     * @example var page = new NavPage({...});
     *
     * var controller = new GLUI.NavController({...});
     *
     * NavPage.navController = controller;
     * controller.backToView(page);
     * @param {String} destView The destination view for this navigation component.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript, Android, Flash
     * @see GLUI.NavController#forwardToView
     */
    backToView: function (destView, fromButton)
    {
        var removedSet = [];
        var removed = this.navStack.pop();
        var originalView = removed;
        if (removed)
        {
            do
            {
                if (removed && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPop === "function" && this._delegate.navControllerShouldPop(this, removed))))
                {
                    removedSet.push(removed);
                }
                else
                {
                    break;
                }
                if (this.getTopView() === destView)
                {
                    break;
                }
                removed = this.navStack.pop();
            } while (removed);
        }
        if (removedSet.length > 0)
        {
            this._viewTransition(originalView, this.getTopView(), true, fromButton);
        }
        return removedSet;
    },
    /**
     * Set this <code>NavController</code> to launch the application when activated.
     * @status Javascript, Android, Flash
     */
    loadApp: function ()
    {},
    /**
     * @private
     * @status Javascript, iOS, Flash
     */
    onBackPressed: function ()
    {
        if (this.navStack.length > 1)
        {
            var analyticsName = "bcksbtn"; // Back System Button
            // if the topmost view has an analytics name, prefix the button
            var topView = this.getTopView();
            if (topView.analyticsName)
            {
                analyticsName = topView.analyticsName + "." + analyticsName;
            }
            this.back(
            {
                analyticsName: analyticsName
            });
            return true;
        }
        return false;
    },
    /**
     * @private
     * @status Javascript, Android
     */
    onKeyPressed: function (event)
    {
        //captures back key press on Android Devices
        if ((event.code === Device.KeyEmitter.Keycode.back) && (this.navStack.length > 1))
        {
            this.back();
            return true;
        }
        return false;
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     */
    _delegate: null,
    /**
     * @description Set subscribers to the <code>NavController</code> behavior. Subscribers can modify what happens.
     * NavControllerDelegateProtocol:
     *  @optional - (BOOL)navControllerShouldPop(NavController,View)
     *  @optional - (BOOL)navControllerShouldPush(NavController,View)
     * @param {String} navDelegate A <code>NavController</code> subscriber.
     * @private
     * @status Javascript, Android, Flash
     */
    setDelegate: function ( /*NavControllerDelegate*/ navDelegate)
    {
        if (navDelegate.hasOwnProperty('navControllerShouldPop') && navDelegate.hasOwnProperty('navControllerShouldPush') && typeof navDelegate.navControllerShouldPop === 'function' && typeof navDelegate.navControllerShouldPush === 'function')
        {
            this._delegate = navDelegate;
        }
        else
        {
            console.log("<NGGo> WARNING : delegate does not implement the required protocol. Error in Method setDelegate " + this.classname);
            this._delegate = null;
        }
    },
    delegate: function ()
    {
        return this._delegate;
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     * @function
     */
    _createBackButton: function ()
    {
        // Do nothing if this device does not require_ an onscreen button.
        if (this._useGraphicalBackButton === false)
        {
            return;
        }
        if (!this._backButton)
        {
            this._backButton = new Button(
            {
                normalText: 'Back',
                textSize: 18.0,
                textColor: "FF",
                normalTextShadow: "00 1.5",
                frame: [-2, 20, Window.outerWidth / 5, Window.outerHeight / 12]
            });
            this._backButton.setBackgroundColor("8B8386");
            this._backButton.Controller = this;
            this._backButton.setOnClick(function ()
            {
                this.Controller.onBackPressed();
            });
        }
        if (this.navStack.length > 1)
        {
            if (!this._backButton.getParent())
            {
                Window.document.addChild(this._backButton);
            }
        }
        else if (this._backButton.getParent())
        {
            this._backButton.removeFromParent();
        }
    },
    /** @private */
    destroy: function ($super)
    {
        $super();
        if (this._nodeForMovement)
        {
            this._nodeForMovement.destroy();
            this._nodeForMovement = null;
        }
        if (this._backButton)
        {
            this._backButton.destroy();
            this._backButton = null;
        }
        if (this._mAnimation)
        {
            this._mAnimation.destroy();
            this._mAnimation = null;
        }
        this.delegate = null;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI/NGWindow'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI/NGWindow'] || {}; $MODULE_REGISTRY['NGGo/GLUI/NGWindow'] = exports; 
var __dirname = 'NGGo/GLUI';
var __filename = 'NGGo/GLUI/NGWindow.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil M.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/*
 *  GLUI.NGWindow  __deprecated__
 *
 *  use the following:
 *
 *  GLUI.Window.document
 *
 */

var Window = require('NGGo/GLUI/Window').Window;
exports.NGWindow = Window.document;; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/GLUI'] = function(){var exports = $MODULE_REGISTRY['NGGo/GLUI'] || {}; $MODULE_REGISTRY['NGGo/GLUI'] = exports; 
var __dirname = 'NGGo';
var __filename = 'NGGo/GLUI.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:	Muzammil Mahmood
 *  Website:	https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Commands	 = require("NGGo/GLUI/Commands").Commands;
var ViewGeometry = require("NGGo/GLUI/ViewGeometry");

/**
 * <p>Classes and objects contained by the GLUI module.</p>
 * @name GLUI
 * @namespace
 * @description <p>The GLUI module is a collection of classes that control user interface components using GL2.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link GLUI.AbstractView}</code>A base class object for constructing other UI objects.</li>
 * <li><code>{@link GLUI.CellView}</code>: Construct <code>CellView</code> objects.</li>
 * <li><code>{@link GLUI.CheckBox}</code>: Construct objects that are used as checkboxes in an application.</li>
 * <li><code>{@link GLUI.Element}</code>: A base class object for constructing other UI objects.</li>
 * <li><code>{@link GLUI.Image}</code>: Constructs objects that control the location and size of images used in the user interface.</li>
 * <li><code>{@link GLUI.Label}</code>: Constructs objects that control the look and feel of application labels.</li>
 * <li><code>{@link GLUI.ListView}</code>: Construct <code>ListView</code> objects.</li>
 * <li><code>{@link GLUI.ListViewItem}</code>: Construct <code>ListViewItem</code> objects.</li>
 * <li><code>{@link GLUI.ListViewSection}</code>: Construct <code>ListViewSection</code> objects.</li>
 * <li><code>{@link GLUI.ScrollView}</code>: Construct <code>ScrollView</code> objects.</li>
 * <li><code>{@link GLUI.View}</code>: Construct objects that control the look and feel of the application view state.</li>
 * <li><code>{@link GLUI.ViewGeometry.Rect}</code>: Construct rectangle objects for use as positionable elements in the user interface.</li>
 * <li><code>{@link GLUI.ViewGeometry.Scale}</code>: Construct objects that handle view geometry for different scales of measurement.</li>
 * <li><code>{@link GLUI.Commands.FontLocation}</code>: Font location for GLUI objects.</li>
 * <li><code>{@link GLUI.Commands.FontStyle}</code>: Font Styles for GLUI  Objects.</li>
 * <li><code>{@link GLUI.Commands.State}</code>: Object States for GLUI Objects.</li>
 * <li><code>{@link GLUI.Commands.FitMode}</code>: Image Fit Modes for GLUI Objects.</li>
 * <li><code>{@link GLUI.Window}</code>: Construct application window objects.</li>
 * </ul>
 */


exports.GLUI =
{

    //Modules
    View                : require('NGGo/GLUI/View').View,
    Image               : require('NGGo/GLUI/Image').Image,
    Label               : require('NGGo/GLUI/Label').Label,
    Button              : require('NGGo/GLUI/Button').Button,
    CheckBox            : require('NGGo/GLUI/CheckBox').CheckBox,
    CellView			: require('NGGo/GLUI/CellView').CellView,
    ScrollView			: require('NGGo/GLUI/ScrollView').ScrollView,
    ListView			: require('NGGo/GLUI/ListView').ListView,
    ListViewSection		: require('NGGo/GLUI/ListViewSection').ListViewSection,
    ListViewItem		: require('NGGo/GLUI/ListViewItem').ListViewItem,
    Spinner             : require('NGGo/GLUI/Spinner').Spinner,
    NavController	: require('NGGo/GLUI/NavController').NavController,


	//Application Window and Document
	Window		: require('NGGo/GLUI/Window').Window,
	WindowLayer	: require('NGGo/GLUI/WindowLayer').WindowLayer,

	//Utils Files
	Commands	: Commands,
	FontLocation: Commands.FontLocation,
	FontStyle	: Commands.FontStyle,
	State	: Commands.State,
	FitMode	: Commands.FitMode,
	ViewGeometry: ViewGeometry,
	Scale	: ViewGeometry.Scale,

	//__Deprecated Modules__
	/**
	 * @deprecated now Replaced by {@link GLUI.Window.document}.
	 * @Note: use GLUI.Window.document.METHOD() now.
	 */
	NGWindow	: require('NGGo/GLUI/NGWindow').NGWindow  /* __deprecated__  use GLUI.Window.document instead */
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/GUIBuilder'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/GUIBuilder'] || {}; $MODULE_REGISTRY['NGGo/Framework/GUIBuilder'] = exports; 
var __dirname = 'NGGo/Framework';
var __filename = 'NGGo/Framework/GUIBuilder.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Harris Khurram
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

// ngCore
var Class              = require('NGCore/Client/Core/Class').Class;
var GL2                = require('NGCore/Client/GL2').GL2;
var GLUI               = require('NGGo/GLUI').GLUI;
var State              = require('NGCore/Client/UI').UI.State;
var Capabilities       = require('NGCore/Client/Core/Capabilities').Capabilities;
var FileSystem         = require('NGCore/Client/Storage/FileSystem').FileSystem;
var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;

// ngGo
var ServerSync         = require('NGGo/Service/Data/ServerSync').ServerSync;

exports.GUIBuilder = ServerSync.singleton(
/** @lends Framework.GUIBuilder.prototype */
{
    classname: 'GUIBuilder',
    /**
     * @class The <code>Builde</code> class is a Singleton class for
     * craeting GLUI and GL2 element against json.
     * @constructs The default constructor.
     * @status Android, Flash
     */
    initialize: function()
    {
        this._basePath = "";
        this._defaultAnchor = [0, 0];
        this._defaultUVs = [0, 0, 1, 1];
        this._defaultDepth = 20000;
        this._defaultFont = 'Arial';
        this._defaultSize = [128, 128];
        this._defaultFontLocation = GL2.Text.FontLocation.Default;
        this._userDefinedTypes = [];
    },
    /**
     * Creates the components from JSON string or JS object.
     * @name Framework.GUIBuilder#loadConfigFromData
     * @example var controller = {};
     * Framework.GUIBuilder.loadConfigFromData(aJSONDef, controller);
     * @param {String} jsonData The JSON format to extract GLUI and Gl2 component.
     * @param {Object} controller The object to store all nodes.
     * @status Android, Test
     * @function
     */
    /**
     * Takes JSON file or URI for JSON to iterarate the component and store all nodes in controller.
     * @name Framework.GUIBuilder#loadConfigFromFile
     * @example var controller = {};
     * Framework.GUIBuilder.loadConfigFromFile("./Content/infowindow.json", controller, function(error, data) {
     *
     * });
     * @param {String} jsonData The JSON format to extract GLUI and Gl2 component.
     * @param {Object} controller The object to store all nodes.
     * @status Android, Test
     * @function
     */
    /**
     * Gets the base path for images.
     * @returns {String} Base path
     */
    get basePath()
    {
        return this._basePath;
    },
    /**
     * Sets the base path for images.
     * Default value of this parameter is <code>""</code>.
     * @param {String} basePath Image base path
     */
    set basePath(value)
    {
        this._basePath = value;
    },
    /**
     * Gets the default anchor for images
     * @returns {Number[]} Default anchor
     */
    get defaultAnchor()
    {
        return this._defaultAnchor.slice();
    },
    /**
     * Sets the default anchor for images.
     * Default value of this parameter is <code>[0, 0]</code>.
     * @param {Number[]} anchor Default anchor.
     */
    set defaultAnchor(value)
    {
        this._defaultAnchor = value;
    },
    /**
     * Gets the default font for text.
     * @returns {String} Default anchor
     */
    get defaultFont()
    {
        return this._defaultFont;
    },
    /**
     * Sets the default font for text.
     * Default value of this parameter is <code>'Arial'</code>.
     * @param {String} font Default font.
     */
    set defaultFont(value)
    {
        this._defaultFont = value;
    },
    /**
     * Gets the default font location for text.
     * @returns {GL2.Text.FontLocatio} Default font location
     */
    get defaultFontLocation()
    {
        return this._defaultFontLocation;
    },
    /**
     * Sets the default font location for text.
     * Default value of this parameter is <code>GL2.Text.FontLocation.Default</code>.
     * @param {GL2.Text.FontLocation} location Font location
     * */
    set defaultFontLocation(value)
    {
        this._defaultFontLocation = value;
    },
    /**
     * Gets the default depth for node.
     * @returns {Number} Default depth
     * */
    get defaultDepth()
    {
        return this._defaultDepth;
    },
    /**
     * Sets the default depth for node.
     * Default value of this parameter is <code>20000</code>.
     * @param {Number} depth Default depth
     */
    set defaultDepth(value)
    {
        this._defaultDepth = value;
    },
    /**
     * Registers the user defined type.
     * @param {String} type The type name defined by user.
     * @param {Function} methodDefinition The definition of type defined by user.
     * @name Framework.GUIBuilder#registerTypeMethod
     * @status Android, Test
     */
    registerTypeMethod: function(type, methodDefinition)
    {
        if (typeof type === 'string' && typeof methodDefinition === 'function')
        {
            this._userDefinedTypes[type] = methodDefinition;
        }
    },
    /**
     * Checks wether method are defined by user or not.
     * @private
     */
    _checkUserDefinedMethods: function(controller, def)
    {
        var type = def.type;
        var userDefinedTypes = this._userDefinedTypes;
        var userType;
        for (userType in userDefinedTypes)
        {
            if (userDefinedTypes.hasOwnProperty(userType))
            {
                if (type === userType)
                {
                    return this._userDefinedTypes[type](controller, def);
                }
            }
        }
        NgLogE("<NGGo> Element type not found in GUIBuilder.js");
        return null;
    },
    /** @private */
    _destroyElement: function(elem)
    {
        if(typeof elem ==='object')
        {
            if(elem.gluiobj)
            {
                elem.gluiobj.destroy();
                elem.gluiobj = null;
                elem = null;
            }
            else
            {
                elem.destroy();
                elem=null;
            }
        }
    },
    /** @private */
    __onLoadData: function(jsonData, controller)
    {
        var attr;
        if (jsonData.defaultPath)
        {
            this.setDefaultPath(jsonData.defaultPath);
        }
        if (!controller.__nodes)
        {
            controller.__nodes = [];
        }
        controller.destroyAll = function()
        {
            var i;
            for (i=0; i < this.__nodes.length; ++i)
            {
                this.__nodes[i].destroy();

                if (this.__nodes[i].gluiobj &&
                    this.__nodes[i].gluiobj._internalGLObject.__objectRegistryId) {
                        this.__nodes[i].gluiobj._internalGLObject.destroy();
                }
            }
        };
        for (attr in jsonData)
        {
            if (jsonData.hasOwnProperty(attr))
            {
            	NgLogD("++++ attr:" + attr);
                var json = jsonData[attr];
                var root = this._buildUI(controller, json);
                root.setDepth(this._defaultDepth);
            }
        }
        return controller;
    },
    /**
     * @private
     */
    _buildUI: function(controller, def,  parentElem)
    {
        var elem = this._createElement(controller, def, parentElem);
        if (def.children)
        {
            var i;
            for (i=0; i<def.children.length; ++i)
            {
                var child = this._buildUI(controller, def.children[i], elem);
                elem.addChild(child);
            }
        }
        return elem;
    },
    /**
     * @private
     */
    _createElement: function(controller, def, parentElem)
    {
    	NgLogD("++++ create element type:" + def.type);
        var elem;
        switch (def.type)
        {
        case "button":
            elem = this._createGLUIElement(GLUI.Button, controller, def);
            break;
        case "checkbox":
            elem = this._createGLUIElement(GLUI.CheckBox, controller, def);
            break;
        case "image":
            elem = this._createGLUIElement(GLUI.Image, controller, def);
            break;
        case "label":
            elem = this._createGLUIElement(GLUI.Label, controller, def);
            break;
        case "view":
            elem = this._createGLUIElement(GLUI.View, controller, def);
            break;
        case "node":
            elem = this._createNode(controller, def);
            break;
        case "sprite":
            elem = this._createSprite(controller, def);
            break;
        case "text":
            elem = this._createText(controller, def);
            break;
        default:
            elem = this._checkUserDefinedMethods(controller, def);
            break;
        }
        if (def.name)
        {
            elem.name = def.name;
            controller[def.name] = elem;
            if (parentElem)
            {
                parentElem[def.name] = elem;
            }
        }
        controller.__nodes.push(elem);

        elem.type = def.type;
        elem.align = def.align;
        elem.marginRight = def.marginRight;
        elem.marginLeft = def.marginLeft;
        elem.valign = def.valign;
        elem.marginBottom = def.marginBottom;
        elem.marginTop = def.marginTop;
        elem.layout = def.layout;
        if (!elem.layout && parentElem)
        {
            elem.layout = parentElem.layout;
        }
        return elem;
    },
    /** @private */
    _createActionCaller: function(controller, elem, action)
    {
        var caller = function()
        {
            if (typeof action === 'string')
            {
                var fnByString = controller["action_" + action];
                fnByString.call(controller, elem);
            }
            else if (typeof action === 'object')
            {
                var fnByObject = controller["action_" + action.name];
                var params = [elem];
                if (action.param)
                {
                    params.push(action.param);
                }
                if (action.params)
                {
                    params = params.concat(action.params);
                }
                fnByObject.apply(controller, params);
            }
        };
        return caller;
    },
    /** @private */
    _createGLUIElement: function(elementType, controller, def)
    {
        var shallowCopy = function(obj)
        {
            var newObj = {};
            var key;
            for (key in obj)
            {
                if (obj.hasOwnProperty(key))
                {
                    newObj[key] = obj[key];
                }
            }
            return newObj;
        };

        var attrs = shallowCopy(def.attrs);

        var action = attrs.action;
        delete attrs.action;

        var elem = new elementType(attrs);

        if (action)
        {
            elem.setOnClick(this._createActionCaller(controller, elem, action));
        }

        var glObject = elem.getGLObject();
        glObject.gluiobj = elem;
        return glObject;
    },
    /**
     * create and reutrn GL2.Node.
     * @private
     */
    _createNode: function(controller, def)
    {
        var attrs = def.attrs;
        var frame = attrs.frame;
        var elem = new GL2.Node();
        var anchor = def.attrs.anchor || this._defaultAnchor;
        var uvs = def.attrs.uvs || this._defaultUVs;

        elem.getFrame = function()
        {
            return this._frame;
        };

        var self = this;
        elem.setFrame = function(frame)
        {
            this.setPosition(frame[0], frame[1]);
            this._frame = frame;
        };
        var key;
        for (key in attrs)
        {
            if (attrs.hasOwnProperty(key))
            {
                switch (key)
                {
                case "frame":
                    elem.setFrame(frame);
                    break;
                default:
                    this._applyProperty(elem, key, attrs[key], def.name);
                }
            }
        }
        return elem;
    },
    /**
     * create and reutrn GL2.Sprite.
     * @private
     * */
    _createSprite: function(controller, def)
    {
        var attrs = def.attrs;
        var frame = attrs.frame;
        var image = attrs.image;
        var anchor = (image) ? image.anchor : this._defaultAnchor;
        var uvs = (image) ? image.uvs : this._defaultUVs;
        var size = (image) ? image.size : this._defaultSize;

        var Sprite = require('NGGo/GLUI/Sprite').URLSprite;

        var elem = new Sprite();

        elem.getFrame = function()
        {
            return this._frame;
        };
        var self = this;
        elem.setFrame = function(frame)
        {
            if (image)
            {
                elem.setImage(self._basePath + image.url, [frame[2], frame[3]], anchor, uvs);
            }
            this.setPosition(frame[0], frame[1]);
            this._frame = frame;
        };
        var key, methodCall, argsArr;
        //iterate through attributes
        for (key in attrs)
        {
            if (attrs.hasOwnProperty(key))
            {
                switch (key)
                {
                case "frame":
                    elem.setFrame(frame);
                    break;
                case "image":
                    if (!frame)
                    {
                        elem.setImage(self._basePath + image.url, size, anchor, uvs);
                    }
                    break;
                case "animation":
                    //currently animation is not supported
                    break;
                default:
                    this._applyProperty(elem, key, attrs[key], def.name);
                }
            }
        }
        return elem;
    },
    /**
     * create and reutrn GL2.Text.
     * @private
     * */
    _createText: function(controller, def)
    {
        var attrs = def.attrs;
        var frame = attrs.frame;
        var horizontalAlignment = attrs.horizontalAlign;
        var verticalAlignment = attrs.verticalAlign;
        var overflowMode = attrs.overflowMode;
        var fontFamily = attrs.fontFamily;
        var fontLocation = attrs.fontLocation;

        var elem = new GL2.Text();

        elem.getFrame = function()
        {
            return this._frame;
        };
        elem.setFrame = function(frame)
        {
            this.setPosition(frame[0], frame[1]);
            this._frame = frame;
        };
        var key;
        for (key in attrs)
        {
            if (attrs.hasOwnProperty(key))
            {
                switch (key)
                {
                case "frame":
                    elem.setFrame(frame);
                    break;
                case "horizontalAlign":
                    if (String(horizontalAlignment).toLowerCase.search("right") !== -1)
                    {
                        horizontalAlignment = GL2.Text.HorizontalAlign.Right;
                    }
                    else if (String(horizontalAlignment).toLowerCase.search("left") !== -1)
                    {
                        horizontalAlignment = GL2.Text.HorizontalAlign.Left;
                    }
                    else // include "center"
                    {
                        horizontalAlignment = GL2.Text.HorizontalAlign.Center;
                    }
                    elem.setHorizontalAlign(horizontalAlignment);
                    break;
                case "verticalAlign":
                    if (String(verticalAlignment).toLowerCase.search("bottom") !== -1)
                    {
                        verticalAlignment = GL2.Text.VerticalAlign.Bottom;
                    }
                    else if (String(verticalAlignment).toLowerCase.search("top") !== -1)
                    {
                        verticalAlignment = GL2.Text.VerticalAlign.Top;
                    }
                    else // include "middle"
                    {
                        verticalAlignment = GL2.Text.HorizontalAlign.Middle;
                    }
                    elem.setVerticalAlign(verticalAlignment);
                    break;
                case "overflowMode":
                    if (String(overflowMode).toLowerCase.search("reducefontsize") !== -1)
                    {
                        overflowMode = GL2.Text.OverflowMode.ReduceFontSize;
                    }
                    else // include "multiline"
                    {
                        overflowMode = GL2.Text.OverflowMode.Multiline;
                    }
                    elem.setOverflowMode(overflowMode);
                    break;
                case "fontLocation":
                    if (String(fontLocation).toLowerCase.search("bundled"))
                    {
                        fontLocation = GL2.Text.FontLocation.Bundled;
                    }
                    else if (String(fontLocation).toLowerCase.search("system"))
                    {
                        fontLocation = GL2.Text.FontLocation.System;
                    }
                    else if (String(fontLocation).toLowerCase.search("manifest"))
                    {
                        fontLocation = GL2.Text.FontLocation.Manifest;
                    }
                    else // include "default"
                    {
                        fontLocation= GL2.Text.FontLocation.Default;
                    }
                    elem.setFontLocation(fontLocation);
                    break;
                default:
                    this._applyProperty(elem, key, attrs[key], def.name);
                }
            }
        }
        return elem;
    },
    /** @private */
    _applyProperty: function(elem, key, value, name)
    {
        console.log(name + ": " + key);
        var methodCall = [];
        methodCall.push('set');
        methodCall.push(key.charAt(0).toUpperCase());
        methodCall.push(key.substr(1));
        methodCall = methodCall.join("");

        if(elem[methodCall])
        {
            elem[methodCall].call(elem, value);
        }
        else
        {
            console.log('<NGGo> | ' + key + ' property not defined for ' + name);
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Framework/Scene/Scene'] = function(){var exports = $MODULE_REGISTRY['NGGo/Framework/Scene/Scene'] || {}; $MODULE_REGISTRY['NGGo/Framework/Scene/Scene'] = exports; 
var __dirname = 'NGGo/Framework/Scene';
var __filename = 'NGGo/Framework/Scene/Scene.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Require Block
var Class         = require('NGCore/Client/Core/Class').Class;
var SceneDirector = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;

////////////////////////////////////////////////////////////////////////////////
exports.Scene = Class.subclass(
/** @lends Framework.Scene.Scene.prototype */
{
    classname: 'Scene',
    sceneName: undefined,
    /**
     * @class This <code>Scene</code> class is a base class of scene object.
     * You can implement scene specific code into these sub classes.
     * It has 4 event handlers. they are called in the transition between scenes.
     * In these event handlers, load or destroy assets which is needed in the scene,
     * create/destroy UI/GL2 scene graph and so on.
     * @constructs Constructor for the object.
     * @name Framework.Scene.Scene
     * @augments Core.Class
     */
    initialize: function() {},
    /**
     * Closes current scene and transits to the parent scene.
     * @param {Object} [option] This is passed to current scene's <code>onExit()</code> and parent's <code>onResume()</code>.
     */
    exit: function(option)
    {
        SceneDirector.pop(option);
    },
    /**
     * If this scene is pushed as new scene, this event handler is called.
     * @param {Framework.Scene.Scene} prevScene parent scene object.
     * @param {any} option This is option value passed at pop() and push() method.
     */
    onEnter: function(prevScene, option) {},
    /**
     * If child scene is closed and return to this scene, this event handler is called.
     * @param {Framework.Scene.Scene} prevScene child scene object.
     * @param {any} option This is option value passed at pop() and push() method.
     */
    onResume: function(prevScene, option) {},
    /**
     * If child scene is pushed and transit to next scene, this event handler is called.
     * In this method, you can't use <code>SceneDirector.push()</code> and
     * <code>SceneDirector.pop()</code> and <code>SceneDirector.transition()</code>
     * @param {Framework.Scene.Scene} nextScene child scene object.
     * @param {any} option This is option value passed at pop() and push() method.
     */
    onPause: function(nextScene, option) {},
    /**
     * If current scene is closed and return to parent scene, this event handler is called.
     * In this method, you can't use <code>SceneDirector.push()</code> and
     * <code>SceneDirector.pop()</code> and <code>SceneDirector.transition()</code>
     * @param {Framework.Scene.Scene} nextScene parent scene object.
     * @param {any} option This is option value passed at pop() and push() method.
     */
    onExit: function(nextScene, option) {}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/GlobalParameter'] = function(){var exports = $MODULE_REGISTRY['Code/utils/GlobalParameter'] || {}; $MODULE_REGISTRY['Code/utils/GlobalParameter'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/GlobalParameter.js';

var Core = require('NGCore/Client/Core').Core;

exports.GlobalParameter = Core.Class.singleton({    
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/cutscene/SpecialMission'] = function(){var exports = $MODULE_REGISTRY['Code/module/cutscene/SpecialMission'] || {}; $MODULE_REGISTRY['Code/module/cutscene/SpecialMission'] = exports; 
var __dirname = 'Code/module/cutscene';
var __filename = 'Code/module/cutscene/SpecialMission.js';

var Core  = require('NGCore/Client/Core').Core;
var GL2   = require('NGCore/Client/GL2').GL2;
var Audio = require('NGCore/Client/Audio').Audio;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var ScreenManager		= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
//========================================================================================
exports.SpecialMission = Scene.subclass({
	
	//--------------------------------------------------------------------------
	initialize: function( rootNode, message1, message2,onCompleteHandler ) {
		
		this.name = "SpecialMission";
		this.rootNode = rootNode  ||  new GL2.Node();
		this.rootNode.setDepth(65535);
		
		this.nodes = [];
		this.onCompleteHandler = onCompleteHandler;
		this._message1 = message1;
		this._message2 = message2;
		
		this._color1 = [1, 1, 0.5];
		this._color2 = [0.2, 0.8, 0.2];
	},
	//--------------------------------------------------------------------------
	destroy: function() {},
	
	//--------------------------------------------------------------------------
	onEnter: function() {
		console.log("NDL: --- onEnter");
		
		
		var duration = 1.0;
		//dn.AudioPlayer.playEffect( 'common/Z_009.wav' );
		
		//----- diagonal black frame
		//var p = this.makeBrushStroke( 145-50, 235, 100, 100 );
		var p = new GL2.Sprite();
		p.setImage("Content/cutscene/brush_stroke.png");
		//p.setRotation( 45 );
		//p.setAlpha( 0 );
		this.rootNode.addChild( p );
		this.nodes.push( p );
		GL2.Root.addChild(this.rootNode);
		//dn.VFX.enchant( p ).fi( 0.2 ).wait( duration ).fo( 0.2 );
		//dn.VFX.enchant( p ).move( 0.2, 50, 0, -1 ).wait( duration ).move( 0.2, 50, 0, 1);
		
		
		//----- logo: SPECIAL MISSION
		//var n = new GL2.Node();
		
		//var t = dn.ImageFontFactory.create(
		//	'common/font/general.png', nj.TT('SPECIAL'), 48, -1, [1, 1, 0.5], [0.2, 0.8, 0.2]
		//);
		//t.setAnchor( 1, 1 );
		//t.setPosition( 0, 0 );
		//console.log("NDL:1111");
		//var t = new GL2.Text();
		//t.setSize(100, 30);
		//t.setText("SPECIAL ABCDEF");
		//n.addChild( t );
		//this.nodes.push( t );
		
		//var t = dn.ImageFontFactory.create(
		//	'common/font/general.png', nj.TT('MISSION!'), 48, -1, [1, 1, 0.5], [0.2, 0.8, 0.2]
		//);
		//t.setAnchor( 1, 1 );
		//t.setPosition( 120, 42 );
		//n.addChild( t );
		//this.nodes.push( t );
		//console.log("NDL:2222");
		//n.setRotation( 45 );
		//n.setPosition( 135 - 200, 200 - 200 );
		//this.rootNode.addChild( n );
		//this.nodes.push( n );
		//console.log("NDL:33333");
		//dn.VFX.enchant( n ).move( 0.3, 200, 200, 1 )
		//	.move( 0.03, -5, -5, -1 ).move( 0.03, 9, 9, -1 )
		//	.move( 0.03, -7, -7, -1 ).move( 0.03, 5, 5, -1 )
		//	.move( 0.03, -3, -3, -1 ).move( 0.03, 1, 1, -1 )
		//	.wait( duration - 0.3 ).move( 0.4, 250, 250, 1 );
		//dn.VFX.enchant( n ).wait( duration + 0.2 ).fo( 0.3 );
		
		//----- set end trigger
		console.log("NDL:-- set time out");
		dn.Timekeeper.setTimeout( dn.bind( this, function() {
			this.endScene();
		}), duration + 0.6 );
	},
	
	//--------------------------------------------------------------------------
	onExit: function() {
		
		dn.VFX.removeAllTasks();
		dn.Timekeeper.clearAllTimeout();
		dn.each( this.nodes, function(i) {
			i.destroy();
		});
		this.destroy();
	},
	
	//--------------------------------------------------------------------------
	endScene: function() {
		console.log("NDL: endScene");
		SceneDirector.pop();
		console.log("NDL:this.onCompleteHandler="+this.onCompleteHandler);
		//if (this.onCompleteHandler) {
		//	this.onCompleteHandler.apply();
		//}
	},
	makePrimitive: function( x, y, w, h, color1, color2, color3, color4 ) {
		
		if (arguments.length <= 6) {
			color3 = color2 || color1;
			color4 = color2 || color1;
			color2 = color1;
		}
		
		var p = new GL2.Primitive();
		p.setType( GL2.Primitive.Type.TriangleStrip );
		
		p.pushVertex( new GL2.Primitive.Vertex([0, 0], [0, 0], color1) );
		p.pushVertex( new GL2.Primitive.Vertex([w, 0], [1, 0], color2) );
		p.pushVertex( new GL2.Primitive.Vertex([0, h], [0, 1], color3) );
		p.pushVertex( new GL2.Primitive.Vertex([w, h], [1, 1], color4) );
		
		p.setPosition( x, y );
		return p;
	},
	//--------------------------------------------------------------------------
	makeBrushStroke: function( x, y, w, h ) {
		
		var s = new GL2.Sprite();
		s.setImage("Content/cutscene/brush_stroke.png");
		//nj.Utils.setSpriteImage(
		//	s,
		//	nj.IMG("common/cutscene", "brush_stroke.png"),
		//	[w, h], [0.5, 0.5]
		//);
		s.setPosition( x, y );
		return s;
	},
	
	//--------------------------------------------------------------------------
	onEnterViaPush: function( prevScene, option ) { this.onEnter( prevScene ); },
	onEnterViaPop : function( prevScene, option ) {},
	onExitViaPush : function( nextScene, option ) {},
	onExitViaPop  : function( nextScene, option ) { this.onExit( nextScene ); }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/Logger'] = function(){var exports = $MODULE_REGISTRY['Code/utils/Logger'] || {}; $MODULE_REGISTRY['Code/utils/Logger'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/Logger.js';

var Core = require('NGCore/Client/Core').Core; 
exports.Logger = Core.Class.singleton({
	log: function(obj, title) {
		var t = title || "study123:";
		console.log(t + obj);
	},
	
	log1: function(obj, title){
		var _title = title || "";
		if(typeof(obj) == "object" && obj != null && obj != undefined){
			if(Core.Capabilities.getPlatformOS() == 'flash'){
				console.log("Logger.log>>===========Start logging========" + _title + "====================");
				console.log(obj);
				console.log("Logger.log>>===========End logging==========" + _title + "====================");
			}else{
				console.log("Logger.log>>===========Start logging========" + _title + "====================");
				for(var k in obj){
					console.log("Logger.log>>"+k+": " + obj[k]);
				}
				console.log("Logger.log>>===========End logging==========" + _title + "====================");
			}
		}else{
			console.log("Logger.log>>" + _title + ": " + obj);
		}		
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/controller/PreBattleSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/controller/PreBattleSceneController'] || {}; $MODULE_REGISTRY['Code/module/battle/controller/PreBattleSceneController'] = exports; 
var __dirname = 'Code/module/battle/controller';
var __filename = 'Code/module/battle/controller/PreBattleSceneController.js';

/**
 * @author sonnn
 */

var Core 				= require('NGCore/Client/Core').Core;
var Device 				= require('NGCore/Client/Device').Device;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 		= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var JSONData 			= require('NGGo/Service/Data/JSONData').JSONData;
var GUIBuilder 			= require('NGGo/Framework/GUIBuilder').GUIBuilder;
var ScreenManager 		= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GL2 				= require('NGCore/Client/GL2').GL2;
var GlobalParameter 	= require('Code/utils/GlobalParameter').GlobalParameter;
var Logger 				= require('Code/utils/Logger').Logger;

var preBattleSceneController = 
{
	initialize: function() {
		Logger.log("Load Game successfully!");
	},
	
    action_click: function (elem, battleName)
    {
    	var self = this;
        console.log('You clicked ' + battleName + '!');
        
        if (battleName === "Battle1" || battleName === "Battle2") {
        	this.gotoBattle(self, battleName);
        } else if (battleName === "Reload") {
        	this._initBackKey();
        } else if (battleName === "Test") {
            this.transitionToTestScene();
        }
    },
    
    gotoBattle: function(self, battleName) {
    	self.transitionToBattleMain(battleName);
    },
    
    transitionToBattleMain: function(battleName) {
		console.log("transition to main scene: " + battleName);
		SceneDirector.push("BATTLE_SCENE", battleName);
    },
    
    transitionToTestScene: function() {
		console.log("transition to test scene");
		SceneDirector.transition("TEST_SCENE");
    },
    
    transitionToDebugScene: function() {
        console.log("transition to Viet");
        SceneDirector.push("DEBUG_SCENE");
    },
    
	_initBackKey: function () {
		var KeyListener = Core.MessageListener.singleton ({
			initialize: function() {
				Device.KeyEmitter.addListener(this, this.onUpdate);
				Device.KeyEmitter.emit(new Device.KeyEmitter.KeyEvent(Device.KeyEmitter.EventType.onUp, Device.KeyEmitter.Modifier.NONE, Device.KeyEmitter.Keycode.back));
			},

			onUpdate : function(keyEvent) {
				var gameUrl = Core.Capabilities.getStartingServer() + "/" + Core.Capabilities.getBootGame();
				Logger.log("Reload Game " + gameUrl);
				
				Core.LocalGameList.runUpdatedGame(gameUrl);
				return false;
			}
		});
		
		KeyListener.instantiate();
	}
};

exports.PreBattleSceneController = Core.Class.subclass(preBattleSceneController);
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/VFX/AutoReloader'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/AutoReloader'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/AutoReloader'] = exports; 
var __dirname = 'NGGo/Service/Graphics/VFX';
var __filename = 'NGGo/Service/Graphics/VFX/AutoReloader.js';

/*
 * Copyright (c) 2011 DeNA Co., Ltd.
 * Permission is hereby granted, free of charge, to any person to obtain a copy of
 * this software and associated documentation files (collectively called
 * the "Software"), in order to exploit the Software without restriction, including
 * without limitation the permission to use, copy, modify, merge, publish,
 * distribute, and/or sublicense copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS LICENSED TO YOU "AS IS" AND WITHOUT
 * WARRANTY OF ANY KIND. DENA CO., LTD. DOES NOT AND CANNOT
 * WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY
 * USING THE SOFTWARE. EXCEPT FOR ANY WARRANTY, CONDITION,
 * REPRESENTATION OR TERM TO THE EXTENT TO WHICH THE SAME
 * CANNOT OR MAY NOT BE EXCLUDED OR LIMITED BY LAW APPLICABLE
 * TO YOU IN YOUR JURISDICTION, DENA CO., LTD., MAKES NO
 * WARRANTIES, CONDITIONS, REPRESENTATIONS OR TERMS, EXPRESS
 * OR IMPLIED, WHETHER BY STATUTE, COMMON LAW, CUSTOM, USAGE,
 * OR OTHERWISE AS TO THE SOFTWARE OR ANY COMPONENT
 * THEREOF, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * INTEGRATION, MERCHANTABILITY,SATISFACTORY QUALITY, FITNESS
 * FOR ANY PARTICULAR PURPOSE OR NON-INFRINGEMENT OF THIRD
 * PARTY RIGHTS. IN NO EVENT SHALL DENA CO., LTD. BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * EXPLOITATION OF THE SOFTWARE.
 */

var Class 		= require('NGCore/Client/Core/Class').Class;
var FileSystem 	= require('NGCore/Client/Storage/FileSystem').FileSystem;


exports.AutoReloader = Class.subclass(
/** @lends AutoReloader.prototype */
{
	classname: 'AutoReloader',
	/**
	 * @class
	 */
	initialize: function(onReloadFunc, interval) {
		this._onReloadFunc = onReloadFunc;
		this._ongoing = true;
		this._interval = interval || 1000;
		this._path = "reload.txt";
		this._start();
	},
	/**
	 *
	 */
	_processReloadFile: function(filePath) {
		FileSystem.readFile(filePath, false, function(err, data) {
			if(err) { return; }

			NgLogD("readFile: success");
			this._ongoing = false;
			fileSys.deleteFile(filePath, function() {
				this._onReloadFunc(data);
				this._ongoing = true;
			}.bind(this));
		}.bind(this));
	},
	_start: function() {
		var update = function() {
			if(!this._ongoing) { return; }
			this._processReloadFile(this._path);
		}.bind(this);
		setInterval(update, this._interval);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/VFX/utils'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/utils'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/utils'] = exports; 
var __dirname = 'NGGo/Service/Graphics/VFX';
var __filename = 'NGGo/Service/Graphics/VFX/utils.js';

/* Copyright (c) 2011 DeNA Co., Ltd.
 * Permission is hereby granted, free of charge, to any person to obtain a copy of
 * this software and associated documentation files (collectively called
 * the "Software"), in order to exploit the Software without restriction, including
 * without limitation the permission to use, copy, modify, merge, publish,
 * distribute, and/or sublicense copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS LICENSED TO YOU "AS IS" AND WITHOUT
 * WARRANTY OF ANY KIND. DENA CO., LTD. DOES NOT AND CANNOT
 * WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY
 * USING THE SOFTWARE. EXCEPT FOR ANY WARRANTY, CONDITION,
 * REPRESENTATION OR TERM TO THE EXTENT TO WHICH THE SAME
 * CANNOT OR MAY NOT BE EXCLUDED OR LIMITED BY LAW APPLICABLE
 * TO YOU IN YOUR JURISDICTION, DENA CO., LTD., MAKES NO
 * WARRANTIES, CONDITIONS, REPRESENTATIONS OR TERMS, EXPRESS
 * OR IMPLIED, WHETHER BY STATUTE, COMMON LAW, CUSTOM, USAGE,
 * OR OTHERWISE AS TO THE SOFTWARE OR ANY COMPONENT
 * THEREOF, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * INTEGRATION, MERCHANTABILITY,SATISFACTORY QUALITY, FITNESS
 * FOR ANY PARTICULAR PURPOSE OR NON-INFRINGEMENT OF THIRD
 * PARTY RIGHTS. IN NO EVENT SHALL DENA CO., LTD. BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * EXPLOITATION OF THE SOFTWARE.
 */

/**
 * Dn.utils package.
 *
 * @name Dn.utils
 * @namespace
 */
 
exports.utils = {
	AutoReloader: require('NGGo/Service/Graphics/VFX/AutoReloader').AutoReloader,

	/**
	 * Helper function to call visitor function with all element in the array.
	 * 
	 * @param {Array} a target array
	 * @param {Function} fn function object to process the element
	 */ 
	each: function (a, fn) {
		for(var i = 0; i < a.length; ++i) {
			fn(a[i], i);
		}
	},

	/**
	 * Helper function to apply the function to element and create.
	 *
	 * @param {Array} a target array
	 * @param {Function} fn function object to process the element
	 * @returns {Array} new array
	 */ 
	map: function (a, fn) {
		var out = [];
		exports.utils.each(a, function(i) {
			out.push( fn(i) );
		});
		return out;
	},

	/**
	 * Find value the function returns true.
	 * 
	 * @param {Array} a target array
	 * @param {Function} fn function it checks the element
	 * @returns return found object or 'undefined'(when missing)
	 */ 
	find: function(a, fn) {
		for (var i = 0; i < a.length; ++i) {
			if(fn( a[i] )) {
				return a[i];
			}
		}
		return undefined;
	},

	/**
	 * Bind object with method. It is used for callback.
	 * In fn function, this == context.
	 *
	 * @param context object
	 * @param {Function} fn method.
	 * @returns {Function} binded method.
	 */ 

	bind: function(context, fn) {
		return function () {
			var args = Array.prototype.slice.call(arguments, 0);
			return fn.apply(context, args);
		};
	},

	/**
	 * Scan the object tree and apply function in each value.
	 *
	 * @param obj target object
	 * @param {Function(key,value)} func function to handle data 
	 */ 

	traverse: function( obj, func ) {
		for (var i in obj) {
			func.apply( this, [i, obj[i]] );
			if (typeof( obj[i] ) === "object" ) {
				exports.utils.traverse( obj[i], func );
			}
		}
	},

	/**
	 * get random number
	 * It returns [0-max).
	 *
	 * @param {Number} max max number
	 * @param {NUmber} random value 
	 */ 

	rand: function( max ) {
		return Math.random() * max;
	},

	/**
	 * Get sin value with degree.
	 *
	 * @param {Number} degree
	 * @returns {Number} result
	 */ 

	sin: function( degree ) {
		return Math.sin( degree / 180 * Math.PI );
	},

	/**
	 * Get cos value with degree.
	 *
	 * @param {Number} degree
	 * @returns {Number} result
	 */ 

	cos: function( degree ) {
		return Math.cos( degree / 180 * Math.PI );
	},
	
	destroyIfAlive: function(obj) {
		if(Core.ObjectRegistry.isObjectRegistered(obj)) {
			obj.destroy();
		}
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/VFX/Timekeeper'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/Timekeeper'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/Timekeeper'] = exports; 
var __dirname = 'NGGo/Service/Graphics/VFX';
var __filename = 'NGGo/Service/Graphics/VFX/Timekeeper.js';

/* Copyright (c) 2011 DeNA Co., Ltd.
 * Permission is hereby granted, free of charge, to any person to obtain a copy of
 * this software and associated documentation files (collectively called
 * the "Software"), in order to exploit the Software without restriction, including
 * without limitation the permission to use, copy, modify, merge, publish,
 * distribute, and/or sublicense copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS LICENSED TO YOU "AS IS" AND WITHOUT
 * WARRANTY OF ANY KIND. DENA CO., LTD. DOES NOT AND CANNOT
 * WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY
 * USING THE SOFTWARE. EXCEPT FOR ANY WARRANTY, CONDITION,
 * REPRESENTATION OR TERM TO THE EXTENT TO WHICH THE SAME
 * CANNOT OR MAY NOT BE EXCLUDED OR LIMITED BY LAW APPLICABLE
 * TO YOU IN YOUR JURISDICTION, DENA CO., LTD., MAKES NO
 * WARRANTIES, CONDITIONS, REPRESENTATIONS OR TERMS, EXPRESS
 * OR IMPLIED, WHETHER BY STATUTE, COMMON LAW, CUSTOM, USAGE,
 * OR OTHERWISE AS TO THE SOFTWARE OR ANY COMPONENT
 * THEREOF, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * INTEGRATION, MERCHANTABILITY,SATISFACTORY QUALITY, FITNESS
 * FOR ANY PARTICULAR PURPOSE OR NON-INFRINGEMENT OF THIRD
 * PARTY RIGHTS. IN NO EVENT SHALL DENA CO., LTD. BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * EXPLOITATION OF THE SOFTWARE.
 */

var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter 	= require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var utils 			= require('NGGo/Service/Graphics/VFX/utils').utils;


exports.Timekeeper = MessageListener.singleton(
/** @lends Timekeeper.prototype */
{
	classname: 'Timekeeper',
	/** 
	 * @class Simple multi tasker
	 * @author Tatsuya Koyama
 	 */
	initialize: function() {
		UpdateEmitter.addListener( this, this.onUpdate );
		
		//----- frame skip を許す範囲
		this.frameRate      = 60;
		this.limitSkipSec   = 5 / this.frameRate;
		this.limitSkipFrame = 5;
		
		//-----
		this.currentTime = +new Date();
		this.prevTime    = this.currentTime;
		this.elapsedSec  = 0;
		this.passedSec   = 0;
		this.passedFrame = 0;
		this.tasks = [];
	},
													
	/**
	 * Set function it is called after specific time.
	 *
	 * @param {function} func call-back function
	 * @param {sec} sec time-out term(seconds)
	 * @see clearAlltimeout()
	 */
	setTimeout: function( func, sec ) {
		
		var task = {
			handler   : func,
			waitRemain: sec
		};
		this.tasks.push( task );
	},
	/**
	 * Clear all time-out functions.
	 */
	clearAllTimeout: function() {
		this.tasks = [];
	},
	/**
	 * 
	 */
	getDelta: function( _diff, _sec ) {
		
		var diff = _diff || (1 / this.frameRate);
		var sec  = _sec  || (1 / this.frameRate);
		var elapsedSec = (this.currentTime - this.prevTime) / 1000;
		if (elapsedSec > this.limitSkipSec) {
			elapsedSec = this.limitSkipSec;
		}
		return (diff * elapsedSec) / sec;
	},

													/**
	 * Return the passed second from last frame.
	 *
	 * @returns {Number} passed second.
	 */
	getPassedSec:   function() { return this.passedSec;   },

	/**
	 * Return the passed frame from last frame.
	 *
	 * @returns {Number} passed frame.
	 */
	getPassedFrame: function() { return this.passedFrame; },

	/**
	 * @event
	 */
	onUpdate: function( delta ) {
		
		//----- 前回のフレームから、実際に過ぎ去った時間を保持
		this.passedSec = delta / 1000;
		if (this.passedSec > this.limitSkipSec) {
			this.passedSec = this.limitSkipSec;
		}
		
		//----- 「本来過ぎ去るはずだったフレーム数」を計算
		this.prevTime    = this.currentTime;
		this.currentTime = +new Date();
		this.elapsedSec += (this.currentTime - this.prevTime) / 1000;
		
		this.passedFrame = 0;
		var frameSec = (1 / this.frameRate);
		if (this.passedSec >= frameSec) {
			this.passedFrame += Math.floor( this.elapsedSec / frameSec );
			this.elapsedSec   -= (frameSec * this.passedFrame);
		}
		if (this.passedFrame > this.limitSkipFrame) {
			this.passedFrame = this.limitSkipFrame;
		}
		var lazyTasks = [];
		//----- setTimeout で登録されたタスクを管理・実行
		for (var i=0;  i < this.tasks.length;  i++) {
			var t = this.tasks[i];
			t.waitRemain -= this.passedSec;
			if (t.waitRemain <= 0) {
				if (typeof( t.handler ) === 'function') {
					lazyTasks.push( t );
				}
				//----- 配列から消して詰めるのアレだからハッシュにした方がいいかな…
				this.tasks.splice( i, 1 );
				--i;
			}
		}
		utils.each(lazyTasks, function(t) {
			t.handler.apply();
		});
	}
	
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/VFX/Bezier'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/Bezier'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/Bezier'] = exports; 
var __dirname = 'NGGo/Service/Graphics/VFX';
var __filename = 'NGGo/Service/Graphics/VFX/Bezier.js';

exports.Bezier = {
	
    bezier3: function(t, p0, p1, p2, p3) {
		return Math.pow(1-t, 3) * p0 + 3 * t * Math.pow(1-t, 2) * p1 + 3 * t * t * (1-t) * p2 + t * t * t * p3;
    }
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/VFX/VFX'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/VFX'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/VFX/VFX'] = exports; 
var __dirname = 'NGGo/Service/Graphics/VFX';
var __filename = 'NGGo/Service/Graphics/VFX/VFX.js';

/* Copyright (c) 2011 DeNA Co., Ltd.
 * Permission is hereby granted, free of charge, to any person to obtain a copy of
 * this software and associated documentation files (collectively called
 * the "Software"), in order to exploit the Software without restriction, including
 * without limitation the permission to use, copy, modify, merge, publish,
 * distribute, and/or sublicense copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS LICENSED TO YOU "AS IS" AND WITHOUT
 * WARRANTY OF ANY KIND. DENA CO., LTD. DOES NOT AND CANNOT
 * WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY
 * USING THE SOFTWARE. EXCEPT FOR ANY WARRANTY, CONDITION,
 * REPRESENTATION OR TERM TO THE EXTENT TO WHICH THE SAME
 * CANNOT OR MAY NOT BE EXCLUDED OR LIMITED BY LAW APPLICABLE
 * TO YOU IN YOUR JURISDICTION, DENA CO., LTD., MAKES NO
 * WARRANTIES, CONDITIONS, REPRESENTATIONS OR TERMS, EXPRESS
 * OR IMPLIED, WHETHER BY STATUTE, COMMON LAW, CUSTOM, USAGE,
 * OR OTHERWISE AS TO THE SOFTWARE OR ANY COMPONENT
 * THEREOF, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * INTEGRATION, MERCHANTABILITY,SATISFACTORY QUALITY, FITNESS
 * FOR ANY PARTICULAR PURPOSE OR NON-INFRINGEMENT OF THIRD
 * PARTY RIGHTS. IN NO EVENT SHALL DENA CO., LTD. BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * EXPLOITATION OF THE SOFTWARE.
 */

var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter 	= require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Class 			= require('NGCore/Client/Core/Class').Class;
var Timekeeper 		= require('NGGo/Service/Graphics/VFX/Timekeeper').Timekeeper;
var Bezier	 		= require('NGGo/Service/Graphics/VFX/Bezier').Bezier;
var utils 			= require('NGGo/Service/Graphics/VFX/utils').utils;

/**
 * @fileoverview VFX class which make creating VFX easily
 * @author Tatsuya Koyama
 * @version 0.1
 */

exports.VFXTaskNode = Class.subclass(
/** @lends Dn.VFXTaskNode.prototype */
{
	classname: 'VFXTaskNode',
	/**
	 * @class <code>VFXTaskNode</code> class is a effect task class. 
	 * Use it in fluent interface(http://martinfowler.com/bliki/FluentInterface.html), like jQuery.
	 *
	 * @example
	 * VFX.enchant(node)
	 *    .move(3.0, 100, 100)
	 *    .hop(5, 5)
	 *    .end();
	 *
	 * @arguments Core.Class
	 * @constructs Init effect task class.
	 * @param {GL2.Node} node Target node object.
	 * @param {Function} call back when called on finish.
	 */
	initialize: function( node ) {
		
		this.node     = node;
		this.func     = null;
		this.args     = [];
		this.progress = 0;
		this.delta    = 0;
		this.next     = null;
		this.param    = {};
		
		this.isInitialized = false;
		this.isActive      = false;
		this.isFinished    = false;
		this.isDestroyed   = false;
	},

	/**
	 * Apply any functions as the task. The function should call <code>this.finish()</code>.
	 *
	 * @example
	 * var msg = function(message) {
	 *     text.setText(message);
	 *     this.finish();
	 * };
	 *
	 * VFX.enchant(node)
	 *     .wait(10)
	 *     .and(msg, ["wait finished"])
	 *     .end();
	 * 
	 * @param {Function} func Function object which is called after previous task was finished.
	 * @param {Array} args arguments they are passed to the function.
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	and: function( func, args ) {
		
		this.isActive = true;
		this.func     = func;
		this.args     = args;
		
		var nextTask = new exports.VFXTaskNode( this.node );
		this.next = nextTask;
		return nextTask;
	},

	/**
	 * Insert new task into the task chain.
	 *
	 * @example
	 * var msg = function(message) {
	 *     text.setText(message);
	 *     if (Math.random() > 0.5) {
	 *          this.insert('hop', [10, 1]);
	 *     }
	 *     this.finish();
	 * };
	 *
	 * VFX.enchant(node)
	 *     .and(msg, ["sometimes hopping finished"])
	 *     .end();
	 * 
	 * @param {Function} func Function object which is called after previous task was finished.
	 * @param {Array} args arguments they are passed to the function.
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	insert: function( func, args ) {
		
		var insertTask = new exports.VFXTaskNode( this.node );
		
		insertTask.isActive = true;
		insertTask.func     = func;
		insertTask.args     = args;

		insertTask.next = this.next;
		this.next       = insertTask;

		return insertTask;
	},
	
	/**
	 * Stop VFX during passed term.
	 * @param {Number} sec seconds
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	wait: function( sec ) {
		return this.and( 'wait', [sec] );
	},
	
	/**
	 * Finish VFX tasks and destroy target node.
	 */
	end: function() {
		return this.and( 'end' );
	},
	
	/**
	 * Fade in task.
	 * @param {Number} duration the time it takes fade in[Seconds].
	 * @param {Number} alpha default=1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#fo
	 */
	fi: function( duration, alpha ) {
		return this.and( 'fadeIn', [duration, alpha] );
	},
	
	/**
	 * Fade out task.
	 * @param {Number} duration the time it takes fade out[Seconds].
	 * @param {Number} alpha default=1.
	 * @returns {Dn.VFXTaskNode} next job.
 	 * @see Dn.VFXTaskNode#fi
	 */
	fo: function( duration, alpha ) {
		return this.and( 'fadeOut', [duration, alpha] );
	},
	
	/**
	 * Alpha task. 
	 * @param {Number} duration the time it takes moving[Seconds].
	 * @param {Number} alpha 
	 * @param {Number} easing easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#moveTo
	 */
	alpha: function( duration, alpha, easing ) {
		return this.and( 'alpha', [duration, alpha, easing] );
	},

	/**
	 * Alpha task.
	 * @param {Number} duration the time it takes moving[Seconds].
	 * @param {Number} alpha 
	 * @param {Number} easing easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#move
	 */
	alphaTo: function( duration, alpha, easing ) {
		return this.and( 'alphaTo', [duration, alpha, easing] );
	},
	
	/**
	 * Move task. Move to the position which is far from current position.
	 * @param {Number} duration the time it takes moving[Seconds].
	 * @param {Number} dx delta x
	 * @param {Number} dy delta y
	 * @param {Number} easing easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#moveTo
	 */
	move: function( duration, dx, dy, easing ) {
		return this.and( 'move', [duration, dx, dy, easing] );
	},
	
	move2: function( cb, duration, dx, dy, easing ) {
		return this.and( 'move2', [cb, duration, dx, dy, easing] );
	},
	
	moveByBezier: function( cb, args, duration, p0, p1, p2, p3, easing ) {
		return this.and( 'moveByBezier', [cb, args, duration, p0, p1, p2, p3, easing] );
	},

	/**
	 * Move task. Move to the position which is far from current position.
	 * @param {Number} duration the time it takes moving[Seconds].
	 * @param {Number} tx x of goal position
	 * @param {Number} ty y of goal position
	 * @param {Number} easing easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#move
	 */
	moveTo: function( duration, tx, ty, easing ) {
		return this.and( 'moveTo', [duration, tx, ty, easing] );
	},
	
	/**
	 * Scale task. Scale with passed scale late.
	 * @param {Number} duration the time it takes scaling[Seconds].
	 * @param {Number} dScaleX delta scale of X
	 * @param {Number} dScaleY delta scale of Y
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#scaleTo
	 */
	scale: function( duration, dScaleX, dScaleY, easeIn ) {
		return this.and( 'scale', [duration, dScaleX, dScaleY, easeIn] );
	},

	/**
	 * Scale task. Scale up to the passed scale.
	 * @param {Number} duration the time it takes scaling[Seconds].
	 * @param {Number} tScaleX goal scale of X
	 * @param {Number} tScaleY goal scale of Y
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#scale
	 */
	scaleTo: function( duration, tScaleX, tScaleY, easeIn ) {
		return this.and( 'scaleTo', [duration, tScaleX, tScaleY, easeIn] );
	},

	/**
	 * Rotate task. Rotate with passed angle.
	 * @param {Number} duration the time it takes rotating[Seconds].
	 * @param {Number} dRot delta angle(degree)
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotateTo
	 */
	rotate: function( duration, dRot, easeIn ) {
		return this.and( 'rotate', [duration, dRot, easeIn] );
	},

	/**
	 * Rotate task. Rotate until passed angle.
	 * @param {Number} duration the time it takes rotating[Seconds].
	 * @param {Number} dRot delta angle(degree)
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	rotateTo: function( duration, tRot, easeIn ) {
		return this.and( 'rotateTo', [duration, tRot, easeIn] );
	},
	
	/**
	 * Color task. Change color filter.
	 * @param {Number} duration the time it takes changing color[Seconds].
	 * @param {Number} dr delta color(red)
	 * @param {Number} dg delta color(green)
	 * @param {Number} db delta color(blue)
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	color: function( duration, dr, dg, db, easeIn ) {
		return this.and( 'color', [duration, dr, dg, db, easeIn] );
	},

	/**
	 * Color task. Change color filter.
	 * @param {Number} duration the time it takes changing color[Seconds].
	 * @param {Number} tr destination color(red)
	 * @param {Number} tg destination color(green)
	 * @param {Number} tb destination color(blue)
	 * @param {Number} easeIn easing parameter. -1 .. +1.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	colorTo: function( duration, tr, tg, tb, easeIn ) {
		return this.and( 'colorTo', [duration, tr, tg, tb, easeIn] );
	},

	/**
	 * Hopping task. Node jumps. Both parameters should be positive number.
	 * @param {Number} velocity first speed.
	 * @param {Number} gravity damping rate.
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	hop: function ( velocity, gravity ) {
		return this.and( 'hop', [velocity, gravity] );
	},

	/**
	 * Visiblity task. Node appears quickly. 
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	on: function() {
		return this.and( 'appear' );
	},

	/**
	 * Visiblity task. Node disappears quickly. 
	 * @returns {Dn.VFXTaskNode} next job.
	 * @see Dn.VFXTaskNode#rotate
	 */
	off: function() {
		return this.and( 'disappear' );
	},
	
	/**
	 * Blink target object.
	 * 
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	blink: function( duration, term, alphas) {
		term = term || 0.5;
		alphas = alphas || [0.8, 0.3];
		return this.and( 'blink', [duration, term, alphas] );
	},
	/**
	 * Register task, but not fire now. To restart this task, run Dn.VFX.resume(node).
	 * 
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	register: function() {
		var next = this.and( 'register', [] );
		this.isActive = false;
		return next;
	},
	
	finish: function( duration ) {
		if (! duration) { duration = 0; }
		if (this.progress > duration) { this.isFinished = true; }
		return this.isFinished;
	},
	
	easing: function( duration, value, easeIn ) {
		
		var e = easeIn;
		if (! e) { e = 0; }
		e /= -3.14;
		var t = (this.progress / duration);
		if (Math.abs( e ) > 0.01) { t += e * utils.sin( 180 * t ); }
		
		return value * t;
	}
});



//========================================================================================
exports.VFX = MessageListener.singleton(
/** @lends Dn.VFX.prototype */
{
	classname: 'VFX',
	/**
	 * @class <code>VFX</code> class effect to the <code>GL2.Node</code> class. 
	 * Use it in fluent interface(http://martinfowler.com/bliki/FluentInterface.html), like jQuery.
	 *
	 * @arguments Core.MessageListener
	 * @constructs Initialize effect class.
	 */
	initialize: function() {
		UpdateEmitter.addListener( this, this.onUpdate );
		
		this.tasks  = {};
		this.nodeId = 0;
		this.taskId = 0;
	},
	
	/**
	 * Start setting new tasks.
	 *
	 * @param {GL2.Node} node Target node object.
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	enchant: function( node ) {
		
		var nodeId = 0;
		var taskId = 0;
		
		if (! node._dnVFXManagedId) {
			nodeId = ++this.nodeId;
			node._dnVFXManagedId = nodeId;
			this.tasks[ nodeId ] = {};
		} else {
			nodeId = node._dnVFXManagedId;
			taskId = ++this.taskId;
		}
		
		var newTask = new exports.VFXTaskNode( node );
		this.tasks[ nodeId ][ taskId ] = newTask;
		return newTask;
	},
	
	/**
	 * Stop all remained tasks of passed node.
	 *
	 * @param {GL2.Node} node Target node object.
	 */
	stop: function( node ) {
		
		if (node._dnVFXManagedId) {
			this.tasks[ node._dnVFXManagedId ] = {};
			delete node._dnVFXManagedId;
		}
	},
	
	/**
	 * Reset task groups and start recreating.
	 *
	 * @param {GL2.Node} node Target node object.
	 * @returns {Dn.VFXTaskNode} next job.
	 */
	restart: function( node ) {
		
		this.stop( node );
		return this.enchant( node );
	},
	
	resume: function( node ) {
		if (node._dnVFXManagedId) {
			var nodeId = node._dnVFXManagedId;
			for (var taskId in this.tasks[ nodeId ]) {
				var task = this.tasks[ nodeId ][ taskId ];
				if (task.func === "register") {
					if (task.next.isActive) {
						this.tasks[ nodeId ][ taskId ] = task.next;
					} else {
						var n = this.tasks[ nodeId ][ taskId ].node;
						if (n._dnVFXManagedId) { delete n._dnVFXManagedId; break; }
						delete this.tasks[ nodeId ][ taskId ];
					}
				}
			}
		}		
	},
	
	//--------------------------------------------------------------------------
	removeAllTasks: function() {
		
		for (var nodeId in this.tasks) {
			for (var taskId in this.tasks[ nodeId ]) {
				var n = this.tasks[ nodeId ][ taskId ].node || null;
				if (!n) { break; }
				if (n._dnVFXManagedId) { delete n._dnVFXManagedId; break; }
			}
		}
		this.tasks = {};
	},
	
	//==========================================================================
	// Animation methods
	//--------------------------------------------------------------------------
	end: function() {
		utils.destroyIfAlive(this.node);
		this.isDestroyed = true;
	},
	
	//--------------------------------------------------------------------------
	wait: function( time ) {
		this.finish( time );
	},
	
	//--------------------------------------------------------------------------
	appear: function() {
		this.node.setVisible( true );
		this.finish();
	},
	
	//--------------------------------------------------------------------------
	disappear: function() {
		this.node.setVisible( false );
		this.finish();
	},
	
	//--------------------------------------------------------------------------
	fadeIn: function( duration, alpha ) {
		if (alpha === undefined) { alpha = 1; }
		this.node.setAlpha( (this.progress / duration) * alpha );
		this.finish( duration );
	},
	
	//--------------------------------------------------------------------------
	fadeOut: function( duration, alpha ) {
		if (alpha === undefined) { alpha = 1; }
		this.node.setAlpha( (1 - (this.progress / duration)) * alpha );
		this.finish( duration );
	},
	
	//--------------------------------------------------------------------------
	alpha: function( duration, alpha, easeIn ) {
		if (! this.isInitialized) {
			this.isInitialized = true;
			var a = this.node.getAlpha();
			this.param.startAlpha = a;
			this.param.targetAlpha = alpha + a;
			if (this.param.targetAlpha > 1) {
				this.param.targetAlpha = 1;
			}
			if (this.param.targetAlpha < 0) {
				this.param.targetAlpha = 0;
			}
		}
		
		this.node.setAlpha( this.param.startAlpha + this.easing(duration, alpha, easeIn) );
		if (this.finish( duration )) {
			this.node.setAlpha( this.param.targetAlpha);
		}
	},
	
	//--------------------------------------------------------------------------
	alphaTo: function( duration, alpha, easeIn ) {
		var a = alpha - this.node.getAlpha();
		this.func = 'alpha';
		this.args = [duration, a, easeIn];
	},
	
	//--------------------------------------------------------------------------
	move: function( duration, dx, dy, easeIn ) {
		
		if (! this.isInitialized) {
			var x = this.node.getPosition().getX();
			var y = this.node.getPosition().getY();
			this.isInitialized = true;
			this.param.startX  = x;
			this.param.startY  = y;
			this.param.targetX = x + dx;
			this.param.targetY = y + dy;
		}
		
		this.node.setPosition(
			this.param.startX + this.easing( duration, dx, easeIn ),
			this.param.startY + this.easing( duration, dy, easeIn )
		);
		if (this.finish( duration )) {
			this.node.setPosition( this.param.targetX, this.param.targetY );
		}
 	},
 	
 	//--------------------------------------------------------------------------
	move2: function( obj, cb, duration, dx, dy, easeIn ) {
		
		if (! this.isInitialized) {
			var x = this.node.getPosition().getX();
			var y = this.node.getPosition().getY();
			this.isInitialized = true;
			this.param.startX  = x;
			this.param.startY  = y;
			this.param.targetX = x + dx;
			this.param.targetY = y + dy;
		}
		
		this.node.setPosition(
			this.param.startX + this.easing( duration, dx, easeIn ),
			this.param.startY + this.easing( duration, dy, easeIn )
		);
		
		if (this.finish( duration )) {
			this.node.setPosition( this.param.targetX, this.param.targetY );
			cb.apply(obj, []);
		}
 	},
 	
 	//--------------------------------------------------------------------------
	moveByBezier: function( obj, cb, args, duration, p0, p1, p2, p3, dir, easeIn ) {
		
		if (! this.isInitialized) {
			var x = this.node.getPosition().getX();
			var y = this.node.getPosition().getY();
			var t = (this.progress / duration);
			this.isInitialized = true;
			this.param.p0 = p0;
			this.param.p1 = p1;
			this.param.p2 = p2;
			this.param.p3 = p3;
		}
		
		t = (this.progress / duration);
		x = Bezier.bezier3(t, p0.x, this.param.p1.x, this.param.p2.x, this.param.p3.x);
		y = Bezier.bezier3(t, this.param.p0.y, this.param.p1.y, this.param.p2.y, this.param.p3.y);
		
		this.node.setPosition(x, y);
		
		if (this.finish( duration )) {
			this.node.setPosition( this.param.p3_x, this.param.p3_y );
			cb.apply(obj, args);
		}
 	},
	
	//--------------------------------------------------------------------------
	moveTo: function( duration, tx, ty, easeIn ) {
		
		var dx = tx - this.node.getPosition().getX();
		var dy = ty - this.node.getPosition().getY();
		this.func = 'move';
		this.args = [duration, dx, dy, easeIn];
	},
	
	//--------------------------------------------------------------------------
	scale: function( duration, dScaleX, dScaleY, easeIn ) {

		if (! this.isInitialized) {
			var sx = this.node.getScale().getX();
			var sy = this.node.getScale().getY();
			this.isInitialized = true;
			this.param.startScaleX  = sx;
			this.param.startScaleY  = sy;
			this.param.targetScaleX = sx + dScaleX;
			this.param.targetScaleY = sy + dScaleY;
		}
		
		this.node.setScale(
			this.param.startScaleX + this.easing( duration, dScaleX, easeIn ),
			this.param.startScaleY + this.easing( duration, dScaleY, easeIn )
		);
		this.finish( duration );
		if (this.finish( duration )) {
			this.node.setScale( this.param.targetScaleX, this.param.targetScaleY );
		}
	},

	//--------------------------------------------------------------------------
	scaleTo: function( duration, tScaleX, tScaleY, easeIn ) {
		
		var dsx = tScaleX - this.node.getScale().getX();
		var dsy = tScaleY - this.node.getScale().getY();
		this.func = 'scale';
		this.args = [duration, dsx, dsy, easeIn];
	},

	//--------------------------------------------------------------------------

	rotate: function( duration, dRot, easeIn ) {
		
		if (! this.isInitialized) {
			var rot = this.node.getRotation();
			this.isInitialized = true;
			this.param.startRot  = rot;
			this.param.targetRot = rot + dRot;
		}
		
		this.node.setRotation(
			this.param.startRot + this.easing( duration, dRot, easeIn )
		);
		if (this.finish( duration )) {
			this.node.setRotation( this.param.targetRot );
		}
	},
	
	//--------------------------------------------------------------------------
	rotateTo: function( duration, tRot, easeIn ) {
		
		var dRot = tRot - this.node.getRotation();
		this.func = 'rotate';
		this.args = [duration, dRot, easeIn];
	},
	
	//--------------------------------------------------------------------------
	color: function( duration, dr, dg, db, easeIn ) {
		
		if (! this.isInitialized) {
			this.isInitialized = true;
			this.param.startR  = this.node.getColor().getRed();
			this.param.targetR = this.param.startR + dr;
			this.param.startG  = this.node.getColor().getGreen();
			this.param.targetG = this.param.startG + dg;
			this.param.startB  = this.node.getColor().getBlue();
			this.param.targetB = this.param.startB + db;
		}
		
		this.node.setColor(
			this.param.startR + this.easing( duration, dr, easeIn ),
			this.param.startG + this.easing( duration, dg, easeIn ),
			this.param.startB + this.easing( duration, db, easeIn )
		);
		if (this.finish( duration )) {
			this.node.setColor(
				this.param.targetR,
				this.param.targetG,
				this.param.targetB
			);
		}
	},
	
	//--------------------------------------------------------------------------
	colorTo: function( duration, tr, tg, tb, easeIn ) {
		
		var dr = tr - this.node.getColor().getRed();
		var dg = tg - this.node.getColor().getGreen();
		var db = tb - this.node.getColor().getBlue();
		this.func = 'color';
		this.args = [duration, dr, dg, db, easeIn];
	},
	
	//--------------------------------------------------------------------------
	hop: function ( velocity, gravity ) {

		if (! this.isInitialized) {
			this.isInitialized = true;
			this.param.vecY = -velocity;
			this.param.baseLineY = this.node.getPosition().getY();
			this.param.hopCount = 10;
		}
		var x = this.node.getPosition().getX();
		var y = this.node.getPosition().getY();
		this.param.vecY += gravity;
		y += this.param.vecY;
		this.node.setPosition( x, y );

		if (y > this.param.baseLineY) {
			y = this.param.baseLineY;
			this.node.setPosition( x, y );
			this.param.vecY *= -0.7;
			this.param.hopCount -= 1;
			if (this.param.hopCount == 0) { this.finish(); }
			if (Math.abs( this.param.vecY ) < 0.1) { this.finish(); }
		}
	},
	
	blink: function (duration, term, alphas) {
		var progress = this.progress % term / term;
		var alpha = alphas[0] * (1 - progress) + alphas[1] * progress;
		this.node.setAlpha( alpha );
		this.finish( duration );
	},
	
	finish: function () {
		this.finish();
	},
	
	//==========================================================================
	//--------------------------------------------------------------------------
	onUpdate: function() {
		var delta = Timekeeper.getPassedSec();
		
		for (var nodeId in this.tasks) {
			for (var taskId in this.tasks[ nodeId ]) {
				
				//----- 途中で task が destroy された
				if (! this.tasks[ nodeId ]) { continue; }
				
				var t = this.tasks[ nodeId ][ taskId ];
				if (! t.isActive) { continue; }
				t.progress += delta;
				t.delta     = delta;
				
				//----- call function
				if (typeof( t.func ) === 'function') {
					t.func.apply( t, t.args );
				} else {
					this[ t.func ].apply( t, t.args );
				}
				
				if (t.isDestroyed) {
					delete this.tasks[ nodeId ];
				}
				else if (t.isFinished) {
					if (t.next.isActive) {
						this.tasks[ nodeId ][ taskId ] = t.next;
					} else {
						var n = this.tasks[ nodeId ][ taskId ].node;
						if (n._dnVFXManagedId) { delete n._dnVFXManagedId; }
						delete this.tasks[ nodeId ][ taskId ];
					}
				}
			}
			//----- 途中で node が destroy された
			if (! this.tasks[ nodeId ]) { continue; }
		}
	}	
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo/Service/Graphics/ParticleEmitter'] = function(){var exports = $MODULE_REGISTRY['NGGo/Service/Graphics/ParticleEmitter'] || {}; $MODULE_REGISTRY['NGGo/Service/Graphics/ParticleEmitter'] = exports; 
var __dirname = 'NGGo/Service/Graphics';
var __filename = 'NGGo/Service/Graphics/ParticleEmitter.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author     Takushima Nobutaka
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter   = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Core       = require('NGCore/Client/Core').Core;
var Node       = require('NGCore/Client/GL2/Node').Node;
var Sprite     = require('NGCore/Client/GL2/Sprite').Sprite;
var Animation  = require('NGCore/Client/GL2/Animation').Animation;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;

var Vector2    = require('NGGo/Foundation/Math/Vector2').Vector2;
var Ops        = require('NGGo/Foundation/Math/Ops').Ops;

var randomMinusOneToOne = Ops.randomMinusOneToOne;

/** @private */
var degreesToRadians = function(angle)
{
    return angle / 180.0 * Math.PI;
};

/** @private */
var color4Make = function(r, g, b, a)
{
    return {r: r, g: g, b: b, a: a};
};

/** @private */
var ParticleType =
{
    Gravity: 0,
    Radial: 1
};

/** @private */
var ParticleEmitterBody = MessageListener.subclass(
{
    classname: 'ParticleEmitterBody',

    initialize: function(root, config)
    {
        this._config = config;
        this._particleCount = 0;
        this._emissionRate = this._config.maxParticles / this._config.particleLifespan;
        this._emitCounter = 0.0;
        this._elapsedTime = 0.0;
        this._active = true;
        this._particleIndex = 0;
        this._particles = null;
        this._sprites = null;

        this._setupArrays(root);
        UpdateEmitter.addListener(this, this._updateWithDelta);
    },

    destroy: function()
    {
        UpdateEmitter.removeListener(this);
        var i;
        for(i=0; i < this._sprites.length; i++)
        {
            var sprite = this._sprites[i];
            sprite.getAnimation().destroy();
            sprite.destroy();
        }
    },

    start: function()
    {
        this._active = true;
        this._elapsedTime = 0.0;
        this._emitCounter = 0.0;
    },

    stop: function()
    {
        this._active = false;
        this._elapsedTime = 0.0;
        this._emitCounter = 0.0;
    },

    _setupArrays: function(root)
    {
        this._particles = new Array(this._config.maxParticles);
        this._sprites = new Array(this._config.maxParticles);
        var i;
        for(i=0; i < this._particles.length; i++)
        {
            var particle =
            {
                position: new Vector2(),
                direction: new Vector2(),
                startPos: new Vector2(),
                color: color4Make(),
                colorPerSecond: color4Make(),
                radialAcceleration: 0.0,
                tangentialAcceleration: 0.0,
                radius: 0.0,
                radiusPerSecond: 0.0,
                angle: 0.0,
                degreesPerSecond: 0.0,
                particleSize: 0.0,
                particleSizePerSecond: 0.0,
                rotation: 0.0,
                rotationPerSecond: 0.0,
                timeToLive: 0.0
            };
            this._particles[i] = particle;
        }

        var blendMode;
        if(this._config.blendFuncSource === 770 && this._config.blendFuncDestination === 1) // GL_SRC_ALPHA(0x0302) && GL_ONE(1)
        {
            blendMode = Animation.BlendMode.Add;
        }
        else
        {
            blendMode = Animation.BlendMode.Alpha;
        }

        for(i=0; i < this._sprites.length; i++)
        {
            var sprite = new Sprite();
            var animation = new Animation();
            animation.pushFrame(new Animation.Frame(this._config.texturePath, 0, [1, 1]));
            animation.setBlendMode(blendMode);
            sprite.setAnimation(animation);
            sprite.setVisible(false);
            root.addChild(sprite);
            this._sprites[i] = sprite;
        }
    },

    _initParticle: function(particle)
    {
        var cnf = this._config;

        particle.position.x = cnf.sourcePosition.x + cnf.sourcePositionVariance.x * randomMinusOneToOne();
        particle.position.y = cnf.sourcePosition.y + cnf.sourcePositionVariance.y * randomMinusOneToOne();
        particle.startPos.x = cnf.sourcePosition.x;
        particle.startPos.y = cnf.sourcePosition.y;

        var newAngle = degreesToRadians(cnf.angle + cnf.angleVariance * randomMinusOneToOne());
        var vector = new Vector2(Math.cos(newAngle), Math.sin(newAngle));
        var vectorSpeed = cnf.speed + cnf.speedVariance * randomMinusOneToOne();

        particle.direction = vector.scale(vectorSpeed);

        particle.radius = cnf.maxRadius + cnf.maxRadiusVariance * randomMinusOneToOne();
        particle.radiusPerSecond = cnf.maxRadius / cnf.particleLifespan;
        particle.angle = degreesToRadians(cnf.angle + cnf.angleVariance * randomMinusOneToOne());
        particle.degreesPerSecond = degreesToRadians(cnf.rotatePerSecond + cnf.rotatePerSecondVariance * randomMinusOneToOne());

        particle.radialAcceleration = cnf.radialAcceleration;
        particle.tangentialAcceleration = cnf.tangentialAcceleration;

        particle.timeToLive = Math.max(0.0, cnf.particleLifespan + cnf.particleLifespanVariance * randomMinusOneToOne());

        var particleStartSize = cnf.startParticleSize + cnf.startParticleSizeVariance * randomMinusOneToOne();
        var particleFinishSize = cnf.finishParticleSize + cnf.finishParticleSizeVariance * randomMinusOneToOne();
        particle.particleSizePerSecond = (particleFinishSize - particleStartSize) / particle.timeToLive;
        particle.particleSize = Math.max(0.0, particleStartSize);

        var rotationStart = cnf.rotationStart + cnf.rotationStartVariance * randomMinusOneToOne();
        var rotationEnd = cnf.rotationEnd + cnf.rotationEndVariance * randomMinusOneToOne();
        particle.rotationPerSecond = (rotationEnd - rotationStart) / particle.timeToLive;
        particle.rotation = rotationStart;

        var start = color4Make();
        var startColor = cnf.startColor;
        var startColorVariance = cnf.startColorVariance;
        start.r = startColor.r + startColorVariance.r * randomMinusOneToOne();
        start.g = startColor.g + startColorVariance.g * randomMinusOneToOne();
        start.b = startColor.b + startColorVariance.b * randomMinusOneToOne();
        start.a = startColor.a + startColorVariance.a * randomMinusOneToOne();

        var end = color4Make();
        var finishColor = cnf.finishColor;
        var finishColorVariance = cnf.finishColorVariance;
        end.r = finishColor.r + finishColorVariance.r * randomMinusOneToOne();
        end.g = finishColor.g + finishColorVariance.g * randomMinusOneToOne();
        end.b = finishColor.b + finishColorVariance.b * randomMinusOneToOne();
        end.a = finishColor.a + finishColorVariance.a * randomMinusOneToOne();

        particle.color = start;
        var colorPerSecond = particle.colorPerSecond;
        var timeToLive = particle.timeToLive;
        colorPerSecond.r = (end.r - start.r) / timeToLive;
        colorPerSecond.g = (end.g - start.g) / timeToLive;
        colorPerSecond.b = (end.b - start.b) / timeToLive;
        colorPerSecond.a = (end.a - start.a) / timeToLive;
    },

    _addParticle: function()
    {
        if(this._particleCount === this._config.maxParticles)
        {
            return false;
        }

        var particle = this._particles[this._particleCount];
        this._initParticle(particle);

        this._particleCount++;

        return true;
    },

    _updateWithDelta: function(delta)
    {
        var cnf = this._config;
        delta = delta / 1000;

        if(this._active && this._emissionRate)
        {
            var rate = 1.0 / this._emissionRate;
            this._emitCounter += delta;
            while(this._particleCount < cnf.maxParticles && this._emitCounter > rate)
            {
                this._addParticle();
                this._emitCounter -= rate;
            }

            this._elapsedTime += delta;
            if(cnf.duration !== -1 && cnf.duration < this._elapsedTime)
            {
                this.stopParticleEmitter();
            }
        }

        this._particleIndex = 0;

        while(this._particleIndex < this._particleCount)
        {
            var currentParticle = this._particles[this._particleIndex];
            var currentPosition = currentParticle.position;

            currentParticle.timeToLive -= delta;

            if(currentParticle.timeToLive > 0.0)
            {
                if(cnf.emitterType === ParticleType.Radial)
                {
                    currentParticle.angle += currentParticle.degreesPerSecond * delta;
                    currentParticle.radius -= currentParticle.radiusPerSecond * delta;
                    currentPosition = new Vector2(
                        cnf.sourcePosition.x - Math.cos(currentParticle.angle) * currentParticle.radius,
                        cnf.sourcePosition.y - Math.sin(currentParticle.angle) * currentParticle.radius);
                    if(currentParticle.radius < cnf.minRadius)
                    {
                        currentParticle.timeToLive = 0.0;
                    }
                }
                else
                {
                    var radial, tangential;
                    currentPosition.sub(currentParticle.startPos);

                    if(currentPosition.x || currentPosition.y)
                    {
                        radial = currentPosition.clone();
                        radial.normalize();
                    } else {
                        radial = new Vector2();
                    }
                    tangential = radial.clone();
                    radial.scale(currentParticle.radialAcceleration);

                    var newy = tangential.x;
                    tangential.x = -tangential.y;
                    tangential.y = newy;
                    tangential.scale(currentParticle.tangentialAcceleration);
                    currentParticle.direction.scale_and_add(delta, radial.add(tangential).add(cnf.gravity));
                    currentPosition.scale_and_add(delta, currentParticle.direction);
                    currentPosition.add(currentParticle.startPos);
                }
                var colorPerSecond = currentParticle.colorPerSecond;
                var currentColor = currentParticle.color;
                currentColor.r += colorPerSecond.r * delta;
                currentColor.g += colorPerSecond.g * delta;
                currentColor.b += colorPerSecond.b * delta;
                currentColor.a += colorPerSecond.a * delta;

                this._sprites[this._particleIndex].setPosition(~~(currentPosition.x),
                                                               ~~(-currentPosition.y));

                currentParticle.particleSize += currentParticle.particleSizePerSecond * delta;
                var scale = Math.max(0.0, currentParticle.particleSize);
                this._sprites[this._particleIndex].setScale(scale, scale);
                currentParticle.rotation += currentParticle.rotationPerSecond * delta;
                this._sprites[this._particleIndex].setRotation(~~(-currentParticle.rotation));
                this._sprites[this._particleIndex].setColor(currentColor.r, currentColor.g, currentColor.b);
                this._sprites[this._particleIndex].setAlpha(currentColor.a);
                this._sprites[this._particleIndex].setVisible(true);

                this._particleIndex++;
            }
            else
            {
                if(this._particleIndex !== this._particleCount - 1)
                {
                    var tmp = this._particles[this._particleIndex];
                    this._particles[this._particleIndex] = this._particles[this._particleCount - 1];
                    this._particles[this._particleCount - 1] = tmp;
                }
                this._particleCount--;

                this._sprites[this._particleCount].setVisible(false);
            }
        }
    }
});

var ParticleEmitter = Node.subclass(
/** @lends Service.Graphics.ParticleEmitter.prototype */
{
    classname: 'ParticleEmitter',

    /**
     * @class This class loads ParticleDesigner's plist and plays a particle animation. New emitter plays effect automatically.
     * @example
     * var particle = new ParticleEmitter("Content/watersplash.plist");
     * particle.setPosition(2/w, 2/h);
     * GL2.Root.addChild(particle);
     * @constructs Default constructor.
     * @name Service.Graphics.ParticleEmitter
     * @augments GL2.Node
     * @param {String} plistPath ParticleDesigner's output file paths.
     */
    initialize: function(plistPath)
    {
        this._body = null;

        var that = this;
        FileSystem.readFile(plistPath, false, function(err, data)
        {
            if(!err)
            {
                that._body = new ParticleEmitterBody(that, that._parsePlist(plistPath, data));
            }
        });
    },

    /**
     * Destroys all used resources and remove graphics.
     */
    destroy: function()
    {
        if(this._body)
        {
            this._body.destroy();
        }
    },

    /**
     * Starts particle animation.
     */
    start: function()
    {
        if(this._body)
        {
            this._body.start();
        }
    },

    /**
     * Stops particle animation.
     */
    stop: function()
    {
        if(this._body)
        {
            this._body.stop();
        }
    },

    /** @private */
    _plistToJSON: function(plist)
    {
        var json = {};
        var re = /<key>(.+)<\/key>\s*<(\w+)>(.+)<\/\w+>/gm;
        var m = re.exec(plist);
        while(m)
        {
            var key = m[1];
            var value = (m[2] === 'string') ? m[3] : Number(m[3]);
            json[key] = value;
            m = re.exec(plist);
        }
        return json;
    },

    /** @private */
    _parsePlist :function(plistPath, data)
    {
        var config = this._plistToJSON(data);
        config.sourcePosition = new Vector2();
        config.sourcePositionVariance = new Vector2(config.sourcePositionVariancex,
                                                    config.sourcePositionVariancey);
        config.gravity = new Vector2(config.gravityx, config.gravityy);
        config.startColor = color4Make(config.startColorRed, config.startColorGreen,
                                       config.startColorBlue, config.startColorAlpha);
        config.startColorVariance = color4Make(config.startColorVarianceRed, config.startColorVarianceGreen,
                                               config.startColorVarianceBlue, config.startColorVarianceAlpha);
        config.finishColor = color4Make(config.finishColorRed, config.finishColorGreen,
                                        config.finishColorBlue, config.finishColorAlpha);
        config.finishColorVariance = color4Make(config.finishColorVarianceRed, config.finishColorVarianceGreen,
                                                config.finishColorVarianceBlue, config.finishColorVarianceAlpha);
        var dirname = plistPath.substring(0, plistPath.lastIndexOf("/"));
        config.texturePath = (dirname ? (dirname + "/") : "") + config.textureFileName;
        return config;
    }
});

exports.ParticleEmitter = ParticleEmitter;
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/controller/BattleSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/controller/BattleSceneController'] || {}; $MODULE_REGISTRY['Code/module/battle/controller/BattleSceneController'] = exports; 
var __dirname = 'Code/module/battle/controller';
var __filename = 'Code/module/battle/controller/BattleSceneController.js';

/**
 * @author sonnn
 */

var Core 			= require('NGCore/Client/Core').Core;
var GL2  			= require('NGCore/Client/GL2').GL2;
var VFX 			= require('NGGo/Service/Graphics/VFX/VFX').VFX;
var SceneDirector 	= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 	= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var ParticleEmitter = require('NGGo/Service/Graphics/ParticleEmitter').ParticleEmitter;
var Logger 			= require('Code/utils/Logger').Logger;

var MoveListener = Core.MessageListener.subclass({
	initialize: function(controller, offsetX, step) {
		this._controller = controller;
		this._offsetX = offsetX;
		this._step = step;
		this._dirY = 1;
		this._currentDirection1 = 1;
		this._currentDirection2 = -1;
		this._done = false;
		this._counter = 0;
		this._dCounter = 0;
		this._alpha = 1;
		this._died = false;
		this._hasFightedE = false;
		this._hasFightedS = false;
		this._fightReady = false;
		this._fCounter = 0;
		
		this._newX1 = this._controller.sumo.getPosition().getX();
		this._newY1 = this._controller.sumo.getPosition().getY();
		
		this._newX2 = this._controller.enemy.getPosition().getX();
		this._newY2 = this._controller.enemy.getPosition().getY();
		
		this._maxY = this._newY1 + 10;
		this._newY = this._newY1;
		this._minY = this._newY1 - 10;
		this._orgY = this._newY1;
		
		this._maxX11 = this._newX1 + offsetX + 10;
		this._maxX12 = this._maxX11 - 15;
		
		this._maxX21 = this._newX2 - offsetX - 10;
		this._maxX22 = this._maxX21 + 15;
		
		this._fMaxX1 = this._maxX11 + (this._maxX21 - this._maxX11);
		this._fMaxX2 = this._maxX21 - (this._maxX21 - this._maxX11);
	},
	
	_damage: function(isEnemy) {
		this._isDamagedE = true;
		this._isDamagedS = false;
		
		var obj = this._controller.enemy;
		
		if (!isEnemy) {
			this._isDamagedE = false;
			this._isDamagedS = true;
			obj = this._controller.sumo
		}
		
		obj.setAnim(null, "damaged");
		obj.setColor(1, 0, 0);
	},
	
	_resetObj: function(isEnemy) {
		this._isDamagedE = false;
		this._isDamagedS = false;
		
		this._controller.sumo.setAnim(null, "stand");
		this._controller.enemy.setAnim(null, "stand");
		
		this._controller.sumo.setColor(1, 1, 1);
		this._controller.sumo.setAlpha(1);
		this._controller.sumo.setRotation(0);
		this._controller.enemy.setColor(1, 1, 1);
		this._controller.enemy.setAlpha(1);
		this._controller.enemy.setRotation(0);
		this._controller.sumo.setPosition(this._controller.sumo.getPosition().getX(), this._orgY);
		this._controller.enemy.setPosition(this._controller.enemy.getPosition().getX(), this._orgY);
		this._newY = this._orgY;
	},
	
	onUpdate: function(delta) {
		
		if (this._controller.isFighting) {
			this._fCounter += 10;
			
			if ((this._fCounter / 50) >= 1) {
				this._fightReady = true;
				this._fCounter = 0;
			}
		}
		
		// Beginning time
		if (!this._done) {
			this._newX1 += this._step;
			this._newX2 -= this._step;
			
			this._done = (this._newX1 >= this._maxX11) ? true : false;
			this._controller.sumo.setPosition(this._newX1, this._newY1);
			this._controller.enemy.setPosition(this._newX2, this._newY2);
		}
		
		// Standing
		if (this._done && !this._fightReady) {
						
			this._newX1 += this._currentDirection1 * 1.8;
			this._newX2 += this._currentDirection2 * 1.8;
			
			// Sumo
			if (this._newX1 <= this._maxX11 && this._currentDirection1 == 1) {
				this._controller.sumo.setPosition(this._newX1, this._newY1);
			} else {
				this._currentDirection1 = -1;
				if (this._newX1 >= this._maxX12) {
					this._controller.sumo.setPosition(this._newX1, this._newY1);
				} else {
					this._currentDirection1 = -this._currentDirection1;
				}
			}
			
			// Enemy
			if (this._newX2 >= this._maxX21 && this._currentDirection2 == -1) {
				this._controller.enemy.setPosition(this._newX2, this._newY2);
			} else {
				this._currentDirection2 = 1;
				if (this._newX2 <= this._maxX22) {
					this._controller.enemy.setPosition(this._newX2, this._newY2);
				} else {
					this._currentDirection2 = -this._currentDirection2;
				}
			}
			
		// Fighting
		} else if (this._controller.isFighting && this._fightReady) {
			
			// Sumo turn
			if (!this._controller.enemyTurn) {
				var sumo = this._controller.sumo;
				
				// Normal skill
				if (this._controller._skillTypeS == 1) {
					sumo.setAlpha(sumo.getAlpha() + 0.2);
					
					this._newX1 += this._step;
					if (this._newX1 <= this._fMaxX1) {
						sumo.setPosition(this._newX1, this._newY1);
					} else {
						this._hasFightedE = true;
					}
				
				// Advanced skill
				} else {
					if (!this._controller.isFightingE) {
						this._controller.isFightingE = true;
						sumo.fight(this._controller._skillTypeS, "ENEMY");
					}
					
					this._hasFightedE = sumo.getFightStatus();
				}
					
				// Sumo has fighted enemy
				if (this._hasFightedE) {
					sumo.resetFightStatus();
					var isEnemy = true;
					this._damage(isEnemy);
					sumo.setAnim(null, "stand");
					this._controller.enemyHp -= Math.round(this._controller.enemy.hp / sumo.attackNum);
					this._controller.enemyHp = this._controller.enemyHp <= 0 ? 0 : this._controller.enemyHp;
					this._controller.updateHpBar(undefined, undefined, this._controller.enemyHp, this._controller.enemy.hp);
					
					this._newX1 = this._maxX11;
					this._controller.enemyTurn = true;
					this._controller.isFighting = false;
					this._fightReady = false;
					this._controller.isFightingE = false;
					this._hasFightedE = false;
				}
				
			// Enemy turn				
			} else if (this._controller.enemyTurn && this._controller.isFighting) {
				var enemy = this._controller.enemy;
				
				// Normal skill
				if (this._controller._skillTypeE == 1) {
					enemy.setAlpha(enemy.getAlpha() + 0.2);
					
					this._newX2 -= this._step;
					if (this._newX2 >= this._fMaxX2) {
						enemy.setPosition(this._newX2, this._newY2);
					} else {
						this._hasFightedS = true;
					}
				
				// Advanced skill
				} else {
					if (!this._controller.isFightingS) {
						this._controller.isFightingS = true;
						enemy.fight(this._controller._skillTypeE, "SUMO");
					}
					
					this._hasFightedS = enemy.getFightStatus();
				}
					
				// Enemy has fighted sumo
				if (this._hasFightedS) {
					enemy.resetFightStatus();
					var isEnemy = false;
					this._damage(isEnemy);
					enemy.setAnim(null, "stand");
					
					this._controller.sumoHp -= Math.round(this._controller.sumo.hp / this._controller.enemy.attackNum);
					this._controller.sumoHp = this._controller.sumoHp <= 0 ? 0 : this._controller.sumoHp;
					this._controller.updateHpBar(this._controller.sumoHp, this._controller.sumo.hp, undefined, undefined);
					
					this._newX2 = this._maxX21;
					this._controller.enemyTurn = false;
					this._controller.isFighting = false;
					this._fightReady = false;
					this._controller.isFightingS = false;
					this._hasFightedS = false;
				}
			}
		}
		
		// Effect in case that Sumo || Enemy is damaged
		if (this._isDamagedE || this._isDamagedS) {
			this._dCounter += 50;
			
			var obj = null;
			if (this._isDamagedE) {
				obj = this._controller.enemy;
			} else {
				obj = this._controller.sumo;
			}
			
			if (!this._died) {
			
				var x = obj.getPosition().getX();
				this._newY += this._dirY * 10;
			
				if (this._newY <= this._maxY && this._dirY == 1) {
					obj.setPosition(x, this._newY);
				} else {
					this._dirY = -1;
					// if (this._controller.enemyHp && this._controller.sumoHp) {
						// this._dirY = -1;
					// } else {
						// this._died = true;
					// }

					if (this._newY >= this._minY) {
						obj.setPosition(x, this._newY);
					} else {
						obj.setPosition(x, this._minY);
						this._dirY = 1;
					}
				}			
			} else {
				// this._alpha -= 0.05;
				// obj.setAlpha(this._alpha);
				// var s = obj.getScale();
				// obj.setScale(s.getX() > 0 ? s.getX() - 0.05 : s.getX() + 0.05, s.getY() - 0.05);
			}
			
			var d = 0.5;
			
			if ((this._dCounter / 1000) >= d && this._controller.enemyHp == 0) {
				this._controller.sumo.setAnim(null, "stand");
			}
			
			// if (this._controller.enemyHp == 0 || this._controller.sumoHp == 0) {
				// d = 1.5;
			// }
			
			if ((this._dCounter / 1000) >= d) {
				this._dCounter = 0;
				
				// if (this._controller.enemyHp == 0 || this._controller.sumoHp == 0) {
					// this.destroy();
					// SceneDirector.pop();
				// }
				
				this._resetObj();
				
				this._controller.skill.reset();
				this._controller.skill.setPosition(-500, this._newY1);
				
				this._controller.resetSkillSlot(this._controller._skillTypeS);
				this._controller.resetSkillSlot(this._controller._skillTypeE, true);
			}
		}
		
		this._counter += 50;
		
		if (this._done && !this._controller.isFighting && !this._controller._light[2] ) { //&& this._controller.enemyHp != 0 && this._controller.sumoHp != 0) {
			this._counter = 0;
			
			if (this._controller.enemyTurn) {
				this._controller.fightSumo();
			} else {
				this._controller.fightEnemy();
			}
		}
	}	
});

var battleSceneController = 
{
	
	initialize: function() {
		this.currentBattle = "";
		this.enemyTurn = false;
		this.isFightingE = false;
		this.isFightingS = false;
		this.isFighting = false;
		this._skillTypeS = 0;
		this._skillTypeE = 0;
		this._light = [];
		this._lightCount = 0;
	},
	
	action_click: function (elem, buttnName) {
        console.log('You clicked ' + buttnName + '!');
        
        if (buttnName === "Home") {
        	this._mvListener.destroy();
        	SceneDirector.pop();
        }
    },
    
    updateHpBar: function(playerHp, maxPlayerHp, enemyHp, maxEnemyHp) {
		if (playerHp >= 0) {
			this.HUD.PlayerHp.setScale(playerHp/maxPlayerHp, 1);
		}
		
		if (enemyHp >= 0) {
			this.HUD.EnemyHp.setScale(-enemyHp/maxEnemyHp, 1);
		}
	},
	
	highlightSkillSlot: function(skillType, isEnemy) {
	    Logger.log("skillType = " + skillType);
	    var d = isEnemy ? -1 : 1;
	    var x = isEnemy ? 3 : 0;
		this.HUD[skillType + x].setColor(0, 0.7, 0.5);
		
		var pos = this.HUD[skillType + x].getPosition();
		var obj = isEnemy ? this.enemy : this.sumo;
		p0 = {x: pos.getX(), y: pos.getY()};
		p3 = {x: obj.getPosition().getX(), y: obj.getPosition().getY()};
		
		
		var epsilon = 100;
		for (var i = 0; i < 3; i++) {
			this._light[i] = new GL2.Sprite();
			this._light[i].setImage("Content/battle/effect/light.png", new Core.Size(30, 30), new Core.Point(0,0));
			this._light[i].setPosition(pos.getX() - 3, pos.getY());
			this.HUD.addChild(this._light[i]);
			
			epsilon *= (i + 0.5) * d;
			
			p1 = {x: p0.x + epsilon * (d == 1 && i == 0 ? -2 : 1), y: p0.y - 10};
			p2 = {x: p0.x + epsilon, y: p0.y - 90};
			
			VFX.enchant(this._light[i]).moveByBezier(this, this.beginFighting, [skillType, isEnemy], 1, p0, p1, p2, p3, 0);
		}
	},
	
	beginFighting: function(skillType, isEnemy) {
		Logger.log("function = beginFighting");
		
		if (this._light[this._lightCount]) {
			this.HUD.removeChild(this._light[this._lightCount]);
			delete this._light[this._lightCount];
		}
		
		this._lightCount++;
		
		if (this._lightCount == 3) {
		
			this.isFighting = true;
			var obj = (skillType == 1 && isEnemy) ? this.enemy : ((skillType == 1) ? this.sumo : null);
			var obj2 = isEnemy ? this.enemy : this.sumo;
			
			if (obj) {
				obj.setAlpha(0);
			}				obj2.setAnim(null, "attack");
			this._lightCount = 0;
		}
	},
	
	resetSkillSlot: function(skillType, isEnemy) {
		Logger.log("skillType = " + skillType);
		var x = isEnemy ? 3 : 0;
		this.HUD[skillType + x].setColor(1, 1, 1);
	},
	
	initData: function(sumoObj, isEnemy) {
		var hp = 200;
		var ap = 1000;
		var dp = 400;
		var isBoss = false;
		var skillType = 1;
		var name = "dragon";
		
		if (isEnemy) {
			if (this.currentBattle === "Battle1") {
				ap = 600;
				dp = 300;
				isBoss = true;
			} else {
				ap = 1600;
				dp = 600;
			}
		}
		
		sumoObj.hp = hp;
		sumoObj.ap = ap;
		sumoObj.dp = dp;
		sumoObj.skillType = skillType;
		sumoObj.isBoss = isBoss;
		sumoObj.name = name;
	},
	
	setup: function(sumo, enemy, skill) {
		this.sumo = sumo;
		this.enemy = enemy;
		this.skill = skill;
		
		// Populate properties
		this.initData(this.sumo, false);
		this.initData(this.enemy, true);
		
		// Calculate attacking capability
		var delta = this.sumo.ap - this.enemy.ap;
		var attackNum1 = 10;
		var attackNum2 = 10;
		
		if (delta > 0) {
			attackNum1 = 10 - 10 * (delta / this.enemy.ap)
			attackNum2 = 10 - 10 * (delta / this.sumo.ap)
		} else {
			attackNum1 = 10 - 10 * (-delta / this.enemy.ap)
			attackNum2 = 10 - 10 * (-delta / this.sumo.ap)
		}
		
		if (attackNum1 > 0) {
			this.sumo.attackNum = Math.floor(attackNum1);
			this.enemy.attackNum = Math.floor(attackNum2);
		} else {
			if (delta > 0) {
				this.sumo.attackNum = 1;
				this.enemy.attackNum = Math.floor(attackNum2);
			} else {
				this.sumo.attackNum = Math.floor(attackNum2);
				this.enemy.attackNum = 1;
			}
		}
		
		this.enemyHp = this.enemy.hp;
		this.sumoHp = this.sumo.hp;
		this.HUD.avatar1.setScale(-1, 1);
		this.HUD.EnemyHp.setScale(-1, 1);
		this.HUD["5"].setVisible(false);
		this.HUD["6"].setVisible(false);
		
		if (this.currentBattle === "Battle2") {
			this.enemy.name = "bull2";
			this.enemy.setScale(1, 1);
			this.HUD["5"].setVisible(true);
			this.HUD["6"].setVisible(true);
		}
		
		enemy.setAnim(null, "stand");
		sumo.setAnim(null, "stand");
		
		this.MainGame.addChild(sumo.getAnim());
		this.MainGame.addChild(enemy.getAnim());
		this.MainGame.addChild(skill.getAnim());
		
		this._mvListener = new MoveListener(this, 220, 50);
    	Core.UpdateEmitter.addListener(this._mvListener, this._mvListener.onUpdate);
	},
	
	fightEnemy: function() {
		this.skill.setRotation(180);
		var skillType = this.getRandomSkill(false, true);

		this.highlightSkillSlot(skillType);
	},
	
	fightSumo: function() {
		var skillType = this.enemy.isBoss ? this.enemy.skillType : this.getRandomSkill(false);
		this._skillTypeE = skillType;
		this.skill.setRotation(0);
		this.skill.setPosition(1000, this.skill.getPosition().getY());

		this.highlightSkillSlot(skillType, true);
	},
	
	getRandomSkill: function(isEnemy, isLeftSumo) {
		if (isEnemy) {
			this._skillTypeE = 1;
			return this._skillTypeE; 
		} else {
			var s = (this._skillTypeS + 1) % 3;
			var e = (this._skillTypeE + 1) % 3;
			this._skillTypeS = s == 0 ? 3 : s;
			this._skillTypeE = e == 0 ? 3 : e;
			
			return this._skillTypeS;
		}
	},
	
	addChild: function(child) {
		this.MainGame.addChild(child);
	}
};

exports.BattleSceneController = Core.Class.subclass(battleSceneController);; return exports;};
$MODULE_FACTORY_REGISTRY['Code/model/Entity/ModelBase'] = function(){var exports = $MODULE_REGISTRY['Code/model/Entity/ModelBase'] || {}; $MODULE_REGISTRY['Code/model/Entity/ModelBase'] = exports; 
var __dirname = 'Code/model/Entity';
var __filename = 'Code/model/Entity/ModelBase.js';

var Core = require('NGCore/Client/Core').Core;

exports.ModelBase = Core.MessageListener.subclass({
    classname: 'ModelBase',

    initialize: function (d) {
        this._listeners = [];
        this._setParams(d || {});
    },

    addListener: function (id, func) {
        for (var i = 0; i < this._listeners.length; i++) {
            if (this._listeners[i]["id"] === id) {
                return;
            }
        }
        this._listeners.push({"id": id, "func": func});
    },

    removeLister: function (id) {
        for (var i = 0; i < this._listeners.length; i++) {
            if (this._listeners[i]["id"] === id) {
                this._listeners.splice(i, 1);
                return;
            }
        }
    },

    removeAllListers: function() {
        this._listeners = [];
    },

    destroy: function() {
        this.removeAllListers();
    },

    dispath: function() {
        for (var i = 0; i < this._listeners.length; i++) {
            this._listeners[i]["func"](this);
        }
    },

    update: function(d) {
        this._setParams(d);
        this.dispath();
    },

    _setParams: function(d) {}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/model/Entity/Sumo'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/model/Entity/Sumo'] || {}; $MODULE_REGISTRY['Code/module/battle/model/Entity/Sumo'] = exports; 
var __dirname = 'Code/module/battle/model/Entity';
var __filename = 'Code/module/battle/model/Entity/Sumo.js';

var GL2		  			= require('NGCore/Client/GL2').GL2;
var AnimationManager 	= require('NGGo/Framework/AnimationManager').AnimationManager;
var ModelBase 			= require('Code/model/Entity/ModelBase').ModelBase;

exports.Sumo = ModelBase.subclass({
    classname: "Sumo",

    _setParams: function (d) {
        d = d || {};
        
        this.name = d.name || "";
        this.type = d.type || "";
        this.hp = d.hp || 0;
        this.attack = d.attack || 0;
        this.attackInterval = d.attackInterval || 0;
        this.defense = d.defense || 0;
        this.speed = d.speed || 0;
        this._skill = null;
        
        this._node = new GL2.Node();
        this._sprite = new GL2.Sprite();
        this._node.addChild(this._sprite);
        
		this._frameDuration = 300;          
        this._sprite = new GL2.Sprite();
        this._sprite.setAnimation(AnimationManager.getAnimationGL2("dragon", "stand", this._frameDuration));
    },
    
    fight: function(skillType, target) {
    	var p = this.getPosition();
    	var d = target == "ENEMY" ? 1 : -1; 
    	this._skill.setPosition(p.getX() + 270 * d, p.getY() - 15);
    	this._skill.present(skillType, d);
    },
    
    getFightStatus: function() {
    	return this._skill.isFinished; 
    },
    
    resetFightStatus: function() {
    	this._skill.isFinished = false;
    },
    
    updateHp: function(hp) {
    	this.hp += hp;
    },
    
    getHp: function() {
    	return this.hp || 0;
    },
    
    getNode:function() {
    	return this._node;
    },
    
    getAnim:function() {
    	return this._sprite;
    },
    
    setSkill: function(skill) {
    	this._skill = skill;
    },
    
    setAnim: function(sumoName, sumoState) {
    	this.name = sumoName || this.name; 
    	this._sprite.setAnimation(AnimationManager.getAnimationGL2(this.name, sumoState, this._frameDuration));;
    },
    
    getPosition: function(x,y) {
    	return this._sprite.getPosition();
    },
    
    setPosition: function(x,y) {
    	this._node.setPosition(x,y);
    	this._sprite.setPosition(x,y);
    },
    
    setRotation: function(degrees) {
    	this._node.setRotation();
    	this._sprite.setRotation(degrees);
    },
    
    setColor: function(r,g,b) {
    	this._node.setColor(r,g,b);
    	this._sprite.setColor(r,g,b);
    },
    
    getScale: function() {
    	return this._sprite.getScale();
    },
    
    setScale: function(scaleX, scaleY) {
    	this._node.setScale(scaleX, scaleY);
    	this._sprite.setScale(scaleX, scaleY);
    },
    
    getAlpha: function(value) {
    	return this._sprite.getAlpha();
    },
    
    setAlpha: function(value) {
    	this._sprite.setAlpha(value);
    },
    
    setVisible: function(value) {
    	this._sprite.setVisible(value);
    },
    
    testData: {
      "name" : "Sumoning 1",
      "type" : "sumo",
      "hp" : 500,
      "attack" : 25,
      "attackInterval" : 1000,
      "defense" : 10,
      "speed" : 50,
      "move_type" : {
      	"type":"small_jump",
      	"step":1
      },
      "avatar" : "avatar.png",
      "animation" : {
       "stand" : {
          "duration" : 50,
          "frameCount" : 1,
          "frameHeight" : 200,
          "frameWidth" : 200,
          "img" : "Content/Sumo/Dragon_1.png"
        },
        "move" : {
          "duration" : 50,
          "frameCount" : 5,
          "frameHeight" : 50,
          "frameWidth" : 50,
          "img" : "image.png"
        },
        "damage" : {
          "duration" : 50,
          "frameCount" : 5,
          "frameHeight" : 50,
          "frameWidth" : 50,
          "img" : "image.png"
        },
        "attack" : {
          "duration" : 50,
          "frameCount" : 5,
          "frameHeight" : 50,
          "frameWidth" : 50,
          "img" : "image.img"
        },
        "dead" : {
          "duration" : 50,
          "frameCount" : 5,
          "frameHeight" : 50,
          "frameWidth" : 90,
          "img" : "image.png"
        },
        "additional" : {
          "duration" : 50,
          "frameCount" : 5,
          "frameHeight" : 50,
          "frameWidth" : 90,
          "img" : "image.png"
        }
      }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/model/Entity/Skill'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/model/Entity/Skill'] || {}; $MODULE_REGISTRY['Code/module/battle/model/Entity/Skill'] = exports; 
var __dirname = 'Code/module/battle/model/Entity';
var __filename = 'Code/module/battle/model/Entity/Skill.js';

var ModelBase 			= require('Code/model/Entity/ModelBase').ModelBase;
var GL2		  			= require('NGCore/Client/GL2').GL2;
var AnimationManager 	= require('NGGo/Framework/AnimationManager').AnimationManager;
var VFX 				= require('NGGo/Service/Graphics/VFX/VFX').VFX;
var Logger 				= require('Code/utils/Logger').Logger;

var skillObj = {
    classname: "Skill",

    _setParams: function (d) {
        d = d || {};
        
        this.type = d.type || "";
        this.damage = d.damage || 0;
        this.avatar = d.avatar || "";
        this.position = d.position ||{};
        this._direction = 1;
        
        this._frameDuration = 150;          
        this._sprite = new GL2.Sprite();
        this._sprite.setAnimation(AnimationManager.getAnimationGL2("fire", "begin", this._frameDuration));
        this._animPool = [];
        
        this.isFinished = false;
    },
    
    present: function(skillType, d) {
    	this._direction = d;
    	
    	if (skillType == 2) {
    		this.fire();
    	} else if(skillType == 3) {
    		this.lighting();
    	}
    },
    
    setPosition: function(x, y) {
    	this._sprite.setPosition(x, y);
    },
    
    getPosition: function() {
    	return this._sprite.getPosition();
    },
    
    setScale: function(sx, sy) {
    	this._sprite.setScale(sx, sy);
    },
    
    setRotation: function(d) {
    	this._sprite.setRotation(d);
    },
    
    getAnim: function() {
    	return this._sprite;
    },
    
    setAnim: function(name, state, frameRate, forceFinish) {
    	frameRate = frameRate || this._frameDuration;
    	var anim = this._animPool[state];
    	
    	if (!anim) {
    		anim = AnimationManager.getAnimationGL2(name, state, frameRate);
    		anim.setLoopingEnabled(false);
    		this._animPool[state] = anim;
    	}
    	
    	this._sprite.setAnimation(anim);
    	
    	if (forceFinish) {
    		this._sprite.getAnimationCompleteEmitter().addListener(this, this.finish);
    	}
    	
    	Logger.log("Anim state = " + state);
    },
    
    reset: function() {
    	this.setAnim("fire", "begin");
    	this.setScale(1, 1);
    },
    
    destroy: function() {
    	this._sprite.destroy();
    },
    
    bigFire: function() {
    	Logger.log("Skill-->Bigfire");
    	var p = this._sprite.getPosition();
    	this._sprite.setPosition(p.getX() - 330 * this._direction, p.getY());
    	this.setAnim("fire", "end", undefined, true);
    },
    
    finish: function() {
    	this.isFinished = true;
    	this._sprite.getAnimationCompleteEmitter().removeListener(this, this.finish);
    },
    
    fire: function() {
    	Logger.log("Skill-->fire");
    	
    	this.setAnim("fire", "begin");
    	var self = this;
    	var task = VFX.enchant(this._sprite).move2(self, this.bigFire, 0.08, 200 * this._direction, 0);
    },
    
    lighting: function() {
    	var p = this._sprite.getPosition();
    	this._sprite.setPosition(p.getX() - 110 * this._direction, p.getY() - 10);
    	this.setAnim("lighting", "line");
    	this.isFinished = true;
    }
};

exports.Skill = ModelBase.subclass(skillObj);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/view/Scene/BattleScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/view/Scene/BattleScene'] || {}; $MODULE_REGISTRY['Code/module/battle/view/Scene/BattleScene'] = exports; 
var __dirname = 'Code/module/battle/view/Scene';
var __filename = 'Code/module/battle/view/Scene/BattleScene.js';

/**
 * @author sonnn
 */
var ScreenManager		 	= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 	= require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 	= require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 	= require('NGCore/Client/GL2').GL2;
var SceneDirector 		 	= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var GlobalParameter 	 	= require('Code/utils/GlobalParameter').GlobalParameter;
var BattleSceneController	= require('Code/module/battle/controller/BattleSceneController').BattleSceneController;
var Sumo		 		 	= require('Code/module/battle/model/Entity/Sumo').Sumo;
var Skill		 		 	= require('Code/module/battle/model/Entity/Skill').Skill;

var battleScene = {
	initialize: function() {
		this.controller = new BattleSceneController();
		
		this.playerSumo = new Sumo();
    	this.playerSumo.setPosition(GlobalParameter.battle.player.x - 250, GlobalParameter.battle.player.y - 150);
    	this.playerSumo.setScale(0.6, 0.6);
		
		this.enemySumo = new Sumo();
		this.enemySumo.setPosition(GlobalParameter.battle.enemy.x + 250, GlobalParameter.battle.enemy.y - 160);
	    this.enemySumo.setScale(-1, 1);
	    
	    this.skill = new Skill();
	    this.skill.setPosition(-500, GlobalParameter.battle.player.y - 150);
	    this.skill.setScale(1, 1);
	    this.skill.setRotation(180);
	    
	    this.playerSumo.setSkill(this.skill);
	    this.enemySumo.setSkill(this.skill);
	    
	    this.controller.offsetX = GlobalParameter.battle.enemy.x + 40 - (GlobalParameter.battle.player.x - 40);
	},
	
	onEnter: function(prevScene, option) {
		this.controller.currentBattle = option;
		this.node = new GL2.Node();
	    GUIBuilder.loadConfigFromFile("Config/Scene/battle/BattleScene.json", this.controller, function ()
	    {
	    	ScreenManager.getRootNode().addChild(this.node);
	    	this.controller.HUD.setDepth(65535);
	    	this.controller.MainGame.setDepth(0);
	    	this.node.addChild(this.controller.HUD);
	    	this.node.addChild(this.controller.MainGame);
	    	
	    	this.controller.setup(this.playerSumo, this.enemySumo, this.skill);
	    	
	    }.bind(this));
	},
	
	fightEnemy: function() {
		var setEnemyTurn = function() {
			this.enemyTurn = true;
		}.bind(this);
		
		this.controller.fightEnemy(setEnemyTurn);
	},
	
	fightSumo: function() {
		this.enemyTurn = false;
		this.controller.fightSumo();
	},
	
	onExit: function(nextScene, option) {
	    this.controller._mvListener.destroy();
		this.node.destroy();
	}
};

exports.BattleScene = Scene.subclass(battleScene);; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/view/Scene/PreBattleScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/view/Scene/PreBattleScene'] || {}; $MODULE_REGISTRY['Code/module/battle/view/Scene/PreBattleScene'] = exports; 
var __dirname = 'Code/module/battle/view/Scene';
var __filename = 'Code/module/battle/view/Scene/PreBattleScene.js';

/**
 * @author sonnn
 */
var ScreenManager		         = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			         = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				         = require('NGGo/Framework/Scene/Scene').Scene;
var SceneFactory                 = require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var GL2					         = require('NGCore/Client/GL2').GL2;
var PreBattleSceneController	 = require('Code/module/battle/controller/PreBattleSceneController').PreBattleSceneController;
var BattleScene                  = require('Code/module/battle/view/Scene/BattleScene').BattleScene;

var preBattleScene = {
	initialize: function() {
	    SceneFactory.register(BattleScene, "BATTLE_SCENE");
		this.controller = new PreBattleSceneController();
	},
	
	onEnter: function(prevScene, option) {
		this.node = new GL2.Node();
		console.log("SON:in debugScene1");
	    GUIBuilder.loadConfigFromFile("Config/Scene/battle/PreBattleScene.json", this.controller, function() {
	    	console.log("SON:in debugScene2:"+this.controller);
	    	this.node.addChild(this.controller.DebugScene);
	        ScreenManager.getRootNode().addChild(this.node);
	        console.log("SON:in debugScene3");
	    }.bind(this));
	},
	
	onExit: function(nextScene, option) {
		this.node.destroy();
	}
};

exports.PreBattleScene = Scene.subclass(preBattleScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/controller/TestSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/controller/TestSceneController'] || {}; $MODULE_REGISTRY['Code/module/battle/controller/TestSceneController'] = exports; 
var __dirname = 'Code/module/battle/controller';
var __filename = 'Code/module/battle/controller/TestSceneController.js';

/**
 * @author sonnn
 */

var Core 				= require('NGCore/Client/Core').Core;
var GL2  				= require('NGCore/Client/GL2').GL2;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 		= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var ParticleEmitter 	= require('NGGo/Service/Graphics/ParticleEmitter').ParticleEmitter;
var AnimationManager 	= require('NGGo/Framework/AnimationManager').AnimationManager;
var Logger 				= require('Code/utils/Logger').Logger;

var MoveListener = Core.MessageListener.subclass({
	initialize: function(ctl, target, min, max) {
		this.ctl = ctl;
		this.target = target;
		this.dir = 1;
		this.x = min;
		this.y = target.getPosition().getY();
		this.min = min;
		this.max = max;
		this.counter = 0;
	},
	
	onUpdate: function() {
		this.x += 5 * this.dir;
		 
		if (this.x < this.max) {
			this.target.setPosition(this.x, this.y);
		} else {
			this.dir *= -1;
		}
		
		if (this.x <= this.min) {
			this.dir *= -1;
			this.counter++;
		}
			
		if (this.counter == 1) {
			this.ctl.check();
		}
		
		if (this.counter == 2) {
			this.ctl.check2();
		}
	}
});

var testSceneController = 
{
	
	initialize: function() {
	},
	
	action_click: function (elem, buttnName) {
        console.log('You clicked ' + buttnName + '!');
        
        if (buttnName === "Home") {
        	SceneDirector.transition("PRE_BATTLE_SCENE");
        }
   },
   
   setup: function() {
   		this.sprite = new GL2.Sprite();
		
		// var a = new GL2.Animation();
		// var dimension = [1952, 845];
		var fRate = 100;
		// var offset = [0, 0.5];
		// a.pushFrame(new GL2.Animation.Frame('Content/test/lighting/lighting-1.png', fRate, dimension, offset, [0, 0, 1, 1]));
		// a.pushFrame(new GL2.Animation.Frame('Content/test/lighting/lighting-2.png', fRate, dimension, offset, [0, 0, 1, 1]));
		// a.pushFrame(new GL2.Animation.Frame('Content/test/lighting/lighting-3.png', fRate, dimension, offset, [0, 0, 1, 1]));
		// a.pushFrame(new GL2.Animation.Frame('Content/test/lighting/lighting-4.png', fRate, dimension, offset, [0, 0, 1, 1]));
// 		
		// sprite.setAnimation(a);
		
		// sprite.setAnimation(AnimationManager.getAnimationGL2("lighting", "line", fRate));
// 		
		// sprite.setScale(-1, 1);
		this.sprite.setPosition(10, 50);
		this.sprite.setImage("Content/battle/Test/card1.png", new Core.Size(50, 100), new Core.Point(0,0));
		this.MainGame.addChild(this.sprite);
		
		this._mvListener = new MoveListener(this, this.sprite, 10, 400);
    	Core.UpdateEmitter.addListener(this._mvListener, this._mvListener.onUpdate);
    	
    	for (var x = 0; x < 1000; x ++) {
    		Logger.log(x);
    	}
    	
    	Logger.log("DONE");
   },
   
   check: function() {
   		this.sprite.setImage("Content/battle/Test/card2.png", new Core.Size(50, 100), new Core.Point(0,0));
   },
   
   check2: function() {
   		for (var x = 0; x < 5000; x ++) {
    		Logger.log(x);
    	}
   }
};

exports.TestSceneController = Core.Class.subclass(testSceneController);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/view/Scene/Test/TestScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/view/Scene/Test/TestScene'] || {}; $MODULE_REGISTRY['Code/module/battle/view/Scene/Test/TestScene'] = exports; 
var __dirname = 'Code/module/battle/view/Scene/Test';
var __filename = 'Code/module/battle/view/Scene/Test/TestScene.js';

/**
 * @author sonnn
 */
var ScreenManager		 = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 = require('NGCore/Client/GL2').GL2;
var SceneDirector 		 = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var TestSceneController	 = require('Code/module/battle/controller/TestSceneController').TestSceneController;

var testScene = {
	initialize: function() {
		this.controller = new TestSceneController();
	},
	
	onEnter: function(prevScene, option) {
		this.node = new GL2.Node();
	    GUIBuilder.loadConfigFromFile("Config/Scene/battle/TestScene.json", this.controller, function ()
	    {
	    	ScreenManager.getRootNode().addChild(this.node);
	    	this.controller.HUD.setDepth(65535);
	    	this.controller.MainGame.setDepth(0);
	    	this.node.addChild(this.controller.HUD);
	    	this.node.addChild(this.controller.MainGame);
	    	
	    	this.controller.setup();
	    }.bind(this));
	},
	
	onExit: function(nextScene, option) {
		this.node.destroy();
		delete this.node;
	}
};

exports.TestScene = Scene.subclass(testScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/battle/BattleEntry'] = function(){var exports = $MODULE_REGISTRY['Code/module/battle/BattleEntry'] || {}; $MODULE_REGISTRY['Code/module/battle/BattleEntry'] = exports; 
var __dirname = 'Code/module/battle';
var __filename = 'Code/module/battle/BattleEntry.js';

/**
 * @author sonnn
 */
var Core				= require('NGCore/Client/Core').Core;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 		= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var JSONData 			= require('NGGo/Service/Data/JSONData').JSONData;
var GlobalParameter 	= require('Code/utils/GlobalParameter').GlobalParameter;
var PreBattleScene 		= require('Code/module/battle/view/Scene/PreBattleScene').PreBattleScene;
var BattleScene 		= require('Code/module/battle/view/Scene/BattleScene').BattleScene;
var TestScene 			= require('Code/module/battle/view/Scene/Test/TestScene').TestScene;

var battleEntry = {
	initialize: function(mode) {
		
		var jsondata = new JSONData();
		jsondata.load("Config/player.json", function(err, obj) {
			if (err) {
				console.log("Error:" + err.errorText);
			} else {
				GlobalParameter.player = obj.data.player;

				jsondata.load("Config/sumo.json", function(err, obj) {
					if (err) {
						console.log("Error:" + err.errorText);
					} else {
						GlobalParameter.sumo = obj.data.sumos;
						
						jsondata.load("Config/skill.json", function(err, obj) {
    						if (err) {
    							console.log("Error:" + err.errorText);
    						} else {
    							GlobalParameter.skill = obj.data.skills;
    							
    							jsondata.load("Config/battle.json", function(err, obj) {
	        						if (err) {
	        							console.log("Error:" + err.errorText);
	        						} else {
	        							GlobalParameter.battle = obj.data.battle;
	        							
	        							SceneFactory.register(PreBattleScene, "PRE_BATTLE_SCENE");
								    	SceneFactory.register(BattleScene, "BATTLE_SCENE");
								    	SceneFactory.register(TestScene, "TEST_SCENE");
								    	
								    	if (mode == "DEBUG") {
								    		SceneDirector.push("PRE_BATTLE_SCENE");
								    	} else {
								    		SceneDirector.transition("BATTLE_SCENE", "Battle2");
								    	}
	        						}
	        					});
		        			}
	        			});
	        		}
        		});
			}
		});
	}
};

exports.BattleEntry = Core.Class.subclass(battleEntry);; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/GlobalTouchEmitter'] = function(){var exports = $MODULE_REGISTRY['Code/utils/GlobalTouchEmitter'] || {}; $MODULE_REGISTRY['Code/utils/GlobalTouchEmitter'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/GlobalTouchEmitter.js';

/*
 * This class is ported based on DnGlobalTouchEmitter class of DnLib
 * 
 * @Purpose: To manage all touch events in game and make management of touch events easier
 * 
 */

var Core = require('NGCore/Client/Core').Core;
var GL2  = require('NGCore/Client/GL2').GL2;


exports.GlobalTouchEmitter = Core.MessageListener.subclass({
	
	//--------------------------------------------------------------------------
	initialize: function() {
		
		this.target = new GL2.TouchTarget();
		this.target.setAnchor( [0, 0] );
		this.target.setSize(
			Core.Capabilities.getScreenHeight(), //----- adapt to landscape
			Core.Capabilities.getScreenWidth()
		);
		this.target.getTouchEmitter().addListener( this, this.onTouch );
		this.target.setDepth( 65535 );
		
		this.node = new GL2.Node();
		this.node.addChild( this.target );
		GL2.Root.addChild( this.node );
		
		this.listeners = {};
		this.index = 0;
		this.isActivated = true;
	},
	
	//--------------------------------------------------------------------------
	destroy: function() {
		this.node.destroy();
	},
	
	//--------------------------------------------------------------------------
	activate:   function() { this.isActivated = true;  },
	deactivate: function() { this.isActivated = false; },
	
	//--------------------------------------------------------------------------
	addListener: function( object, touchTarget, handler, onFingerOutHandler ) {
		
		if (typeof( handler ) !== 'function') {
			NgLogD( "dn.GlobalTouchEmitter.addListener - handler is not function" );
			return false;
		}
		
		this.index++;
		var listener = {};
		listener.object  = object;
		listener.target  = touchTarget;
		listener.handler = handler;
		listener.hasHandled = false;
		listener.onFingerOutHandler = onFingerOutHandler;
		this.listeners[ this.index ] = listener;
		object.touchObserverIndex = this.index;
		
		//NgLogD( "add listener: " + this.index );
		return true;
	},
	
	//--------------------------------------------------------------------------
	removeListener: function( object ) {
		
		if (! object.touchObserverIndex) {
			NgLogD( "dn.GlobalTouchEmitter.removeListener - object is not registered" );
			return false;
		}
		
		delete this.listeners[ object.touchObserverIndex ];
		delete object.touchObserverIndex;
		//NgLogD( "remove listener: " + this.index );
		return true;
	},
	
	//--------------------------------------------------------------------------
	onTouch: function( touch ) {
		
		if (! this.isActivated) { return false; }
		
		//----- call listeners
		for (var i in this.listeners) {
			var listener = this.listeners[i];
			if (listener.target) {
				if (touch.getIsInside( listener.target )) {
					listener.handler.apply( listener.object, [touch] );
					listener.hasHandled = true;
				} else {
					if (listener.hasHandled) {
						listener.hasHandled = false;
						if (listener.onFingerOutHandler) {
							listener.onFingerOutHandler.apply( listener.object );
						}
					}
				}
			} else {
				listener.handler.apply( listener.object, [touch] );
			}
		}
		
		//----- return true to capture subsequent Move / End event.
		//----- In this case, lower priority handlers cannot capture the event.
		if (touch.getAction() === touch.Action.Start) {
			return true;
		}
		return false;
	}
	
});


; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/TouchManager'] = function(){var exports = $MODULE_REGISTRY['Code/utils/TouchManager'] || {}; $MODULE_REGISTRY['Code/utils/TouchManager'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/TouchManager.js';

var Class= require('NGCore/Shared/Class').Class;
var GlobalTouchEmitter= require('Code/utils/GlobalTouchEmitter').GlobalTouchEmitter;

exports.TouchManager= Class.singleton(
{
	classname:"TouchManager",
	
	initialize:function()
	{
		this._touchEmitter= new GlobalTouchEmitter();
	},

	instance:function()
	{
		return this._touchEmitter;
	}
}		
); 


; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/controller/MissionMainSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/controller/MissionMainSceneController'] || {}; $MODULE_REGISTRY['Code/module/mission/controller/MissionMainSceneController'] = exports; 
var __dirname = 'Code/module/mission/controller';
var __filename = 'Code/module/mission/controller/MissionMainSceneController.js';

/**
 * @author lucnd
 */

var Core 			= require('NGCore/Client/Core').Core;
var GL2  			= require('NGCore/Client/GL2').GL2;
var SceneDirector 	= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 	= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var ParticleEmitter = require('NGGo/Service/Graphics/ParticleEmitter').ParticleEmitter;
var Logger 			= require('Code/utils/Logger').Logger;
var UI 				= require('NGCore/Client/UI').UI;
var BattleEntry= require('Code/module/battle/BattleEntry').BattleEntry;
var TouchManager 	 = require('Code/utils/TouchManager').TouchManager;

var mainSceneController = 
{
	
	initialize: function() {
		this.currentBattle = "";
		this._addGoButton();
	},
    	
	setupHero: function(hero) {		
		if(hero) {
				hero.setAnim("hero", "stand");
				this.MainGame.addChild(hero.getAnim());
		}
	},
	setupMonster: function(monsters) {		
		if(monsters) {
			for(var i in monsters) {
				var mon = monsters[i];
				TouchManager.instance().addListener(this, mon.touch, this.onTouch);
				mon.setAnim("evil", "stand");
				this.MainGame.addChild(mon.getNode());
			}
		}
	},
	onTouch:function(touch) {
		console.log("NDL----onTouch");
	},
	_addGoButton: function() {
		this.nextButton = new UI.Button({
			frame: [400, 10, 60, 30],
			text: "Go",
			disabledTextColor: "FFFF",
			textSize: 14,
			textGravity: UI.ViewGeometry.Gravity.Center,
			gradient: {
				corners: '8 8 8 8',
				outerLine: "00 1.5",
				gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
			},
			highlightedGradient: {
				corners: '8 8 8 8',
				outerLine: "00 1.5",
				gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
			},
			disabledGradient: {
				corners: '0 8 8 8',
				gradient: [ "FF55 0.0", "FF00 1.0"],
			},
			// if the back button is pressed, then launch /Samples/Launcher
			onClick: function(event) {
				UI.Window.document.removeChild(this.nextButton);
				this.nextButton.destroy();
				new BattleEntry();
			}.bind(this)
		});
	
		UI.Window.document.addChild(this.nextButton);
	}
};

exports.MissionMainSceneController = Core.MessageListener.subclass(mainSceneController);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/controller/MissionDebugSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/controller/MissionDebugSceneController'] || {}; $MODULE_REGISTRY['Code/module/mission/controller/MissionDebugSceneController'] = exports; 
var __dirname = 'Code/module/mission/controller';
var __filename = 'Code/module/mission/controller/MissionDebugSceneController.js';

/**
 * @author lucnd
 */

var Core 				= require('NGCore/Client/Core').Core;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 		= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var JSONData 			= require('NGGo/Service/Data/JSONData').JSONData;
var GUIBuilder 			= require('NGGo/Framework/GUIBuilder').GUIBuilder;
var ScreenManager 		= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GL2 				= require('NGCore/Client/GL2').GL2;
var GlobalParameter 	= require('Code/utils/GlobalParameter').GlobalParameter;
//var SpecialMission 		= require_('../../../../module/cutscene/SpecialMission').SpecialMission;

var debugSceneController = 
{
    action_click: function (elem, battleName)
    {
    	var self = this;
        console.log('You clicked ' + battleName + '!');
        
        if (battleName === "Mission1" || battleName === "Mission2") {
        	this.gotoMission(self, battleName);
        } else if (battleName === "Test") {
        	console.log("NDL:---- Test");
        }
    },
    
    gotoMission: function(self, battleName) {
    	var jsondata = new JSONData();
		jsondata.load("Config/player.json", function(err, obj) {
			if (err) {
				console.log("Error:"+err.errorText);
			} else {
				GlobalParameter.player = obj.data.player;
				console.log("Player_01.name="+obj.data.player.player_01.name);

				jsondata.load("Config/sumo.json", function(err, obj) {
					if (err) {
						
					} else {
						GlobalParameter.sumo = obj.data.sumos;
						console.log("Sumo_01.name="+obj.data.sumos.sumo_01.name);
						
						jsondata.load("Config/skill.json", function(err, obj) {
    						if (err) {
    							
    						} else {
    							GlobalParameter.skill = obj.data.skills;
    							console.log("Skill_01.name="+GlobalParameter.skill.skill_01.name);
    							
    							jsondata.load("Config/battle.json", function(err, obj) {
	        						if (err) {
	        							
	        						} else {
	        							GlobalParameter.battle = obj.data.battle;
	        							console.log("battle_01.name="+obj.data.battle.background);
									    
									    self.transitionToMain(battleName);
	        						}
	        					});
		        			}
	        			});
	        		}
        		});
			}
		});
    },
    
    transitionToMain: function(battleName) {
		console.log("transition to main scene: " + battleName);
		SceneDirector.transition("MISSION_MAIN_SCENE", battleName);
    }
};

exports.MissionDebugSceneController = Core.Class.subclass(debugSceneController);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/view/Scene/MissionDebugScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/view/Scene/MissionDebugScene'] || {}; $MODULE_REGISTRY['Code/module/mission/view/Scene/MissionDebugScene'] = exports; 
var __dirname = 'Code/module/mission/view/Scene';
var __filename = 'Code/module/mission/view/Scene/MissionDebugScene.js';

/**
 * @author lucnd
 */
var ScreenManager		 = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 = require('NGCore/Client/GL2').GL2;
var MissionDebugSceneController = require('Code/module/mission/controller/MissionDebugSceneController').MissionDebugSceneController;

var debugScene = {
	initialize: function() {
		this.controller = new MissionDebugSceneController();
	},
	
	onEnter: function(prevScene, option) {
		this.node = new GL2.Node();
	    GUIBuilder.loadConfigFromFile("Config/Scene/mission/DebugScene.json", this.controller, function() {
	    	this.node.addChild(this.controller.DebugScene);
	        ScreenManager.getRootNode().addChild(this.node);
	    }.bind(this));
	},
	
	onExit: function(nextScene, option) {
		this.node.destroy();
	}
};

exports.MissionDebugScene = Scene.subclass(debugScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/SumoUtil'] = function(){var exports = $MODULE_REGISTRY['Code/utils/SumoUtil'] || {}; $MODULE_REGISTRY['Code/utils/SumoUtil'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/SumoUtil.js';

var Core = require('NGCore/Client/Core').Core;
var GL2  = require('NGCore/Client/GL2').GL2;

exports.SumoUtil = Core.Class.singleton({
    
    //Create animation 
    createAnimation: function(path, frameCount, duration, w, h){
    	//path = nj.IMG(null, path);
    	if (duration == undefined)
    		duration = 500;
        var animation = new GL2.Animation();

    	for (var i = 0; i < frameCount ; i ++ ){
        	animation.pushFrame(new GL2.Animation.Frame(path, duration, [w, h], [0.5, 1], [i/frameCount, 0, 1/frameCount, 1]));
    	}
        
        return animation;
    },
	
	//--------------------------------------------------------------------------
	traverse: function( obj, func, level ) {
		var level = level || 0;
		for (var i in obj) {
			func.apply( this, [i, obj[i], level] );
			if (typeof( obj[i] ) === "object" ) {
				this.traverse( obj[i], func, level+1 );
			}
		}
	},
	
	//--------------------------------------------------------------------------
	dump: function( obj, name ) {
		NgLogD( '--------------- traverse: ' + name );
		
		this.traverse( obj, function( key, val, level ) {
			var indent = '';
			var output = '';
			for (var i=0;  i<level;  i++) { indent += '    '; }
			output += indent + key + ': ';
			if (! (val + '').match(/\[object Object\]/)) {
				output += val;
			}
			NgLogD( output );
		}, 1);
	},
		
	//--------------------------------------------------------------------------
	makeButton: function( x, y, image, pressedImage, size, anchor, listener, onTouchHandler ) {
	
		var b = new GL2.Sprite();
		nj.Utils.setSpriteImage(b,  image, size, anchor );
		b.setPosition( x, y );
		b.image = image;
		b.pressedImage = pressedImage;
		
		var target = new GL2.TouchTarget();
		target.setAnchor( [0, 0] );
		target.setSize( size[0], size[1] );
		nj.crystal.touchEmitter.addListener(
			listener,
			target,
			//----- on touch
			function( touch ) {
				if (! this._hasPushed) { this._hasPushed = false; }
				switch (touch.getAction()) {
				case touch.Action.Start:
					nj.Utils.setSpriteImage(b,  pressedImage, size, anchor );
					this._hasPushed = true;
					break;
				case touch.Action.End:
					if (this._hasPushed) {
						nj.Utils.setSpriteImage(b,  image, size, anchor );
						onTouchHandler.apply( listener );
					}
					break;
				}
			},
			//----- on finger out
			function() {
				nj.Utils.setSpriteImage(b,  image, size, anchor );
			}
		);
		b.addChild( target );
		
		return b;
	},
	
	//--------------------------------------------------------------------------
	makePrimitive: function( x, y, w, h, color1, color2, color3, color4 ) {
		
		if (arguments.length <= 6) {
			color3 = color2 || color1;
			color4 = color2 || color1;
			color2 = color1;
		}
		
		var p = new GL2.Primitive();
		p.setType( GL2.Primitive.Type.TriangleStrip );
		
		p.pushVertex( new GL2.Primitive.Vertex([0, 0], [0, 0], color1) );
		p.pushVertex( new GL2.Primitive.Vertex([w, 0], [1, 0], color2) );
		p.pushVertex( new GL2.Primitive.Vertex([0, h], [0, 1], color3) );
		p.pushVertex( new GL2.Primitive.Vertex([w, h], [1, 1], color4) );
		
		p.setPosition( x, y );
		return p;
	},
	
	//--------------------------------------------------------------------------
	makeText: function( text, size, color ) {
		return new nj.crystal.ShadowText( text, size, color );
	},
	
	//--------------------------------------------------------------------------
	makeBlind: function() {
		
		//----- linear scaling して余った部分を黒い帯で隠す
		//----- (とりあえずの応急処置)
		var width  = Core.Capabilities.getScreenHeight();
		var height = Core.Capabilities.getScreenWidth();
		
		var scale    = height / 320;
		var shortage = width - (480 * scale);
		
		var blind;
		if (shortage > 0) {
			blind = new GL2.Primitive();
			blind.setType( GL2.Primitive.Type.TriangleStrip );
			blind.pushVertex( new GL2.Primitive.Vertex([width - shortage,      0], [0, 0], [0,0,0]) );
			blind.pushVertex( new GL2.Primitive.Vertex([width           ,      0], [1, 0], [0,0,0]) );
			blind.pushVertex( new GL2.Primitive.Vertex([width - shortage, height], [0, 1], [0,0,0]) );
			blind.pushVertex( new GL2.Primitive.Vertex([width           , height], [1, 1], [0,0,0]) );
			blind.setDepth( 99999999 );
			GL2.Root.addChild( blind );
		}
		return blind;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/model/Entity/Monster'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/model/Entity/Monster'] || {}; $MODULE_REGISTRY['Code/module/mission/model/Entity/Monster'] = exports; 
var __dirname = 'Code/module/mission/model/Entity';
var __filename = 'Code/module/mission/model/Entity/Monster.js';

var ModelBase = require('Code/model/Entity/ModelBase').ModelBase;
var GL2		  = require('NGCore/Client/GL2').GL2;
var SumoUtil = require('Code/utils/SumoUtil').SumoUtil;
var AnimationManager = require('NGGo/Framework/AnimationManager').AnimationManager;
var TouchManager = require('Code/utils/TouchManager').TouchManager;
var SceneDirector = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;

exports.Monster = ModelBase.subclass({
    classname: "Monster",

    _setParams: function (d) {
        d = d || {};
        
        this.monster_id = d.monster_id || "";
        this.name = d.name || "";
        this.type = d.type || "";
        this.hp = d.hp || 0;
        this.attack = d.attack || 0;
        this.attackInterval = d.attackInterval || 0;
        this.defense = d.defense || 0;
        this.speed = d.speed || 0;
        
        this._node = new GL2.Node();
        this._frameDuration = 300;   
        
        this._sprite = new GL2.Sprite();
        this._sprite.setAnimation(AnimationManager.getAnimationGL2("evil", "stand", this._frameDuration));
		this._node.addChild(this._sprite);
		
		
		//this._node.addChild(this._slashSprite);
		
		// add touch target
		//----- create touch target
		
		this.touch = new GL2.TouchTarget();
		this.touch.setAnchor( [0.5, 0.5] );
		this.touch.setSize(
			this._sprite._animation.getFrame(0).getSize().getWidth(),
			this._sprite._animation.getFrame(0).getSize().getHeight()
		);
		TouchManager.instance().addListener(this, this.touch, this.onTouch);
		console.log("NDL:Sumo this._sprite.getSize()="+this._sprite._animation.getFrame(0).getSize().getWidth());
		this._sprite.addChild(this.touch);
		
		this._isTouched = false;
		this._isDamaged = false;
    },
    
    onTouch: function(touch) {
    	if (touch.getAction() === touch.Action.Start) {
    		console.log("NDL:>>> onTouch Monster -- start");
    		this.setAnim("evil", "damage");
    		this._isTouched = true;
    		//this._isDamaged = true;
    		this._slashSprite = new GL2.Sprite();
			this._slashSprite.setAnimation(AnimationManager.getAnimationGL2("slash", "default", this._frameDuration/3));
    		this._slashSprite.getAnimation().setLoopingEnabled(false);
    		this._node.addChild(this._slashSprite);
    		var controller = SceneDirector.currentScene.controller;
    		this._slashSprite.getAnimationCompleteEmitter().addListener(this, this.destroySlash);
    		//this._slashSprite.getAnimationCompleteEmitter().addListener(controller, controller.test("111"));
		}
		else if (touch.getAction() === touch.Action.Move) {
    		console.log("NDL:>>> onTouch Monster -- Move");
    		//if(!this._isTouched){
    			//if(!this._isDamaged) {
    				//this.setAnim("evil", "damage");
    				//this._isTouched = true;
    				//this._isDamaged = true;
    			//}    			
    		//}
    		//else {
    			//this.setAnim("evil", "stand");
    			//this._isTouched = false;
    		//}
    		
    		//this._node.addChild(this._slashSprite);
		}
		else if (touch.getAction() === touch.Action.End) {
			console.log("NDL:>>> onTouch Monster -- end");
			this.setAnim("evil", "stand");
			this._isTouched = false;
		}
    },
    
    destroySlash: function() {
    	console.log("NDL:---destroySlash");
    	if(this._slashSprite) {
    		this._slashSprite.destroy();
    	}
    	if(this._sprite) {
    		this._sprite.destroy();
    	}
    },
    
    updateHp: function(hp) {
    	this.hp += hp;
    },
    
    getHp: function() {
    	return this.hp || 0;
    },
    
    getNode:function() {
    	return this._node;
    },
    
    getAnim:function() {
    	return this._sprite;
    },
    
    setAnim:function(sumoName, sumoState) {
    	this.name = sumoName || this.name; 
    	this._sprite.setAnimation(AnimationManager.getAnimationGL2(this.name, sumoState, this._frameDuration));
    },
    
    getPosition: function(x,y) {
    	return this._node.getPosition();
    },
    
    setPosition: function(x,y) {
    	this._node.setPosition(x,y);
    	//this._sprite.setPosition(x,y);
    },
    
    setRotation: function(degrees) {
    	this._node.setRotation();
    	this._sprite.setRotation(degrees);
    },
    
    setColor: function(r,g,b) {
    	this._node.setColor(r,g,b);
    	this._sprite.setColor(r,g,b);
    },
    
    setScale: function(scaleX, scaleY) {
    	this._node.setScale(scaleX, scaleY);
    	this._sprite.setScale(scaleX, scaleY);
    },
    
    setVisible: function(value) {
    	this._sprite.setVisible(value);
    },
    
    testData: {
      "name" : "dragon",
      "type" : "sumo",
      "hp" : 500,
      "attack" : 25,
      "attackInterval" : 1000,
      "defense" : 10,
      "speed" : 50,
      "move_type" : {
      	"type":"small_jump",
      	"step":1
      }
     }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/model/Entity/Mission'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/model/Entity/Mission'] || {}; $MODULE_REGISTRY['Code/module/mission/model/Entity/Mission'] = exports; 
var __dirname = 'Code/module/mission/model/Entity';
var __filename = 'Code/module/mission/model/Entity/Mission.js';

var ModelBase = require('Code/model/Entity/ModelBase').ModelBase;

exports.Mission = ModelBase.subclass({
    classname: "Mission",

    _setParams: function (d) {
        d = d || {};
        
        this.data = this.testData;
        
        this.name = d.name || "";
        this.type = d.type || "";
        this.level = d.level || 0;
        this.default_sumo = d.default_sumo || {};
    },
    
    testData: {
		"background" : "image.png",
		"width":480,
	    "height":320,
	    "bonus_gold": 400,
	    "monsters" : [
	      {
	        "monster_id" : "evil",
	        "x" : 100,
	        "y" : 50
	      },
	      {
	        "monster_id" : "evil2",
	        "x" : 260,
	        "y" : 50
	      },
	      {
	        "monster_id" : "evil3",
	        "x" : 300,
	        "y" : 70
	      },
	      {
	        "monster_id" : "evil4",
	        "x" : 400,
	        "y" : 100
	      }
	    ],
	    "hero" : {
	    	"hero_id":"hero",
	        "x" : 150,
	        "y" : 270
	    },
	    "bonus" : {
	    } 
  }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/model/Entity/Hero'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/model/Entity/Hero'] || {}; $MODULE_REGISTRY['Code/module/mission/model/Entity/Hero'] = exports; 
var __dirname = 'Code/module/mission/model/Entity';
var __filename = 'Code/module/mission/model/Entity/Hero.js';

var ModelBase = require('Code/model/Entity/ModelBase').ModelBase;
var GL2		  = require('NGCore/Client/GL2').GL2;
var SumoUtil = require('Code/utils/SumoUtil').SumoUtil;
var AnimationManager = require('NGGo/Framework/AnimationManager').AnimationManager;
var TouchManager = require('Code/utils/TouchManager').TouchManager;

exports.Hero = ModelBase.subclass({
    classname: "Hero",

    _setParams: function (d) {
        d = d || {};
        
        this.hero_id = d.hero_id || "";
        this.name = d.name || "";
        this.type = d.type || "";
        this.hp = d.hp || 0;
        this.attack = d.attack || 0;
        this.attackInterval = d.attackInterval || 0;
        this.defense = d.defense || 0;
        this.speed = d.speed || 0;
        
        this._node = new GL2.Node();
        this._sprite = new GL2.Sprite();
        this._node.addChild(this._sprite);
        
        // this._standAnimation = SumoUtil.createAnimation(this.testData.animation.stand.img, this.testData.animation.stand.frameCount, 
        //        this.testData.animation.stand.duration, this.testData.animation.stand.frameWidth, this.testData.animation.stand.frameHeight);

		this._frameDuration = 300;          
        this._sprite = new GL2.Sprite();
        this._sprite.setAnimation(AnimationManager.getAnimationGL2("dragon", "stand", this._frameDuration));
		
		// this._sprite.setAnimation(this._standAnimation);
		
		// add touch target
		//----- create touch target
		
		//this.touch = new GL2.TouchTarget();
		//this.touch.setAnchor( [0.5, 0.5] );
		//this.touch.setSize(
		//	this._sprite._animation.getFrame(0).getSize().getWidth(),
		//	this._sprite._animation.getFrame(0).getSize().getHeight()
		//);
		//TouchManager.instance().addListener(this, this.touch, this.onTouch);
		//console.log("NDL:Sumo this._sprite.getSize()="+this._sprite._animation.getFrame(0).getSize().getWidth());
		//this._sprite.addChild(this.touch);
    },
    
    onTouch: function(touch) {
    	if (touch.getAction() === touch.Action.Start) {
			return true;
		}
		else if (touch.getAction() === touch.Action.End) {
			console.log("NDL:>>> onTouch Hero");
			return true;
		}
    	
    },
    
    updateHp: function(hp) {
    	this.hp += hp;
    },
    
    getHp: function() {
    	return this.hp || 0;
    },
    
    getNode:function() {
    	return this._node;
    },
    
    getAnim:function() {
    	return this._sprite;
    },
    
    setAnim:function(sumoName, sumoState) {
    	this.name = sumoName || this.name; 
    	this._sprite.setAnimation(AnimationManager.getAnimationGL2(this.name, sumoState, this._frameDuration));;
    },
    
    getPosition: function(x,y) {
    	return this._sprite.getPosition();
    },
    
    setPosition: function(x,y) {
    	this._node.setPosition(x,y);
    	this._sprite.setPosition(x,y);
    },
    
    setRotation: function(degrees) {
    	this._node.setRotation();
    	this._sprite.setRotation(degrees);
    },
    
    setColor: function(r,g,b) {
    	this._node.setColor(r,g,b);
    	this._sprite.setColor(r,g,b);
    },
    
    setScale: function(scaleX, scaleY) {
    	this._node.setScale(scaleX, scaleY);
    	this._sprite.setScale(scaleX, scaleY);
    },
    
    setVisible: function(value) {
    	this._sprite.setVisible(value);
    },
    
    testData: {
      "name" : "evil",
      "type" : "sumo",
      "hp" : 500,
      "attack" : 25,
      "attackInterval" : 1000,
      "defense" : 10,
      "speed" : 50,
      "move_type" : {
      	"type":"small_jump",
      	"step":1
      }
     }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/view/Scene/MissionMainScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/view/Scene/MissionMainScene'] || {}; $MODULE_REGISTRY['Code/module/mission/view/Scene/MissionMainScene'] = exports; 
var __dirname = 'Code/module/mission/view/Scene';
var __filename = 'Code/module/mission/view/Scene/MissionMainScene.js';

/**
 * @author sonnn
 */
var ScreenManager		 = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 = require('NGCore/Client/GL2').GL2;
var MissionMainSceneController	 = require('Code/module/mission/controller/MissionMainSceneController').MissionMainSceneController;
var SceneDirector 		 = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var Monster		 		 = require('Code/module/mission/model/Entity/Monster').Monster;
var GlobalParameter 	 = require('Code/utils/GlobalParameter').GlobalParameter;
var Mission		 		 = require('Code/module/mission/model/Entity/Mission').Mission;
var Hero		 		 = require('Code/module/mission/model/Entity/Hero').Hero;
var TouchManager 	 = require('Code/utils/TouchManager').TouchManager;

var mainScene = {
	initialize: function() {
		TouchManager.initialize();
		this.controller = new MissionMainSceneController();
		
		this.mission = new Mission();
		this.monsters = {};
		this.hero = {}
		
		if(this.mission && this.mission.data && this.mission.data.monsters) {
			for(var i = 0; i < this.mission.data.monsters.length; i++ ) {
				var mon = new Monster(this.mission.data.monsters[i]);
				mon.setPosition(this.mission.data.monsters[i].x, this.mission.data.monsters[i].y);
				this.monsters[this.mission.data.monsters[i].monster_id] = mon;
			}
		}

		if(this.mission && this.mission.data && this.mission.data.hero) {
			this.hero = new Hero(this.mission.data.hero);
			this.hero.setPosition(this.mission.data.hero.x, this.mission.data.hero.y);
		}
		
	},
	
	onEnter: function(prevScene, option) {
		this.controller.currentBattle = option;
		this.node = new GL2.Node();
	    GUIBuilder.loadConfigFromFile("Config/Scene/mission/MainScene.json", this.controller, function ()
	    {
	    	ScreenManager.getRootNode().addChild(this.node);
	    	this.controller.MainGame.setDepth(0);
	    	this.node.addChild(this.controller.MainGame);
	    	this.controller.setupHero(this.hero);
	    	this.controller.setupMonster(this.monsters);
	    	
	    }.bind(this));
	},

	onExit: function(nextScene, option) {
		this.node.destroy();
		TouchManager.instance().destroy();
		if(this.mission) {
			this.mission.destroy();
		}
	}
};

exports.MissionMainScene = Scene.subclass(mainScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/module/mission/MissionScene'] = function(){var exports = $MODULE_REGISTRY['Code/module/mission/MissionScene'] || {}; $MODULE_REGISTRY['Code/module/mission/MissionScene'] = exports; 
var __dirname = 'Code/module/mission';
var __filename = 'Code/module/mission/MissionScene.js';

/**
 * @author sonnn
 */
var ScreenManager		 		= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 		= require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 		= require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 		= require('NGCore/Client/GL2').GL2;
var MissionMainSceneController	= require('Code/module/mission/controller/MissionMainSceneController').MissionMainSceneController;
var SceneDirector 		 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 				= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var GlobalParameter 	 		= require('Code/utils/GlobalParameter').GlobalParameter;
var MissionDebugScene 			= require('Code/module/mission/view/Scene/MissionDebugScene').MissionDebugScene;
var MissionMainScene 			= require('Code/module/mission/view/Scene/MissionMainScene').MissionMainScene;
var missionScene = {
	initialize: function() {
		SceneFactory.register(MissionDebugScene, "MISSION_DEBUG_SCENE");
    	SceneFactory.register(MissionMainScene, "MISSION_MAIN_SCENE");
	},
	
	onEnter: function(prevScene, option) {
		if(option) {
			SceneDirector.transition("MISSION_DEBUG_SCENE");
		}
		else {
			SceneDirector.transition("MISSION_MAIN_SCENE");
		}
		
	},

	onExit: function(nextScene, option) {
	}
};

exports.MissionScene = Scene.subclass(missionScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/controller/DebugSceneController'] = function(){var exports = $MODULE_REGISTRY['Code/controller/DebugSceneController'] || {}; $MODULE_REGISTRY['Code/controller/DebugSceneController'] = exports; 
var __dirname = 'Code/controller';
var __filename = 'Code/controller/DebugSceneController.js';

/**
 * @author sonnn
 */

var Core 				= require('NGCore/Client/Core').Core;
var Device 				= require('NGCore/Client/Device').Device;
var SceneDirector 		= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 		= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var JSONData 			= require('NGGo/Service/Data/JSONData').JSONData;
var GUIBuilder 			= require('NGGo/Framework/GUIBuilder').GUIBuilder;
var ScreenManager 		= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GL2 				= require('NGCore/Client/GL2').GL2;
var GlobalParameter 	= require('Code/utils/GlobalParameter').GlobalParameter;
var SpecialMission 		= require('Code/module/cutscene/SpecialMission').SpecialMission;
var BattleEntry 		= require('Code/module/battle/BattleEntry').BattleEntry;
var Logger 				= require('Code/utils/Logger').Logger;
var MissionScene 		= require('Code/module/mission/MissionScene').MissionScene;

var debugSceneController = 
{
	initialize: function(scene) {
		Logger.log("Load Game successfully!");
		this._scene = scene;
	},
	
    action_click: function (elem, battleName)
    {
    	var self = this;
        console.log('You clicked ' + battleName + '!');
        
        if (battleName === "Battle") {
        	this.gotoBattle(self);
        } else if (battleName === "Mission") {
        	console.log("NDL:---- Mission");
        	this.transitionToMission();
        	
        } else if (battleName === "Test") {
        	this.transitionToTest();
        	var a = [];
        	a["key1"] = { "key1": 1 };
        	a["key2"] = { "key2": 2 };
        	var key;
        	for (key in a) {
        		Logger.log(key + " = " + a[key]);
        	}
        } else if (battleName === "Reload") {
        	this._initBackKey();
        } else if (battleName === "Viet") {
            this.transitionToViet();
        } else if (battleName === "Home") {
            this.transitionToHomeScene();
        }
    },
    
    gotoBattle: function(self) {
    	self.transitionToBattle();
    },
    
    transitionToBattle: function() {
		console.log("Jump into battle");
		new BattleEntry("DEBUG");
    },
    
    transitionToTest: function() {
		console.log("transition to test scene");
		SceneDirector.transition("TEST_SCENE");
    },
    transitionToViet: function() {
        console.log("transition to Viet");
        SceneDirector.push("ALL_SCENE");
    },
    transitionToHomeScene: function() {
        console.log("transition to Viet");
        this._scene.node.setTouchable(false);
        SceneDirector.push("HOME_SCENE");
    },
    transitionToMission: function() {
		console.log("Jump into mission");
		SceneDirector.push("MISSION_SCENE");
    },
	_initBackKey: function () {
		// back key
		var KeyListener = Core.MessageListener.singleton ({
			initialize: function() {
				Device.KeyEmitter.addListener(this, this.onUpdate);
				Device.KeyEmitter.emit(new Device.KeyEmitter.KeyEvent(Device.KeyEmitter.EventType.onUp, Device.KeyEmitter.Modifier.NONE, Device.KeyEmitter.Keycode.back));
			},

			onUpdate : function(keyEvent) {
				var gameUrl = Core.Capabilities.getStartingServer() + "/" + Core.Capabilities.getBootGame();
				Logger.log("Reload Game " + gameUrl);
				
				Core.LocalGameList.runUpdatedGame(gameUrl);
				return false;
			}
		});
		
		KeyListener.instantiate();
	}
};

exports.DebugSceneController = Core.Class.subclass(debugSceneController);
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/DebugScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/DebugScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/DebugScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/DebugScene.js';

/**
 * @author sonnn
 */
var ScreenManager		 = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GL2					 = require('NGCore/Client/GL2').GL2;
var DebugSceneController	 = require('Code/controller/DebugSceneController').DebugSceneController;

var debugScene = {
    sceneName: "DEBUG_SCENE",
	initialize: function() {
		this.controller = new DebugSceneController(this);
	},
	
	onEnter: function(prevScene, option) {
	    Log("VVVVVVVVVVVVVVVVVVVSLRLRSSSSSSSSSSSSS111111112222SSSS");
		this.node = new GL2.Node();
		console.log("SON:in debugScene1");
	    GUIBuilder.loadConfigFromFile("Config/Scene/DebugScene.json", this.controller, function() {
	    	console.log("SON:in debugScene2:"+this.controller);
	    	this.node.addChild(this.controller.DebugScene);
	        ScreenManager.getRootNode().addChild(this.node);
	        console.log("SON:in debugScene3");
	    }.bind(this));
	},
	
	onExit: function(nextScene, option) {
		this.node.destroy();
	},
	onResume: function() {
	    Log("VVVVVVVVVVVVVVVVVVVSLRLRSSSSSSSSSSSSSSSSS" + this.node.getTouchable());
	    this.node.setTouchable(true);
	}
};

exports.DebugScene = Scene.subclass(debugScene);
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Foundation/Math/Utils'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Foundation/Math/Utils'] || {}; $MODULE_REGISTRY['NGGo1.3/Foundation/Math/Utils'] = exports; 
var __dirname = 'NGGo1.3/Foundation/Math';
var __filename = 'NGGo1.3/Foundation/Math/Utils.js';

/** 
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 * Permission is hereby granted, free of charge, to any person to obtain a copy of
 * this software and associated documentation files (collectively called
 * the "Software"), in order to exploit the Software without restriction, including
 * without limitation the permission to use, copy, modify, merge, publish,
 * distribute, and/or sublicense copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS LICENSED TO YOU "AS IS" AND WITHOUT
 * WARRANTY OF ANY KIND. DENA CO., LTD. DOES NOT AND CANNOT
 * WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY
 * USING THE SOFTWARE. EXCEPT FOR ANY WARRANTY, CONDITION,
 * REPRESENTATION OR TERM TO THE EXTENT TO WHICH THE SAME
 * CANNOT OR MAY NOT BE EXCLUDED OR LIMITED BY LAW APPLICABLE
 * TO YOU IN YOUR JURISDICTION, DENA CO., LTD., MAKES NO
 * WARRANTIES, CONDITIONS, REPRESENTATIONS OR TERMS, EXPRESS
 * OR IMPLIED, WHETHER BY STATUTE, COMMON LAW, CUSTOM, USAGE,
 * OR OTHERWISE AS TO THE SOFTWARE OR ANY COMPONENT
 * THEREOF, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * INTEGRATION, MERCHANTABILITY,SATISFACTORY QUALITY, FITNESS
 * FOR ANY PARTICULAR PURPOSE OR NON-INFRINGEMENT OF THIRD
 * PARTY RIGHTS. IN NO EVENT SHALL DENA CO., LTD. BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * EXPLOITATION OF THE SOFTWARE.
 */
/**
 * Dn.utils package.
 *
 * @name Dn.utils
 * @namespace
 */
var ObjectRegistry = require('NGCore/Client/Core').ObjectRegistry;
exports.Utils = {
    /**
     * Helper function to call visitor function with all element in the array.
     * 
     * @param {Array} a target array
     * @param {Function} fn function object to process the element
     */
    each: function (a, fn) {
        var i;
        for (i = 0; i < a.length; ++i) {
            fn(a[i], i);
        }
    },

    /**
     * Helper function to apply the function to element and create.
     *
     * @param {Array} a target array
     * @param {Function} fn function object to process the element
     * @returns {Array} new array
     */
    map: function (a, fn) {
        var out = [];
        exports.utils.each(a, function (i) {
            out.push(fn(i));
        });
        return out;
    },

    /**
     * Find value the function returns true.
     * 
     * @param {Array} a target array
     * @param {Function} fn function it checks the element
     * @returns return found object or 'undefined'(when missing)
     */
    find: function (a, fn) {
        var i;
        for (i = 0; i < a.length; ++i) {
            if (fn(a[i])) {
                return a[i];
            }
        }
        return undefined;
    },

    /**
     * Bind object with method. It is used for callback.
     * In fn function, this == context.
     *
     * @param context object
     * @param {Function} fn method.
     * @returns {Function} binded method.
     */

    bind: function (context, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments, 0);
            return fn.apply(context, args);
        };
    },

    /**
     * Scan the object tree and apply function in each value.
     *
     * @param obj target object
     * @param {Function(key,value)} func function to handle data 
     */

    traverse: function (obj, func) {
        var i;
        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                func.apply(this, [i, obj[i]]);
                if (typeof (obj[i]) === "object") {
                    exports.utils.traverse(obj[i], func);
                }
            }
        }
    },

    /**
     * get random number
     * It returns [0-max).
     *
     * @param {Number} max max number
     * @param {NUmber} random value 
     */

    rand: function (max) {
        return Math.random() * max;
    },

    /**
     * Get sin value with degree.
     *
     * @param {Number} degree
     * @returns {Number} result
     */

    sin: function (degree) {
        return Math.sin(degree / 180 * Math.PI);
    },

    /**
     * Get cos value with degree.
     *
     * @param {Number} degree
     * @returns {Number} result
     */

    cos: function (degree) {
        return Math.cos(degree / 180 * Math.PI);
    },

    destroyIfAlive: function (obj) {
        if (ObjectRegistry.isObjectRegistered(obj)) {
            obj.destroy();
        }
    }
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Foundation/Math/Ops'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Foundation/Math/Ops'] || {}; $MODULE_REGISTRY['NGGo1.3/Foundation/Math/Ops'] = exports; 
var __dirname = 'NGGo1.3/Foundation/Math';
var __filename = 'NGGo1.3/Foundation/Math/Ops.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/**
 * @name Foundation.Math.Ops
 * @class Set of basic utility operations to make my life a little easier.
 * <br><br>
 * Really this is just do a "Collision" test between a point an a box.
 * We should move this to Box2D or something faster....
 */
exports.Ops = {};

/**
 * Generates random number which is in [rangeMin, rangeMax).
 * <br><br>
 * If only <code>rangeMin</code> is passed, It runs like: <code>randomInt(0, rangeMin)</code>.
 * @name Foundation.Math.Ops.randomInt
 * @param {Number} rangeMin Minimum value.
 * @param {Number} rangeMax Maximum value, but results not includes this value it self.
 * @returns {Number} Result random number.
 */
exports.Ops.randomInt = function(rangeMin, rangeMax)
{
    if(rangeMax === undefined)
    {
        rangeMax = rangeMin;
        rangeMin = 0;
    }

    var range = rangeMax - rangeMin;
    return Math.floor(Math.random() * range) + rangeMin;
};

/**
 * Generates random number which is in [-1, +1]
 * <br><br>
 * @returns {Number} Result random number.
 */
exports.Ops.randomMinusOneToOne = function()
{
    return Math.random() * 2.0 - 1.0;
};

/**
 * Clamps the input value to the specified range.
 * <br><br>
 * If the value is not in the range between <code>nMin</code> and <code>nMax</code>, the result is set in this range.
 * @name Foundation.Math.Ops.clamp
 * @param {Number} nValue Input value.
 * @param {Number} nMin Minimum number of result.
 * @param {Number} nMax Maximum number of result.
 * @returns {Number} Result value.
 */
exports.Ops.clamp = function(nValue, nMin, nMax)
{
    return nValue < nMin ? nMin : nValue > nMax ? nMax : nValue ;
};

/**
 * Calculates the linear position for a motion tween object.
 * @name Foundation.Math.Ops.linearTween
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.linearTween = function(time, begin, change, duration)
{
    return change * time / duration + begin;
};

/**
 * Calculates the position for a motion tween object with ease in.
 * @name Foundation.Math.Ops.easeInQuad
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeInQuad = function(time, begin, change, duration)
{
    return change * (time /= duration) * time + begin;
};

/**
 * Calculates the position for a motion tween object with ease out.
 * @name Foundation.Math.Ops.easeOutQuad
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeOutQuad = function(time, begin, change, duration)
{
    return -change * (time /= duration) * (time - 2) + begin;
};

/**
 * Calculates the position for a motion tween object with exponential ease in.
 * @name Foundation.Math.Ops.easeInExpo
 * @param {Number} time that has elapsed
 * @param {Number} begin position
 * @param {Number} change in position so far
 * @param {Number} duration of the tween
 * @returns {Number} new potion
 */
exports.Ops.easeInExpo = function(time, begin, change, duration)
{
    return change * Math.pow(2, 10 * (time/duration - 1)) + begin;
};

/**
 * Calculates the position for a motion tween object with exponential ease out.
 * @name Foundation.Math.Ops.easeOutExpo
 * @param {Number} time Time that has elapsed.
 * @param {Number} begin Begin position.
 * @param {Number} change Change in position so far.
 * @param {Number} duration Duration of the tween.
 * @returns {Number} New potion.
 */
exports.Ops.easeOutExpo = function(time, begin, change, duration)
{
    return change * (-Math.pow(2, -10 * time/duration) + 1) + begin;
};

/*
exports.Ops.easeInOutExpo = function(time, begin, change, duration)
{
    if ((time/=(duration*0.5)) < 1)
    {
        return change*0.5 * Math.pow(2, 10 * (time - 1)) + begin;
    }
    return change * 0.5 * (-Math.pow(2, -10 * --time) + 2) + begin;
*/
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Service/Graphics/_VFXActions'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Service/Graphics/_VFXActions'] || {}; $MODULE_REGISTRY['NGGo1.3/Service/Graphics/_VFXActions'] = exports; 
var __dirname = 'NGGo1.3/Service/Graphics';
var __filename = 'NGGo1.3/Service/Graphics/_VFXActions.js';

/**
 *  @author:    Amjad Aziz, Tatsuya Koyama
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Class = require('NGCore/Client/Core/Class').Class;
var Time = require('NGCore/Client/Core/Time').Time;
var Utils = require('NGGo1.3/Foundation/Math/Utils').Utils;
var Ops = require('NGGo1.3/Foundation/Math/Ops').Ops;
exports.VFXTaskNode = Class.subclass( /** @lends Service.Graphics.VFXTaskNode.prototype */
{
    classname: 'VFXTaskNode',
    /**
     * @class <code>VFXTaskNode</code> class is a effect task class. 
     * Use it in fluent interface(http://martinfowler.com/bliki/FluentInterface.html), like jQuery.
     *
     * @example
     * VFX.enchant(node)
     *    .move(3.0, 100, 100)
     *    .hop(5, 5)
     *    .end();
     *
     * @arguments Core.Class
     * @constructs Init effect task class.
     * @param {GL2.Node} node Target node object.
     * @param {Function} call back when called on finish.
     */
    initialize: function (node)
    {
        this.node = node;
        this.func = null;
        this.args = [];
        this.progress = 0;
        this.delta = 0;
        this.next = null;
        this.param = {};
        this.isInitialized = false;
        this.isActive = false;
        this.isFinished = false;
        this.isDestroyed = false;
    },
    /**
     * Apply any functions as the task. The function should call <code>this.finish()</code>.
     *
     * @example
     * var msg = function(message) {
     *     text.setText(message);
     *     this.finish();
     * };
     *
     * VFX.enchant(node)
     *     .wait(10)
     *     .and(msg, ["wait finished"])
     *     .end();
     * 
     * @param {Function} func Function object which is called after previous task was finished.
     * @param {Array} args arguments they are passed to the function.
     * @returns {Service.Graphics.VFXTaskNode} next job.
     */
    and: function (func, args)
    {
        if(func === "blink")
        {
            this.node._previousAlpha = this.node.getAlpha();
        }
        this.isActive = true;
        this.func = func;
        this.args = args;
        var nextTask = new exports.VFXTaskNode(this.node);
        this.next = nextTask;
        return nextTask;
    },
    /**
     * Insert new task into the task chain.
     *
     * @example
     * var msg = function(message) {
     *     text.setText(message);
     *     if (Math.random() > 0.5) {
     *          this.insert('hop', [10, 1]);
     *     }
     *     this.finish();
     * };
     *
     * VFX.enchant(node)
     *     .and(msg, ["sometimes hopping finished"])
     *     .end();
     * 
     * @param {Function} func Function object which is called after previous task was finished.
     * @param {Array} args arguments they are passed to the function.
     * @returns {Service.Graphics.VFXTaskNode} next job.
     */
    insert: function (func, args)
    {
        var insertTask = new exports.VFXTaskNode(this.node);
        insertTask.isActive = true;
        insertTask.func = func;
        insertTask.args = args;
        insertTask.next = this.next;
        this.next = insertTask;
        return insertTask;
    },
    /**
     * Finish VFX tasks and destroy target node.
     */
    end: function ()
    {
        return this.and('end');
    },
    /**
     * Register task, but not fire now. To restart this task, run Service.Graphics.VFX.run(node).
     * 
     * @returns {Service.Graphics.VFXTaskNode} next job.
     */
    register: function ()
    {
        var next = this.and('register', []);
        this.isActive = false;
        return next;
    },
    finish: function (duration)
    {
        if(!duration)
        {
            duration = 0;
        }
        if(this.progress >= duration)
        {
            this.isFinished = true;
        }
        return this.isFinished;
    },
    /**
     * @private
     */
    _bezierat: function (a, b, c, d, t)
    {
        return(Math.pow(1 - t, 3) * a + 3 * t * (Math.pow(1 - t, 2)) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d);
    },
    _getEasingFunction: function (easingFunc)
    {
        var easingFunction = null;
        if(typeof easingFunc === "function")
        {
            easingFunction = easingFunc;
        }
        else if(typeof easingFunc === "string")
        {
            easingFunction = Ops[easingFunc];
            if(easingFunction === undefined)
            {
                throw new Error("Provided name:" + easingFunc + " is not an easingFunction available in Math.Ops");
            }
        }
        else
        {
            easingFunction = Ops.linearTween;
        }
        return easingFunction;
    }
});
//========================================================================================
exports.VFX = MessageListener.singleton( /** @lends Service.Graphics.VFX.prototype */
{
    classname: 'VFX',
    /**
     * @class <code>VFX</code> class effect to the <code>GL2.Node</code> class. 
     * Use it in fluent interface(http://martinfowler.com/bliki/FluentInterface.html), like jQuery.
     *
     * @arguments Core.MessageListener
     * @constructs Initialize effect class.
     */
    initialize: function ()
    {
        UpdateEmitter.addListener(this, this.onUpdate);
        this.tasks = {};
        this.nodeId = 0;
        this.taskId = 0;
        this.isActive = true;
    },
    /**
     * Start setting new tasks.
     *
     * @param {GL2.Node} node Target node object.
     * @returns {Service.Graphics.VFXTaskNode} next job.
     */
    enchant: function (node)
    {
        var nodeId = 0;
        var taskId = 0;
        if(!node._dnVFXManagedId)
        {
            nodeId = ++this.nodeId;
            node._dnVFXManagedId = nodeId;
            this.tasks[nodeId] = {};
        }
        else
        {
            nodeId = node._dnVFXManagedId;
            taskId = ++this.taskId;
        }
        //Work around
        if(!this.tasks[nodeId])
        {
            this.tasks[nodeId] = {};
        }
        var newTask = new exports.VFXTaskNode(node);
        this.tasks[nodeId][taskId] = newTask;
        return newTask;
    },
    /**
     * Stop all remained tasks of passed node.
     *
     * @param {GL2.Node} node Target node object.
     */
    stop: function (node)
    {
        if(node._dnVFXManagedId)
        {
            delete this.tasks[node._dnVFXManagedId];
            delete node._dnVFXManagedId;
        }
    },
    /**
     * Reset task groups and start recreating.
     *
     * @param {GL2.Node} node Target node object.
     * @returns {Service.Graphics.VFXTaskNode} next job.
     */
    restart: function (node)
    {
        this.stop(node);
        return this.enchant(node);
    },
    /**
     * Starts all registered tasks for given node.
     *
     * @param {GL2.Node} node Target node object.
     */
    run: function (node)
    {
        if(node._dnVFXManagedId)
        {
            var nodeId = node._dnVFXManagedId;
            var taskId;
            for(taskId in this.tasks[nodeId])
            {
                if(this.tasks[nodeId].hasOwnProperty(taskId))
                {
                    var task = this.tasks[nodeId][taskId];
                    if(task.func === "register")
                    {
                        if(task.next.isActive)
                        {
                            this.tasks[nodeId][taskId] = task.next;
                        }
                        else
                        {
                            delete this.tasks[nodeId][taskId];
                        }
                    }
                }
            }
        }
    },
    //--------------------------------------------------------------------------
    removeAllTasks: function ()
    {
        var nodeId;
        for(nodeId in this.tasks)
        {
            if(this.tasks.hasOwnProperty(nodeId))
            {
                var taskId;
                for(taskId in this.tasks[nodeId])
                {
                    if(this.tasks[nodeId].hasOwnProperty(taskId))
                    {
                        var n = this.tasks[nodeId][taskId].node || null;
                        if(!n)
                        {
                            break;
                        }
                        if(n._previousAlpha)
                        {
                            n.setAlpha(n._previousAlpha);
                            delete n._previousAlpha;
                        }
                        if(n._dnVFXManagedId)
                        {
                            delete n._dnVFXManagedId;
                            break;
                        }
                        delete this.tasks[nodeId][taskId];
                    }
                }
                delete this.tasks[nodeId];
            }
        }
        this.tasks = {};
    },
    //==========================================================================
    // Animation methods
    //--------------------------------------------------------------------------
    end: function ()
    {
        Utils.destroyIfAlive(this.node);
        this.isDestroyed = true;
    },
    //--------------------------------------------------------------------------
    waitFor: function (time)
    {
        this.finish(time);
    },
    //--------------------------------------------------------------------------
    appear: function ()
    {
        this.node.setVisible(true);
        this.finish();
    },
    //--------------------------------------------------------------------------
    disappear: function ()
    {
        this.node.setVisible(false);
        this.finish();
    },
    //--------------------------------------------------------------------------
    toggleVisible: function ()
    {
        this.node.setVisible(!this.node.getVisible());
        this.finish();
    },
    //--------------------------------------------------------------------------
    fadeIn: function (duration, alpha, easingFunc)
    {
        if(!alpha)
        {
            alpha = 1;
        }
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            this.isInitialized = true;
            this.param.startAlpha = 0;
            this.param.targetAlpha = alpha;
            if(this.param.targetAlpha > 1)
            {
                this.param.targetAlpha = 1;
            }
            if(this.param.targetAlpha < 0)
            {
                this.param.targetAlpha = 0;
            }
        }
        this.node.setAlpha(this._easingFunc(this.progress, this.param.startAlpha, this.param.targetAlpha, duration));
        this.finish(duration);
    },
    //--------------------------------------------------------------------------
    fadeOut: function (duration, alpha, easingFunc)
    {
        if(!alpha)
        {
            alpha = 0;
        }
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            this.isInitialized = true;
            this.param.startAlpha = 1;
            this.param.targetAlpha = alpha - 1;
            if(this.param.targetAlpha < -1)
            {
                this.param.targetAlpha = -1;
            }
            if(this.param.targetAlpha > 0)
            {
                this.param.targetAlpha = 0;
            }
        }
        this.node.setAlpha(this._easingFunc(this.progress, this.param.startAlpha, this.param.targetAlpha, duration));
        this.finish(duration);
    },
    //--------------------------------------------------------------------------
    alpha: function (duration, alpha, easingFunc)
    {
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            this.isInitialized = true;
            var a = this.node.getAlpha();
            this.param.startAlpha = a;
            this.param.targetAlpha = alpha + a;
            if(this.param.targetAlpha > 1)
            {
                this.param.targetAlpha = 1;
            }
            if(this.param.targetAlpha < 0)
            {
                this.param.targetAlpha = 0;
            }
        }
        if(this.finish(duration))
        {
            this.node.setAlpha(this.param.targetAlpha);
        }
        else
        {
            this.node.setAlpha(this._easingFunc(this.progress, this.param.startAlpha, alpha, duration));
        }
    },
    //--------------------------------------------------------------------------
    alphaTo: function (duration, alpha, easeIn)
    {
        var a = alpha - this.node.getAlpha();
        this.func = 'alpha';
        this.args = [duration, a, easeIn];
    },
    //--------------------------------------------------------------------------
    move: function (duration, dx, dy, easingFunc)
    {
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            var x = this.node.getPosition().getX();
            var y = this.node.getPosition().getY();
            this.isInitialized = true;
            this.param.startX = x;
            this.param.startY = y;
            this.param.targetX = x + dx;
            this.param.targetY = y + dy;
        }
        if(this.finish(duration))
        {
            this.node.setPosition(this.param.targetX, this.param.targetY);
        }
        else
        {
            this.node.setPosition(
            this._easingFunc(this.progress, this.param.startX, dx, duration), this._easingFunc(this.progress, this.param.startY, dy, duration));
        }
    },
    //--------------------------------------------------------------------------
    moveTo: function (duration, tx, ty, easeIn)
    {
        var dx = tx - this.node.getPosition().getX();
        var dy = ty - this.node.getPosition().getY();
        this.func = 'move';
        this.args = [duration, dx, dy, easeIn];
    },
    //--------------------------------------------------------------------------
    bezier: function (duration, bezierConfigObject)
    {
        if(!this.isInitialized)
        {
            var _x = this.node.getPosition().getX();
            var _y = this.node.getPosition().getY();
            this.param.startX = _x;
            this.param.startY = _y;
            this._xa = 0;
            this._xb = bezierConfigObject.controlPoint_1[0];
            this._xc = bezierConfigObject.controlPoint_2[0];
            this._xd = bezierConfigObject.endPosition[0];
            this._ya = 0;
            this._yb = bezierConfigObject.controlPoint_1[1];
            this._yc = bezierConfigObject.controlPoint_2[1];
            this._yd = bezierConfigObject.endPosition[1];
            this.isInitialized = true;
        }
        var t = this.progress / duration;
        var x = this._bezierat(this._xa, this._xb, this._xc, this._xd, t);
        var y = this._bezierat(this._ya, this._yb, this._yc, this._yd, t);
        if(this.finish(duration))
        {
            this.node.setPosition(this.param.startX + bezierConfigObject.endPosition[0], this.param.startY + bezierConfigObject.endPosition[1]);
        }
        else
        {
            this.node.setPosition(this.param.startX + x, this.param.startY + y);
        }
    },
    //--------------------------------------------------------------------------
    bezierTo: function (duration, bezierConfigObject)
    {
        var _x = this.node.getPosition().getX();
        var _y = this.node.getPosition().getY();
        bezierConfigObject.controlPoint_1[0] -= _x;
        bezierConfigObject.controlPoint_2[0] -= _x;
        bezierConfigObject.endPosition[0] -= _x;
        bezierConfigObject.controlPoint_1[1] -= _y;
        bezierConfigObject.controlPoint_2[1] -= _y;
        bezierConfigObject.endPosition[1] -= _y;
        this.func = 'bezier';
        this.args = [duration, bezierConfigObject];
    },
    //---------------------------------------------------------------------------------
    jump: function (duration, dx, dy, height, jumps)
    {
        if(!this.isInitialized)
        {
            var _x = this.node.getPosition().getX();
            var _y = this.node.getPosition().getY();
            this.param.startX = _x;
            this.param.startY = _y;
            this.isInitialized = true;
        }
        var t = this.progress / duration;
        var value = (t * jumps) % 1.0;
        var y = height * 4 * value * (1 - value);
        y = -1 * y + dy * t;
        var x = dx * t;
        if(this.finish(duration))
        {
            this.node.setPosition(this.param.startX + dx, this.param.startY + dy);
        }
        else
        {
            this.node.setPosition(this.param.startX + x, this.param.startY + y);
        }
    },
    //-----------------------------------    -----------------------------------
    jumpTo: function (duration, tx, ty, heights, jumps)
    {
        var dx = tx - this.node.getPosition().getX();
        var dy = ty - this.node.getPosition().getY();
        this.func = 'jump';
        this.args = [duration, dx, dy, heights, jumps];
    },
    //--------------------------------------------------------------------------
    place: function (duration, targetX, tragetY)
    {
        if(!this.isInitialized)
        {
            var _x = this.node.getPosition().getX();
            var _y = this.node.getPosition().getY();
            this.param.startX = _x;
            this.param.startY = _y;
            this.isInitialized = true;
        }
        if(this.finish(duration))
        {
            this.node.setPosition(this.param.startX + targetX, this.param.startY + tragetY);
        }
    },
    //--------------------------------------------------------------------------
    placeTo: function (duration, targetX, tragetY)
    {
        var dx = targetX - this.node.getPosition().getX();
        var dy = tragetY - this.node.getPosition().getY();
        this.func = 'place';
        this.args = [duration, dx, dy];
    },
    //--------------------------------------------------------------------------
    scale: function (duration, dScaleX, dScaleY, easingFunc)
    {
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            var sx = this.node.getScale().getX();
            var sy = this.node.getScale().getY();
            this.isInitialized = true;
            this.param.startScaleX = sx;
            this.param.startScaleY = sy;
            this.param.targetScaleX = sx + dScaleX;
            this.param.targetScaleY = sy + dScaleY;
        }
        if(this.finish(duration))
        {
            this.node.setScale(this.param.targetScaleX, this.param.targetScaleY);
        }
        else
        {
            this.node.setScale(
            this._easingFunc(this.progress, this.param.startScaleX, dScaleX, duration), this._easingFunc(this.progress, this.param.startScaleY, dScaleY, duration));
        }
    },
    //--------------------------------------------------------------------------
    scaleTo: function (duration, tScaleX, tScaleY, easeIn)
    {
        var dsx = tScaleX - this.node.getScale().getX();
        var dsy = tScaleY - this.node.getScale().getY();
        this.func = 'scale';
        this.args = [duration, dsx, dsy, easeIn];
    },
    //--------------------------------------------------------------------------
    rotate: function (duration, dRot, easingFunc)
    {
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            var rot = this.node.getRotation();
            this.isInitialized = true;
            this.param.startRot = rot;
            this.param.targetRot = rot + dRot;
        }
        if(this.finish(duration))
        {
            this.node.setRotation(this.param.targetRot);
        }
        else
        {
            this.node.setRotation(
            this._easingFunc(this.progress, this.param.startRot, dRot, duration));
        }
    },
    //--------------------------------------------------------------------------
    rotateTo: function (duration, tRot, easeIn)
    {
        var dRot = tRot - this.node.getRotation();
        this.func = 'rotate';
        this.args = [duration, dRot, easeIn];
    },
    //--------------------------------------------------------------------------
    color: function (duration, dr, dg, db, easingFunc)
    {
        if(!this.isInitialized)
        {
            this._easingFunc = this._getEasingFunction(easingFunc);
            this.isInitialized = true;
            this.param.startR = this.node.getColor().getRed();
            this.param.targetR = this.param.startR + dr;
            this.param.startG = this.node.getColor().getGreen();
            this.param.targetG = this.param.startG + dg;
            this.param.startB = this.node.getColor().getBlue();
            this.param.targetB = this.param.startB + db;
        }
        if(this.finish(duration))
        {
            this.node.setColor(
            this.param.targetR, this.param.targetG, this.param.targetB);
        }
        else
        {
            this.node.setColor(
            this._easingFunc(this.progress, this.param.startR, dr, duration), this._easingFunc(this.progress, this.param.startG, dg, duration), this._easingFunc(this.progress, this.param.startB, db, duration));
        }
    },
    //--------------------------------------------------------------------------
    colorTo: function (duration, tr, tg, tb, easeIn)
    {
        var dr = tr - this.node.getColor().getRed();
        var dg = tg - this.node.getColor().getGreen();
        var db = tb - this.node.getColor().getBlue();
        this.func = 'color';
        this.args = [duration, dr, dg, db, easeIn];
    },
    //--------------------------------------------------------------------------
    hop: function (velocity, gravity)
    {
        if(!this.isInitialized)
        {
            this.isInitialized = true;
            this.param.vecY = -velocity;
            this.param.baseLineY = this.node.getPosition().getY();
            this.param.hopCount = 10;
        }
        var x = this.node.getPosition().getX();
        var y = this.node.getPosition().getY();
        this.param.vecY += gravity;
        y += this.param.vecY;
        this.node.setPosition(x, y);
        if(y > this.param.baseLineY)
        {
            y = this.param.baseLineY;
            this.node.setPosition(x, y);
            this.param.vecY *= -0.7;
            this.param.hopCount -= 1;
            if(this.param.hopCount === 0)
            {
                this.finish();
            }
            if(Math.abs(this.param.vecY) < 0.1)
            {
                this.finish();
            }
        }
    },
    blink: function (duration, term, alphas)
    {
        var progress = this.progress % term / term;
        var alpha = alphas[0] * (1 - progress) + alphas[1] * progress;
        this.node.setAlpha(alpha);
        this.finish(duration);
    },
    finish: function ()
    {
        this.finish();
    },
    /**
     * Pause all tasks.
     *
     */
    pause: function ()
    {
        if(this.isActive)
        {
            this.isActive = false;
            UpdateEmitter.removeListener(this, this.onUpdate);
        }
    },
    /**
     * Resume all paused tasks.
     *
     */
    resume: function ()
    {
        if(!this.isActive)
        {
            this.isActive = true;
            UpdateEmitter.addListener(this, this.onUpdate);
        }
    },
    //==========================================================================
    //--------------------------------------------------------------------------
    onUpdate: function ()
    {
        var delta = Time.getFrameDelta() / 1000;
        var nodeId;
        for(nodeId in this.tasks)
        {
            if(this.tasks.hasOwnProperty(nodeId))
            {
                var taskId;
                for(taskId in this.tasks[nodeId])
                {
                    if(this.tasks[nodeId].hasOwnProperty(taskId))
                    {
                        var t = this.tasks[nodeId][taskId];
                        if(t.isActive)
                        {
                            t.progress += delta;
                            t.delta = delta;
                            if(!t.isFinished)
                            {
                                if(typeof (t.func) === 'function')
                                {
                                    t.func.apply(t, t.args);
                                    t.isFinished = true;
                                }
                                else
                                {
                                    this[t.func].apply(t, t.args);
                                }
                            }
                            if(t.isDestroyed)
                            {
                                if(this.tasks[nodeId])
                                {
                                    delete this.tasks[nodeId];
                                }
                            }
                            else if(t.isFinished)
                            {
                                if(t.func === "blink")
                                {
                                    if(t.node._previousAlpha)
                                    {
                                        t.node.setAlpha(t.node._previousAlpha);
                                        delete t.node._previousAlpha;
                                    }
                                }
                                if(this.tasks[nodeId] && t.next.isActive)
                                {
                                    var nextTask = this.tasks[nodeId][taskId] = t.next;
                                    // Check to avoid call utilizeTick if task has duration less than delta.
                                    if(!nextTask.args || typeof (nextTask.args[0]) !== "number" || nextTask.args[0] >= delta)
                                    {
                                        this._utilizeTick(nextTask, delta);
                                    }
                                }
                                else
                                {
                                    if(this.tasks[nodeId] && this.tasks[nodeId][taskId])
                                    {
                                        delete this.tasks[nodeId][taskId];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    _utilizeTick: function (nextTask, delta)
    {
        if(nextTask.isActive)
        {
            nextTask.progress += delta;
            nextTask.delta = delta;
            if(!nextTask.isFinished)
            {
                if(typeof (nextTask.func) === 'function')
                {
                    nextTask.func.apply(nextTask, nextTask.args);
                    nextTask.isFinished = true;
                }
                else
                {
                    this[nextTask.func].apply(nextTask, nextTask.args);
                }
            }
        }
    },
    _isNodeBusy: function (node)
    {
        var nodeId;
        for(nodeId in this.tasks)
        {
            if(this.tasks.hasOwnProperty(nodeId))
            {
                var taskId;
                for(taskId in this.tasks[nodeId])
                {
                    if(this.tasks[nodeId].hasOwnProperty(taskId))
                    {
                        var n = this.tasks[nodeId][taskId].node || null;
                        if(n.__objectRegistryId === node.__objectRegistryId)
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Service/Graphics/VFXActions'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Service/Graphics/VFXActions'] || {}; $MODULE_REGISTRY['NGGo1.3/Service/Graphics/VFXActions'] = exports; 
var __dirname = 'NGGo1.3/Service/Graphics';
var __filename = 'NGGo1.3/Service/Graphics/VFXActions.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Amjad Aziz
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var VFX = require('NGGo1.3/Service/Graphics/_VFXActions').VFX;
var Node = require('NGCore/Client/GL2/Node').Node;
var Core = require('NGCore/Client/Core').Core;
var VFXActions;
var Sequence = Core.Class.subclass( /** @lends Service.Graphics.Sequence.prototype*/
{
    classname: "Sequence",
    /**
     * Creates new sequence for provided actions. Sets repeat 1 as default. 
     * @param {Array} actions.
     * @arguments Core.Class
     * @constructs Init sequence class.
     * @example 
     * var action1 = VFXActions.moveTo(4,new Core.Point(200,200),Ops.easeInQuad);
     * var action2 = VFXActions.moveTo(4,new Core.Point(20,20),Ops.easeInQuad);
     * var sequence = VFXActions.createSequence([action1,action2]);
     * 
     * @see Service.Graphics.VFXActions
     * */
    initialize: function (actions)
    {
        if(actions instanceof Array && VFXActions._isEligible(actions))
        {
            this.actions = [];
            var i, len = actions.length;
            for(i = 0; i < len; i++)
            {
                if(actions[i].classname === "Action" || actions[i].classname === "Sequence" || actions[i].classname === "Spawn")
                {
                    this.actions.push(actions[i]);
                }
            }
            this._totalDuration = VFXActions._calculateTotalDuration(this.actions);
            this._frequency = 1;
            this._progress = 0;
            this._parent = null;
            this._index = 0;
            this._node = null;
        }
        else
        {
            throw new Error('Invalid actions or One of inner Sequence or Spawn has repeat forever.');
        }
    },
    /**
     * destroy the current sequence.
     */
    destroy: function ()
    {
        if(this.actions)
        {
            delete this.actions;
        }
        delete this._frequency;
        if(this._parent)
        {
            delete this._parent;
        }
        delete this._index;
        if(this._node)
        {
            delete this._node;
        }
        if(this._callback)
        {
            delete this._callback;
        }
        delete this._progress;
    },
    /**
     * Starts already created sequence on passed node.
     * @param {GL2.Node} node 
     * @param {Function} callback. When sequence completes it's execution after play then callback function is called.
     * @example 
     * var callback = function() {
     * console.log("Sequence Ended...");
     * };
     * var action1 = VFXActions.moveTo(4,new Core.Point(200,200),Ops.easeInQuad);
     * var action2 = VFXActions.moveTo(4,new Core.Point(20,20),Ops.easeInQuad);
     * var sequence = VFXActions.createSequence([action1,action2]);
     * sequence.play(node,callback);
     * 
     * */
    play: function (node, callback)
    {
        if(node && node instanceof Node)
        {
            //TODO: Is it neccesity? Why is it necessity?
            //if(!VFX._isNodeBusy(node))
            //{
                if(callback)
                {
                    if(typeof (callback) === "function")
                    {
                        this._callback = callback;
                    }
                }
                if(VFXActions._isEligible(this.actions))
                {
                    this._progress = 0;
                    this._node = node;
                    this._handleRepeat(this);
                }
                else
                {
                    throw new Error("Inner Sequence or Spawn has repeat forever property. Could not run this Sequence.");
                }
            //}
            //else
            //{
            //    console.log("Another Sequence or Spawn is already in-progess on " + node);
            //}
        }
        else
        {
            throw new Error('Argument Can\'t be null or should be instance of Node.\n For Example: sequence.play(node,callback);');
        }
    },
    /**
     * Repeat current sequence for given number of times. 
     * @param {Number} frequency 
     * */
    repeat: function (frequency)
    {
        if(frequency >= 1)
        {
            this._frequency = frequency;
            return this;
        }
        else
        {
            throw new Error('Repeat accepts only positive number \nFor Example: seq.repeat(2);\n');
        }
    },
    /**
     * Repeat current sequence forever. 
     * */
    repeatForEver: function ()
    {
        if(VFXActions._isEligible(this.actions))
        {
            this._frequency = -1;
            return this;
        }
        else
        {
            throw new Error("Inner Sequence or Spawn already have repeat forever property .. ");
        }
    },
    /** 
     *@private
     */
    _handleRepeat: function (context)
    {
        if(this !== context)
        {
            this.finish(0);
        }
        if(context._frequency !== -1 && context._progress >= context._frequency)
        {
            if(context._parent && context._hasMaxDuration)
            {
                context._parent._index = 0;
                VFX.enchant(context._node).and(context._parent._handleRepeat, [context._parent]);
            }
            else if(context._parent && context._parent.classname !== "Spawn")
            {
                VFX.enchant(context._node).and(context._parent._execute, [context._parent]);
            }
            else
            {
                context._progress = 0;
                context._index = 0;
            }
            if(context._callback)
            {
                context._callback();
            }
        }
        else
        {
            context._progress++;
            context._index = 0;
            context._execute(context);
        }
    },
    /** 
     *@private
     */
    _execute: function (context)
    {
        if(this !== context)
        {
            this.finish(0);
        }
        if(context.actions[context._index])
        {
            /**
             * Reset both inner Sequences and Spawn.
             */
            var resetSS = function (context)
                {
                    context.actions[context._index]._node = context._node;
                    context.actions[context._index]._parent = context;
                    context.actions[context._index]._index = 0;
                    context.actions[context._index]._progress = 0;
                };
            switch(context.actions[context._index].classname)
            {
            case "Action":
                var vfxTask = VFX.enchant(context._node).and(context.actions[context._index].func, context.actions[context._index].args);
                context._index++;
                while(context.actions[context._index] && context.actions[context._index].classname === "Action")
                {
                    vfxTask = vfxTask.and(context.actions[context._index].func, context.actions[context._index].args);
                    context._index++;
                }
                if(context.actions.length === context._index)
                {
                    vfxTask.and(context._handleRepeat, [context]);
                }
                else
                {
                    vfxTask.and(context._execute, [context]);
                }
                break;
            case "Sequence":
            case "Spawn":
                resetSS(context);
                VFX.enchant(context._node).and(context.actions[context._index]._handleRepeat, [context.actions[context._index]]);
                context._index++;
                break;
            }
        }
        else
        {
            if(context.actions.length === context._index)
            {
                VFX.enchant(context._node).and(context._handleRepeat, [context]);
            }
        }
    }
});
exports.Sequence = Sequence;
var Spawn = Core.Class.subclass( /** @lends Service.Graphics.Spawn.prototype*/
{
    classname: "Spawn",
    /**
     * Creates new spawn for provided actions. Sets repeat 1 as default.
     *  Note: For spawn all actions must have equal duration.
     * @param {Array} actions.
     * @arguments Core.Class
     * @constructs Init spawn class. 
     * @example 
     * var action1 = VFXActions.moveTo(4,new Core.Point(200,200),Ops.easeInQuad);
     * var action2 = VFXActions.scaleTo(4,new Core.Vector(2,2),Ops.easeInQuad);
     * var spawn   = VFXActions.createSpawn([action1,action2]);
     * 
     * @see Service.Graphics.VFXActions
     * */
    initialize: function (actions)
    {
        this.actions = [];
        if(actions instanceof Array)
        {
            var i, len = actions.length;
            for(i = 0; i < len; i++)
            {
                if(actions[i].classname === "Action" || actions[i].classname === "Sequence" || actions[i].classname === "Spawn")
                {
                    this.actions.push(actions[i]);
                }
            }
            this._totalDuration = VFXActions._calculateMaxDuration(this.actions);
            this._node = null;
            this._frequency = 1;
            this._index = 0;
            this._progress = 0;
            this._parent = null;
        }
        else
        {
            throw new Error('Invalid actions or One of inner Sequence or Spawn has repeat forever.');
        }
    },
    /**
     * destroy the current spawn.
     * 
     * */
    destroy: function ()
    {
        if(this.actions)
        {
            delete this.actions;
        }
        delete this._frequency;
        if(this._parent)
        {
            delete this._parent;
        }
        delete this._index;
        if(this._node)
        {
            delete this._node;
        }
        if(this._callback)
        {
            delete this._callback;
        }
        delete this._progress;
    },
    /**
     * Starts already created spawn on passed node.
     * @param {GL2.Node} node 
     * @example 
     * var callback = function() {
     * console.log("Spawn Ended...");
     * };
     * var action1 = VFXActions.moveTo(4,new Core.Point(200,200),Ops.easeInQuad);
     * var action2 = VFXActions.scaleTo(4,new Core.Vector(2,2),Ops.easeInQuad);
     * var spawn   = VFXActions.createSpawn([action1,action2]);
     * spawn.play(node,callback);
     * 
     * */
    play: function (node, callback)
    {
        if(node && node instanceof Node)
        {
            //TODO: Is it neccesity? Why is it necessity?
            //if(!VFX._isNodeBusy(node))
            //{
                if(callback)
                {
                    if(typeof (callback) === "function")
                    {
                        this._callback = callback;
                    }
                }
                this._progress = 0;
                this._node = node;
                this._handleRepeat(this);
            //}
            //else
            //{
            //    console.log("Another Sequence or Spawn is already in-progess on " + node);
            //}
        }
        else
        {
            throw new Error('Argument Can\'t be null or should be instance of Node.\n For Example: spawn.play(node,callback);');
        }
    },
    /**
     * Repeat current spawn for given number of times. 
     * @param {Number} frequency 
     * */
    repeat: function (frequency)
    {
        if(frequency >= 1)
        {
            this._frequency = frequency;
            return this;
        }
        else
        {
            throw new Error('Repeat accepts only positive number\nFor Example: spawn.repeat(2);\n');
        }
    },
    /**
     * Repeat current spawn forever. 
     * */
    repeatForEver: function ()
    {
        this._frequency = -1;
        return this;
    },
    /** 
     *@private
     */
    _handleRepeat: function (context)
    {
        if(this !== context)
        {
            this.finish(0);
        }
        if(context._progress >= context._frequency && context._frequency !== -1)
        {
            if(context._parent && context._hasMaxDuration)
            {
                context._parent._index = 0;
                VFX.enchant(context._node).and(context._parent._handleRepeat, [context._parent]);
            }
            else if(context._parent && context._parent.classname !== "Spawn")
            {
                VFX.enchant(context._node).and(context._parent._execute, [context._parent]);
            }
            else
            {
                context._progress = 0;
                context._index = 0;
            }
            if(context._callback)
            {
                context._callback();
            }
        }
        else
        {
            context._progress++;
            context._index = 0; // Looping back
            context._execute(context);
        }
    },
    /** 
     *@private
     */
    _execute: function (context)
    {
        if(this !== context)
        {
            this.finish(0);
        }
        if(context.actions[context._index])
        {
            /**
             * Reset both inner Sequences and Spawns.
             */
            var resetSS = function (context)
                {
                    context.actions[context._index]._node = context._node;
                    context.actions[context._index]._parent = context;
                    context.actions[context._index]._index = 0;
                    context.actions[context._index]._progress = 0;
                };
            switch(context.actions[context._index].classname)
            {
            case "Action":
                if(context.actions[context._index]._hasMaxDuration)
                {
                    VFX.enchant(context._node).and(context.actions[context._index].func, context.actions[context._index].args).and(context._handleRepeat, [context]);
                }
                else
                {
                    VFX.enchant(context._node).and(context.actions[context._index].func, context.actions[context._index].args);
                }
                if(context.actions.length !== context._index + 1)
                {
                    VFX.enchant(context._node).and(context._execute, [context]);
                }
                context._index++;
                break;
            case "Sequence":
            case "Spawn":
                resetSS(context);
                VFX.enchant(context._node).and(context.actions[context._index]._handleRepeat, [context.actions[context._index]]);
                if(context.actions.length !== context._index + 1)
                {
                    VFX.enchant(context._node).and(context._execute, [context]);
                }
                context._index++;
                break;
            }
        }
        else
        {
            if(context.actions.length === context._index)
            {
                VFX.enchant(context._node).and(context._handleRepeat, [context]);
            }
        }
    }
});
exports.Spawn = Spawn;
var Action = Core.Class.subclass( /** @lends Service.Graphics.Action.prototype*/
{
    classname: "Action",
    initialize: function (func, args)
    {
        this._duration = 0;
        if(args && func !== "hop")
        {
            this._duration = args[0];
        }
        this.func = func;
        this.args = args;
    },
    repeatForEver: function ()
    {
        var sequence = new Sequence([this]);
        sequence.repeatForEver();
        return sequence;
    }
});
exports.Action = Action;
var VFXActions = Core.Class.singleton( /** @lends Service.Graphics.VFXActions.prototype*/
{
    classname: "VFXActions",
    /**
     * @class This <code>VFXActions</code> 
     * <br><br>
     * VFXActions class helps you to run different visual effects sequentially or simultaneously.
     * @arguments Core.Class
     * @constructs Init VFXActions.
     * @see Service.Graphics.Sequence
     * @see Service.Graphics.Spawn
     * */
    initialize: function ()
    {},
    /**
     * Apply any function as the task. It can be used if any callback is required after any action within the sequence.
     * It takes <code>function</code> as parameter.
     * @example 
     *  var notification = function ()
     *  {
     *      console.log("My custom function executed");
     *      
     *  }
     *  var action1  = VFXActions.rotate(4, 180, Ops.easeInQuad);
     *  var action2  = VFXActions.move(3, [200, 0], Ops.easeInQuad);
     *  var action3  = VFXActions.blink(4, 0.5, [1, 0]);
     *  var action4  = VFXActions.callFunc(notification);
     *  var sequence = VFXActions.createSequence([action1,action4, action2,action4 , action3, action4]);
     *  sequence.play(this._node);
     * @param {Function} custom function. It takes "function" as parameter and this function is registered as a task in the sequence.
     * @returns {Service.Graphics.VFXActions} next job
     */
    callFunc: function (callback)
    {
        if(typeof (callback) === "function")
        {
            this._callback = callback;
            return new Action(callback);
        }
        else
        {
            throw new Error("Parameter should be a function");
        }
    },
    /**
     * Creates a Move action which moves a node to target position passed, in given duration. 
     * @param {Number} duration The time it takes in moving[Seconds].
     * @param {Core.Point | Core.Vector | Array} targetPosition
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad , "easeOutQuad".
     * @returns {Service.Graphics.Action} action.
     * @see Service.Graphics.VFXActions#move
     */
    moveTo: function (duration, position, easing)
    {
        if(typeof (duration) === "number" && (position instanceof Core.Vector || position instanceof Core.Point || (position instanceof Array && position.length === 2)))
        {
            var p = new Core.Point(position);
            if(VFXActions._isNumber(p))
            {
                return new Action('moveTo', [duration, p.getX(), p.getY(), easing]);
            }
            else
            {
                throw new Error("Invalid point. Only numbers are acceptable for position. \nFor Example:  VFXActions.moveTo(4,[200,300],Ops.easeInQuad); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.moveTo(4,[200,300],Ops.easeInQuad)");
        }
    },
    /**
     * Creates a Move action which moves a node by the delta position passed, in given duration.  
     * @param {Number} duration the time it takes moving[Seconds].
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#moveTo
     */
    move: function (duration, deltaPosition, easing)
    {
        if(typeof (duration) === "number" && (deltaPosition instanceof Core.Vector || deltaPosition instanceof Core.Point || (deltaPosition instanceof Array && deltaPosition.length === 2)))
        {
            var p = new Core.Point(deltaPosition);
            if(VFXActions._isNumber(p))
            {
                return new Action('move', [duration, p.getX(), p.getY(), easing]);
            }
            else
            {
                throw new Error("Invalid point. Only numbers are acceptable for deltaPosition. \nFor Example:  VFXActions.move(4,new Core.Vector(20,30),Ops.easeInQuad); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.move(4,new Core.Point(50,50),Ops.easeInQuad);");
        }
    },
    /**
     * Creates a Scale action which scales a node by delta scale passed, in given duration.
     * @param {Number} duration the time it takes in scaling[Seconds].     
     * @param {Core.Point | Core.Vector | Array} deltaScale
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#scaleTo
     */
    scale: function (duration, dScale, easing)
    {
        if(typeof (duration) === "number" && (dScale instanceof Core.Vector || dScale instanceof Core.Point || (dScale instanceof Array && dScale.length === 2)))
        {
            var p = new Core.Point(dScale);
            if(VFXActions._isNumber(p))
            {
                return new Action('scale', [duration, p.getX(), p.getY(), easing]);
            }
            else
            {
                throw new Error("Invalid scale factor. Only numbers are acceptable for deltaScale. \nFor Example:  VFXActions.scale(4,new Core.Vector(1,0.5),Ops.easeInQuad); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.scale(4,[1,1],Ops.easeInQuad)");
        }
    },
    /**
     * Creates a Scale action which scales a node to target scale passed, in given duration.
     * @param {Number} duration the time it takes in scaling[Seconds].
     * @param {Core.Point | Core.Vector | Array} targetScale
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#scale
     */
    scaleTo: function (duration, scale, easing)
    {
        if(typeof (duration) === "number" && (scale instanceof Core.Vector || scale instanceof Core.Point || (scale instanceof Array && scale.length === 2)))
        {
            var p = new Core.Point(scale);
            if(VFXActions._isNumber(p))
            {
                return new Action('scaleTo', [duration, p.getX(), p.getY(), easing]);
            }
            else
            {
                throw new Error("Invalid scale factor. Only numbers are acceptable for scale. \nFor Example:  VFXActions.scaleTo(4,new Core.Vector(2,2),Ops.easeInQuad); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.scaleTo(4,[2,2],Ops.easeInQuad)");
        }
    },
    /**
     * Creates a Blink action which applies blinking effect to a node, for given duration.  
     * @param {Number} duration the time it takes for blinking[Seconds].
     * @param {Number} term Time duration for completing a blinking cycle default = 0.5.
     * @param {Number} alphas ranage of alphas to blink. default = [1,0]
     * @returns {Service.Graphics.Action} new action.
     */
    blink: function (duration, term, alphas)
    {
        if(typeof (duration) === "number")
        {
            if(!alphas || (alphas instanceof Array && alphas.length === 2 && typeof (alphas[0]) === "number" && typeof (alphas[1]) === "number"))
            {
                if(!term || typeof (term) === "number")
                {
                    term = term || 0.5;
                    alphas = alphas || [1, 0];
                    return new Action('blink', [duration, term, alphas]);
                }
                else
                {
                    throw new Error("term must be number.\nFor Example: VFXActions.blink(4,0.5,[0.8,0.3]);");
                }
            }
            else
            {
                throw new Error("alphas must be an Array.\nFor Example: VFXActions.blink(4,0.5,[0.8,0.3]);");
            }
        }
        else
        {
            throw new Error("duration must be provided:\nFor Example: VFXActions.blink(4,0.5,[0.8,0.3]);");
        }
    },
    /**
     * Creates FadeIn action which applies fading in effect on a node, in given duration.
     * @param {Number} duration the time it takes to fade in[Seconds].
     * @param {Number} alpha default=1.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#fadeOut
     */
    fadeIn: function (duration, alpha, easing)
    {
        if(typeof (duration) === "number" && (!alpha || typeof (alpha) === "number"))
        {
            return new Action('fadeIn', [duration, alpha, easing]);
        }
        else
        {
            throw new Error("Invalid Arguments. \nFor Example: VFXActions.fadeIn(4,0.5);");
        }
    },
    /**
     * Creates FadeOut action which applies fading out effect on a node, in given duration.
     * @param {Number} duration the time it takes to fade out[Seconds].
     * @param {Number} alpha default=0.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.Action#fadeIn
     */
    fadeOut: function (duration, alpha, easing)
    {
        if(typeof (duration) === "number" && (!alpha || typeof (alpha) === "number"))
        {
            return new Action('fadeOut', [duration, alpha, easing]);
        }
        else
        {
            throw new Error("Invalid Arguments. \nFor Example: VFXActions.fadeOut(4,0.5);");
        }
    },
    /**
     * Creates an Alpha action which modifies opacity of a node by passed delta alpha, in given duration. 
     * @param {Number} duration the time it takes for action[Seconds].
     * @param {Number} deltaAlpha 
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#moveTo
     */
    alpha: function (duration, alpha, easing)
    {
        if(typeof (duration) === "number" && typeof (alpha) === "number")
        {
            return new Action('alpha', [duration, alpha, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.aplha(4,0.5,Ops.easeInQuad);");
        }
    },
    /**
     * Creates an Alpha action which modifies opacity of a node to passed target alpha, in given duration.
     * @param {Number} duration the time it takes moving[Seconds].
     * @param {Number} targetAlpha 
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#move
     */
    alphaTo: function (duration, alpha, easing)
    {
        if(typeof (duration) === "number" && typeof (alpha) === "number")
        {
            return new Action('alphaTo', [duration, alpha, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.alphaTo(4,0.5,Ops.easeInQuad);");
        }
    },
    /**
     * Creates a Rotate action which rotates a node by passed delta angle, in given duration.
     * @param {Number} duration the time it takes in rotation[Seconds].
     * @param {Number} deltaRot delta angle(degree)
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#rotateTo
     */
    rotate: function (duration, dRot, easing)
    {
        if(typeof (duration) === "number" && typeof (dRot) === "number")
        {
            return new Action('rotate', [duration, dRot, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.rotate(4,180,Ops.easeInQuad);");
        }
    },
    /**
     * Creates a Rotate action which rotates a node to passed target angle, in given duration.
     * @param {Number} duration the time it takes in rotation[Seconds].
     * @param {Number} targetRot target rotation angle in degrees.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#rotate
     */
    rotateTo: function (duration, tRot, easing)
    {
        if(typeof (duration) === "number" && typeof (tRot) === "number")
        {
            return new Action('rotateTo', [duration, tRot, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.rotateTo(4,180,Ops.easeInQuad);");
        }
    },
    /**
     * Creates a Color action which modifies color filter of a node by passed deltaRGB, in given duration.
     * @param {Number} duration the time it takes changing color[Seconds].
     * @param {Number} dr change in red component of color.
     * @param {Number} dg change in green component of color.
     * @param {Number} db change in blue component of color.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#colorTo
     */
    color: function (duration, dr, dg, db, easing)
    {
        if(typeof (duration) === "number" && typeof (dr) === "number" && typeof (dg) === "number" && typeof (db) === "number")
        {
            return new Action('color', [duration, dr, dg, db, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.color(4,1,0,0,Ops.easeInQuad)");
        }
    },
    /**
     * Creates a Color action which modifies color filter of a node to passed targetRGB, in given duration.
     * @param {Number} duration the time it takes changing color[Seconds].
     * @param {Number} tr target red component of color.
     * @param {Number} tg target green component of color.
     * @param {Number} tb target blue component of color.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#color
     */
    colorTo: function (duration, r, g, b, easing)
    {
        if(typeof (duration) === "number" && typeof (r) === "number" && typeof (g) === "number" && typeof (b) === "number")
        {
            return new Action('colorTo', [duration, r, g, b, easing]);
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.colorTo(4,1,0,0,Ops.easeInQuad)");
        }
    },
    /**
     * Creates a Bezier action which moves the target node to the destination point, moving it through a curve created from the control points passed in configuration object, in the duration passed. 
     * @param {Number} duration Time duration for action.
     * @param {Object} Object Contains 3 points controlPoint_1{Point},controlPoint_2{Point},endPosition{Point} 
     * @example
     * var obj = {};
        obj.controlPoint_1 = [75,200];
        obj.controlPoint_2 = [150,400];
        obj.endPosition = [250,300];
        var action = VFXActions.bezierTo(5,obj);
     */
    bezierTo: function (duration, bezierConfigObject)
    {
        if(isNaN(duration) === false && bezierConfigObject.controlPoint_1 && (bezierConfigObject.controlPoint_1 instanceof Array) && bezierConfigObject.controlPoint_1.length === 2 && bezierConfigObject.controlPoint_2 && (bezierConfigObject.controlPoint_2 instanceof Array) && bezierConfigObject.controlPoint_2.length === 2 && bezierConfigObject.endPosition && (bezierConfigObject.endPosition instanceof Array) && bezierConfigObject.endPosition.length === 2)
        {
            return new Action('bezierTo', [duration, bezierConfigObject]);
        }
        else
        {
            throw new Error("Invalid arguments for VFXActions.bezierTo");
        }
    },
    /**
     * Creates a Bezier action which moves the target node by the delta position, moving it through a curve created from the control points passed in configuration object, in the duration passed.  
     * @param {Number} duration Time duration for action.
     * @param {Object} Object containing 3 points ControlPoint_1{Point},ControlPoint_2{Point},EndPosition{Point} 
     */
    bezier: function (duration, bezierConfigObject)
    {
        if(isNaN(duration) === false && bezierConfigObject.controlPoint_1 && (bezierConfigObject.controlPoint_1 instanceof Array) && bezierConfigObject.controlPoint_1.length === 2 && bezierConfigObject.controlPoint_2 && (bezierConfigObject.controlPoint_2 instanceof Array) && bezierConfigObject.controlPoint_2.length === 2 && bezierConfigObject.endPosition && (bezierConfigObject.endPosition instanceof Array) && bezierConfigObject.endPosition.length === 2)
        {
            return new Action('bezier', [duration, bezierConfigObject]);
        }
        else
        {
            throw new Error("Invalid arguments for VFXActions.bezier");
        }
    },
    /**
     * Creates a Jump action which moves the target node to destination, while giving it a jumping effect. Number of jumps and height of each jump can be configured by parameters. 
     * @param {Number} duration Time duration for action.
     * @param {Core.Point | Core.Vector | Array} targetPosition
     * @param {Number} height for Jump.
     * @param {Number} numberofJumps 
     */
    jumpTo: function (duration, position, height, jumps)
    {
        if(typeof (duration) === "number" && (position instanceof Core.Vector || position instanceof Core.Point || (position instanceof Array && position.length === 2)))
        {
            if((!height || typeof (height) === "number") && (!jumps || typeof (jumps) === "number"))
            {
                var p = new Core.Point(position);
                if(VFXActions._isNumber(p))
                {
                    height = height || 100;
                    jumps = jumps || 1;
                    return new Action('jumpTo', [duration, p.getX(), p.getY(), height, jumps]);
                }
                else
                {
                    throw new Error("Invalid position. Only numbers are acceptable for position. \nFor Example:  VFXActions.jumpTo(4,new Core.Vector(20,20),100,5); ");
                }
            }
            else
            {
                throw new Error("height and jumps should be numbers. ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.jumpTo(4,[100,100],10,3)");
        }
    },
    /**
     * Creates a Jump action which moves the target node by delta position, while giving it a jumping effect. Number of jumps and height of each jump can be confiugred by parameters.
     * @param {Number} duration Time duration for action.
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     * @param {Number} height for Jump.
     * @param {Number} numberofJumps 
     */
    jump: function (duration, dPosition, height, jumps)
    {
        if(typeof (duration) === "number" && (dPosition instanceof Core.Vector || dPosition instanceof Core.Point || (dPosition instanceof Array && dPosition.length === 2)))
        {
            if((!height || typeof (height) === "number") && (!jumps || typeof (jumps) === "number"))
            {
                var p = new Core.Point(dPosition);
                if(VFXActions._isNumber(p))
                {
                    height = height || 100;
                    jumps = jumps || 1;
                    return new Action('jump', [duration, p.getX(), p.getY(), height, jumps]);
                }
                else
                {
                    throw new Error("Invalid position. Only numbers are acceptable for position. \nFor Example:  VFXActions.jump(4,new Core.Vector(20,20),100,5); ");
                }
            }
            else
            {
                throw new Error("Only numbers are acceptable for jumps and height. ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.jump(4,[100,0],10,3)");
        }
    },
    /**
     * Creates a Place action which changes the position relative to the node after the given duration.
     * @param {Number} duration Time duration for Place action.
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     */
    place: function (duration, position)
    {
        if(typeof (duration) === "number" && (position instanceof Core.Vector || position instanceof Core.Point || (position instanceof Array && position.length === 2)))
        {
            var p = new Core.Point(position);
            if(VFXActions._isNumber(p))
            {
                return new Action('place', [duration, p.getX(), p.getY()]);
            }
            else
            {
                throw new Error("Invalid point. Only numbers are acceptable for position. \nFor Example:  VFXActions.place(4,[200,300]); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.place(4,[100,100])");
        }
    },
    /**
     * Creates a Place action which changes the position of the node to destination point, after a given duration.
     * @param {Number} duration Time duration for that particular task.
     * @param {Core.Point | Core.Vector | Array} targetPosition
     */
    placeTo: function (duration, position)
    {
        if(typeof (duration) === "number" && (position instanceof Core.Vector || position instanceof Core.Point || (position instanceof Array && position.length === 2)))
        {
            var p = new Core.Point(position);
            if(VFXActions._isNumber(p))
            {
                return new Action('placeTo', [duration, p.getX(), p.getY()]);
            }
            else
            {
                throw new Error("Invalid point. Only numbers are acceptable for position. \nFor Example:  VFXActions.placeTo(4,[200,300]); ");
            }
        }
        else
        {
            throw new Error("Invalid arguments. \nFor Example: VFXActions.placeTo(4,[100,100]);");
        }
    },
    /**
     * Creates a Visibility action which instantly toggles the visibility of a node. 
     */
    toggleVisible: function ()
    {
        return new Action('toggleVisible');
    },
    /**
     * Creates a Hop action which makes a node jump with velocity under the effect of gravity. Velocity and gravity are configurable. 
     * @param {Number} velocity first speed.
     * @param {Number} gravity damping rate.
     * @returns {Service.Graphics.Action} new action.
     */
    hop: function (velocity, gravity)
    {
        if(typeof (velocity) === "number" && typeof (gravity) === "number" && velocity >= 0)
        {
            return new Action('hop', [velocity, gravity]);
        }
        else
        {
            throw new Error("Velocity and Gravity must be provided and velocity should be positive.");
        }
    },
    /**
     * Creates a Visibility action which makes the node appear instantly. 
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#disappear
     */
    appear: function ()
    {
        return new Action('appear');
    },
    /**
     * Creates a Visibility action which makes a node disappear instantly.
     * @returns {Service.Graphics.Action} new action.
     * @see Service.Graphics.VFXActions#appear
     */
    disappear: function ()
    {
        return new Action('disappear');
    },
    /**
     * Creates a wait action which stops running actions for given duration.
     * @param {Number} time seconds
     * @returns {Service.Graphics.Action} new action.
     */
    waitFor: function (duration)
    {
        if(typeof (duration) === "number" && duration >= 0)
        {
            return new Action('waitFor', [duration]);
        }
        else
        {
            throw new Error("Time should be provided and must be positive. :)");
        }
    },
    /**
     * creates new sequence for given actions. 
     * @param {Array}  actions 
     * @returns currently created sequence.
     */
    createSequence: function (actions)
    {
        return new exports.Sequence(actions);
    },
    /**
     * creates new spawn for given actions. 
     * @param {Array}  actions 
     * @returns currently created spawn.
     */
    createSpawn: function (actions)
    {
        return new exports.Spawn(actions);
    },
    /**
     * Pauses all actions. 
     */
    pause: function ()
    {
        VFX.pause();
    },
    /**
     * Resumes paused actions. 
     */
    resume: function ()
    {
        VFX.resume();
    },
    /**
     * Checks if actions are paused or running.
     * @returns {Boolean}. Returns true if actions are running otherwise false. 
     */
    isRunning: function ()
    {
        return VFX.isActive;
    },
    /**
     * Stop all remained tasks of passed node.
     *
     * @param {GL2.Node} node Target node object.
     */
    stopAction: function (node)
    {
        if(node instanceof Node)
        {
            VFX.stop(node);
        }
        else
        {
            throw new Error("Only instance of GL2.Node is acceptable");
        }
    },
    /**
     * removes all running tasks.
     */
    stopActions: function ()
    {
        VFX.removeAllTasks();
        VFX.resume();
    },
    /**
     * Checks if input is valid number or not.. 
     * @private
     * */
    _isNumber: function (input)
    {
        if(typeof (input.getX()) === "number" && typeof (input.getY()) === "number")
        {
            return true;
        }
        else
        {
            return false;
        }
    },
    /**
     * checks if inner sequence or spawn has repeatForEver property.
     * @private
     */
    _isEligible: function (actions)
    {
        var length = actions.length;
        var i;
        for(i = 0; i < length; i++)
        {
            if(actions[i] && actions[i].classname === "Action")
            {
                if(i + 1 === length)
                {
                    return true;
                }
            }
            else if(actions[i] && (actions[i].classname === "Spawn" || actions[i].classname === "Sequence"))
            {
                if(actions[i]._frequency === -1)
                {
                    return false;
                }
                else
                {
                    if(!VFXActions._isEligible(actions[i].actions))
                    {
                        return false;
                    }
                    if(i + 1 === length)
                    {
                        return true;
                    }
                }
            }
        }
    },
    /**
     * private method
     */
    _calculateTotalDuration: function (actions)
    {
        var length = actions.length;
        var i, duration = 0;
        for(i = 0; i < length; i++)
        {
            if(actions[i] && actions[i].classname === "Action")
            {
                duration = duration + actions[i]._duration;
            }
            else if(actions[i] && (actions[i].classname === "Spawn" || actions[i].classname === "Sequence"))
            {
                duration = duration + actions[i]._totalDuration;
            }
        }
        return duration;
    },
    /**
     * private method
     */
    _calculateMaxDuration: function (actions)
    {
        var maxDuration = 0;
        var maxIndex = 0;
        var i = 0;
        for(i = 0; i < actions.length; i++)
        {
            if(actions[i] && actions[i].classname === "Action" && actions[i]._duration >= maxDuration)
            {
                maxIndex = i;
                maxDuration = actions[i]._duration;
            }
            else if(actions[i] && (actions[i].classname === "Spawn" || actions[i].classname === "Sequence"))
            {
                if(maxDuration <= actions[i]._totalDuration)
                {
                    maxDuration = actions[i]._totalDuration;
                    maxIndex = i;
                }
            }
        }
        actions[maxIndex]._hasMaxDuration = true;
        return maxDuration;
    }
});
exports.VFXActions = VFXActions;; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Service/Graphics/VFX'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Service/Graphics/VFX'] || {}; $MODULE_REGISTRY['NGGo1.3/Service/Graphics/VFX'] = exports; 
var __dirname = 'NGGo1.3/Service/Graphics';
var __filename = 'NGGo1.3/Service/Graphics/VFX.js';

/**
 *  @author     Shibukawa Yoshiki
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
var Core = require('NGCore/Client/Core').Core;
var VFXActions = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var ActionList = Core.Class.subclass(
{ /** @lends Service.Graphics.ActionList.prototype */
    classname: "ActionList",
    /**
     * @class The <code>ActionList</code>  class is a effect task class.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function ()
    {
        this._actions = [];
        this._frequency = 1;
        var i, j;
        for(i = 0; i < arguments.length; i++)
        {
            var item = arguments[i];
            if(item.length && item instanceof Object)
            {
                for(j = 0; j < item.length; j++)
                {
                    if(item[j] instanceof ActionList)
                    {
                        this._actions.push(item[j]._generate(item[j]));
                    }
                    else
                    {
                        this._actions.push(item[j]);
                    }
                }
            }
            else
            {
                if(item instanceof ActionList)
                {
                    this._actions.push(item._generate(item));
                }
                else
                {
                    this._actions.push(item);
                }
            }
        }
    },
    /**
     * Apply any function as the task. It can be used if any callback is required after any action within the sequence.
     * @example
     *  var sequence = VFX.sequence().rotate(4, 180, Ops.easeInQuad).move(3, [200, 0], Ops.easeInQuad).blink(4, 0.5, [1, 0]).callFunc(function(){
     *  console.log("My custom function executed");	
     *  });
     *  sequence.play(this._node);
     * @param {Function} custom function. It takes "functon" as parameter and this function is registered as a task in the sequence.
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or at-once (simultaneously).
     */
    callFunc: function ()
    {
        var custFunction = VFXActions.callFunc.apply(VFXActions, arguments);
        this._actions.push(custFunction);
        return this;
    },
    /**
     * Creates a Move action which moves a node by the delta position passed, in given duration.  
     * @param {Number} duration the time it takes moving[Seconds].
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    move: function ()
    {
        var move = VFXActions.move.apply(VFXActions, arguments);
        this._actions.push(move);
        return this;
    },
    /**
     * Creates a Move action which moves a node to target position passed, in given duration. 
     * @param {Number} duration The time it takes in moving[Seconds].
     * @param {Core.Point | Core.Vector | Array} targetPosition
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad , "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    moveTo: function ()
    {
        var moveTo = VFXActions.moveTo.apply(VFXActions, arguments);
        this._actions.push(moveTo);
        return this;
    },
    /**
     * Creates a Scale action which scales a node by delta scale passed, in given duration.
     * @param {Number} duration the time it takes in scaling[Seconds].     
     * @param {Core.Point | Core.Vector | Array} deltaScale
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    scale: function ()
    {
        var scale = VFXActions.scale.apply(VFXActions, arguments);
        this._actions.push(scale);
        return this;
    },
    /**
     * Creates a Scale action which scales a node to target scale passed, in given duration.
     * @param {Number} duration the time it takes in scaling[Seconds].
     * @param {Core.Point | Core.Vector | Array} targetScale
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    scaleTo: function ()
    {
        var scaleTo = VFXActions.scaleTo.apply(VFXActions, arguments);
        this._actions.push(scaleTo);
        return this;
    },
    /**
     * Creates a Blink action which applies blinking effect to a node, for given duration.  
     * @param {Number} duration the time it takes for blinking[Seconds].
     * @param {Number} term Time duration for completing a blinking cycle default = 0.5.
     * @param {Number} alphas ranage of alphas to blink. default = [1,0]
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    blink: function ()
    {
        var blink = VFXActions.blink.apply(VFXActions, arguments);
        this._actions.push(blink);
        return this;
    },
    /**
     * Creates FadeIn action which applies fading in effect on a node, in given duration.
     * @param {Number} duration the time it takes to fade in[Seconds].
     * @param {Number} alpha default=1.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    fadeIn: function ()
    {
        var fadeIn = VFXActions.fadeIn.apply(VFXActions, arguments);
        this._actions.push(fadeIn);
        return this;
    },
    /**
     * Creates FadeOut action which applies fading out effect on a node, in given duration.
     * @param {Number} duration the time it takes to fade out[Seconds].
     * @param {Number} alpha default=0.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    fadeOut: function ()
    {
        var fadeOut = VFXActions.fadeOut.apply(VFXActions, arguments);
        this._actions.push(fadeOut);
        return this;
    },
    /**
     * Creates an Alpha action which modifies opacity of a node by passed delta alpha, in given duration. 
     * @param {Number} duration the time it takes for action[Seconds].
     * @param {Number} deltaAlpha 
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    alpha: function ()
    {
        var alpha = VFXActions.alpha.apply(VFXActions, arguments);
        this._actions.push(alpha);
        return this;
    },
    /**
     * Creates an Alpha action which modifies opacity of a node to passed target alpha, in given duration.
     * @param {Number} duration the time it takes moving[Seconds].
     * @param {Number} targetAlpha 
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    alphaTo: function ()
    {
        var alphaTo = VFXActions.alphaTo.apply(VFXActions, arguments);
        this._actions.push(alphaTo);
        return this;
    },
    /**
     * Creates a Rotate action which rotates a node by passed delta angle, in given duration.
     * @param {Number} duration the time it takes in rotation[Seconds].
     * @param {Number} deltaRot delta angle(degree)
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    rotate: function ()
    {
        var rotate = VFXActions.rotate.apply(VFXActions, arguments);
        this._actions.push(rotate);
        return this;
    },
    /**
     * Creates a Rotate action which rotates a node to passed target angle, in given duration.
     * @param {Number} duration the time it takes in rotation[Seconds].
     * @param {Number} targetRot target rotation angle in degrees.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    rotateTo: function ()
    {
        var rotateTo = VFXActions.rotateTo.apply(VFXActions, arguments);
        this._actions.push(rotateTo);
        return this;
    },
    /**
     * Creates a Color action which modifies color filter of a node by passed deltaRGB, in given duration.
     * @param {Number} duration the time it takes changing color[Seconds].
     * @param {Number} dr change in red component of color.
     * @param {Number} dg change in green component of color.
     * @param {Number} db change in blue component of color.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    color: function ()
    {
        var color = VFXActions.color.apply(VFXActions, arguments);
        this._actions.push(color);
        return this;
    },
    /**
     * Creates a Color action which modifies color filter of a node to passed targetRGB, in given duration.
     * @param {Number} duration the time it takes changing color[Seconds].
     * @param {Number} tr target red component of color.
     * @param {Number} tg target green component of color.
     * @param {Number} tb target blue component of color.
     * @param {Function | String} easing easing function. i.e. Ops.easeInQuad, "easeOutQuad".
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    colorTo: function ()
    {
        var colorTo = VFXActions.colorTo.apply(VFXActions, arguments);
        this._actions.push(colorTo);
        return this;
    },
    /**
     * Creates a Bezier action which moves the target node to the destination point, moving it through a curve created from the control points passed in configuration object, in the duration passed. 
     * @param {Number} duration Time duration for action.
     * @param {Object} Object Contains 3 points controlPoint_1{Point},controlPoint_2{Point},endPosition{Point}
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     * @example
     * var obj = {};
        obj.controlPoint_1 = [75,200];
        obj.controlPoint_2 = [150,400];
        obj.endPosition = [250,300];
        var spawn = VFX.spawn().bezierTo(5,obj).blink(4,0.5,[1,0]);
        spawn.play(node);
     */
    bezier: function ()
    {
        var bezier = VFXActions.bezier.apply(VFXActions, arguments);
        this._actions.push(bezier);
        return this;
    },
    /**
     * Creates a Bezier action which moves the target node by the delta position, moving it through a curve created from the control points passed in configuration object, in the duration passed.  
     * @param {Number} duration Time duration for action.
     * @param {Object} Object containing 3 points ControlPoint_1{Point},ControlPoint_2{Point},EndPosition{Point}
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     */
    bezierTo: function ()
    {
        var bezierTo = VFXActions.bezierTo.apply(VFXActions, arguments);
        this._actions.push(bezierTo);
        return this;
    },
    /**
     * Creates a Jump action which moves the target node by delta position, while giving it a jumping effect. Number of jumps and height of each jump can be confiugred by parameters.
     * @param {Number} duration Time duration for action.
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     * @param {Number} height for Jump.
     * @param {Number} numberofJumps
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     */
    jump: function ()
    {
        var jump = VFXActions.jump.apply(VFXActions, arguments);
        this._actions.push(jump);
        return this;
    },
    /**
     * Creates a Jump action which moves the target node to destination, while giving it a jumping effect. Number of jumps and height of each jump can be configured by parameters. 
     * @param {Number} duration Time duration for action.
     * @param {Core.Point | Core.Vector | Array} targetPosition
     * @param {Number} height for Jump.
     * @param {Number} numberofJumps
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     */
    jumpTo: function ()
    {
        var jumpTo = VFXActions.jumpTo.apply(VFXActions, arguments);
        this._actions.push(jumpTo);
        return this;
    },
    /**
     * Creates a Place action which changes the position relative to the node after the given duration.
     * @param {Number} duration Time duration for Place action.
     * @param {Core.Point | Core.Vector | Array} deltaPosition
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    place: function ()
    {
        var place = VFXActions.place.apply(VFXActions, arguments);
        this._actions.push(place);
        return this;
    },
    /**
     * Creates a Place action which changes the position of the node to destination point, after a given duration.
     * @param {Number} duration Time duration for that particular task.
     * @param {Core.Point | Core.Vector | Array} targetPosition
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    placeTo: function ()
    {
        var placeTo = VFXActions.placeTo.apply(VFXActions, arguments);
        this._actions.push(placeTo);
        return this;
    },
    /**
     * Creates a Visibility action which instantly toggles the visibility of a node.
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     */
    toggleVisible: function ()
    {
        var toggleVisible = VFXActions.toggleVisible.apply(VFXActions, arguments);
        this._actions.push(toggleVisible);
        return this;
    },
    /**
     * Creates a Hop action which makes a node jump with velocity under the effect of gravity. Velocity and gravity are configurable. 
     * @param {Number} velocity first speed.
     * @param {Number} gravity damping rate.
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    hop: function ()
    {
        var hop = VFXActions.hop.apply(VFXActions, arguments);
        this._actions.push(hop);
        return this;
    },
    /**
     * Creates a Visibility action which makes the node appear instantly. 
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    appear: function ()
    {
        var appear = VFXActions.appear.apply(VFXActions, arguments);
        this._actions.push(appear);
        return this;
    },
    /**
     * Creates a Visibility action which makes a node disappear instantly.
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    disappear: function ()
    {
        var disappear = VFXActions.disappear.apply(VFXActions, arguments);
        this._actions.push(disappear);
        return this;
    },
    /**
     * Creates a wait action which stops running actions for given duration.
     * @param {Number} time seconds
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously.
     */
    waitFor: function ()
    {
        var waitFor = VFXActions.waitFor.apply(VFXActions, arguments);
        this._actions.push(waitFor);
        return this;
    },
    /**
     * Repeat current sequence | spawn for given number of times. 
     * @param {Number} frequency
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     * */
    repeat: function (frequency)
    {
        this._frequency = frequency;
        return this;
    },
    /**
     * Repeat current sequence | spawn forever.
     * @returns {Service.Graphics.ActionList} sequence or spawn to play actions in sequence or simultaneously. 
     */
    repeatForEver: function ()
    {
        this._frequency = -1;
        return this;
    },
    /**
     * Starts already created sequence | spawn on passed node.
     * @param {GL2.Node} node 
     * @example 
     * var callback = function() {
     * console.log("Sequence Ended...");
     * };
     * var sequence = VFX.sequence().moveTo(4,new Core.Point(200,200),Ops.easeInQuad).moveTo(4,new Core.Point(20,20),Ops.easeInQuad);
     * sequence.play(node,callback);
     * 
     * */
    play: function (node, callback)
    {
        var actions = this._generate();
        actions.play(node, callback);
    },
    /**
     * Stop all remained tasks of passed node.
     *
     * @param {GL2.Node} node Target node object.
     */
    stop: function (node)
    {
        VFXActions.stopAction(node);
    },
    /**
     * Destroy the current sequence or spawn and release resources on backend.
     */
    destroy: function ()
    {
        delete this._actions;
        delete this._frequency;
    }
});
var SequenceGenerator = ActionList.subclass(
{
    classname: "SequenceGenerator",
    initialize: function ()
    {},
    /**
     * private method..
     */
    _generate: function ()
    {
        var sequence = VFXActions.createSequence(this._actions);
        if(this._frequency)
        {
            if(this._frequency === -1)
            {
                sequence.repeatForEver();
            }
            else
            {
                sequence.repeat(this._frequency);
            }
        }
        return sequence;
    }
});
var SpawnGenerator = ActionList.subclass(
{
    classname: "SpawnGenerator",
    initialize: function ()
    {},
    /**
     * private method..
     */
    _generate: function ()
    {
        var spawn = VFXActions.createSpawn(this._actions);
        if(this._frequency)
        {
            if(this._frequency === -1)
            {
                spawn.repeatForEver();
            }
            else
            {
                spawn.repeat(this._frequency);
            }
        }
        return spawn;
    }
});
exports.VFX = Core.Class.singleton(
{ /** @lends Service.Graphics.VFX.prototype */
    classname: "VFX",
    /**
     * @class The <code>VFX</code> class extends Core.Class and is a singleton class to create Sequences and Spawns.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function ()
    {},
    /**
     * Creates a sequence for provided actions. If  want to run sequence or spawn inside a sequence then earlier sequence and spawn can be passed as argument. 
     * @param {SpawnGenerator | SequenceGenerator} actions earlier created sequence and spawn can be passed as argument.
     * @return {SequenceGenerator} currently created sequence.
     * @example
     * var callback = function() {
     * console.log("Sequence Completed.");
     * }
     * var node = new GL2.Node();
     * GL2.Root.addChild(node);
     * var tankImage = new GL2.Sprite();
     * tankImage.setPosition(0, 0);
     * tankImage.setDepth(-1);
     * tankImage.setImage('Content/tank.png', [64, 64], [0.5, 0.5], [0, 0, 1 / 5, 1]);
     * node.addChild(tankImage);
     * node.setPosition(40, 240);
     * var sequence = VFX.sequence().move(3, [50, -50], Ops.easeInQuad).alphaTo(1, 0.5, Ops.easeInQuad).rotate(3, 200, Ops.easeInQuad).alphaTo(1, 1.0, Ops.easeInQuad).repeat(3);
     * sequence.play(node,callback); //  instanceof GL2.Node.
     * 
     */
    sequence: function ()
    {
        return new SequenceGenerator(arguments);
    },
    /**
     * Creates a spawn for provided actions. If  want to run sequence or spawn inside a spawn then earlier sequence and spawn can be passed as argument. 
     * @param {SpawnGenerator | SequenceGenerator} actions earlier created sequence and spawn can be passed as argument.
     * @return {SequenceGenerator} currently created spawn.
     * @example
     * var callback = function() {
     * console.log("Spawn Completed.");
     * }
     * var node = new GL2.Node();
     * GL2.Root.addChild(node);
     * var tankImage = new GL2.Sprite();
     * tankImage.setPosition(0, 0);
     * tankImage.setDepth(-1);
     * tankImage.setImage('Content/tank.png', [64, 64], [0.5, 0.5], [0, 0, 1 / 5, 1]);
     * node.addChild(tankImage);
     * node.setPosition(40, 240);
     * var spawn = VFX.spawn().move(3, [50, -50], Ops.easeInQuad).alphaTo(1, 0.5, Ops.easeInQuad).rotate(3, 200, Ops.easeInQuad).blink(1, 0.5, [1,0]).repeat(3);
     * spawn.play(node,callback); //  instanceof GL2.Node.
     * 
     */
    spawn: function ()
    {
        return new SpawnGenerator(arguments);
    },
    /**
     * Stops all running actions.
     */
    stopAll: function ()
    {
        VFXActions.stopActions();
    },
    /**
     * Pause all running actions.
     */
    pause: function ()
    {
        VFXActions.pause();
    },
    /**
     * Resume all paused actions.
     */
    resume: function ()
    {
        VFXActions.resume();
    },
    /**
     * Return true if actions are active else false.
     * @return {Boolean} true if actions are active else false. 
     */
    isActive: function ()
    {
        return VFXActions.isRunning();
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/DebugView'] = function(){var exports = $MODULE_REGISTRY['Code/utils/DebugView'] || {}; $MODULE_REGISTRY['Code/utils/DebugView'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/DebugView.js';

var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;

/*
 * DebugView is used to modify configurations for one scene. Instead of restart Game, we can use DebugView to enter values for
 * some configurations, and then reload Scene to view result. To use DebugView, Scene must install:
 * 1. Init a debugView object as its attribute
 * 2. reloadForDebug function (see StoryScene's one)
 * 3. Call debugView.destroy in scene's onExit
 * 
 */
exports.DebugView = Core.Class.subclass({
	// max frame width = 480
	initialize: function(scene, text, frame) {
		this._scene = scene;
		this._text = text;
		this._frame = frame;
		this.values = [];
		this._view = new UI.View();
		this.scrollView = new UI.ScrollView();
		this.config = new UI.Button();
		this.reset = new UI.Button();
		
		this.objs = [];
		this.createView();
	},
	createView: function() {
		Log("in CreateView");
		this._view.setFrame(this._frame);
		this.scrollView.setFrame(this._frame[2]/16 + 2, 0, this._frame[2]/16*14 -2, this._frame[3]);
		this.scrollView.setContentSize((3 + this._frame[2]/7)*this._text.length, this._frame[3]);
		this.scrollView.setScrollIndicatorsVisible(false);
		UI.Window.document.addChild(this._view.addChild(this.scrollView));
		this.scrollView.setVisible(false);
		this._create2Button();
		var x = 0;
		var w = this._frame[2]/ 7;
		for(var i = 0; i < this._text.length; i++) {
			var obj = {};
				
			obj.editText = new UI.EditText();
			//obj.editText.setBackgroundColor("FF2FFF");
			obj.editText.setAlpha(0.4);
			obj.editText.setPlaceholder(this._text[i]);
			obj.editText.setBackgroundColor("FFFFFF");
			obj.editText.setPlaceholderColor("FF0000");
			obj.editText.setFrame([x, 0, w, this._frame[3]]);
			this.scrollView.addChild(obj.editText);
			this.objs.push(obj);
		
			x += w + 2 ;
		}
	},
	
	_create2Button: function() {
		Log("in Create2Button");
		this.config.setFrame(0,0,this._frame[2]/16, this._frame[3]);
		this.config.setImage('Content/viet/avatar_arrow.png');
		this.config.onclick = function() {
			this.scrollView.setVisible(true);
			this.reset.setVisible(true);
		}.bind(this);
		this._view.addChild(this.config);
		this.reset.setImage('Content/viet/reset.png');
		this.reset.setFrame(this._frame[2] - this._frame[2]/16, 0,this._frame[2]/18, this._frame[3] -5);
		this.reset.setVisible(false);
		this.reset.onclick = function() {
			this.scrollView.setVisible(false);
			this.reset.setVisible(false);
			this.values = [];
			if(this.objs != undefined) {
				for(var i = 0; i < this.objs.length; i++) {
					
					this.values.push(this._getValue(this.objs[i].editText.getText()));
					Log("values_origin[" + i + "]  = " + this.values[i]);
				}
			}
			
			setTimeout(function() {this._scene.reloadForDebug(this.values);}.bind(this),500);
			
		}.bind(this);
		this._view.addChild(this.reset);
	},
	/*
	 * Return number value or array from a string that contains comma ','
	 * ex: 34,56
	 */
	_getValue: function(str) {
		if(str) {
			if(str.indexOf(',') == -1)
				return str;
			else {
				return str.split(',');
			}
		}
	},
	destroy: function() {
		this._view.destroy();
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/VietScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/VietScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/VietScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/VietScene.js';

var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var DebugView            = require('Code/utils/DebugView').DebugView;
var ScreenManager        = require('NGGo/Service/Display/ScreenManager').ScreenManager;
var VietScene = ({
 	classname: "VietScene",  // must be unique
 	sceneName: "VIET_SCENE",
 	initialize: function(data) {
 		Log(this.classname + " initialized");
 		this.controller = {};
 		this.CONF = {};
 		this.node = new GL2.Node();
 		this._addBackground();
 	},
 	onEnter: function(preScene, option) {
 		Log(" call onEnter");
		GUIBuilder.registerTypeMethod(this.classname, this.defineConfig);
		GUIBuilder.loadConfigFromFile("Config/Scene/" + this.classname + ".json", this.controller, function(err) {
			if(this.controller.CONF!= undefined) {
				this.CONF = this.controller.CONF;
				if(this.CONF.debug) {
					if(this.setupForDebug == undefined)
						Log("You must implement setupForDebug function");
					else {
						this.setupForDebug();
						this._debugView = new DebugView(this, this.CONF.debugAttrs, [0,40,480,30]);
					}
				}
				this._addBackButton();
 				this.onSuccessConfig();
 			}
 		}.bind(this));
 		ScreenManager.getRootNode().addChild(this.node);
 		//GL2.Root.addChild(this.node);
 		this._slowAppear();
 	},
 	onSuccessConfig: function() {
 		Log("call onSuccessConfig");
 	},
 	reloadForDebug: function(values) {
 		Log("call reloadForDebug");
 		var str = "[";
		this.reInitForDebug();
		for ( var i = 0; i < values.length; i++) {
			if (values[i] != null) {
				str += this.CONF.debugAttrs[i]  + ":" + values[i] + "|";
				this._setConfigAttrs(this.CONF.debugAttrs[i], values[i]);
			}
		}
		Log("CONF after debug: " + str + "]");
		this.onSuccessConfig();
 	},
 	
 	
 	//Must be override
 	defineConfig: function(controller,def){
 			var conf = {};
			conf.description = def.attrs.description;
			conf.debug = def.attrs.debug || false;
			conf.debugAttrs = def.attrs.debugAttrs || [];
    		return conf;
	},
 	// Must be implement if scene has debug mode in scene.
 	// setupForDebug: function() {
 		// this.reInitForDebug = function() {Log("call reInitForDebug");};
 		// this._setConfigAttrs = function(name,value) {
 			// Log("call _setConfigAttrs");
 			// switch(name) {
 			// case 'description' : {this.CONF.description = value;break;}
 			// case 'debug' : {this.CONF.debug = value;break;}
 			// default: Log("Can't find " + name + " in CONF");
 		// }
 		// };
 	// },
 	onExit: function() {
 	    Log("call onExit of " + this.sceneName);
 		this.node.destroy();
 		
 		if(this._debugView)
 			this._debugView.destroy();
 	},
 	onPause: function() {
 		//this.btnBack.setEnabled(false);
 	},
 	onResume: function() {
 	    Log(this.sceneName + " resumed");
 		this._slowAppear();
 		//this.btnBack.setEnabled(true);
 	},
 	
 	//add background right after init, so hard code
 	_addBackground: function() {
		this.bg = new GL2.Sprite();
		this.bg.setImage("Content/white.png", new Core.Size(1024,1024), new Core.Point(0,0));
		this.node.addChild(this.bg);
	},
	_slowAppear: function() {
	    this.node.setAlpha(0);
	    var seq = VFX.spawn().alphaTo(1,2);
	    seq.play(this.node);
	},
	_addBackButton: function() {
        /*this.btnBack = new UI.Button({
        frame: [460, 0, 20, 20],
        text: "X",
        disabledTextColor: "FFFF",
        textSize: 14,
        textGravity: UI.ViewGeometry.Gravity.Center,
        gradient: {
            corners: '8 8 8 8',
            outerLine: "00 1.5",
            gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
        },
        highlightedGradient: {
            corners: '8 8 8 8',
            outerLine: "00 1.5",
            gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
        },
        disabledGradient: {
            corners: '0 8 8 8',
            gradient: [ "FF55 0.0", "FF00 1.0"],
        },
        // if the back button is pressed, then launch /Samples/Launcher
        });
        this.btnBack.setOnClick(function(event) {
            Log("Back button onclicked + currentScene = " + SceneDirector.currentScene.sceneName);
             SceneDirector.pop();
             this.btnBack.destroy();
           /* if(SceneDirector.currentScene.sceneName == this.sceneName) {
                this.btnBack.setVisible(false);
                SceneDirector.pop();
                return;
            }
            while(SceneDirector.currentScene.sceneName != this.sceneName) {
                SceneDirector.pop();
                Log("CurrentScene is " + SceneDirector.currentScene.sceneName);
            }
        }.bind(this));
        UI.Window.document.addChild(this.btnBack); */
    },
 });
 exports.VietScene = Scene.subclass(VietScene);; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Element'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Element'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Element'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Element.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Jabbar M
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

exports.Element = Class.subclass( /** @lends GLUI.Element.prototype */
{
    classname: 'Element',
    _setters: [],
    _getters: [],
    /**
     * @class The <code>Element</code> class is a base class for derived classes that manage object properties and handle user interface events.<br><br>
     * <b>Caution!:</b> This base class is not exported in the GLUI module. Do not access it or subclass it at runtime.
     * Derived classes from <code>Element</code> include:
     * <div class="ul">
     * <li>{@link GLUI.AbstractView}</li>
     * <li>{@link GLUI.ListViewSection}</li>
     * </div>
     * @constructs The default constructor.
     * @param {String} properties
     * @augments Core.Class
     */
    initialize: function ()
    {
        this._internalGLObject = null;
        this._onLoadCallBack = null;
        this._onUnloadCallBack = null;
        this.__retainCount = 0; //by default ngcore uses 0, will be used by listview.
        this._registerSetters(); //to be implemented by the derived classes
        this._registerGetters(); //to be implemented by the derived classes
    },
    /**
     * @private
     * @name GLUI.Element#setOnLoad
     * @description Set a function to call when the <code>load</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @param {Function} loadCallback The new functoin to call.<br><br><b>Note:</b> The <code>load</code> event is disabled
     * if the value of this parameter is not a function.
     * @example function() {
     *  onLoad.loaded = true;
     * };
     * @see GLUI.Element#event:getOnLoad
     */
    setOnLoad: function (onLoadCallBack)
    {
        this._onLoadCallBack = onLoadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#getOnUnload
     * @description Retrieve the function to call when the <code>unload</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @returns {Function} The current function to call.
     * @see GLUI.Element#event:setOnUnload
     */
    getOnUnload: function ()
    {
        return this._onUnloadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#getOnLoad
     * @description Retrieve the function to call when the <code>load</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @returns {Function} The current function to call.
     * @see GLUI.Element#event:setOnLoad
     */
    getOnLoad: function ()
    {
        return this._onLoadCallBack;
    },
    /**
     * @private
     * @name GLUI.Element#setOnUnload
     * @description Set a function to call when the <code>unload</code> event occurs.<br><br><b>Note:</b> The <code>load</code> event is not supported yet for GLUI.Element
     * @param {Function} unloadCallback The new functoin to call.<br><br><b>Note:</b> The <code>unload</code> event is disabled
     * if the value of this parameter is not a function.
     * @example function() {
     *  onUnload.unloaded = true;
     * };
     * @see GLUI.Element#event:getOnUnload
     */
    setOnUnload: function (onUnloadCallback)
    {
        this._onUnloadCallBack = onUnloadCallback;
    },
    /**
     * Set the property value for each specified key. Property values are passed in as key/value pairs.
     * @param {Object} dict A dictionary of property key/value pairs.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttribute
     * @status Android, Test
     */
    setAttributes: function (dict)
    {
        var key;
        for (key in dict)
        {
            if (dict.hasOwnProperty(key))
            {
                this.setAttribute(key, dict[key]);
            }
        }
        return this;
    },
    /**
     * Retrieve property values for each specified key.
     * @param {String} list A list of property keywords.
     * @returns {Object} A list of key/value pairs.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#setAttribute,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    getAttributes: function (list)
    {
        var i, accessor;
        var output = {};
        if (list instanceof Array)
        {
            for (i = 0; i < list.length; i++)
            {
                var key = list[i];
                var methodName = this._getters[key];
                if (typeof methodName === 'function')
                {
                    output[key] = this._getters[key](this);
                }
            }
        }
        else
        {
            for (accessor in this._getters)
            {
                if (this._getters.hasOwnProperty(accessor))
                {
                    output[accessor] = this._getters[accessor](this);
                }
            }
        }
        return output;
    },
    /**
     * Retrieve the property value of the given key.
     * @param {String} key The property keyword.
     * @returns {String} The current property value.
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttribute,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    getAttribute: function (key)
    {
        var getter = this._getters[key];
        if (typeof getter === 'function')
        {
            return getter(this, key);
        }
        else
        {
            console.log("Getter for '" + key + "' not found for " + this.classname);
            return undefined;
        }
    },
    /**
     * Set the property value for the given key.
     * @example var glView = new GLUI.GLView
     * ...
     * glView.setAttribute('normalImage', {url:'./Content/example.png', size:[120, 30] });
     * @param {String} key The property keyword.
     * @param {String} value The new property value.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.Element#getAttribute,
     * @see GLUI.Element#getAttributes,
     * @see GLUI.Element#setAttributes
     * @status Android, Test
     */
    setAttribute: function (key, value)
    {
        var myFunction = this._setters[key];
        if (myFunction)
        {
            myFunction(this, value);
        }
        else
        {
            console.log("Setter for '" + key + "' not found for " + this.classname);
        }
        return this;
    },
    retain: function ()
    { //will be used by listview.
        if (this.__retainCount)
        {
            ++this.__retainCount;
        }
        else
        {
            this.__retainCount = 1;
        }
        return this;
    },
    release: function ()
    { //will be used by listview.
        if (--this.__retainCount === 0)
        {
            this.destroy();
        }
    },
    retainCount: function ()
    { //will be used by listview.
        return this.__retainCount;
    },
    /**
     * @function
     * @description Destroy this instance and release resources on the backend.
     * @status Android, Test
     */
    destroy: function ($super)
    {
        if (this._internalGLObject)
        {
            this._internalGLObject.destroy();
            this._internalGLObject = null;
        }
        this.__retainCount = 0;
        //this._setters = null; //SETTERS ARE AT CLASS LEVEL
        //this._getters = null; //GETTERS ARE AT CLASS LEVEL
        this._onLoadCallBack = null;
        this._onUnloadCallBack = null;
        if ($super)
        {
            $super();
        }
    },
    /**
     * @private
     * */
    getGLObject: function ()
    {
        if (this._parentNode)
        {
            return this._parentNode;
        }
        else
        {
            return this._internalGLObject;
        }
    },
    _registerSetters: function ()
    {
        //must be written by derived classes
    },
    _registerGetters: function ()
    {
        //must be written by derived classes
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Commands'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Commands'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Commands'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Commands.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan H, Harris K 
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;

var Commands = Class.singleton( /** @lends GLUI.Commands.prototype */
{
    /**
     * @name GLUI.Commands
     * @class 
     * @augments Core.Class
     */
    /** 
     * @field
     */
    classname: 'Commands',

    /**
     * @constructs
     */
    initialize: function ()
    {
    },

    // Enums.
    /** 
     * Enumeration for image fit modes.
     * Image Fit is always applied relative to view bounds *after* content insets are applied.
     * @namespace
     */
    FitMode:
    { /** The image content is not scaled at all. */
        None: 0,
        /** The image will be aspect-scaled to fit completely within the view. */
        Inside: 1,
        /** The image will be aspect-scaled to cover the entire view bounds. Clipping may occur. */
        Fill: 2,
        /** The image will be distorted to cover the exact view bounds. */
        Stretch: 3,
        /** The image will be aspect-scaled so its width matches the view bounds. Clipping may occur. */
        AspectWidth: 5,
        /** The image will be aspect-scaled so its height matches the view bounds. Clipping may occur. */
        AspectHeight: 6,
        /** The image will be scaled down to fit completely within the view, but not upscaled. */
        InsideNoUpscaling: 7
    },

    /** 
     * Enumeration for fontLocation
     * @namespace
     */
    FontLocation: { /** Use Default fonts. */
        Default: 0,
        /** Use System fonts. */
        System: 1,
        /** Use bundled fonts that ship with engine and available to all apps. */
        Bundled: 2,
        /** Use custom fonts that are loaded with app manifest. */
        Manifest: 3
    },

    /** 
     * Enumeration for supported units for dimensions.
     * Math.round() is your friend. Sending decimal pixel coordinates can result in unpredictable behavior on various platforms, but half- and quarter-pixels can be useful tools on iOS.
     * @namespace
     */
    Scaling:
    { 
        /** The native format, and the default for view bounds. No conversion will be performed. */
        Pixels: 0,
        /** Adjusted to roughly one typesetting point, downscaled from 72 to 160 dpi. */
        Points: 1,
        /** 1.0 represents 100% of the provided or implied size (usually a view width or height). */
        Unit: 2,
        /** A percentage of the provided or implied size (typically from 0 to 100). */
        Percent: 3,
        /** At this scale, the device's screen is always 320 units wide. */
        iPhone: 4
    },

    /** 
     * Enumeration for text font styles.
     * @namespace
     */
    FontStyle:
    { 
        /** * */
        Normal: 0,
        /** * */
        Bold: 1,
        /** * */
        Italic: 2,
        /** * */
        BoldItalic: 3
    },

    /** 
     * Flags for control / view states. Used in View and its subclasses.
     * When setting content and properties for states, the value with the highest id when AND'ed with the current state, but no additional bits, will be used.
     * @namespace
     */
    State:
    { 
        /** The view is in an unexceptional state. */
        Normal: 0x00,
        /** * */
        Focused: 0x01,
        /** * */
        Selected: 0x02,
        /** * */
        Pressed: 0x04,
        /** * */
        Checked: 0x08,
        /** * */
        Custom: 0x00FF0000,
        /** * */
        Disabled: 0x40000000
    },

    /** 
     * Enumeration for Enter Key Behavior in editable text fields.
     * @private
     */
    EnterKeyType:
    {
        /** * */
        Return: 0,
        /** * */
        Done: 1,
        /** * */
        Next: 2,
        /** * */
        Submit: 3,
        /** * */
        Go: 4,
        /** * */
        Search: 5,
        /** * */
        Send: 6
    },

    /** 
     * Enumeration for Input Types for editable text fields.
     * @private
     */
    InputType:
    {
        /** * */
        None: 0,
        /** * */
        TextWithCorrection: 1,
        /** * */
        Password: 2,
        /** * */
        Numeric: 4,
        /** * */
        Email: 5,
        /** * */
        URL: 6,
        /** * */
        Date: 7,
        /** * */
        ANDROID_LANDSCAPE_FULLSCREEN: 8
    },

    /** 
     * Arrangement of combinations of text and images for buttons. When stacked, the button rect will be divided proportionally into two rects that completely cover the button. Gravity will apply to the image and text within their rects.
     * @private
     */
    ButtonLayout:
    {
        /** The view is in an unexceptional state. */
        CenterTextOver: 0,
        /** * */
        StackImageLeft: 1,
        /** * */
        StackImageTop: 2,
        /** * */
        StackImageRight: 3,
        /** * */
        StackImageBottom: 4,
        /** * */
        CenterImageOver: 5
    },

    /** 
     * Describes what direction a user swiped during a swipe callback.
     * @see UI.AbstractView#setOnSwipe
     * @private
     */
    SwipeDirection:
    {
        /** * */
        Left: 1,
        /** * */
        Right: 2,
        /** * */
        Up: 3,
        /** * */
        Down: 4
    },

    _registerSettersForImage: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._setters.image = this._setImageProperty.bind("Normal");
        callee._setters.normalImage = this._setImageProperty.bind("Normal");
        callee._setters.focusedImage = this._setImageProperty.bind("Focused");
        callee._setters.selectedImage = this._setImageProperty.bind("Selected");
        callee._setters.pressedImage = this._setImageProperty.bind("Pressed");
        callee._setters.checkedImage = this._setImageProperty.bind("Checked");
        callee._setters.customImage = this._setImageProperty.bind("Custom");
        callee._setters.disabledImage = this._setImageProperty.bind("Disabled");

        callee._setters.imageFit = this._setImageFit;
        callee._setters.imageGravity = this._setImageGravity;

    },
    _registerGettersForImage: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._getters.image = this._getImageProperty.bind("Normal");
        callee._getters.normalImage = this._getImageProperty.bind("Normal");
        callee._getters.focusedImage = this._getImageProperty.bind("Focused");
        callee._getters.selectedImage = this._getImageProperty.bind("Selected");
        callee._getters.pressedImage = this._getImageProperty.bind("Pressed");
        callee._getters.checkedImage = this._getImageProperty.bind("Checked");
        callee._getters.customImage = this._getImageProperty.bind("Custom");
        callee._getters.disabledImage = this._getImageProperty.bind("Disabled");

        callee._getters.imageFit = this._getImageFit.bind(callee);
        callee._getters.imageGravity = this._getImageGravity.bind(callee);

    },
    _registerSettersForLabel: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._setters.text = this._setTextProperty.bind("Normal");
        callee._setters.normalText = this._setTextProperty.bind("Normal");
        callee._setters.focusedText = this._setTextProperty.bind("Focused");
        callee._setters.selectedText = this._setTextProperty.bind("Selected");
        callee._setters.pressedText = this._setTextProperty.bind("Pressed");
        callee._setters.checkedText = this._setTextProperty.bind("Checked");
        callee._setters.customText = this._setTextProperty.bind("Custom");
        callee._setters.disabledText = this._setTextProperty.bind("Disabled");

        callee._setters.textColor = this._setColorProperty.bind("Normal");
        callee._setters.normalTextColor = this._setColorProperty.bind("Normal");
        callee._setters.focusedTextColor = this._setColorProperty.bind("Focused");
        callee._setters.selectedTextColor = this._setColorProperty.bind("Selected");
        callee._setters.pressedTextColor = this._setColorProperty.bind("Pressed");
        callee._setters.checkedTextColor = this._setColorProperty.bind("Checked");
        callee._setters.customTextColor = this._setColorProperty.bind("Custom");
        callee._setters.disabledTextColor = this._setColorProperty.bind("Disabled");

        callee._setters.textShadow = this._setShadowProperty.bind("Normal");
        callee._setters.normalTextShadow = this._setShadowProperty.bind("Normal");
        callee._setters.focusedTextShadow = this._setShadowProperty.bind("Focused");
        callee._setters.selectedTextShadow = this._setShadowProperty.bind("Selected");
        callee._setters.pressedTextShadow = this._setShadowProperty.bind("Pressed");
        callee._setters.checkedTextShadow = this._setShadowProperty.bind("Checked");
        callee._setters.customTextShadow = this._setShadowProperty.bind("Custom");
        callee._setters.disabledTextShadow = this._setShadowProperty.bind("Disabled");

        callee._setters.textFont = this._setFontProperty.bind("Normal");
        callee._setters.normalTextFont = this._setFontProperty.bind("Normal");
        callee._setters.focusedTextFont = this._setFontProperty.bind("Focused");
        callee._setters.selectedTextFont = this._setFontProperty.bind("Selected");
        callee._setters.pressedTextFont = this._setFontProperty.bind("Pressed");
        callee._setters.checkedTextFont = this._setFontProperty.bind("Checked");
        callee._setters.customTextFont = this._setFontProperty.bind("Custom");
        callee._setters.disabledTextFont = this._setFontProperty.bind("Disabled");

        callee._setters.textSize = this._setTextSize.bind(callee);
        callee._setters.textGravity = this._setTextGravity.bind(callee);
        callee._setters.textInsets = this._setTextInsets.bind(callee);
        callee._setters.fontLocation = this._setFontLocation.bind(callee);

    },
    _registerGettersForLabel: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._getters.text = this._getTextProperty.bind("Normal");
        callee._getters.normalText = this._getTextProperty.bind("Normal");
        callee._getters.focusedText = this._getTextProperty.bind("Focused");
        callee._getters.selectedText = this._getTextProperty.bind("Selected");
        callee._getters.pressedText = this._getTextProperty.bind("Pressed");
        callee._getters.checkedText = this._getTextProperty.bind("Checked");
        callee._getters.customText = this._getTextProperty.bind("Custom");
        callee._getters.disabledText = this._getTextProperty.bind("Disabled");

        callee._getters.textColor = this._getColorProperty.bind("Normal");
        callee._getters.normalTextColor = this._getColorProperty.bind("Normal");
        callee._getters.focusedTextColor = this._getColorProperty.bind("Focused");
        callee._getters.selectedTextColor = this._getColorProperty.bind("Selected");
        callee._getters.pressedTextColor = this._getColorProperty.bind("Pressed");
        callee._getters.checkedTextColor = this._getColorProperty.bind("Checked");
        callee._getters.customTextColor = this._getColorProperty.bind("Custom");
        callee._getters.disabledTextColr = this._getColorProperty.bind("Disabled");

        callee._getters.textShadow = this._getShadowProperty.bind("Normal");
        callee._getters.normalTextShadow = this._getShadowProperty.bind("Normal");
        callee._getters.focusedTextShadow = this._getShadowProperty.bind("Focused");
        callee._getters.selectedTextShadow = this._getShadowProperty.bind("Selected");
        callee._getters.pressedTextShadow = this._getShadowProperty.bind("Pressed");
        callee._getters.checkedTextShadow = this._getShadowProperty.bind("Checked");
        callee._getters.customTextShadow = this._getShadowProperty.bind("Custom");
        callee._getters.disabledTextShadow = this._getShadowProperty.bind("Disabled");

        callee._getters.textFont = this._getFontProperty.bind("Normal");
        callee._getters.normalTextFont = this._getFontProperty.bind("Normal");
        callee._getters.focusedTextFont = this._getFontProperty.bind("Focused");
        callee._getters.selectedTextFont = this._getFontProperty.bind("Selected");
        callee._getters.pressedTextFont = this._getFontProperty.bind("Pressed");
        callee._getters.checkedTextFont = this._getFontProperty.bind("Checked");
        callee._getters.customTextFont = this._getFontProperty.bind("Custom");
        callee._getters.disabledTextFont = this._getFontProperty.bind("Disabled");

        callee._getters.textSize = this._getTextSize.bind(callee);
        callee._getters.textGravity = this._getTextGravity.bind(callee);
        callee._getters.textInsets = this._getTextInsets.bind(callee);
        callee._getters.fontLocation = this._getFontLocation.bind(callee);


    },

    _registerSettersForCellView: function (callee)
    {
        if (!callee)
        {
            return;
        }
        callee._setters.title = this._setTitleProperty.bind("Normal");
        callee._setters.normalTitle = this._setTitleProperty.bind("Normal");
        callee._setters.focusedTitle = this._setTitleProperty.bind("Focused");
        callee._setters.selectedTitle = this._setTitleProperty.bind("Selected");
        callee._setters.pressedTitle = this._setTitleProperty.bind("Pressed");
        callee._setters.checkedTitle = this._setTitleProperty.bind("Checked");
        callee._setters.customTitle = this._setTitleProperty.bind("Custom");
        callee._setters.disabledTitle = this._setTitleProperty.bind("Disabled");

        callee._setters.titleColor = this._setTitleColorProperty.bind("Normal");
        callee._setters.normalTitleColor = this._setTitleColorProperty.bind("Normal");
        callee._setters.focusedTitleColor = this._setTitleColorProperty.bind("Focused");
        callee._setters.selectedTitleColor = this._setTitleColorProperty.bind("Selected");
        callee._setters.pressedTitleColor = this._setTitleColorProperty.bind("Pressed");
        callee._setters.checkedTitleColor = this._setTitleColorProperty.bind("Checked");
        callee._setters.customTitleColor = this._setTitleColorProperty.bind("Custom");
        callee._setters.disabledTitleColor = this._setTitleColorProperty.bind("Disabled");

        callee._setters.titleShadow = this._setTitleShadowProperty.bind("Normal");
        callee._setters.normalTitleShadow = this._setTitleShadowProperty.bind("Normal");
        callee._setters.focusedTitleShadow = this._setTitleShadowProperty.bind("Focused");
        callee._setters.selectedTitleShadow = this._setTitleShadowProperty.bind("Selected");
        callee._setters.pressedTitleShadow = this._setTitleShadowProperty.bind("Pressed");
        callee._setters.checkedTitleShadow = this._setTitleShadowProperty.bind("Checked");
        callee._setters.customTitleShadow = this._setTitleShadowProperty.bind("Custom");
        callee._setters.disabledTitleShadow = this._setTitleShadowProperty.bind("Disabled");

        callee._setters.titleFont = this._setTitleFontProperty.bind("Normal");
        callee._setters.normalTitleFont = this._setTitleFontProperty.bind("Normal");
        callee._setters.focusedTitleFont = this._setTitleFontProperty.bind("Focused");
        callee._setters.selectedTitleFont = this._setTitleFontProperty.bind("Selected");
        callee._setters.pressedTitleFont = this._setTitleFontProperty.bind("Pressed");
        callee._setters.checkedTitleFont = this._setTitleFontProperty.bind("Checked");
        callee._setters.customTitleFont = this._setTitleFontProperty.bind("Custom");
        callee._setters.disabledTitleFont = this._setTitleFontProperty.bind("Disabled");

        callee._setters.titleSize = this._setTitleSize.bind(callee);
        callee._setters.titleGravity = this._setTitleGravity.bind(callee);


        callee._setters.rightImage = this._setRightImageProperty.bind("Normal");
        callee._setters.normalRightImage = this._setRightImageProperty.bind("Normal");
        callee._setters.focusedRightImage = this._setRightImageProperty.bind("Focused");
        callee._setters.selectedRightImage = this._setRightImageProperty.bind("Selected");
        callee._setters.pressedRightImage = this._setRightImageProperty.bind("Pressed");
        callee._setters.checkedRightImage = this._setRightImageProperty.bind("Checked");
        callee._setters.customRightImage = this._setRightImageProperty.bind("Custom");
        callee._setters.disabledRightImage = this._setRightImageProperty.bind("Disabled");

        callee._setters.rightImageFit = this._setRightImageFit.bind(callee);
        callee._setters.rightImageGravity = this._setRightImageGravity.bind(callee);
    },
    _registerGettersForCellView: function (callee)
    {
        if (!callee)
        {
            return;
        }

        callee._getters.title = this._getTitleProperty.bind("Normal");
        callee._getters.normalTitle = this._getTitleProperty.bind("Normal");
        callee._getters.focusedTitle = this._getTitleProperty.bind("Focused");
        callee._getters.selectedTitle = this._getTitleProperty.bind("Selected");
        callee._getters.pressedTitle = this._getTitleProperty.bind("Pressed");
        callee._getters.checkedTitle = this._getTitleProperty.bind("Checked");
        callee._getters.customTitle = this._getTitleProperty.bind("Custom");
        callee._getters.disabledTitle = this._getTitleProperty.bind("Disabled");

        callee._getters.titleColor = this._getTitleColorProperty.bind("Normal");
        callee._getters.normalTitleColor = this._getTitleColorProperty.bind("Normal");
        callee._getters.focusedTitleColor = this._getTitleColorProperty.bind("Focused");
        callee._getters.selectedTitleColor = this._getTitleColorProperty.bind("Selected");
        callee._getters.pressedTitleColor = this._getTitleColorProperty.bind("Pressed");
        callee._getters.checkedTitleColor = this._getTitleColorProperty.bind("Checked");
        callee._getters.customTitleColor = this._getTitleColorProperty.bind("Custom");
        callee._getters.disabledTitleColor = this._getTitleColorProperty.bind("Disabled");

        callee._getters.titleShadow = this._getTitleShadowProperty.bind("Normal");
        callee._getters.normalTitleShadow = this._getTitleShadowProperty.bind("Normal");
        callee._getters.focusedTitleShadow = this._getTitleShadowProperty.bind("Focused");
        callee._getters.selectedTitleShadow = this._getTitleShadowProperty.bind("Selected");
        callee._getters.pressedTitleShadow = this._getTitleShadowProperty.bind("Pressed");
        callee._getters.checkedTitleShadow = this._getTitleShadowProperty.bind("Checked");
        callee._getters.customTitleShadow = this._getTitleShadowProperty.bind("Custom");
        callee._getters.disabledTitleShadow = this._getTitleShadowProperty.bind("Disabled");

        callee._getters.titleFont = this._getTitleFontProperty.bind("Normal");
        callee._getters.normalTitleFont = this._getTitleFontProperty.bind("Normal");
        callee._getters.focusedTitleFont = this._getTitleFontProperty.bind("Focused");
        callee._getters.selectedTitleFont = this._getTitleFontProperty.bind("Selected");
        callee._getters.pressedTitleFont = this._getTitleFontProperty.bind("Pressed");
        callee._getters.checkedTitleFont = this._getTitleFontProperty.bind("Checked");
        callee._getters.customTitleFont = this._getTitleFontProperty.bind("Custom");
        callee._getters.disabledTitleFont = this._getTitleFontProperty.bind("Disabled");

        callee._getters.titleSize = this._getTitleSize.bind(callee);
        callee._getters.titleGravity = this._getTitleGravity.bind(callee);

        callee._getters.rightImage = this._getRightImageProperty.bind("Normal");
        callee._getters.normalRightImage = this._getRightImageProperty.bind("Normal");
        callee._getters.focusedRightImage = this._getRightImageProperty.bind("Focused");
        callee._getters.selectedRightImage = this._getRightImageProperty.bind("Selected");
        callee._getters.pressedRightImage = this._getRightImageProperty.bind("Pressed");
        callee._getters.checkedRightImage = this._getRightImageProperty.bind("Checked");
        callee._getters.customRightImage = this._getRightImageProperty.bind("Custom");
        callee._getters.disabledRightImage = this._getRightImageProperty.bind("Disabled");

        callee._getters.rightImageFit = this._getRightImageFit.bind(callee);
        callee._getters.rightImageGravity = this._getRightImageGravity.bind(callee);
    },

    _setImageProperty: function (callee, args)
    {
        var state = this;
        if (typeof args === 'string')
        {
            var url = args;
            args = {
                url: url,
                size: undefined
            };
        }
        else if (!args || !(args.hasOwnProperty("url")))
        {
            throw new Error("Too few arguments for " + state + "Image ");
        }
        if (!(args.size instanceof Array && args.size.length > 1))
        {
            args.size = [1, 1];
        }

        if (typeof args.url === 'string' && args.url.length > 1)
        {
            return callee.setImage(args.url, Commands.State[state], args.size);
        }
        else
        {
            throw new Error("Invalid arguments for image in setImage | _setNormalImage");
        }
    },
    _getImageProperty: function (callee)
    {
        var state = this;
        return callee.getImage(Commands.State[state] || 0);
    },

    _setTextProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "Text ");
        }
        return callee.setText(args, Commands.State[state]);
    },
    _setFontLocation: function (callee, args)
    {
        callee.setFontLocation(args);
    },
    _getTextProperty: function (callee)
    {
        var state = this;
        return callee.getText(Commands.State[state] || 0);
    },

    _setFontProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextFont ");
        }

        return callee.setTextFont(args, Commands.State[state]);
    },

    _getFontProperty: function (callee)
    {
        var state = this;
        return callee.getTextFont(Commands.State[state] || 0);
    },

    _setColorProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextColor ");
        }
        return callee.setTextColor(args, Commands.State[state]);
    },

    _getColorProperty: function (callee)
    {
        var state = this;
        return callee.getTextColor(Commands.State[state] || 0);
    },

    _setShadowProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TextShadow");
        }

        return callee.setTextShadow(args, Commands.State[state]);
    },
    _getShadowProperty: function (callee, state)
    {
        return callee.getTextShadow(Commands.State[state] || 0);
    },

    _setRightImageProperty: function (callee, args)
    {
        var state = this;
        if (!args || !(args.hasOwnProperty("url") && args.hasOwnProperty("size")))
        {
            throw new Error("Too few arguments for " + state + "RightImage ");
        }

        if (typeof args.url === 'string' && args.url.length > 1 && args.size instanceof Array && args.size.length > 1)
        {
            return callee.setRightImage(args.url, Commands.State[state], args.size);
        }
        else
        {
            throw new Error("Invalid arguments for image in setImage | _setNormalRightImage");
        }
    },
    _getRightImageProperty: function (callee)
    {
        var state = this;
        return callee.getRightImage(Commands.State[state] || 0);
    },

    _setImageFit: function (callee, args)
    {
        if (callee.setImageFit)
        {
            return callee.setImageFit(args);
        }
        return undefined;
    },
    _setImageGravity: function (callee, args)
    {
        if (callee.setImageGravity)
        {
            return callee.setImageGravity(args);
        }
        return undefined;
    },

    _getImageFit: function (callee, args)
    {
        if (callee.getImageFit)
        {
            return callee.getImageFit(args);
        }
        return undefined;
    },
    _getImageGravity: function (callee, args)
    {
        if (callee.getImageGravity)
        {
            return callee.getImageGravity(args);
        }
        return undefined;
    },


    _setTextSize: function (callee, args)
    {
        if (callee.setTextSize)
        {
            return callee.setTextSize(args);
        }
        return undefined;
    },

    _setTextGravity: function (callee, args)
    {
        if (callee.setTextGravity)
        {
            return callee.setTextGravity(args);
        }
        return undefined;
    },

    _setTextInsets: function (callee, args)
    {
        if (callee.setTextInsets)
        {
            return callee.setTextInsets(args);
        }
        return undefined;
    },

    _getTextSize: function (callee, args)
    {
        if (callee.getTextSize)
        {
            return callee.getTextSize(args);
        }
        return undefined;
    },
    _getTextGravity: function (callee, args)
    {
        if (callee.getTextGravity)
        {
            return callee.getTextGravity(args);
        }
        return undefined;
    },
    _getTextInsets: function (callee)
    {
        if (callee.getTextInsets)
        {
            return callee.getTextInsets();
        }
        return undefined;
    },
    _getFontLocation: function (callee)
    {
        if (callee.getFontLocation)
        {
            return callee.getFontLocation();
        }
        return undefined;
    },
    _setTitleSize: function (callee, args)
    {
        if (callee.setTitleSize)
        {
            return callee.setTitleSize(args);
        }
        return undefined;
    },
    _setTitleGravity: function (callee, args)
    {
        if (callee.setTitleGravity)
        {
            return callee.setTitleGravity(args);
        }
        return undefined;
    },

    _setRightImageFit: function (callee, args)
    {
        if (callee.setRightImageFit)
        {
            return callee.setRightImageFit(args);
        }
        return undefined;
    },
    _setRightImageGravity: function (callee, args)
    {
        if (callee.setRightImageGravity)
        {
            return callee.setRightImageGravity(args);
        }
        return undefined;
    },

    _getTitleSize: function (callee, args)
    {
        if (callee.setTitleSize)
        {
            return callee.setTitleSize(args);
        }
        return undefined;
    },
    _getTitleGravity: function (callee, args)
    {
        if (callee.getTitleGavity)
        {
            return callee.getTitleGavity(args);
        }
        return undefined;
    },

    _getRightImageFit: function (callee, args)
    {
        if (callee.getRightImageFit)
        {
            return callee.getRightImageFit(args);
        }
        return undefined;
    },
    _getRightImageGravity: function (callee, args)
    {
        if (callee.getRightImageGravity)
        {
            return callee.getRightImageGravity(args);
        }
        return undefined;
    },

    _setTitleProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "Title ");
        }
        return callee.setTitle(args, Commands.State[state]);
    },
    _getTitleProperty: function (callee)
    {
        var state = this;
        return callee.getTitle(Commands.State[state] || 0);
    },

    _setTitleFontProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleFont ");
        }

        return callee.setTitleFont(args, Commands.State[state]);
    },

    _getTitleFontProperty: function (callee)
    {
        var state = this;
        return callee.getTitleFont(Commands.State[state] || 0);
    },

    _setTitleColorProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleColor ");
        }
        return callee.setTitleColor(args, Commands.State[state]);
    },

    _getTitleColorProperty: function (callee)
    {
        var state = this;
        return callee.getTitleColor(Commands.State[state] || 0);
    },

    _setTitleShadowProperty: function (callee, args)
    {
        var state = this;
        if (!args)
        {
            throw new Error("Too few arguments for " + state + "TitleShadow");
        }

        return callee.setTitleShadow(args, Commands.State[state]);
    },
    _getTitleShadowProperty: function (callee)
    {
        var state = this;
        return callee.getTitleShadow(Commands.State[state] || Commands.State.Normal);
    }


});

exports.Commands = Commands;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/ViewGeometry'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/ViewGeometry'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/ViewGeometry'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/ViewGeometry.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil Mahmood
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;

/**
 * <p>Classes and objects contained by the <code>ViewGeometry</code> class.</p>
 * @name GLUI.ViewGeometry
 * @namespace
 * @description <p>The <code>ViewGeometry</code> class is a collection of classes and objects that control spatial components for UI views.
 * Derived classes from <code>ViewGeometry</code> include:</p>
 * <ul>
 * <li><code>{@link GLUI.ViewGeometry.Rect}</code></li>
 * <li><code>{@link GLUI.ViewGeometry.Scale}</code></li>
 * </ul>
 * <p><code>ViewGeometry</code> utilizes the following enumerated constants:</p>
 * <ul>
 * <li><code>{@link GLUI.ViewGeometry.FitMode}</code></li>
 * <li><code>{@link GLUI.ViewGeometry.Gravity}</code></li>
 * </ul>
 */

exports.FitModes = Commands.FitMode;
/**
 * @name GLUI.ViewGeometry.FitMode
 * @class Enumeration for image fit modes in a view.
 * @see GLUI.Commands#FitMode
 */

exports.Gravity = {
    /**
     * @name GLUI.ViewGeometry.Gravity
     * @class Enumeration for image gravity in a view.
     */
    /**
     * Center of gravity is the top-left corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopLeft: [0.0, 0.0],
    /**
     * Center of gravity is the top-center portion of the image.
     * @fieldOf GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopCenter: [0.5, 0.0],
    /**
     * Center of gravity is the top-right corner of the image.
     * @fieldOf GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    TopRight: [1.0, 0.0],
    /**
     * Center of gravity is the left side of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Left: [0.0, 0.5],
    /**
     * Center of gravity is the center of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Center: [0.5, 0.5],
    /**
     * Center of gravity is the right side of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    Right: [1.0, 0.5],
    /**
     * Center of gravity is the bottom-left corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomLeft: [0.0, 1.0],
    /**
     * Center of gravity is the bottom-center portion of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomCenter: [0.5, 1.0],
    /**
     * Center of gravity is the bottom-right corner of the image.
     * @fieldof GLUI.ViewGeometry.Gravity.prototype
     * @constant
     */
    BottomRight: [1.0, 1.0]
};

var Scale = Class.singleton( /** @lends GLUI.ViewGeometry.Scale.prototype */
{
    /**
     * @name GLUI.ViewGeometry.Scale
     * @class The <code>Scale</code> class constructs objects that handle view geometry for different scales of measurement.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function ()
    {
        var screenUnits = Capabilities.getScreenUnits();
        this.iOSConversion = screenUnits;
        this.pointConversion = this.iOSConversion * 160 / 72;
    },
    Pixels: Commands.Scaling.Pixels,
    Points: Commands.Scaling.Points,
    Unit: Commands.Scaling.Unit,
    Percent: Commands.Scaling.Percent,
    iPhone: Commands.Scaling.iPhone,
    pointConversion: 1.0,
    iOSConversion: 1.0,
    /**
     * Retrieve the supported measurement scale from the device.
     * @param {Number} units The unit of measure.
     * @param {Number} size The screen size of the device.
     * @returns The current screen dimension supported by the device.
     */
    getScale: function (units, size)
    {
        switch (+units)
        {
        case this.Points:
            return this.pointConversion;
        case this.Unit:
            return size;
        case this.Percent:
            return size / 100;
        case this.iPhone:
            return this.iOSConversion;
        }
        return 1.0;
    }
});

var Rect = Class.subclass( /** @lends GLUI.ViewGeometry.Rect.prototype */
{
    /**
     * @name GLUI.ViewGeometry.Rect
     * @class <code>Rect</code> constructs rectangle objects for use as positionable elements in the user interface.
     * @constructs The default constructor.
     * @augments Core.Class
     */
    initialize: function (arg0)
    {
        if (arg0 instanceof this.constructor)
        {
            // Another Rect
            this.x = arg0.x;
            this.y = arg0.y;
            this.w = arg0.w;
            this.h = arg0.h;
        }
        else if (arg0 instanceof Array)
        {
            if (arguments.length === 2 && arguments[0].length >= 2 && arguments[1] instanceof Array && arguments[1].length >= 2)
            {
                this.x = arguments[0][0];
                this.y = arguments[0][1];
                this.w = arguments[1][0];
                this.h = arguments[1][1];
            }
            else if (arguments.length === 1 && arg0.length >= 4)
            {
                this.x = arg0[0];
                this.y = arg0[1];
                this.w = arg0[2];
                this.h = arg0[3];
            }
            else
            {
                console.log("UI.ViewGeometry.Rect initialized with unparseable Array(s)");
            }
        }
        else if (arguments.length === 4)
        {
            this.x = arguments[0];
            this.y = arguments[1];
            this.w = arguments[2];
            this.h = arguments[3];
        }
        return this;
    },
    /**
     * @returns {Boolean} Returns <code>true</code> if any component value is undefined, NaN, or the value indicates this rect has an area of 0 (<i>width</i> * <i>height</i>).
     */
    isEmpty: function ()
    {
        return (this.w * this.h <= 0) || isNaN(this.x) || isNaN(this.y) || isNaN(this.w) || isNaN(this.h);
    },
    /**
     * Copy the component values of this <code>Rect</code>
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> with identical component values.
     */
    copy: function ()
    {
        return new(this).constructor(this);
    },
    /**
     * Copy the component values of this <code>Rect</code>
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> with identical component values.
     */
    array: function ()
    {
        return [this.x, this.y, this.w, this.h];
    },
    /**
     * Set the dimensions of this <code>Rect</code> as an inset.
     * @example var imageRect = null;
     * var remainingRect = rect.copy();
     * ...
     * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
     * @param {Number} t The size for the top of the rectangle.
     * @param {Number} r The size for the right side of the rectangle.
     * @param {Number} b The size for the bottom of the rectangle.
     * @param {Number} l The size for the left side of the rectangle.
     * @param {GLUI.ViewGeometry.Scale} units The unit of measure for the rectangle.
     * @returns {GLUI.ViewGeometry.Rect} This function returns <code>this</code> to support method invocation chaining.
     */
    inset: function (t, r, b, l, units)
    {
        if (arguments.length > 4)
        {
            var xScale = Scale.getScale(units, this.w);
            var yScale = Scale.getScale(units, this.h);
            t = Math.floor(t * yScale);
            r = Math.floor(r * xScale);
            b = Math.floor(b * yScale);
            l = Math.floor(l * xScale);
        }
        if (arguments.length < 2)
        {
            r = t;
        }
        if (arguments.length < 4)
        {
            b = t;
            l = r;
        }
        this.y += t;
        this.h -= t + b;
        this.x += l;
        this.w -= l + r;
        return this;
    },
    /**
     *  Create and return a new <code>Rect</code> representing the top (if positive) or bottom (if negative).
     *  Destructively modifies this Rect, removing the new rect area from the receiver.
     * @example var topPart = rect.inset(10).sliceVertical(50, GLUI.Scale.Percent);
     * @param {Number} height The new rect height.
     * @param {GLUI.ViewGeometry.Scale} [units] The scale of measurement.
     * @returns {GLUI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
     * @see GLUI.ViewGeometry.Rect#sliceHorizontal
     */
    sliceVertical: function (height, units)
    {
        if (arguments.length > 1)
        {
            height = Math.floor(height * Scale.getScale(units, this.h));
        }
        var newRect = this.copy();
        if (height < 0)
        {
            // Return the bottom area...
            newRect.h = -height;
            this.h += height;
            newRect.y += this.h;
        }
        else
        {
            newRect.h = height;
            this.y += height;
            this.h -= height;
        }
        return newRect;
    },
    /**
     *  Create and return a new <code>Rect</code> representing the left (if positive) or right (if negative).
     *  Destructively modifies this Rect, removing the new rect area from the receiver.
     * @example var imageRect = null;
     * var remainingRect = rect.copy();
     * ...
     * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
     * @param {Number} width The new rect width.
     * @param {UI.ViewGeometry.Scale} [units] The scale of measurement.
     * @returns {UI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
     * @see UI.ViewGeometry.Rect#sliceVertical
     */
    sliceHorizontal: function (width, units)
    {
        if (arguments.length > 1)
        {
            width = Math.floor(width * Scale.getScale(units, this.w));
        }

        var newRect = this.copy();
        if (width < 0)
        {
            newRect.w = -width;
            this.w += width;
            newRect.x += this.w;
        }
        else
        {
            newRect.w = width;
            this.x += width;
            this.w -= width;
        }
        return newRect;
    },
    toString: function ()
    {
        return "Rect: {" + this.array().join(',') + "}";
    },
    /**
     * Retrieve an array of component values for this <code>Rect</code> with rows and columns redistributed evenly.
     * @returns {Array (Number)}
     * @param {Number} rows The rect rows.
     * @param {Number} columns The rect columns.
     * @param {String} flat A one-dimensional array (left to right, top to bottom).
     */
    getGrid: function (rows, columns, flat)
    {
        var i,j;
        flat = (flat === true);
        var cellW = Math.floor(this.w / columns);
        var cellH = Math.floor(this.h / rows);
        var rowSet = [];
        for (i = 0; i < rows; i++)
        {
            var colSet = [];
            for (j = 0; j < columns; j++)
            {
                var r = new this.constructor(this.x + j * cellW, this.y + i * cellH, cellW, cellH);
                (flat ? rowSet : colSet).push(r);
            }
            if (!flat)
            {
                rowSet.push(colSet);
            }
        }
        return rowSet;
    }
});

exports.Scale = Scale;
exports.Rect = Rect;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Util'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Util'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Util'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Util.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S, Ihsan S
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Node = require('NGCore/Client/GL2/Node').Node;
var Primitive = require('NGCore/Client/GL2/Primitive').Primitive;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Root = require('NGCore/Client/GL2/Root').Root;
var Core = require('NGCore/Client/Core').Core;
var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Util = {
    getAnchor: function (sprite)
    {
        return sprite._animation.getFrame(0).getAnchor();
    },
    TouchFilter: Core.MessageListener.subclass(
    {
        classname: 'TouchFilter',
        initialize: function (touchId)
        {
            this.target = new TouchTarget();
            this.target.setAnchor([0, 0]);
            this.trackingId = touchId;
            this.ignoreFingers = [];
            this.shouldDestroy = false;
            var orientation = OrientationEmitter.getInterfaceOrientation();
            var w = Core.Capabilities.getScreenWidth();
            var h = Core.Capabilities.getScreenHeight();
            if ((orientation === OrientationEmitter.Orientation.Portrait) || (orientation === OrientationEmitter.Orientation.PortraitUpsideDown))
            {
                this.target.setSize(w, h);
            }
            else
            {
                this.target.setSize(h, w);
            }
            this.target.getTouchEmitter().addListener(this, this.onTouch);
            this.target.setDepth(65535);
            Root.addChild(this.target);
        },
        destroy: function ($super)
        {
            Root.removeChild(this.target);
            this.target.destroy();
            $super();
        },
        setDestroyFlag: function ()
        {
            this.shouldDestroy = true;
            if (this.isValidTouch())
            {
                this.destroy();
            }
        },
        onTouch: function (touch)
        {
            var touchId = touch.getId();
            if (touchId === this.trackingId)
            {
                console.log("<NGGo> Error: Invalid input at GLUIUtil.TouchFilter.onTouch()");
                console.log("<NGGo> touchId: " + touchId);
                console.log("<NGGo> this.trackingId: " + this.trackingId);
                this.destroy();
                return true;
            }
            switch (touch.getAction())
            {
            case touch.Action.Start:
                if (!this.shouldDestroy)
                {
                    this.ignoreFingers.push(touch.getId());
                }
                break;
            case touch.Action.End:
                var index = this.ignoreFingers.indexOf(touch.getId());
                if (index !== -1)
                {
                    this.ignoreFingers.splice(index, 1);
                }
                if (this.shouldDestroy)
                {
                    this.destroy();
                }
                break;
            default:
                break;
            }
            return true;
        },
        isValidTouch: function ()
        {
            if (this.ignoreFingers.length === 0)
            {
                return true;
            }
            return false;
        }
    }),
    Rectangle: Node.subclass(
    {
        classname: 'Rectangle',
        initialize: function ()
        {
            this.setChildrenDepthGrouped(true);
            this._color = null;
            this._size = null;
            this._primitive = null;
        },
        setFrame: function (frame)
        {
            frame = new Core.Rect(frame);
            this.setPosition(frame.getOrigin());
            this._size = frame.getSize();
            this._updateBox();
        },
        destroy: function ()
        {
            if (this._primitive)
            {
                this._primitive.destroy();
                this._primitive = null;
            }
            this._color = null;
            this._size = null;
        },
        setColor: function (color)
        {
            this._color = new Core.Color(color);
            this._updateBox();
        },
        _updateBox: function ()
        {
            if (!this._size || !this._color)
            {
                return;
            }
            if (this._primitive !== null)
            {
                this.removeChild(this._primitive);
                this._primitive.destroy();
            }
            var p = new Primitive();
            p.setColor(this._color);
            var w = this._size.getWidth();
            var h = this._size.getHeight();
            p.setType(Primitive.Type.TriangleFan);
            var v = [];
            v.push(new Primitive.Vertex([0, 0], [0, 0]));
            v.push(new Primitive.Vertex([w, 0], [0, 0]));
            v.push(new Primitive.Vertex([w, h], [0, 0]));
            v.push(new Primitive.Vertex([0, h], [0, 0]));
            p.spliceVertexes.apply(p, ([0, 0]).concat(v));
            this._primitive = p;
            this.addChild(this._primitive);
        }
    }),
    makePrimitive: function (x, y, w, h, color1, color2, color3, color4)
    {
        if (arguments.length <= 6)
        {
            color3 = color2 || color1;
            color4 = color2 || color1;
            color2 = color1;
        }
        var p = new Primitive();
        p.setType(Primitive.Type.TriangleStrip);
        p.pushVertex(new Primitive.Vertex([0, 0], [0, 0], color1));
        p.pushVertex(new Primitive.Vertex([w, 0], [1, 0], color2));
        p.pushVertex(new Primitive.Vertex([0, h], [0, 1], color3));
        p.pushVertex(new Primitive.Vertex([w, h], [1, 1], color4));
        p.setPosition(x, y);
        return p;
    },
    hexToARGB: function (color)
    {
        if (color === null || color === undefined)
        {
            // empty color string
            return [0, 0, 0, 0];
        }
        if ((isNaN("0x" + color)))
        {
            throw new Error('Expecting a color value but found ' + typeof (color));
        }
        var n = color.length;
        var A = 1,
            R = 0,
            G = 0,
            B = 0;
        switch (n)
        {
        case 2:
            A = 1;
            R = color.charAt(0);
            R = R + color.charAt(1);
            B = R;
            G = R;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 3:
            A = 1;
            R = color.charAt(0);
            G = color.charAt(1);
            B = color.charAt(2);
            R = R + R;
            G = G + G;
            B = B + B;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 4:
            A = color.charAt(0);
            R = color.charAt(1);
            G = color.charAt(2);
            B = color.charAt(3);
            A = A + A;
            R = R + R;
            G = G + G;
            B = B + B;
            A = parseInt(A, 16) / 255.0;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 6:
            A = 1;
            R = color.substring(0, 2);
            G = color.substring(2, 4);
            B = color.substring(4, 6);
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        case 8:
            A = color.substring(0, 2);
            R = color.substring(2, 4);
            G = color.substring(4, 6);
            B = color.substring(6, 8);
            A = parseInt(A, 16) / 255.0;
            R = parseInt(R, 16) / 255.0;
            G = parseInt(G, 16) / 255.0;
            B = parseInt(B, 16) / 255.0;
            break;
        default:
            if (n > 8)
            {
                console.log('Exception: Hex String exceeds allowed precision');
            }
            A = 1;
            R = 0;
            G = 0;
            B = 0;
            break;
        }
        return [A, R, G, B];
    },
    getOrientationSreenHeight: function ()
    {
        if (OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.Portrait || OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.PortraitUpsideDown)
        {
            return Capabilities.getScreenHeight();
        }
        else
        {
            return Capabilities.getScreenWidth();
        }
    },
    getOrientationSreenWidth: function ()
    {
        if (OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.LandscapeLeft || OrientationEmitter.getInterfaceOrientation() === OrientationEmitter.Orientation.LandscapeRight)
        {
            return Capabilities.getScreenWidth();
        }
        else
        {
            return Capabilities.getScreenHeight();
        }
    }
};
exports.Util = Util;; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Sprite'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Sprite'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Sprite'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Sprite.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/*
 * URLSprite - extend GL2.Sprite to be able to use URL instead of file path
 *
 */
var Sprite = require('NGCore/Client/GL2/Sprite').Sprite;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var DownloadFile = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;
var UI = require('NGCore/Client/UI').UI;

var $_lock = {};
var $_queue = {};
/** @private
 * This ENTIRE CLASS is private.
 */
var URLSprite = Sprite.subclass( /** @lends GLUI.URLSprite.prototype */
{
    "classname": 'URLSprite',
    /**
     * @class The <code>URLSprite</code> class inherits GL2.Sprite and add the image downloading function.
     * (see <code><a href="GL2.Sprite.html">GL2.Sprite</a></code>).
     * It also has caching mechanism to decrease network trafic.
     **/
    "_default_options": {
        "cache": true,
        "directory": "urlsprite",
        "localcachetime": 3600,
        "cachesize": 100,
        "forceResize": true
    },
    /**
     * @ignore
     * @constructs The default constructor.
     **/
    initialize: function (options)
    {
        var name;
        this.options = {};
        if (!options)
        {
            options = {};
        }
        for (name in this._default_options)
        {
            if (this._default_options.hasOwnProperty(name))
            {
                this.options[name] = options.hasOwnProperty(name) ? options[name] : this._default_options[name];
            }
        }
        this.tempfiles = {};

    },
    destroy: function ($super)
    {
        var file;
        for (file in this.tempfiles)
        {
            if (this.tempfiles.hasOwnProperty(file))
            {
                FileSystem.deleteFile(file);
            }
        }
        $super();
    },
    /**
     * Download a image and set it for this <code>Sprite</code>.
     * It has same interface as GL2.Sprite but it can use URL instead of local image path.
     * It can accept local image path and at that time, it's behaviour is totally same as GL2.Sprite's setImage method.
     * @param {String} image URL or the directory path to an image referenced by a frame.
     * @param {Core.Size} [size] The size of the image to display (in pixels).
     * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
     * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     **/
    setImage: function ($super, image, size, anchor, uvs)
    {
        if (!image)
        {
            return this;
        }
        if (image.slice(0, 7).toLowerCase() !== "http://" && image.slice(0, 8).toLowerCase() !== "https://")
        {
            return $super(image, size, anchor, uvs);
        }
        var url = image;
        var args = {
            _super: $super,
            url: url,
            name: toMD5(url) + this._extractExstension(url),
            size: size,
            anchor: anchor,
            uvs: uvs,
            addpath: "",
            forceResize: this.options.forceResize
        };

        if (!this.options.cache)
        {
            var time = new Date();
            args.addpath = "nocache/" + Math.floor(Math.random() * 100) + time.getTime();
        }
        if (!$_queue[this.options.directory])
        {
            $_queue[this.options.directory] = [];
        }
        if ($_lock[this.options.directory])
        {
            $_queue[this.options.directory].push(this._setImageInternal.bind(this, args));
        }
        else
        {
            $_lock[this.options.directory] = 1;
            this._setImageInternal(args);
        }
        return this;
    },
    $unlock: function (directory)
    {
        $_lock[directory] = 0;
        $_queue[directory] = [];
    },
    _extractExstension: function (url)
    {
        var qpos = url.indexOf("?");
        if (qpos > -1)
        {
            url = url.slice(0, qpos);
        }
        var filepos = url.lastIndexOf("/");
        if (filepos > -1)
        {
            url = url.slice(filepos + 1);
        }
        var dotpos = url.lastIndexOf(".");
        if (dotpos === -1)
        {
            return "";
        }
        var extension = url.slice(dotpos).toLowerCase();
        if (extension === ".jpeg")
        {
            extension = ".jpg";
        }
        return extension;
    },
    _setImageInternal: function (args, cache)
    {
        if (this.options.cache)
        {
            if (cache)
            {
                this._checkCacheData(args, undefined, undefined, cache);
            }
            else
            {
                this._setImageWithCache(args);
            }
        }
        else
        {
            this._fetchImage(args, [], -1);
        }
    },
    _searchCache: function (cache, name)
    {
        var i;
        var length = cache.length;
        for (i = 0; i < length; i++)
        {
            if (cache[i].name === name)
            {
                return i;
            }
        }
        return -1;
    },
    _setImageWithCache: function (args)
    {
        FileSystem.readFile(
            this.options.directory + "-urlsprite.json", false, this._checkCacheData.bind(this, args));
    },
    _checkCacheData: function (args, error, value, obj)
    {
        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._fetchImage(args, cache, i);
        }
        else
        {
            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._fetchImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateCacheData(args, cache);
            }
        }
    },
    _updateCacheData: function (args, cache)
    {
        var i;
        var length = cache.length;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishUpdateCacheData.bind(this, args));
        }
    },
    _finishUpdateCacheData: function (args, error, key)
    {
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _fetchImage: function (args, cache, i, epoch)
    {
        var request = new DownloadFile();
        var resizePrefix = (args.forceResize) ? "original_" : "";
        var filepath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;

        var headers = [];
        request.start(filepath, "GET", args.url, headers, this._finishFetchImage.bind(this, args, cache, i, request));
    },
    _finishFetchImage: function (args, cache, i, request, statuscode, filesignature)
    {
        if (statuscode === 200)
        {
            var imagePath = "./" + this.options.directory + "/" + args.addpath + args.name;
            var that = this;
            var _showAndUpdateCache = function ()
                {
                    args._super(imagePath, args.size, args.anchor, args.uvs);
                    if (that.options.cache)
                    {
                        that._addCacheData(args, cache, i);
                    }
                    else
                    {
                        that._unlockDirectory(args);
                    }
                };
            if (args.forceResize)
            {
                var _getPowerdBy2Size = function (originalSize)
                    {
                        var imageSize = 2;
                        while (true)
                        {
                            if (originalSize < 2)
                            {
                                return (imageSize > 1024) ? 1024 : imageSize;
                            }
                            originalSize /= 2;
                            imageSize *= 2;
                        }
                    };
                var x = _getPowerdBy2Size(args.size[0]);
                var y = _getPowerdBy2Size(args.size[1]);
                var resizeSize = (x > y) ? x : y;
                var resizePrefix = (args.forceResize) ? "original_" : "";
                var tmpImagePath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;
                UI.compositeImages(resizeSize, resizeSize, imagePath, [
                {
                    image: tmpImagePath,
                    fit: UI.FitMode.Stretch}], function (event)
                {

                    FileSystem.deleteFile(tmpImagePath);
                    _showAndUpdateCache();
                });
            }
            else
            {
                _showAndUpdateCache();
            }
        }
        else if (statuscode === 304 && this.options.cache)
        {
            args._super("./" + this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
            this._unlockDirectory(args);
        }
        else
        {
            this._unlockDirectory(args);
        }
    },
    _unlockDirectory: function (args)
    {
        this.tempfiles["./" + this.options.directory + "/" + args.addpath + args.name] = 1;
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _addCacheData: function (args, cache, i)
    {
        if (!(cache instanceof Array))
        {
            cache = [];
        }
        var now = new Date();
        var cachedata = {
            "name": args.name,
            "epoch": now.getTime()
        };
        if (i > -1)
        {
            if (cache[i].name !== args.name)
            {
                i = this._searchCache(cache, args.name);
            }
            if (i > -1)
            {
                cache.splice(i, 1);
            }
        }
        cache.unshift(cachedata);
        this._updateCacheData(args, cache);
    }
});
/** @private
 *  This ENTIRE CLASS is private.
 */
var UISprite = URLSprite.subclass( /** @lends GLUI.UISprite.prototype */
{
    "classname": 'UISprite',
    /**
     * @class The <code>UISprite</code> class inherits URLSprite and adds conversion for local images to fit GL2 requirements.
     * It also has caching mechanism to decrease reconversion overhead on each access.
     **/
    "_default_options": {
        "cache": true,
        "directory": "uisprite",
        "localcachetime": 3600,
        "cachesize": 1024,
        "forceResize": true
    },
    _manifestCache: null,
    _urlImageCache: null,

    /**
     * @ignore
     * @constructs The default constructor.
     **/
    initialize: function ($super, options)
    {
        $super(options);
    },

    destroy: function ($super)
    {
        $super();
    },
    /**
     * Download a image and set it for this <code>Sprite</code>.
     * It has same interface as URLSprite but it can also convert local images.
     * It can accept local image path and at that time, it's behaviour is totally same as GL2.Sprite's setImage method.
     * @param {String} image URL or the directory path to an image referenced by a frame.
     * @param {Core.Size} [size] The size of the image to display (in pixels).
     * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
     * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     **/
    setImage: function ($super, image, size, anchor, uvs)
    {
        var now;
        if (!image)
        {
            return this;
        }
        var imagePath = image;
        if (!size || size.length < 2 || !size[0] || size[1])
        {
            size = [128, 128];
        }
        var hashedName = toMD5(imagePath + size[0] + size[1]) + this._extractFileExstension(imagePath);

        var cachedata = null;
        if (image.slice(0, 7).toLowerCase() === "http://" || image.slice(0, 8).toLowerCase() === "https://")
        {
            if (this.options.cache && this._urlImageCache)
            {
                var i = this._searchCache(this._urlImageCache, hashedName);
                now = 0;
                if (i > -1)
                {
                    now = new Date();
                    if (this._urlImageCache[i].epoch + this.options.localcachetime * 1000 >= now.getTime())
                    {
                        cachedata = this._urlImageCache[i];
                        $super(this.options.directory + "/" + hashedName, size, anchor, uvs);
                        return this;
                    }
                }
            }
            return $super(image, size, anchor, uvs);
        }

        if (this.options.cache && this._manifestCache)
        {
            var j = this._searchCache(this._manifestCache, hashedName);
            if (j > -1)
            {
                now = new Date();
                if (this._manifestCache[j].epoch + this.options.localcachetime * 1000 >= now.getTime())
                {
                    cachedata = this._manifestCache[j];
                    $super(this.options.directory + "/" + hashedName, size, anchor, uvs);
                    return this;
                }
            }
        }

        var args = {
            _super: $super,
            imagePath: imagePath,
            name: hashedName,
            size: size,
            anchor: anchor,
            uvs: uvs,
            addpath: "",
            forceResize: this.options.forceResize
        };

        if (!this.options.cache)
        {
            var time = new Date();
            args.addpath = "nocache/" + Math.floor(Math.random() * 100) + time.getTime();
        }
        if (!$_queue[this.options.directory])
        {
            $_queue[this.options.directory] = [];
        }
        if ($_lock[this.options.directory])
        {
            $_queue[this.options.directory].push(this._setImageInternalFile.bind(this, args));
        }
        else
        {
            $_lock[this.options.directory] = 1;
            this._setImageInternalFile(args);
        }
        return this;
    },

    $setDefaultCacheMode: function (boolVal)
    {
        UISprite._default_options.cache = boolVal;
    },
    $getDefaultCacheMode: function ()
    {
        return UISprite._default_options.cache;
    },

    $setDefaultDirectory: function (directoryPath)
    {
        if (typeof (directoryPath) !== 'string')
        {
            directoryPath = 'urlimages';
        }
        UISprite._default_options.directory = directoryPath;
    },
    $getDefaultDirectory: function ()
    {
        return this._default_options.directory;
    },


    //        "_default_options" : {
    //      "cache"          : true,
    //      "directory"      : "urlimages",
    //      "localcachetime" : 3600,
    //      "cachesize"      : 1024,
    //      "forceResize"    : true
    //private Methods
    _extractFileExstension: function (imageName)
    {
        var filepos = imageName.lastIndexOf("/");
        if (filepos > -1)
        {
            imageName = imageName.slice(filepos + 1);
        }
        var dotpos = imageName.lastIndexOf(".");
        if (dotpos === -1)
        {
            return "";
        }
        var extension = imageName.slice(dotpos).toLowerCase();
        if (extension === ".jpeg")
        {
            extension = ".jpg";
        }
        return extension;
    },
    _setImageInternalFile: function (args, cache)
    {
        if (this.options.cache)
        {
            if (cache)
            {
                this._checkFileCacheData(args, undefined, undefined, cache);
            }
            else
            {
                this._setImageFileWithCache(args);
            }
        }
        else
        {
            this._resizeImage(args, [], -1);
        }
    },
    _setImageFileWithCache: function (args)
    {
        FileSystem.readFile(
        this.options.directory + "-urlsprite.json", false, this._checkFileCacheData.bind(this, args));
    },
    _checkFileCacheData: function (args, error, value, obj)
    {
        var self = this;
        var _createFolderForImages = function ()
            {
                //create default conversion output directory
                FileSystem.writeFile("./" + self.options.directory + "/.emptyfile", null, false, null);

                //create a converstion output directory for noncached images
                FileSystem.writeFile("./" + self.options.directory + "/nocache/.emptyfile", null, false, null);
            };

        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            _createFolderForImages();
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
            this._manifestCache = cache;
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._resizeImage(args, cache, i);
        }
        else
        {

            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._resizeImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateFileCacheData(args, cache);
            }
        }
    },
    _updateFileCacheData: function (args, cache)
    {
        var i;
        this._manifestCache = cache;
        var length = cache.length;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishFileUpdateCacheData.bind(this, args));
        }
    },
    _finishFileUpdateCacheData: function (args, error, key)
    {
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next();
        }
        else
        {
            $_lock[this.options.directory] = 0;
        }
    },
    _resizeImage: function (args, cache, i, epoch)
    {
        var resizePrefix = (args.forceResize) ? "original_" : "";
        var saveAsPath = this.options.directory + "/" + args.addpath + resizePrefix + args.name;
        this._startResizingImage(args.imagePath, saveAsPath, args, cache, i);
    },
    _startResizingImage: function (srcFile, dstFile, args, cache, i)
    {
        var imagePath = "./" + this.options.directory + "/" + args.addpath + args.name;
        var that = this;
        var _showAndUpdateCache = function ()
            {
                args._super(imagePath, args.size, args.anchor, args.uvs);
                if (that.options.cache)
                {
                    that._addFileCacheData(args, cache, i);
                }
                else
                {
                    that._unlockDirectory(args);
                }
            };
        if (args.forceResize)
        {
            var _getPowerdBy2Size = function (originalSize)
                {
                    var imageSize = 2;
                    while (true)
                    {
                        if (originalSize < 2)
                        {
                            return (imageSize > 1024) ? 1024 : imageSize;
                        }
                        originalSize /= 2;
                        imageSize *= 2;
                    }
                };
            var x = _getPowerdBy2Size(args.size[0]);
            var y = _getPowerdBy2Size(args.size[1]);
            var resizeSize = (x > y) ? x : y;

            UI.compositeImages(resizeSize, resizeSize, imagePath, [
            {
                image: srcFile,
                fit: UI.FitMode.Stretch}], function (event)
            {
                _showAndUpdateCache();
            });
        }
        else
        {
            _showAndUpdateCache();
        }
        this._unlockDirectory(args);
    },
    _addFileCacheData: function (args, cache, i)
    {
        if (!(cache instanceof Array))
        {
            cache = [];
        }
        var now = new Date();
        var cachedata = {
            "name": args.name,
            "epoch": now.getTime()
        };
        if (i > -1)
        {
            if (cache[i].name !== args.name)
            {
                i = this._searchCache(cache, args.name);
            }
            if (i > -1)
            {
                cache.splice(i, 1);
            }
        }
        cache.unshift(cachedata);
        this._updateFileCacheData(args, cache);
    },
    _checkCacheData: function (args, error, value, obj)
    {
        var cache;
        if (obj)
        {
            cache = obj;
        }
        else if (!value || error)
        {
            cache = [];
        }
        else
        {
            cache = JSON.parse(value);
            this._urlImageCache = cache;
        }
        var i = this._searchCache(cache, args.name);
        if (i === -1)
        {
            this._fetchImage(args, cache, i);
        }
        else
        {
            var now = new Date();
            if (cache[i].epoch + this.options.localcachetime * 1000 < now.getTime())
            {
                this._fetchImage(args, cache, i, cache[i].epoch);
            }
            else
            {
                var cachedata = cache[i];
                cache.splice(i, 1);
                cache.unshift(cachedata);
                args._super(this.options.directory + "/" + args.name, args.size, args.anchor, args.uvs);
                this._updateCacheData(args, cache);
            }
        }
    },
    _updateCacheData: function (args, cache)
    {
        var i;
        var length = cache.length;
        this._urlImageCache = cache;
        if (length > this.options.cachesize)
        {
            for (i = this.options.cachesize; i < length; i++)
            {
                FileSystem.deleteFile(this.options.directory + "/" + cache[i].name);
            }
            cache = cache.slice(0, this.options.cachesize);
        }
        if ($_queue[this.options.directory].length > 0)
        {
            var next = $_queue[this.options.directory].shift();
            next(cache);
        }
        else
        {
            var jsondata = JSON.stringify(cache);
            FileSystem.writeFile(
            this.options.directory + "-urlsprite.json", jsondata, false, this._finishUpdateCacheData.bind(this, args));
        }
    }
});

exports.URLSprite = URLSprite;
exports.UISprite = UISprite;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Image'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Image'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Image'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Image.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Gohar A
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var Point = require('NGCore/Client/Core/Point').Point;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var Sprite = require('NGGo1.3/GLUI/Sprite').URLSprite; //for now using url sprite, when this is fixed, we'll use Sprite - which can convert files on disk to power of two.
var Commands = require('NGGo1.3/GLUI/Commands').Commands;

var Image = AbstractView.subclass(
/** @lends GLUI.Image.prototype */
{
    classname: 'Image',
    /**
     * @name GLUI.Image
     * @class The <code>Image</code> class constructs objects that control the location and size of images used in the user interface.
     * @constructs
     * @augments GLUI.AbstractView
     */
    initialize: function ($super, properties)
    {
        $super();
        this._internalGLObject = new Sprite();
        this._internalGLObject.setScale(1, 1);
        this._imageSpriteSize = [64, 64];
        this._imageGravity = [0.5, 0.5];
        this._imageURL = null;
        this._fitMode = Commands.FitMode.Inside;
        this._anchor = [0.5, 0.5];
        this.__scaledImageSize = [0, 0];
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    /**
     * @name GLUI.Image#setImage
     * @description Set an image URL for a view state. This property defines a remote image resource to use in arbitrary contexts.
     * <br /><b>Note: </b> Images must be in powers of two and/or mentioned under <code>"textures":</code> key in manifests.
     * <br />URL is also supported, and the image will be converted to power of two.
     * <br />Local image auto conversion will be supported later.
     * @example var someSprite = new GLUI.Image();
     * ...
     * someSprite.setImage('./Content/mySprite.png', GLUI.State.Normal, [w, h]);
     * someSprite.setImage('http://www.example.com/somepicture80x92.png', GLUI.State.Normal, [200, 110]);
     * @see GLUI.Image#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.State} [flags=GLUI.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {Array} imageSize an array for the size of image. [w, h]
     * @status iOS, Android, Test
     * @function
     */
    setImage: function (imageURL, flags, imageSize)
    {
        var errorMsg = null;
        if(typeof(imageURL) === 'object')
        {
            var url = null;
            var size = [0, 0];
            if(imageURL.hasOwnProperty('url'))
            {
                url = imageURL.url;
            }
            else
            {
                errorMsg = "Image URL is not correct in " + this.classname + ".setImage Method";
                throw new Error(errorMsg);
            }
            if(imageURL.hasOwnProperty('size'))
            {
                size = imageURL.size;
            }
            imageURL = url;
            imageSize = size;
        }
        errorMsg = null;
        if (!imageURL || typeof imageURL !== 'string')
        {
            errorMsg = "Image URL is not correct in " + this.classname + ".setImage Method";
            throw new Error(errorMsg);
        }
        try
        {
            this._imageSpriteSize = (imageSize && imageSize.length === 2) ? imageSize : [0, 0];
            flags = (typeof (flags) === 'number') ? flags : Commands.State.Normal;
            this._images[String(flags)] = [imageURL, this._imageSpriteSize];
            this._updateView();
        }
        catch (exception)
        {
            errorMsg = [];
            errorMsg.push("Exception: setImage()");
            errorMsg.push(exception);
            errorMsg.push(this.classname);
            errorMsg.join();
            throw new Error(errorMsg);
        }
        return this;
    },
    /**
     * @name GLUI.Image#setImageFit
     * @description Set the value of the <code>imageFit</code> property.
     * This property defines the scaling of bitmap images to fit within the bounds of a control
     *
     * @example var splashGraphic = new GLUI.Image();
     * ...
     * splashGraphic.setImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.Image#getImageFit
     * @function
     * @status Android, Test
     */
    setImageFit: function (FitMode)
    {
        this._fitMode = FitMode;
        var glObject = this._internalGLObject;
        glObject.setScale(1, 1);
        switch (FitMode)
        {
        case Commands.FitMode.None:
            this._handleNoneMode(glObject);
            break;
        case Commands.FitMode.Inside:
            this._handleInsideMode(glObject);
            break;
        case Commands.FitMode.Fill:
            this._handleFillMode(glObject);
            break;
        case Commands.FitMode.Stretch:
            this._handleStretchMode(glObject);
            break;
        case Commands.FitMode.AspectWidth:
            this._handleAspectWidthMode(glObject);
            break;
        case Commands.FitMode.AspectHeight:
            this._handleAspectHeightMode(glObject);
            break;
        case Commands.FitMode.InsideNoUpscaling:
            this._handleInsideNoUpscalingMode(glObject);
            break;
        default:
            //setting to none -- which is default UI.Image behavior
            this.setImageFit(Commands.FitMode.None);
            return this;
        }
        var glPosition = this._getInternalGLObjectPosition();
        var posX = glPosition.getX();
        var posY = glPosition.getY();
        glObject.setPosition([posX, posY]);

        return this;
    },
    /**
     * @name GLUI.Image#getImage
     * @description Retrieve the <code>image</code> URL for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current image URL for the specified view state..
     * @see GLUI.Image#setImage
     * @status Android, Test
     * @function
     */
    getImage: function (flags)
    {
        var state = this._getEffectiveState(flags);
        var value = this._images[String(state)];
        if (value !== null && value !== undefined)
        {
            return value[0];
        }
        else
        {
            return undefined;
        }
    },
    /**
     * @name GLUI.Image#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.Image#setImageFit
     * @function
     * @status Android, Test
     */
    getImageFit: function ()
    {
        return this._fitMode;
    },
    /**
     * @name GLUI.Image#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area. Gravity values supported are: value-from-[0.0, 0.0] to [1.0, 1.0]
     * @example var splashGraphic = new GLUI.Image();
     * ...
     * splashGraphic.setImageGravity([0.5, 0.0]);
     * @param {Number} imageGravity The new value for <code>imageGravity</code> expressed as two floats.
     * @see GLUI.Image#getImageGravity
     * @function
     * @status Android, Test
     */
    setImageGravity: function(imageGravity)
    {
        if(arguments)
        {
        if(arguments.length >=2)
        {
            imageGravity = [arguments[0], arguments[1]];
        }
        this.__setImageGravity(imageGravity);
        }
        else
        {
        throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    /**
    @private
    */
    __setImageGravity: function (imageGravity)
    {
        imageGravity = (imageGravity && imageGravity.length === 2 && !isNaN(imageGravity[0]) && !isNaN(imageGravity[1])) ? [imageGravity[0], imageGravity[1]] : [0.5, 0.5];
        this._imageGravity = imageGravity;
        this._anchor = imageGravity;
        this._adjustImageGravity();
        this.setImageFit(this.getImageFit());
        return this;
    },
    /**
     * @name GLUI.Image#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code> expressed as two floats.
     * @see GLUI.Image#setImageGravity
     * @function
     * @status Android, Test
     */
    getImageGravity: function ()
    {
        return [this._imageGravity[0], this._imageGravity[1]];
    },
    __setFrame: function ($super, frame)
    {
        $super(frame);
        if (this._imageSpriteSize)
        {
            this.setImageFit(this.getImageFit());
        }
        this._updateView();
    },
    destroy: function ($super)
    {
        this.__scaledImageSize = null;
        this._imageSpriteSize = null;
        this._imageURL = null;
        this._imageGravity = null;
        $super();
    },
    /**
     * @private
     */
    _adjustImageGravity: function ()
    {
        if (this.getImageFit() === Commands.FitMode.None || this.getImageFit() === Commands.FitMode.Inside)
        {
            var glObject = this._internalGLObject;
            var currImageGravity = this.getImageGravity();
            currImageGravity = (currImageGravity) ? currImageGravity : [0.5, 0.5];
            var gravityX = currImageGravity[0];
            var gravityY = currImageGravity[1];
            var currScale = glObject.getScale();
            currScale = (currScale) ? currScale : new Point(1, 1);
            var scaleX = currScale.getX();
            var scaleY = currScale.getY();
            var currSize = this._imageSpriteSize;
            currSize = (currSize) ? currSize : [0, 0];
            var sizeX = currSize[0];
            var sizeY = currSize[1];
            var currFrame = this.getFrame();
            currFrame = (currFrame) ? currFrame : [0, 0, 0, 0];
            var frameX = currFrame[2];
            var frameY = currFrame[3];
            var currAnchor = this._anchor;
            currAnchor = (currAnchor) ? currAnchor : [0.5, 0.5];
            var anchorX = currAnchor[0];
            var anchorY = currAnchor[1];
            var pos = [];
            pos[0] = (gravityX * frameX) - (scaleX * sizeX) * (gravityX - anchorX);
            pos[1] = (gravityY * frameY) - (scaleY * sizeY) * (gravityY - anchorY);
            glObject.setPosition(pos);
        }
        else
        {
            return;
        }
    },
    /**
     * @private
     */
    _updateView: function ()
    {
        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if (!this._frame || (this._frame && this._frame.length < 4))
        {
            this._frame = [0, 0, 0, 0];
        }
        if (!this._images[String(Commands.State.Normal)] || !this._frame[2] || !this._frame[3])
        {
            return;
        }
        var currentState = this._state;
        var nextState = this._getEffectiveState(currentState);
        var nextImage = this._images[String(nextState)];
        if (!nextImage || nextImage.length === 0)
        {
            nextImage = this._images[String(Commands.State.Normal)];
        }
        if (nextImage !== null)
        {
            this._imageURL = nextImage[0];
            this._imageSpriteSize = nextImage[1];
            this.setImageFit(this._fitMode);
        }
    },
    /**
     * @private
     */
    _handleNoneMode: function (glObject)
    {
        var currImageGrav = this.getImageGravity();
        var anchor = new Point(currImageGrav);
        var rectX = 0;
        var rectY = 0;
        var x = 0;
        var y = 0;
        if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            glObject.setImage(this._imageURL, this._imageSpriteSize, anchor);
        }
        else if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] <= this._imageSpriteSize[1])
        {
            rectY = this._frame[3] / this._imageSpriteSize[1];
            y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0], this._frame[3]], anchor, [0, y, 1, rectY]);
        }
        else if (this._frame[2] <= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            rectX = this._frame[2] / this._imageSpriteSize[0];
            x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._imageSpriteSize[1]], anchor, [x, 0, rectX, 1]);
        }
        else
        {
            rectX = this._frame[2] / this._imageSpriteSize[0];
            rectY = this._frame[3] / this._imageSpriteSize[1];
            x = (1 - rectX) * currImageGrav[0];
            y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], anchor, [x, y, rectX, rectY]);
        }
    },
    /**
     * @private
     */
    _handleInsideMode: function (glObject)
    {
        var tempSize = new Vector(this._frame[2] / this._imageSpriteSize[0], this._frame[3] / this._imageSpriteSize[1]);
        var x = tempSize.getX();
        var y = tempSize.getY();
        glObject.setImage(this._imageURL, this._imageSpriteSize, this._anchor);
        if (x <= y)
        {
            glObject.setScale(x, x);
        }
        else
        {
            glObject.setScale(y, y);
        }
    },
    /**
     * @private
     */
    _handleFillMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        var currImageGrav = this.getImageGravity();
        if (diffX >= diffY)
        {
            var rectY = this._frame[3] / this._frame[2];
            var y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [0, y, 1, rectY]);
        }
        else
        {
            var rectX = this._frame[2] / this._frame[3];
            var x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [x, 0, rectX, 1]);
        }
    },
    /**
     * @private
     */
    _handleStretchMode: function (glObject)
    {
        glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor);
    },
    /**
     * @private
     */
    _handleAspectWidthMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        if (diffX >= diffY)
        {
            var rectY = this._frame[3] / this._frame[2];
            var currImageGrav = this.getImageGravity();
            var y = (1 - rectY) * currImageGrav[1];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [0, y, 1, rectY]);
        }
        else
        {
            var scaleX = this._frame[2] / this._imageSpriteSize[0];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0] * scaleX, this._imageSpriteSize[1] * scaleX], this._anchor);
        }
    },
    /**
     * @private
     */
    _handleAspectHeightMode: function (glObject)
    {
        var diffX = (this._frame[2] - this._imageSpriteSize[0]);
        var diffY = (this._frame[3] - this._imageSpriteSize[1]);
        if (diffY >= diffX)
        {
            var rectX = this._frame[2] / this._frame[3];
            var currImageGrav = this.getImageGravity();
            var x = (1 - rectX) * currImageGrav[0];
            glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor, [x, 0, rectX, 1]);
            this.__scaledImageSize = [this._frame[2], this._frame[3]];
        }
        else
        {
            var scaleY = this._frame[3] / this._imageSpriteSize[1];
            glObject.setImage(this._imageURL, [this._imageSpriteSize[0] * scaleY, this._imageSpriteSize[1] * scaleY], this._anchor);
            this.__scaledImageSize = [this._imageSpriteSize[0] * scaleY, this._imageSpriteSize[1] * scaleY];
        }
    },

    /**
     * @private
     * */
    _handleInsideNoUpscalingMode: function (glObject)
    {
        if (this._frame[2] >= this._imageSpriteSize[0] && this._frame[3] >= this._imageSpriteSize[1])
        {
            this.setImageFit(Commands.FitMode.None);
        }
        else
        {
            this.setImageFit(Commands.FitMode.Inside);

        }
    },
    /**
     * @private
     */
    _getEffectiveState: function (flags)
    {
        var currentState = flags;
        var nextState = null;
        if (currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if (currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if (currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if (currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if (currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if (currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     * @private
     */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForImage(this);
    },
    /**
     * @private
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForImage(this);
    },
    /**
     * @private
     */
    ___getSpriteSizeForCheckBox: function ()
    {
        return this.__scaledImageSize;
    },
    /////////// Empty Functions ////////////
    /**
     * @name GLUI.Image#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.Commands.State} [ flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>
     * @see GLUI.Image#setImageBorder
     * @status Android, Test
     * @function
     */
    getImageBorder: function (flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder(flags) in Image');
    },

    /**
     * @name GLUI.Image#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>
     * @see GLUI.Image#setImageTransform
     * @status Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() in Image');
    },

    /**
     * @name GLUI.Image#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder.</code>.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The UI view state.
     * @see GLUI.Image#getImageBorder
     * @status Android, Test
     * @function
     */
    setImageBorder: function (imageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) in Image');
    },

    /**
     * @name GLUI.Image#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var splashGraphic = new UI.Image();
     * ...
     * splashGraphic.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.Image#getImageTransform
     * @status Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in Image');
    }
});

exports.Image = Image;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Label'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Label'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Label'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Label.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan H
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var Util = require('NGGo1.3/GLUI/Util').Util;
var Text = require('NGCore/Client/GL2/Text').Text;
exports.Label = AbstractView.subclass(
{ /** @lends GLUI.Label.prototype */
    classname: 'Label',
    /**
     * @name GLUI.Label
     * @class The <code>Label</code> class constructs objects for managing strings that are used as application labels. 
     * These objects include access to a wide range of attributes for manipulating the look and feel of application labels.
     * @constructs
     * @augments GLUI.AbstractView
     */
    initialize: function (properties)
    {
        this._internalGLObject = new Text();
        this._internalGLObject.setAnchor(0, 0);
        this._internalGLObject.setColor(0, 0, 0);
        this._internalGLObject.setOverflowMode(Text.OverflowMode.Multiline);
        this._textInset = [0, 0, 0, 0];
        this._shadowValues = [];
        this._textSize = 8;
        this._colors = [];
        this._texts = [];
        this._fonts = [];
        this._shadow = null;
        this._textGravity = null;
        this._fontLocation = 0;
        this.setTextSize(this._textSize);
        if(properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    /**
     * @name GLUI.Label#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>text</code>.
     * @see GLUI.Label#setText
     * @function
     * @status Android, Test
     *
     */
    getText: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._texts[state + ''];
    },
    /**
     * @name GLUI.Label#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textColor</code>.
     * @see GLUI.Label#setTextColor
     * @status Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._colors[state + ''];
    },
    /**
     * @name GLUI.Label#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code>.
     * @see GLUI.Label#setTextFont
     * @status Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._fonts[state + ''];
    },
    /**
     * @name GLUI.Label#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property for this <code>Label</code>.
     * @returns {Number} The current value of <code>textSize</code>.
     * @see GLUI.Label#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._textSize;
    },
    /**
     * @name GLUI.Label#setTextInsets
     * @description Set the value of the <code>textInsets</code> property for this <code>Label</code>. This property defines the viewable area of a text string when applying gravity.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextInsets(0, 0, 0, 64);
     * @param {Number, Array (Number)} textInsets The new value for <code>textInsets</code>. Set as individual components or a single array of components.
     * @see GLUI.Label#getTextInsets
     * @status Android, Test
     * @function
     */
    setTextInsets: function (textInsets)
    {
        if(arguments)
        {
            if(arguments.length >= 4)
            {
                textInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            this.__setTextInsets(textInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTextInsets in " + this.classname);
        }
    },
    /**
     * @private
     * @status Android
     */
    __setTextInsets: function (textInset)
    {
        if(textInset.length < 4)
        {
            throw new Error('Too few arguments for \'textInset\' in setTextInsets(textInset)');
        }
        if(isNaN(textInset[0]) || isNaN(textInset[1]) || isNaN(textInset[2]) || isNaN(textInset[3]))
        {
            throw new Error('Wrong arguments for \'textInset\' in setTextInsets(textInset)');
        }
        this._textInset = [textInset[0], textInset[1], textInset[2], textInset[3]];
        var bgColor = this.getBackgroundColor();
        if(!bgColor)
        {
            this.setBackgroundColor("00000000");
        }
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.Label#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property for this <code>Label</code>.
     * @returns {Number, Array (Number)} The current value of <code>textInsets</code>.
     * @see GLUI.Label#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return [this._textInset[0], this._textInset[1], this._textInset[2], this._textInset[3]];
    },
    /*
     * @private
     */
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._renderView();
    },
    /**
     * @name GLUI.Label#setText
     * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setText("Friends List");
     * @param {String} text The new value for <code>text</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getText
     * @status Android,Test
     * @function
     */
    setText: function (text, flags)
    {
        var state = this._getFinalState(flags);
        this._texts[state + ''] = text;
        var curState = this._getCurrentState();
        var curText = this._texts[curState + ''];
        if(curText === undefined || curText === null)
        {
            curText = this._texts[Commands.State.Normal + ''];
        }
        this._internalGLObject.setText(curText);
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string for a label in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextColor('FFFF');
     * @param {String} textColor The new value for <code>textColor</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextColor
     * @status Android, Test
     * @function
     */
    setTextColor: function (color, flags)
    {
        var state = this._getFinalState(flags);
        this._colors[state + ''] = color;
        var curState = this._getCurrentState();
        var currentColor = this._colors[curState + ''];
        if(currentColor === undefined || currentColor === null)
        {
            currentColor = this._colors[Commands.State.Normal + ''];
        }
        var rgbValue = Util.hexToARGB(currentColor);
        this.__internalAlpha = rgbValue[0];
        this._internalGLObject.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
        this._updateAlpha();
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (font, flags)
    {
        var state = this._getFinalState(flags);
        this._fonts[state + ''] = font;
        var curState = this._getCurrentState();
        var currentFont = this._fonts[curState + ''];
        if(currentFont === undefined || currentFont === null)
        {
            currentFont = this._fonts[Commands.State.Normal + ''];
        }
        this._internalGLObject.setFontFamily(currentFont);
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>Label</code> node.
     * @example var label = new GLUI.Label();
     * ...
     * label.setFontLocation(0);
     * @param {GLUI.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.Label#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function (fontLocation)
    {
        if(fontLocation === null || fontLocation === undefined)
        {
            return;
        }
        this._fontLocation = Text.FontLocation.Default;
        switch(fontLocation)
        {
        case 1:
            this._fontLocation = Text.FontLocation.System;
            break;
        case 2:
            this._fontLocation = Text.FontLocation.Bundled;
            break;
        case 3:
            this._fontLocation = Text.FontLocation.Manifest;
            break;
        }
        this._internalGLObject.setFontLocation(this._fontLocation);
        if(this._shadow)
        {
            this._shadow.setFontLocation(this._fontLocation);
        }
    },
    /**
     * @name GLUI.Label#setTextSize
     * @description Set the value of the <code>textSize</code> property for this <code>Label</code>. This property defines the size of text strings for a label.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextSize(24);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.Label#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (size)
    {
        if(isNaN(size))
        {
            throw new Error('Expecting number but found ' + typeof (size) + ' for setTextSize(size)');
        }
        this._textSize = size;
        if(this._internalGLObject)
        {
            this._internalGLObject.setFontSize(this._textSize);
        }
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#setTextGravity
     * @description Set the value of the <code>textGravity</code> property for this <code>Label</code>. This property defines how a text string is positioned within a viewable area.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextGravity([1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.Label#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        if(arguments)
        {
            if(arguments.length >= 2)
            {
                textGravity = [arguments[0], arguments[1]];
            }
            this.__setTextGravity(textGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTextGravity in " + this.classname);
        }
    },
    /**
     * @private
     * @status Android
     */
    __setTextGravity: function (textGravity)
    {
        if(textGravity.length < 2)
        {
            throw new Error('Too few arguments for \'textGravity\' in setTextGravity(textGravity)');
        }
        if(isNaN(textGravity[0]) && isNaN(textGravity[1]))
        {
            throw new Error('Wrong arguments for \'textGravity\' in setTextGravity(textGravity)');
        }
        var gravityX = null;
        var gravityY = null;
        if(textGravity[0] < 0.5)
        {
            gravityX = 0;
        }
        else if(textGravity[0] > 0.5)
        {
            gravityX = 2;
        }
        else
        {
            gravityX = 1;
        }
        if(textGravity[1] < 0.5)
        {
            gravityY = 0;
        }
        else if(textGravity[1] > 0.5)
        {
            gravityY = 2;
        }
        else
        {
            gravityY = 1;
        }
        this._textGravity = [textGravity[0], textGravity[1]];
        this._internalGLObject.setHorizontalAlign(gravityX);
        this._internalGLObject.setVerticalAlign(gravityY);
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property for this <code>Label</code>.
     * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.Label#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        if(this._textGravity === null || this._textGravity === undefined)
        {
            return this._textGravity;
        }
        else
        {
            return [this._textGravity[0], this._textGravity[1]];
        }
    },
    /**
     * @name GLUI.Label#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on labels in the specified view state.
     * @example var label = new GLUI.Label();
     * ...
     * label.setTextShadow("FF00 0.2");
     * @param {String} textShadow The new value for <code>textShadow</code>.
     * @param {GLUI.Commands.State} [flags=UI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Label#getTextShadow
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        if(textShadow === undefined || textShadow === null)
        {
            console.log("Wrong number of arguments for shadow");
            return this;
        }
        var params = textShadow.split(" ");
        if(params.length < 2)
        {
            console.log("Wrong number of arguments for shadow");
            return this;
        }
        if(isNaN("0x" + params[0]) || isNaN(params[1]))
        {
            console.log(params[0], params[1]);
            console.log("Invalid Parameters for arguments for setTextShadow()");
            return this;
        }
        var state = this._getFinalState(flags);
        this._shadowValues[state + ''] = textShadow;
        this._updateShadow();
        return this;
    },
    /**
     * @name GLUI.Label#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code>.
     * @see GLUI.Label#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        var state = this._getFinalState(flags);
        return this._shadowValues[state + ''];
    },
    /**
     * @name GLUI.Label#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>Label</code> node.
     * @example var label = new GLUI.Label();
     * ...
     * label.getFontLocation();
     * @see GLUI.Label#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function ()
    {
        return this._fontLocation;
    },
    /**
     * @private
     **/
    destroy: function ($super)
    {
        if(this._colors)
        {
            this._colors.length = 0;
            this._colors = null;
        }
        if(this._texts)
        {
            this._texts.length = 0;
            this._texts = null;
        }
        if(this._fonts)
        {
            this._fonts.length = 0;
            this._fonts = null;
        }
        if(this._shadowValues)
        {
            this._shadowValues.length = 0;
            this._shadowValues = null;
        }
        if(this._textGravity)
        {
            this._textGravity.length = 0;
            this._textGravity = null;
        }
        if(this._textInset)
        {
            this._textInset.length = 0;
            this._textInset = null;
        }
        if(this._shadow)
        {
            this._shadow.destroy();
            this._shadow = null;
        }
        this._textSize = null;
        $super();
    },
    /**
     * @private
     * */
    setVisible: function ($super, value)
    {
        $super(value);
        if(this._parentNode)
        {
            this._parentNode.setVisible(value);
        }
        this._internalGLObject.setVisible(value);
    },
    /**
     *
     * @private
     * @status Android
     */
    __fillBackgroundColor: function ($super)
    {
        $super();
        this._internalGLObject.setPosition(0, 0);
    },
    /**
     *
     * @private
     * @status Android
     */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForLabel(this);
    },
    /**
     *
     * @private
     * @status Android
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
    },
    /**
     *
     * @private
     * @status Android
     */
    _getFinalState: function (flags)
    {
        var currentState = flags;
        var nextState = null;
        if(currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if(currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if(currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if(currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if(currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if(currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     *
     * @private
     * @status Android
     */
    _getCurrentState: function ()
    {
        var currentState = this._state;
        var nextState = null;
        if(currentState & Commands.State.Disabled)
        {
            nextState = Commands.State.Disabled;
        }
        else if(currentState & Commands.State.Custom)
        {
            nextState = Commands.State.Custom;
        }
        else if(currentState & Commands.State.Checked)
        {
            nextState = Commands.State.Checked;
        }
        else if(currentState & Commands.State.Pressed)
        {
            nextState = Commands.State.Pressed;
        }
        else if(currentState & Commands.State.Selected)
        {
            nextState = Commands.State.Selected;
        }
        else if(currentState & Commands.State.Focused)
        {
            nextState = Commands.State.Focused;
        }
        else
        {
            nextState = Commands.State.Normal;
        }
        return nextState;
    },
    /**
     *
     * @private
     * @status Android
     */
    _updateView: function ($super)
    {
        $super();
        var curState = this._getCurrentState();
        var currentColor = this._colors[curState + ''];
        if(currentColor === undefined || currentColor === null)
        {
            currentColor = this._colors[Commands.State.Normal + ''];
            var rgbValue = Util.hexToARGB(currentColor);
            if(currentColor === undefined || currentColor === null)
            {
                this.__internalAlpha = 1.0;
                this._internalGLObject.setColor(0, 0, 0);
            }
            else
            {
                this.__internalAlpha = rgbValue[0];
                this._internalGLObject.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
            }
            this._updateAlpha();
        }
        else
        {
            this.setTextColor(currentColor, curState);
        }
        var currentFont = this._fonts[curState + ''];
        if(currentFont === undefined)
        {
            currentFont = this._fonts[Commands.State.Normal + ''];
            this._internalGLObject.setFontFamily(currentFont);
        }
        else
        {
            this.setTextFont(currentFont, curState);
        }
        var currentText = this._texts[curState + ''];
        if(currentText === undefined)
        {
            currentText = this._texts[Commands.State.Normal + ''];
            this._internalGLObject.setText(currentText);
        }
        else
        {
            this.setText(currentText, curState);
        }
        this._updateShadow();
    },
    /**
     *
     * @private
     * @status Android
     */
    _updateShadow: function ()
    {
        var curState = this._getCurrentState();
        var currentShadow = this._shadowValues[curState + ''];
        if(currentShadow === undefined || currentShadow === null)
        {
            currentShadow = this._shadowValues[Commands.State.Normal + ''];
        }
        if(currentShadow === undefined || currentShadow === null)
        {
            if(this._shadow)
            {
                this.getGLObject().removeChild(this._shadow);
                this._shadow.destroy();
                this._shadow = null;
            }
            return;
        }
        if(!this._shadow)
        {
            var bgColor = this.getBackgroundColor();
            if(bgColor)
            {
                this.setBackgroundColor(bgColor);
            }
            else
            {
                this.setBackgroundColor("00000000");
            }
            this._shadow = new Text();
            this.getGLObject().addChild(this._shadow);
            this._shadow.setAnchor(0, 0);
            this._shadow.setDepth(this._internalGLObject.getDepth() - 1);
        }
        var params = currentShadow.split(" ");
        var opacity = params[1];
        var txt = this.getText(curState);
        if(txt === undefined || currentShadow === null)
        {
            txt = this.getText(Commands.State.Normal);
        }
        var font = this.getTextFont(curState);
        if(font === undefined || currentShadow === null)
        {
            font = this.getTextFont(Commands.State.Normal);
        }
        this._shadow.setText(txt);
        this._shadow.setFontSize(this._textSize);
        var rgbValue = Util.hexToARGB(params[0]);
        this._shadow.setColor(rgbValue[1], rgbValue[2], rgbValue[3]);
        this._shadow.setFontLocation(this._fontLocation);
        this._shadow.setFontFamily(font);
        this._shadow.setSize(this._frame[2], this._frame[3]);
        var Position = this._internalGLObject.getPosition();
        this._shadow.setPosition(Position.getX() + 3, Position.getY() + 3);
        var gravityX = this._internalGLObject.getHorizontalAlign();
        var gravityY = this._internalGLObject.getVerticalAlign();
        this._shadow.setHorizontalAlign(gravityX);
        this._shadow.setVerticalAlign(gravityY);
        this._shadow.setAlpha(opacity);
    },
    /**
     *
     * @private
     * @status Android
     */
    _renderView: function ()
    {
        var top = this._textInset[0];
        var right = this._textInset[1];
        var bottom = this._textInset[2];
        var left = this._textInset[3];
        var xTop = this._frame[0];
        var yTop = this._frame[1];
        if(this._parentNode)
        {
            xTop = yTop = 0;
        }
        if(right > this._frame[2] / 2)
        {
            right = this._frame[2] / 2;
        }
        this._updateShadow();
        this._internalGLObject.setPosition(xTop + left - right / 4, yTop + top - bottom / 4);
        this._internalGLObject.setSize(this._frame[2] - right - left, this._frame[3] - bottom - top);
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Button'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Button'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Button'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Button.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Taha S, Harris K
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var View = require('NGGo1.3/GLUI/View').View;
var Label = require('NGGo1.3/GLUI/Label').Label;

exports._unbindButtons = [];
exports._activeButton = undefined;
var Button = View.subclass(
/** @lends GLUI.Button.prototype */
{
    classname: "Button",
    /**
     * @name GLUI.Button
     * @class The <code>Button</code> class constructs objects that are used as application buttons.
     * @augments GLUI.View
     */
    initialize: function ($super, properties, cleanView)
    {
        $super();
        this._text = new Label();
        this._text._setClickable(false);
        this._text.setTextGravity([0.5, 0.5]);
        this.addChild(this._text);
        this.setAttributes(properties);
        if (this.addChild && !cleanView)
        {
            delete this.addChild;
            this.addChild = undefined;
        }
        if (this.removeChild && !cleanView)
        {
            delete this.removeChild;
            this.removeChild = undefined;
        }
        if (this.getChildren && !cleanView)
        {
            delete this.getChildren;
            this.getChildren = undefined;
        }
        if (this.getChildrenCount && !cleanView)
        {
            delete this.getChildrenCount;
            this.getChildrenCount = undefined;
        }
        return this;
    },
    /**
     * @name GLUI.Button#setTextInsets
     * @description Set the value of the <code>textInsets</code> property.
     * This property defines the viewable area of a text string when applying gravity.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextInsets([0, 0, 0, 64]);
     * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
     * @see GLUI.Button#getTextInsets
     * @status Android, Test
     * @function
     */
    setTextInsets: function (insets)
    {
        return this._text.setTextInsets(insets);
    },
    /**
     * @name GLUI.Button#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property.
     * @returns {Array (Number)} The curent value for <code>textInsets</code>.
     * @see GLUI.Button#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return this._text.getTextInsets();
    },
    /**
     * @name GLUI.Button#setText
     * @description Set the value of the <code>text</code> property for a view state.
     * This property defines a text string to use as a label for a button in different
     * view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setText("More information");
     * @see GLUI.Button#getText
     * @param {String} text The new value for <code>text</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status iOS, Android, Flash, Test
     * @function
     */
    setText: function (text, flags)
    {
        this._text.setText(text, flags || Commands.State.Normal);
        return this;
    },
    /**
     * @name GLUI.Button#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state.
     *  This property defines the color of a text string used as a label on a
     * button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextColor('FFFFFF');
     * @see GLUI.Button#getTextColor
     * @param {String} textColor The new value for <code>textColor</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commonds.State.Normal] The GLUI view state.
     * @status  Android, Test
     * @function
     */
    setTextColor: function (textColor, flags)
    {
        this._text.setTextColor(textColor, flags);
        return this;
    },
    /**
     * @name GLUI.Button#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.Button#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (textFont, flags)
    {
        this._text.setTextFont(textFont, flags);
        return this;
    },
    /**
     * @name GLUI.Button#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>Button</code> node.
     * @example var button = new GLUI.Button();
     * ...
     * button.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.Button#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function(fontLocation){
        this._text.setFontLocation(fontLocation);
        return this;
    },
     /**
     * @name GLUI.Button#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>Button</code> node.
     * @example var button = new GLUI.Button();
     * ...
     * button.getFontLocation();
     * @see GLUI.Button#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function(){
        return this._text.getFontLocation();
    },
    /**
     * @name GLUI.Button#setTextSize
     * @description Set the value of the <code>textSize</code> property. This property defines the text size of labels for a button.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextSize(24);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.Button#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (textSize)
    {
        this._text.setTextSize(textSize);
        return this;
    },
    /**
     * @name GLUI.Button#setTextGravity
     * @description Set the value of the <code>textGravity</code> property. This property defines how a text string for a button is positioned within a viewable area.
     * @example var infoButton = new UI.Button();
     * ...
     * infoButton.setTextGravity([0.1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.Button#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        this._text.setTextGravity(textGravity);
        return this;
    },
    /**
     * @name GLUI.Button#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on text strings for a button in different view states.
     * @example var infoButton = new GLUI.Button();
     * ...
     * infoButton.setTextShadow("FF00 0.2");
     * @see GLUI.Button#getTextShadow
     * @param {String} textShadow The new value for <code>textShadow</code> in the specified view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        this._text.setTextShadow(textShadow, flags);
    },
    /**
     * @name GLUI.Button#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>text</code> in the specified view state..
     * @see GLUI.Button#setText
     * @status Android, Test
     * @function
     */
    getText: function (flags)
    {
        return this._text.getText(flags);
    },
    /**
     * @name UI.Button#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {UI.State} [flags=UI.State.Normal] The UI view state.
     * @returns {String} The current value of <code>textColor</code> in the specified view state..
     * @see UI.Button#setTextColor
     * @status  Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        return this._text.getTextColor(flags);
    },
    /**
     * @name GLUI.Button#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property.
     * @returns {Number} The current value for <code>textSize</code>.
     * @see GLUI.Button#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._text.getTextSize();
    },
    /**
     * @name GLUI.Button#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code> in the specified view state.
     * @see GLUI.Button#setTextFont
     * @status  Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        return this._text.getTextFont(flags);
    },
    /**
     * @name GLUI.Button#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property.
     * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.Button#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        return this._text.getTextGravity();
    },
    /**
     * @name GLUI.Button#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code> in the specified view state..
     * @see GLUI.Button#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        return this._text.getTextShadow(flags);
    },
    setState: function ($super, flags)
    {
        $super(flags);
        this._text.setState(flags);
    },
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._text.setFrame([0, 0, this._frame[2], this._frame[3]]);
        if (!this.getOnClick())
        {
            this.setOnClick(function ()
            {});
        }
        this._updateDepth();
    },
    destroy: function ($super)
    {
        if (this._text)
        {
            this._text.destroy();
            this._text = null;
        }
        $super();
    },
    /**
     * @private
     * */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @private
     * */
    _renderView: function ()
    {
        this._text.setState(this.getState());
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForLabel(this);
        this._setters.visible = this.setVisible.bind(this);
    },
    /**
     * @private
     * */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
        this._getters.visible = this.getVisible.bind(this);
    },
    /////////// Empty Functions /////////////////
    /**
     * @name GLUI.Button#setImageInsets
     * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var backButton = new UI.Button();
     * ...
     * backButton.setImageInset([10,10,10,10]);
     * @param {Number|Array (Number)} imageInsets The new value for <code>imageInsets.</code> Set as insets or an array of insets (expressed as floats).
     * @see GLUI.Button#getImageInsets
     * @status  Android, Test
     * @function
     */
    setImageInsets: function (imageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageInsets(imageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.Button#getImageInsets
     * @description Retrieve the value of the <code>imageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number|Array (Number)} The current value of <code>imageInsets.</code>
     * @see GLUI.Button#setImageInsets
     * @status  Android, Test
     * @function
     */
    getImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageInsets() in Button');
    },

    /**
     * @name GLUI.Button#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for an image used as a button.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var button = new UI.Button()
     * ...
     * button.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.Button#getImageTransform
     * @status  Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in ' + this.classname);
    },

    /**
     * @name GLUI.Button#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>
     * @see GLUI.Button#setImageTransform
     * @status  Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() in ' + this.classname);
    }
});

exports.Button = Button;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/WindowLayer'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/WindowLayer'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/WindowLayer'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/WindowLayer.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno T.
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Element = require('NGGo1.3/GLUI/Element').Element;
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var Root = require('NGCore/Client/GL2/Root').Root;
var View = require('NGGo1.3/GLUI/View').View;
////////////        UI Components       //////////////
var EditText = require('NGCore/Client/UI/EditText').EditText;
var EditTextArea = require('NGCore/Client/UI/EditTextArea').EditTextArea;
var WebView = require('NGCore/Client/UI/WebView').WebView;
var MapView = require('NGCore/Client/UI/MapView').MapView;
var UIWindow = require('NGCore/Client/UI/Window').Window;
/** @private
 *  This ENTIRE CLASS is private.
 */
exports.WindowLayer = Element.subclass( /** @lends GLUI.WindowLayer.prototype */
{
    'type': 'WindowLayer',
    initialize: function ($super, props)
    {
        this._children = [];
        this._uiChildren = [];
        this._visible = true;
    },
    getRoot: function ()
    {
        return this;
    },
    getParent: function ()
    {
        return undefined;
    },
    getGLObject: function ()
    {
        return Root;
    },
    addChild: function (childNode, index)
    {
        if (childNode instanceof AbstractView)
        {
            if (childNode._parent)
            {
                childNode.removeFromParent();
            }
            if (this._children)
            {
                if ((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            childNode._parent = this;
            try
            {
                Root.addChild(childNode.getGLObject());
                childNode._parent = this;
                this._updateDepth();
                childNode._callAppearanceEvent(false);
                var Button = require('NGGo1.3/GLUI/Button').Button;
                if (childNode instanceof View && !(childNode instanceof Button))
                {
                    childNode._addedToParent();
                }
            }
            catch (ex)
            {
                throw new Error(ex);
            }
        }
        else if ((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            if (this._uiChildren.indexOf(childNode) === -1)
            {
                this._uiChildren.push(childNode); // maintaining array
                UIWindow.document.addChild(childNode);
                childNode._parent = this;
            }
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not an Instance of AbstractView!");
        }
    },
    _updateDepth: function ()
    {
        var i;
        if (this._children)
        {
            for (i = 0; i < this._children.length; i++)
            {
                if (this._children[i])
                {
                    this._children[i].getGLObject().setDepth(i + 1);
                }
            }
        }
    },
    removeChild: function (childNode)
    {
        var nodeIndex;
        if (childNode instanceof AbstractView)
        {
            try
            {
                nodeIndex = this._children.indexOf(childNode);
                if (nodeIndex !== -1)
                {
                    this._children.splice(nodeIndex, 1);
                }
                childNode._callAppearanceEvent(true);
                Root.removeChild(childNode.getGLObject());
                childNode._parent = null;
                this._updateDepth();
                var Button = require('NGGo1.3/GLUI/Button').Button;
                if (childNode instanceof View && !(childNode instanceof Button))
                {
                    childNode._removedFromParent();
                }
            }
            catch (ex)
            {
                throw new Error(ex);
            }
        }
        else if ((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            nodeIndex = this._uiChildren.indexOf(childNode);
            if (nodeIndex !== -1)
            {
                this._uiChildren.splice(nodeIndex, 1);
            }
            UIWindow.document.removeChild(childNode);
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not an Instance of AbstractView!");
        }
    },
    getChildCount: function ()
    {
        return (this._children.length + this._uiChildren.length);
    },
    getChildren: function ()
    {
        var childrenArray = this._children.slice(); //using slice, it is returning the copy instead of original reference
        childrenArray = childrenArray.concat(this._uiChildren.slice());
        return childrenArray;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/View'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/View'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/View'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/View.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S, Harris K
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Node = require('NGCore/Client/GL2/Node').Node;
var Point = require('NGCore/Client/Core/Point').Point;
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var Image = require('NGGo1.3/GLUI/Image').Image;
////////////        UI Components       //////////////
var EditText = require('NGCore/Client/UI/EditText').EditText;
var EditTextArea = require('NGCore/Client/UI/EditTextArea').EditTextArea;
var WebView = require('NGCore/Client/UI/WebView').WebView;
var MapView = require('NGCore/Client/UI/MapView').MapView;
var UIWindow = require('NGCore/Client/UI/Window').Window;
exports.View = AbstractView.subclass( /** @lends GLUI.View.prototype */
{
    type: 'View',
    classname: 'View',
    /**  
     * @class The <code>View</code> class is a base class for derived classes that handle application views. Derived classes from <code>View</code> include:
     * <div class="ul">
     * <li>{@link GLUI.ScrollView}</li>
     * <li>{@link GLUI.Button}</li>
     * <li>{@link GLUI.CellView}</li>
     * </div>
     * @constructs The default constructor. 
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments GLUI.AbstractView
     */
    initialize: function ($super, properties)
    {
        $super();
        this._children = [];
        this._uiChildren = [];
        this._internalGLObject = new Node();
        this._sprite = null;
        this._imageURL = null;
        this._imageObject = null;
        this._isAddedToParent = false;
        this._hasUIChildren = false;
        if(properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    /**
     * Add a child node to this <code>View</code> at the specified index.
     * Index is treated as Depth (z-index) of the child too.
     * @example var mainView = new UI.View();
     * ...
     * var errorView = new UI.View();
     * ...
     * mainView.addChild(errorView);
     * @param {GLUI.AbstractView | UI.EditText | UI.EditTextArea | UI.MapView | UI.WebView } childNode The child which should be a derived class of GLUI.AbstractView | UI.EditText | UI.EditTextArea | UI.MapView | UI.WebView to add.
     * @param {Number} index The specified index.
     * @throws {"message:" + this.type + ".addChild: " + childNode + " is not a view!"} Specified child is not an instance of GLUI.AbstractView | UI.EditText | UI.EditTextArea | UI.MapView | UI.WebView.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.View#removeChild
     * @status Android, Test
     */
    addChild: function (childNode, index)
    {
        if(childNode instanceof AbstractView)
        {
            if(childNode._parent)
            {
                childNode.removeFromParent();
            }
            if(this._children)
            {
                if((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            // Must populate parent before setting visibility
            childNode._parent = this;
            childNode._setEnabled(this._enabled && this._parentEnabled, false);
            childNode._setVisible(this._visible && this._parentVisible, false);
            childNode._setTouchable(this._touchable && this._parentTouchable, false);
            this._internalGLObject.addChild(childNode.getGLObject());
            this._updateDepth();
            this._updateUIChildrenState(true, childNode);
            var Button = require('NGGo1.3/GLUI/Button').Button;
            var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
            if(this.getRoot() instanceof WindowLayer)
            {
                childNode._callAppearanceEvent(false);
            }
            if(childNode instanceof exports.View && !(childNode instanceof Button) && this._isAddedToParent)
            {
                childNode._addedToParent();
            }
        }
        else if((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            if(this._uiChildren.indexOf(childNode) === -1)
            {
                this._uiChildren.push(childNode); // maintaining array
                if(childNode._parent)
                {
                    childNode.removeFromParent();
                }
                this._updateUIChildrenState(true, childNode);
                if(this._isAddedToParent)
                {
                    UIWindow.document.addChild(childNode);
                }
                this._addSettersGettersForUIComponents(childNode);
            }
        }
        else
        {
            var errorMsg = [];
            errorMsg.push("message:");
            errorMsg.push(this.type);
            errorMsg.push(".addChild: ");
            errorMsg.push(childNode);
            errorMsg.push(" is not a view!");
            throw new Error(errorMsg.join());
        }
        return this;
    },
    /**
     * Remove a child from this <code>View</code>.
     * @example mainView.removeChild(errorView);
     * @param {GLUI.AbstractView | UI.EditText | UI.EditTextArea | UI.MapView | UI.WebView} childNode The child node to remove.
     * @throws {"message:" + this.type + ".addChild: " + childNode + " is not a view!"} Specified child is not an instance of GLUI.AbstractView | UI.EditText | UI.EditTextArea | UI.MapView | UI.WebView.
     * @returns The child node that was removed.
     * @see GLUI.View#addChild
     * @status Android, Test
     */
    removeChild: function (childNode)
    {
        var nodeIndex;
        if(childNode instanceof AbstractView)
        {
            nodeIndex = this._children.indexOf(childNode);
            if(nodeIndex !== -1)
            {
                this._updateUIChildrenState(false, childNode);
                this._children.splice(nodeIndex, 1);
            }
            var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
            if(this.getRoot() instanceof WindowLayer)
            {
                childNode._callAppearanceEvent(true);
            }
            this._internalGLObject.removeChild(childNode.getGLObject());
            childNode._parent = null;
            childNode._setEnabled(true, false);
            childNode._setVisible(true, false);
            childNode._setTouchable(true, false);
            this._updateDepth();
            var Button = require('NGGo1.3/GLUI/Button').Button;
            if(childNode instanceof exports.View && !(childNode instanceof Button) && this._isAddedToParent)
            {
                childNode._removedFromParent();
            }
        }
        else if((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            nodeIndex = this._uiChildren.indexOf(childNode);
            if(nodeIndex !== -1)
            {
                this._updateUIChildrenState(false, childNode);
                this._uiChildren.splice(nodeIndex, 1);
            }
            if(this._isAddedToParent)
            {
                UIWindow.document.removeChild(childNode);
            }
            this._removeSettersGettersForUIComponents(childNode);
            childNode._parent = null;
        }
        else
        {
            var errorMsg = [];
            errorMsg.push("message:");
            errorMsg.push(this.type);
            errorMsg.push(".addChild: ");
            errorMsg.push(childNode);
            errorMsg.push(" is not a view!");
            throw new Error(errorMsg.join());
        }
        return childNode;
    },
    /**
     * Retrieve a count of the child nodes attached to this <code>View</code>.
     * @return {Number} The current number of child nodes.
     * @status Android, Flash
     */
    getChildCount: function ()
    {
        var length = 0;
        if(this._children)
        {
            length = this._children.length;
        }
        if(this._uiChildren)
        {
            length = (length + this._uiChildren.length);
        }
        return length;
    },
    /**
     * @function
     * @return {Array} A copy of array containing children (sub-views) of a View.
     */
    getChildren: function ()
    {
        var childrenArray = [];
        if(this._children)
        {
            childrenArray = this._children.slice(); //using slice, it is returning the copy instead of original reference
        }
        if(this._uiChildren)
        {
            childrenArray = childrenArray.concat(this._uiChildren.slice());
        }
        return childrenArray;
    },
    /**
     * @name GLUI.View#setImage
     * @description Set an image URL for a view state. This property defines a remote image resource to use in arbitrary contexts.
     * <br /><b>Note: </b> Images must be in powers of two and/or mentioned under <code>"textures":</code> key in manifests.
     * <br />URL is also supported, and the image will be converted to power of two.
     * <br />Local image auto conversion will be supported later.
     * @example var someSprite = new GLUI.View();        
     * someSprite.setImage('./Content/mySprite.png', GLUI.State.Normal, [w, h]);
     * someSprite.setImage('http://www.example.com/somepicture80x92.png', GLUI.State.Normal, [200, 110]);
     * @see GLUI.View#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.State} [flags=GLUI.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {Array} imageSize an array for the size of image. [w, h]
     * @status iOS, Android, Test
     * @function 
     */
    setImage: function (imageURL, flags, imageSize)
    {
        if(!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject._setClickable(false);
        }
        this._adjustFrameForBgImage();
        this._imageObject.setImage(imageURL, flags, imageSize);
    },
    /**
     * @name GLUI.View#getImage
     * @description Retrieve the <code>image</code> URL for a view state.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @returns {String} The current image URL for the specified view state.
     * @see GLUI.View#setImage
     * @status Android, Flash, Test
     * @function
     */
    getImage: function (flags)
    {
        if(this._imageObject)
        {
            var val = this._imageObject.getImage(flags);
            return val;
        }
        else
        {
            return undefined;
        }
    },
    /**
     * @name GLUI.View#setImageFit
     * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
     * @example var someSprite = new GLUI.View();
     * ...
     * someSprite.setImageFit(GLUI.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.View#getImageFit
     * @function
     */
    setImageFit: function (fitMode)
    {
        if(this._imageObject)
        {
            this._imageObject.setImageFit(fitMode);
        }
    },
    /**
     * @name GLUI.View#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.View#setImageFit
     * @function
     * @status 
     */
    getImageFit: function ()
    {
        if(this._imageObject)
        {
            return this._imageObject.getImageFit();
        }
        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.View#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
     * @example var someSprite = new GLUI.View();
     * ...
     * someSprite.setImageGravity([0.5, 0.0]);
     * @param {Number} imageGravity The new value for <code>imageGravity</code> (expressed as two floats). Currently clipping is not supported for values greater than 1.0 or less than 0.0
     * @see GLUI.View#getImageGravity
     * @function
     * @status iOS, Android, Test
     */
    setImageGravity: function (imageGravity)
    {
        if(arguments)
        {
            if(arguments.length >= 2)
            {
                imageGravity = [arguments[0], arguments[1]];
            }
            this.__setImageGravity(imageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    /**
        @private
    */
    __setImageGravity: function (imageGravity)
    {
        imageGravity = (imageGravity && imageGravity.length === 2 && !isNaN(imageGravity[0]) && !isNaN(imageGravity[1])) ? [imageGravity[0], imageGravity[1]] : [0.5, 0.5];
        if(this._imageObject)
        {
            this._imageObject._imageGravity = imageGravity;
            this._imageObject._anchor = imageGravity;
            this._imageObject._adjustImageGravity();
            this._imageObject.setImageFit(this.getImageFit());
        }
    },
    /**
     * @name GLUI.View#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code> (expressed as two floats).
     * @see GLUI.View#setImageGravity
     * @function
     * @status Android, Flash, Test
     */
    getImageGravity: function ()
    {
        if(this._imageObject)
        {
            return this._imageObject.getImageGravity();
        }
        return undefined;
    },
    /*private methods*/
    _registerSetters: function ($super)
    {
        $super();
        Commands._registerSettersForImage(this);
    },
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForImage(this);
    },
    _updateDepth: function ()
    {
        var i;
        if(this._children)
        {
            for(i = 0; i < this._children.length; i++)
            {
                if(this._children[i])
                {
                    this._children[i].getGLObject().setDepth(i + 1);
                }
            }
        }
    },
    _updateView: function ($super)
    {
        $super();
        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if(this._imageObject)
        {
            this._imageObject.setState(this._state);
        }
    },
    /**
     * @private
     * */
    _addedToParent: function ()
    {
        this._showUIChildren();
        var Button = require('NGGo1.3/GLUI/Button').Button;
        var children = this._children;
        var i;
        if(children)
        {
            var length = children.length;
            for(i = 0; i < length; i++)
            {
                var child = children[i];
                if(child instanceof exports.View && !(child instanceof Button))
                {
                    child._addedToParent();
                }
            }
        }
        this._isAddedToParent = true;
    },
    /**
     * @private
     * */
    _removedFromParent: function ()
    {
        this._hideUIChildren();
        var Button = require('NGGo1.3/GLUI/Button').Button;
        var children = this._children;
        if(children)
        {
            var i = 0;
            var length = children.length;
            for(i = 0; i < length; i++)
            {
                var child = children[i];
                if(child instanceof exports.View && !(child instanceof Button))
                {
                    child._removedFromParent();
                }
            }
        }
        this._isAddedToParent = false;
    },
    /**
     * @private
     * */
    _showUIChildren: function ()
    {
        var i = 0;
        if(this._uiChildren)
        {
            var length = this._uiChildren.length;
            for(i = 0; i < length; i++)
            {
                var child = this._uiChildren[i];
                child._parent = null;
                UIWindow.document.addChild(child);
                child._parent = this;
                var frame = child.getFrame();
                if(frame)
                {
                    child.setFrame(frame);
                }
                child.setAlpha(child.getAlpha());
                child.setVisible(child.getVisible());
                child.setEnabled(child.getEnabled());
                child.setTouchable(child.getTouchable());
            }
        }
    },
    /**
     * @private
     * */
    _hideUIChildren: function ()
    {
        var i = 0;
        if(this._uiChildren)
        {
            var length = this._uiChildren.length;
            for(i = 0; i < length; i++)
            {
                var child = this._uiChildren[i];
                UIWindow.document.removeChild(child);
                child._parent = this;
            }
        }
    },
    /**
     * @private
     * */
    _setFrameForUIChildren: function (targetFrame)
    {
        if(targetFrame)
        {
            var frame;
            if(targetFrame instanceof Array)
            {
                frame = targetFrame.slice(); //frame is okay.
            }
            else if(targetFrame.array)
            {
                frame = targetFrame.array();
            }
            else if(arguments && arguments.length >= 4)
            {
                frame = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            else
            {
                throw new Error('Frame is not an array [x, y, w, h] in setFrame(frame) :: ' + this.classname);
            }
            this._gluiFrame = frame.slice();
            var point;
            var ScrollView = require('NGGo1.3/GLUI/ScrollView').ScrollView;
            if(this._parent instanceof ScrollView)
            {
                point = this._parent._content.localToScreen(new Point(frame[0], frame[1]));
            }
            else
            {
                point = this._parent.getGLObject().localToScreen(new Point(frame[0], frame[1]));
            }
            if(point)
            {
                this._setFrame([point.getX(), point.getY(), frame[2], frame[3]]);
            }
            else
            {
                this._setFrame(frame);
            }
        }
    },
    /**
     * @private
     * */
    _getFrameForUIChildren: function ()
    {
        return this._gluiFrame;
    },
    /**
     * @private
     * */
    _setAlphaForUIChildren: function (alpha)
    {
        if(alpha === undefined || alpha === null)
        {
            alpha = 1;
        }
        else if(isNaN(alpha))
        {
            throw new Error('Wrong arguments for \'alphaValue\' in setAlpha(alpha)');
        }
        var parent = this._parent;
        var targetAlpha = 1;
        var alp = 1;
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        while(parent && !(parent instanceof WindowLayer))
        {
            var __alpha = 1;
            if(!isNaN(parent.getAlpha()))
            {
                __alpha = parent.getAlpha();
                if(__alpha > 1)
                {
                    __alpha = 1;
                }
                if(__alpha < 0)
                {
                    __alpha = 0;
                }
            }
            targetAlpha *= __alpha;
            parent = parent._parent;
        }
        if(!isNaN(alpha))
        {
            alp = alpha;
            if(alp > 1)
            {
                alp = 1;
            }
            if(alp < 0)
            {
                alp = 0;
            }
        }
        targetAlpha *= alp;
        this._setAlpha(targetAlpha);
        this._gluiAlpha = alpha;
    },
    /**
     * @private
     * */
    _getAlphaForUIChildren: function ()
    {
        return this._gluiAlpha;
    },
    /**
     * @private
     * */
    _setVisibleForUIChildren: function (flag)
    {
        if(flag === undefined || flag === null)
        {
            flag = true;
        }
        else if((flag !== true) && (flag !== false))
        {
            throw new Error('Expecting boolean value but found ' + typeof (flag) + ' for setVisible(boolValue)');
        }
        var parent = this._parent;
        var targetFlag = true;
        var flg = true;
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        while(parent && !(parent instanceof WindowLayer))
        {
            var __flag = true;
            if(parent.getVisible() === false)
            {
                __flag = parent.getVisible();
            }
            targetFlag = targetFlag && __flag;
            parent = parent._parent;
        }
        if(flag === false)
        {
            flg = flag;
        }
        targetFlag = targetFlag && flg;
        this._gluiSetVisible(targetFlag);
        this._gluiIsVisible = flg;
    },
    /**
     * @private
     * */
    _getVisibleForUIChildren: function ()
    {
        return this._gluiIsVisible;
    },
    /**
     * @private
     * */
    _setEnabledForUIChildren: function (flag)
    {
        if(flag === undefined || flag === null)
        {
            flag = true;
        }
        else if((flag !== true) && (flag !== false))
        {
            throw new Error('Expecting boolean value but found ' + typeof (flag) + ' for setEnabled(boolValue)');
        }
        var parent = this._parent;
        var targetFlag = true;
        var flg = true;
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        while(parent && !(parent instanceof WindowLayer))
        {
            var __flag = true;
            if(parent.getEnabled() === false)
            {
                __flag = parent.getEnabled();
            }
            targetFlag = targetFlag && __flag;
            parent = parent._parent;
        }
        if(flag === false)
        {
            flg = flag;
        }
        targetFlag = targetFlag && flg;
        this._setEnabled(targetFlag);
        this._gluiIsEnable = flg;
    },
    /**
     * @private
     * */
    _getEnabledForUIChildren: function ()
    {
        return this._gluiIsEnable;
    },
    _setTouchableForUIChildren: function (flag)
    {
        if(flag === undefined || flag === null)
        {
            flag = true;
        }
        else if((flag !== true) && (flag !== false))
        {
            throw new Error('Expecting boolean value but found ' + typeof (flag) + ' for setTouchable(boolValue)');
        }
        var parent = this._parent;
        var targetFlag = true;
        var flg = true;
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        while(parent && !(parent instanceof WindowLayer))
        {
            var __flag = true;
            if(parent.getTouchable() === false)
            {
                __flag = parent.getTouchable();
            }
            targetFlag = targetFlag && __flag;
            parent = parent._parent;
        }
        if(flag === false)
        {
            flg = flag;
        }
        targetFlag = targetFlag && flg;
        this._setTouchable(targetFlag);
        this._gluiIsTouchable = flg;
    },
    _getTouchableForUIChildren: function ()
    {
        return this._gluiIsTouchable;
    },
    /**
     * @private
     * */
    _addSettersGettersForUIComponents: function (childNode)
    {
        var frame = childNode.getFrame();
        var alpha = childNode.getAlpha();
        var visibleFlag = childNode.getVisible();
        var enableFlag = childNode.getEnabled();
        var touchableFlag = childNode.getTouchable();
        childNode._parent = this;
        childNode._setFrame = childNode.setFrame;
        childNode.setFrame = this._setFrameForUIChildren;
        childNode._getFrame = childNode.getFrame;
        childNode.getFrame = this._getFrameForUIChildren;
        if(frame)
        {
            childNode.setFrame(frame);
        }
        childNode._setAlpha = childNode.setAlpha;
        childNode.setAlpha = this._setAlphaForUIChildren;
        childNode._getAlpha = childNode.getAlpha;
        childNode.getAlpha = this._getAlphaForUIChildren;
        childNode.setAlpha(alpha);
        childNode._gluiSetVisible = childNode.setVisible;
        childNode.setVisible = this._setVisibleForUIChildren;
        childNode._gluiGetVisible = childNode.getVisible;
        childNode.getVisible = this._getVisibleForUIChildren;
        childNode.setVisible(visibleFlag);
        childNode._setEnabled = childNode.setEnabled;
        childNode.setEnabled = this._setEnabledForUIChildren;
        childNode._getEnabled = childNode.getEnabled;
        childNode.getEnabled = this._getEnabledForUIChildren;
        childNode.setEnabled(enableFlag);
        //////////////////////  Touchable Code //////////////////////////////
        childNode._setTouchable = childNode.setTouchable;
        childNode.setTouchable = this._setTouchableForUIChildren;
        childNode._getTouchable = childNode.getTouchable;
        childNode.getTouchable = this._getTouchableForUIChildren;
        childNode.setTouchable(touchableFlag);
    },
    /**
     * @private
     * */
    _removeSettersGettersForUIComponents: function (childNode)
    {
        var frame = childNode.getFrame();
        var alpha = childNode.getAlpha();
        var visibleFlag = childNode.getVisible();
        var enableFlag = childNode.getEnabled();
        var touchableFlag = childNode.getTouchable();
        childNode.setFrame = childNode._setFrame;
        delete childNode._setFrame;
        childNode.setFrame(frame);
        childNode.getFrame = childNode._getFrame;
        delete childNode._getFrame;
        delete childNode._gluiFrame;
        childNode.setAlpha = childNode._setAlpha;
        delete childNode._setAlpha;
        childNode.setAlpha(alpha);
        childNode.getAlpha = childNode._getAlpha;
        delete childNode._getAlpha;
        delete childNode._gluiAlpha;
        childNode.setVisible = childNode._gluiSetVisible;
        delete childNode._gluiSetVisible;
        childNode.setVisible(visibleFlag);
        childNode.getVisible = childNode._gluiGetVisible;
        delete childNode._gluiGetVisible;
        delete childNode._gluiIsVisible;
        childNode.setEnabled = childNode._setEnabled;
        delete childNode._setEnabled;
        childNode.setEnabled(enableFlag);
        childNode.getEnabled = childNode._getEnabled;
        delete childNode._getEnabled;
        delete childNode._gluiIsEnable;
        ///////////////////////////Touchable Code ///////////////////////////////
        childNode.setTouchable = childNode._setTouchable;
        delete childNode._setTouchable;
        childNode.setTouchable(touchableFlag);
        childNode.getTouchable = childNode._getTouchable;
        delete childNode._getTouchable;
        delete childNode._gluiIsTouchable;
    },
    /**
     * @private
     * */
    setVisible: function ($super, flag)
    {
        $super(flag);
        this._setVisibleUI();
    },
    /**
     * @private
     * */
    setEnabled: function ($super, flag)
    {
        $super(flag);
        this._setEnabledUI();
    },
    /**
     * @private
     * */
    setAlpha: function ($super, flag)
    {
        $super(flag);
        this._setAlphaUI();
    },
    /**
     * @private
     * */
    setTouchable: function ($super, touchable)
    {
        $super(touchable);
        this._setTouchableUI();
    },
    /**
     * @private
     * */
    _setTouchableUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, y;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    this._uiChildren[x].setTouchable(this._uiChildren[x].getTouchable());
                }
            }
            if(this._children)
            {
                var Button = require('NGGo1.3/GLUI/Button').Button;
                var gluiChildrenLength = this._children.length;
                for(y = 0; y < gluiChildrenLength; y++)
                {
                    var childNode = this._children[y];
                    if(childNode instanceof exports.View && !(childNode instanceof Button))
                    {
                        childNode._setTouchableUI();
                    }
                }
            }
        }
    },
    /**
     * @private
     * */
    _setVisibleUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, y;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    this._uiChildren[x].setVisible(this._uiChildren[x].getVisible());
                }
            }
            if(this._children)
            {
                var Button = require('NGGo1.3/GLUI/Button').Button;
                var gluiChildrenLength = this._children.length;
                for(y = 0; y < gluiChildrenLength; y++)
                {
                    var childNode = this._children[y];
                    if(childNode instanceof exports.View && !(childNode instanceof Button))
                    {
                        childNode._setVisibleUI();
                    }
                }
            }
        }
    },
    /**
     * @private
     * */
    _setEnabledUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, y;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    this._uiChildren[x].setEnabled(this._uiChildren[x].getEnabled());
                }
            }
            if(this._children)
            {
                var Button = require('NGGo1.3/GLUI/Button').Button;
                var gluiChildrenLength = this._children.length;
                for(y = 0; y < gluiChildrenLength; y++)
                {
                    var childNode = this._children[y];
                    if(childNode instanceof exports.View && !(childNode instanceof Button))
                    {
                        childNode._setEnabledUI();
                    }
                }
            }
        }
    },
    /**
     * @private
     * */
    _setAlphaUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, y;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    this._uiChildren[x].setAlpha(this._uiChildren[x].getAlpha());
                }
            }
            if(this._children)
            {
                var Button = require('NGGo1.3/GLUI/Button').Button;
                var gluiChildrenLength = this._children.length;
                for(y = 0; y < gluiChildrenLength; y++)
                {
                    var childNode = this._children[y];
                    if(childNode instanceof exports.View && !(childNode instanceof Button))
                    {
                        childNode._setAlphaUI();
                    }
                }
            }
        }
    },
    /**
     * @private
     * */
    _setFrameUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, y;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    var childFrame = this._uiChildren[x].getFrame();
                    if(childFrame)
                    {
                        this._uiChildren[x].setFrame(childFrame);
                    }
                }
            }
            if(this._children)
            {
                var Button = require('NGGo1.3/GLUI/Button').Button;
                var gluiChildrenLength = this._children.length;
                for(y = 0; y < gluiChildrenLength; y++)
                {
                    var childNode = this._children[y];
                    if(childNode instanceof exports.View && !(childNode instanceof Button))
                    {
                        childNode._setFrameUI();
                    }
                }
            }
        }
    },
    /**
     * @private
     * */
    __setFrame: function ($super, frame)
    {
        $super(frame); //after this step, this._frame will have a valid frame - exception handling done with super. 
        this.getGLObject().setPosition(this._frame[0], this._frame[1]);
        this._adjustFrameForBgImage();
        this._setFrameUI();
    },
    /**
     * @private
     * */
    setAnchor: function (anchor)
    {
        this._anchor = anchor;
    },
    /**
     * @private
     * */
    _updateUIChildrenState: function (boolValue, childNode)
    {
        var parent = this;
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        if(boolValue === true && ((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView) || childNode._hasUIChildren === true))
        {
            while(parent && !(parent instanceof WindowLayer))
            {
                parent._hasUIChildren = true;
                parent = parent._parent;
            }
        }
        else if(boolValue === false)
        {
            var hasParentOtherUIChildren = false;
            var siblings = parent.getChildren();
            var sibLength = siblings.length;
            var i;
            for(i = 0; i < sibLength; i++)
            {
                if(childNode !== siblings[i])
                {
                    if((siblings[i] instanceof EditText) || (siblings[i] instanceof EditTextArea) || (siblings[i] instanceof WebView) || (siblings[i] instanceof MapView))
                    {
                        hasParentOtherUIChildren = true;
                    }
                    else
                    {
                        if(siblings[i]._hasUIChildren === true || siblings[i]._hasUIChildren === false)
                        {
                            hasParentOtherUIChildren = siblings[i]._hasUIChildren || hasParentOtherUIChildren;
                            if(hasParentOtherUIChildren === true)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            if(hasParentOtherUIChildren === false)
            {
                parent._hasUIChildren = false;
                if(parent._parent && parent._parent instanceof AbstractView && !(parent._parent instanceof WindowLayer))
                {
                    parent._parent._updateUIChildrenState(false, this);
                }
            }
        }
    },
    /**
     * @private
     * */
    _adjustFrameForBgImage: function ()
    {
        if(this._imageObject)
        {
            var frameForBgImage = [0, 0, this._frame[2], this._frame[3]]; //hence it is a child node of view, its position should be 0, 0 locally as this is a background.
            this._imageObject.setFrame(frameForBgImage);
        }
    },
    /**
     * @private
     * */
    _removeAllChildren: function ()
    {
        if(this._children && this.removeChild)
        {
            while(this._children.length)
            {
                this.removeChild(this._children[0]);
            }
        }
        if(this._uiChildren && this.removeChild)
        {
            while(this._uiChildren.length)
            {
                this.removeChild(this._uiChildren[0]);
            }
        }
    },
    destroy: function ($super)
    {
        this._removeAllChildren();
        if(this._sprite)
        {
            this._sprite.destroy();
            this._sprite = null;
        }
        if(this._children)
        {
            delete this._children;
            this._children = null;
        }
        if(this._uiChildren)
        {
            delete this._uiChildren;
            this._uiChildren = null;
        }
        if(this._imageObject)
        {
            this._imageObject.destroy();
            this._imageObject = null;
        }
        this._imageURL = null;
        $super();
    },
    ///////////// Empty Functions/////////////
    /**
     * @name GLUI.View#layoutSubviews
     * @description Override this for custom view subclass layout code.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @function
     * @status Android, Flash, Test
     */
    layoutSubviews: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: layoutSubviews() ' + this.classname);
    },
    /**
     * @name GLUI.View#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>
     * @see GLUI.View#setImageBorder
     * @function
     * @status Android, Flash, Test
     */
    getImageBorder: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder() ' + this.classname);
    },
    /**
     * @name GLUI.View#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder</code>.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @see GLUI.View#getImageBorder
     * @function
     * @status Android, Flash, Test
     */
    setImageBorder: function (imageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) ' + this.classname);
    },
    /**
     * @name GLUI.View#getStyle
     * @description Retrieve the style for this <code>View.</code>
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {GLUI.Style} The current <code>View</code> style.
     * @see GLUI.View#setStyle
     * @function
     * @status Android, Flash, Test
     */
    getStyle: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getStyle() ' + this.classname);
    },
    /**
     * @name GLUI.View#setStyle
     * @description Set the style for this <code>View.</code> This call allows custom view objects to process and update their styles more easily.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.Style} style The new  <code>View</code> style.
     * @see GLUI.View#getStyle
     * @function
     * @status Android, Flash, Test
     */
    setStyle: function (style)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setStyle(style) ' + this.classname);
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/ScrollView'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/ScrollView'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/ScrollView'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/ScrollView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Taha S, Jabbar M
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Size = require('NGCore/Client/Core/Size').Size;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Point = require('NGCore/Client/Core/Point').Point;
var OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Root = require('NGCore/Client/GL2/Root').Root;
var Node = require('NGCore/Client/GL2/Node').Node;
var Util = require('NGGo1.3/GLUI/Util').Util;
var View = require('NGGo1.3/GLUI/View').View;
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var Button = require('NGGo1.3/GLUI/Button').Button;
////////////////////////        UI Components       /////////////////////
var EditText = require('NGCore/Client/UI/EditText').EditText;
var EditTextArea = require('NGCore/Client/UI/EditTextArea').EditTextArea;
var WebView = require('NGCore/Client/UI/WebView').WebView;
var MapView = require('NGCore/Client/UI/MapView').MapView;
var UIWindow = require('NGCore/Client/UI/Window').Window;
/** @private
 *class not to be accessed from out side
 *
 */
var Scrollbar = Util.Rectangle.subclass( /** @lends Scrollbar.prototype */
{
    initialize: function ($super)
    {
        $super();
        this.setColor([0.5, 0.5, 0.5]);
        this.setAlpha(0);
        this.setDepth(65535);
    },
    updateSize: function (mode, frame, contentSize)
    {
        var r;
        var f_width = frame.getSize().getWidth();
        var f_height = frame.getSize().getHeight();
        var c_width = contentSize.getWidth();
        var c_height = contentSize.getHeight();
        if(mode === exports.ScrollView.ScrollDirection.Horizontal)
        {
            if(f_width < c_width)
            {
                r = c_width === 0 ? 1 : (f_width / c_width);
                this.setFrame([0, f_height - 5, f_width * r, 5]);
            }
            else
            {
                this.setFrame([0, f_height - 5, f_width, 5]);
            }
        }
        else
        {
            if(f_height < c_height)
            {
                r = c_height === 0 ? 1 : (f_height / c_height);
                this.setFrame([f_width - 5, 0, 5, f_height * r]);
            }
            else
            {
                this.setFrame([f_width - 5, 0, 5, f_height]);
            }
        }
        this.mode = mode;
        this.frameSize = new Size([f_width, f_height]);
        this.contentSize = new Size([c_width, c_height]);
    },
    updateAlpha: function (momentum)
    {
        if(momentum.x === 0 && momentum.y === 0)
        {
            var alpha = this.getAlpha();
            if(alpha === 0)
            {
                return;
            }
            else
            {
                alpha -= 0.03;
                if(alpha < 0.01)
                {
                    alpha = 0;
                }
                this.setAlpha(alpha);
            }
        }
    },
    updatePosition: function (new_x, new_y)
    {
        this.setAlpha(1);
        if(!this.mode)
        {
            return;
        }
        var f_width = this.frameSize.getWidth();
        var f_height = this.frameSize.getHeight();
        var c_width = this.contentSize.getWidth();
        var c_height = this.contentSize.getHeight();
        if(this.mode === exports.ScrollView.ScrollDirection.Horizontal)
        {
            this.setPosition(-f_width * (new_x / c_width), f_height - 5);
        }
        else
        {
            this.setPosition(f_width - 5, -f_height * (new_y / c_height));
        }
    }
});
/** @private
 *class not to be accessed from out side
 *
 */
var DragListener = MessageListener.subclass( /** @lends DragListener.prototype */
{
    classname: 'DragListener',
    DRAGTHRESHOLD: 15,
    initialize: function (listview)
    {
        this._touch = null;
        this.listview = listview;
        this._target = new TouchTarget();
        this._target.getTouchEmitter().addListener(this, this.onTouch);
        this._clickChild = null;
    },
    getTarget: function ()
    {
        return this._target;
    },
    onTouch: function (touch)
    {
        switch(touch.getAction())
        {
        case touch.Action.Start:
            if(this._touch || (this.listview._OS === "android" && touch.getId() !== 1) || !this.listview._enabled || !this.listview._visible || !this.listview._parentEnabled || !this.listview._touchable || !this.listview._parentTouchable || !this.listview._parentVisible || (this.listview.getState() & Commands.State.Disabled))
            {
                return false;
            }
            this._touch = {
                id: touch.getId(),
                sx: touch.getPosition().getX(),
                sy: touch.getPosition().getY(),
                x: touch.getPosition().getX(),
                y: touch.getPosition().getY(),
                lx: touch.getPosition().getX(),
                ly: touch.getPosition().getY(),
                dx: 0,
                dy: 0,
                hasMovedOutside: false,
                initialState: this.listview.getState()
            };
            this.listview.setState(Commands.State.Pressed);
            this._clickChild = this.listview._giveTouchesToChildren(touch, this.listview._visibleArray);
            if(!this._clickChild instanceof AbstractView)
            {
                this._clickChild = null;
            }
            return true;
        case touch.Action.End:
            if(!this._touch || this._touch.id !== touch.getId())
            {
                return false;
            }
            if(!this._touch.hasMovedOutside)
            {
                if(!(this._touch.initialState & Commands.State.Pressed))
                {
                    this.listview.clearState(Commands.State.Pressed);
                }
                if(this._clickChild)
                {
                    this._clickChild._touchReceivedCallBack(touch);
                    this._clickChild = null;
                }
                else
                {
                    this.listview._endTap();
                }
            }
            this._touch = null;
            break;
        case touch.Action.Move:
            if(!this._touch || this._touch.id !== touch.getId() || this.listview._scrollLock)
            {
                return false;
            }
            if(!this.listview._isTouchInFrame(touch) && !this._touch.hasMovedOutside)
            {
                this._touch.hasMovedOutside = true;
                if(!(this._touch.initialState & Commands.State.Pressed))
                {
                    this.listview.clearState(Commands.State.Pressed);
                }
                if(this._clickChild)
                {
                    this._clickChild._touchReceivedCallBack(touch, true);
                    this._clickChild = null;
                }
            }
            var pos = touch.getPosition();
            if(this._touch === null || pos === undefined)
            {
                break;
            }
            this._touch.x = pos.getX();
            this._touch.y = pos.getY();
            var moveDis = 0;
            if(this.listview)
            {
                if(this.listview.getScrollDirection() === this.listview.ScrollDirection.Horizontal)
                {
                    moveDis = Math.abs(this._touch.x - this._touch.lx);
                }
                else if(this.listview.getScrollDirection() === this.listview.ScrollDirection.Vertical)
                {
                    moveDis = Math.abs(this._touch.y - this._touch.ly);
                }
            }
            if(moveDis <= this.DRAGTHRESHOLD)
            {
                if(this._clickChild)
                {
                    this._clickChild._touchReceivedCallBack(touch);
                }
                break;
            }
            this._touch.dx += this._touch.x - this._touch.lx;
            this._touch.dy += this._touch.y - this._touch.ly;
            this._touch.lx = this._touch.x;
            this._touch.ly = this._touch.y;
            if(this._clickChild)
            {
                this._clickChild._touchReceivedCallBack(touch, true);
                this._clickChild = null;
            }
            if(this.listview._onScrollCallBack)
            {
                this.listview._onScrollCallBack();
            }
            break;
        default:
            break;
        }
        return false;
    },
    onUpdate: function ()
    {
        var count = 0;
        var delta = {
            x: 0,
            y: 0
        };
        if(this._touch)
        {
            delta.x += this._touch.dx;
            delta.y += this._touch.dy;
            this._touch.dx = this._touch.dy = 0;
            ++count;
        }
        if(count > 1)
        {
            delta.x /= count;
            delta.y /= count;
        }
        this.listview._onUpdate(delta);
    },
    hasTouch: function ()
    {
        return(this._touch !== null);
    },
    __addDragListenerToUpdateEmitter: function ()
    {
        UpdateEmitter.addListener(this, this.onUpdate);
    },
    destroy: function ($super)
    {
        if(this._target)
        {
            this._target.destroy();
            this._target = null;
        }
        this._touch = null;
        this.listview = null;
        this._clickChild = null;
        $super();
    }
});
exports.ScrollView = View.subclass( /** @lends GLUI.ScrollView.prototype */
{
    classname: 'ScrollView',
    /**
     * @class The <code>ScrollView</code> class constructs objects that handle views in a scrolling list (see <code>{@link GLUI.ListView}</code>). 
     * You can define these views as scrolling vertically or horizontially.<br><br>
     * <b>Note:</b> Android devices can only scroll in one direction at a time.
     * @name GLUI.ScrollView
     * @augments GLUI.View
     */
    ScrollDirection: {
        Horizontal: 1,
        Vertical: 2
    },
    /**
     * @constructs The default constructor.
     * @augments GLUI.View
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     */
    initialize: function ($super, properties)
    {
        $super();
        this._myFrame = new Rect();
        this._contentSize = new Size();
        this._userFrame = null;
        this._content = new Node();
        this._content.setTouchable(false);
        this._scrollPosition = [0, 0];
        this._internalGLObject.addChild(this._content);
        this._content.setDepth(1);
        this._feeling = {
            friction: 0.90,
            smoothingFactor: 0.5,
            stretchDecay: 0.65,
            rangeFactor: 0.5
        };
        this.setScrollDirection(this.ScrollDirection.Vertical);
        this._momentum = {
            x: 0,
            y: 0
        };
        this._visibleArray = [];
        this._buttons = [];
        this._scrollbar = new Scrollbar();
        this._needUpdateScrollView = false;
        this._needEvaluateMarginalLimits = false;
        this._internalGLObject.addChild(this._scrollbar);
        this._internalGLObject.setClipRectEnabled(true);
        this._target = 1;
        this._lastClipRectFrame = [0, 0, 0, 0];
        this.setAttributes(properties);
    },
    /**
     * Add a child node to this <code>ScrollView</code> at the specified index.
     * @example var scrollView = new GLUI.ScrollView();
     * ...
     * var childView = new UI.View();
     * ...
     * scrollView.addChild(childView);
     * @param {GL2.Node} childNode The child node to add.
     * @param {Number} index The specified index.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     * @throws {this.type + ".addChild: " + childNode + " is not a view!"} Specified node is not attached to a scrollView.
     * @see GLUI.ScrollView#removeChild
     * @status Android, Test
     * @private 
     */
    addChild: function (childNode, index)
    {
        if(childNode instanceof AbstractView)
        {
            if(childNode._parent)
            {
                childNode.removeFromParent();
            }
            if(this._children)
            {
                if((index === 0 || index > 0) && index < this._children.length)
                {
                    index = +index;
                    this._children.splice(index, 0, childNode);
                }
                else
                {
                    index = this._children.length;
                    this._children.push(childNode);
                }
            }
            // Must populate parent before setting visibility
            childNode._parent = this;
            childNode._setEnabled(this._enabled && this._parentEnabled, false);
            childNode._setVisible(this._visible && this._parentVisible, false);
            childNode._setTouchable(this._touchable && this._parentTouchable, false);
            this._updateUIChildrenState(true, childNode);
            this._content.addChild(childNode.getGLObject());
            this._needUpdateScrollView = true;
            this._updateDepth();
            var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
            if(this.getRoot() instanceof WindowLayer)
            {
                childNode._callAppearanceEvent(false);
            }
            if(childNode instanceof View && !(childNode instanceof Button) && this._isAddedToParent)
            {
                childNode._addedToParent();
            }
        }
        else if((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            if(this._uiChildren.indexOf(childNode) === -1)
            {
                this._uiChildren.push(childNode); // maintaining array
                if(childNode._parent)
                {
                    childNode.removeFromParent();
                }
                this._updateUIChildrenState(true, childNode);
                if(this._isAddedToParent) // if node is already pushed into stack so its UIchildren must become visible at time of addChild
                {
                    UIWindow.document.addChild(childNode);
                }
                // getting frame and alpha values of editText
                this._addSettersGettersForUIComponents(childNode);
            }
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not a view!");
        }
        return this;
    },
    /**
     * Remove a child node from this <code>scrollView</code>.
     * @example scrollView.removeChild(ChildView);
     * @param {GL2.Node} childNode The child node to remove.
     * @throws Any Exception occured with {Node.js} while removing a child node.
     * @see GLUI.ScrollView#addChild
     * @status Android, Test
     * @private 
     */
    removeChild: function (childNode)
    {
        var nodeIndex;
        if(childNode instanceof AbstractView)
        {
            try
            {
                nodeIndex = this._children.indexOf(childNode);
                if(nodeIndex !== -1)
                {
                    this._updateUIChildrenState(false, childNode);
                    this._children.splice(nodeIndex, 1);
                }
                var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
                if(this.getRoot() instanceof WindowLayer)
                {
                    childNode._callAppearanceEvent(true);
                }
                this._content.removeChild(childNode.getGLObject());
                childNode._parent = null;
                childNode._setEnabled(true, false);
                childNode._setVisible(true, false);
                childNode._setTouchable(true, false);
                this._needUpdateScrollView = true;
                this._updateDepth();
                if(childNode instanceof View && !(childNode instanceof Button) && this._isAddedToParent)
                {
                    childNode._removedFromParent();
                }
            }
            catch(ex)
            {
                throw new Error(ex);
            }
        }
        else if((childNode instanceof EditText) || (childNode instanceof EditTextArea) || (childNode instanceof WebView) || (childNode instanceof MapView))
        {
            nodeIndex = this._uiChildren.indexOf(childNode);
            if(nodeIndex !== -1)
            {
                this._updateUIChildrenState(false, childNode);
                this._uiChildren.splice(nodeIndex, 1);
            }
            if(this._isAddedToParent)
            {
                UIWindow.document.removeChild(childNode);
            }
            this._removeSettersGettersForUIComponents(childNode);
            childNode._parent = null;
        }
        else
        {
            throw new Error("message:" + this.type + ".addChild: " + childNode + " is not a view!");
        }
    },
    /**
     * @name GLUI.ScrollView#setFrame
     * @function 
     * @description Set the value of the <code>frame</code> property. This property defines the size of ViewAble area of the ScrollView.
     * @example var scrollView = new GLUI.ScrollView();
     * ...
     * scrollView.setFrame([10, 10, 64, 64]);
     * @param {Number, Array (Number), Object} arg0 This parameter will pass in values in one of three ways:
     * <div class="ul">
     * <li>Four float values (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>).</li>
     * <li>Single array containing the above four values.</li>
     * <li>A rect specifying the frame (see <code>{@link UI.ViewGeometry.Rect}</code>).</li>
     * </div>
     * <b>Note:</b>  Clipping is not supported on Flash.
     * @see GLUI.ScrollVIew#getFrame
     * @private
     */
    __setFrame: function ($super, frame)
    {
        $super(frame);
        this._userFrame = this._frame;
        this._evaluateScrollDirection();
        if(this._scroll === this.ScrollDirection.Horizontal)
        {
            if(frame[0] > 0)
            {
                console.log("Clipping is not supported for GLUI.ScrollView on FLASH, Horizontal recommended frame is: [0,y,w,h] provided frame: " + JSON.stringify(frame));
            }
            this._frame = [this._frame[0], this._frame[1], /*Util.getOrientationSreenWidth()*/ this._frame[2], this._frame[3]];
        }
        else
        {
            if(frame[1] > 0)
            {
                console.log("Clipping is not supported for GLUI.ScrollView on FLASH, Vertical recommended frame is: [x,0,w,h] provided frame: " + JSON.stringify(frame));
            }
            this._frame = [this._frame[0], this._frame[1], this._frame[2], this._frame[3] /*, Util.getOrientationSreenHeight()*/ ];
        }
        this._myFrame = new Rect(this._frame);
        var origin = this._myFrame.getOrigin();
        var size = this._myFrame.getSize();
        this.getGLObject().setPosition(origin.getX(), origin.getY());
        if(this._touchTarget)
        {
            this._internalGLObject.removeChild(this._touchTarget);
            this._touchTarget = null;
        }
        if(this._dragger)
        {
            this._dragger.destroy();
            this._dragger = null;
        }
        this._dragger = new DragListener(this);
        this._dragger.__addDragListenerToUpdateEmitter();
        this._touchTarget = this._dragger.getTarget();
        this._touchTarget.setSize(size);
        this._touchTarget.setPosition(0, 0);
        this._touchTarget.setDepth(2);
        this._internalGLObject.addChild(this._touchTarget);
        this._updateScrollBar();
        this._needUpdateScrollView = true;
        this._needEvaluateMarginalLimits = true;
    },
    _setFrameUI: function ()
    {
        if(this._hasUIChildren === true)
        {
            var x, j;
            if(this._uiChildren)
            {
                var uiChildrenLength = this._uiChildren.length;
                for(x = 0; x < uiChildrenLength; x++)
                {
                    var childFrame = this._uiChildren[x].getFrame();
                    if(childFrame)
                    {
                        this._uiChildren[x].setFrame(childFrame);
                    }
                }
            }
            if(this._visibleArray)
            {
                var gluiChildrenLength = this._visibleArray.length;
                for(j = 0; j < gluiChildrenLength; j++)
                {
                    if(this._visibleArray[j] instanceof View && !(this._visibleArray[j] instanceof Button))
                    {
                        this._visibleArray[j]._setFrameUI();
                    }
                }
            }
        }
    },
    /**
     * @name GLUI.ScrollView#getFrame
     * @description Retrieve the value of the <code>frame</code> property set by user.
     * @param {Number, Array (Number)} frame Individual components or a component array (<i>x</i>,<i>y</i>,<i>w</i>,<i>h</i>).
     * @see GLUI.ScrollView#setFrame
     * @private
     */
    getFrame: function ()
    {
        return this._userFrame;
    },
    /**
     * @name GLUI.ScrollView#setContentSize
     * @description Set the value for the <code>contentSize</code> property. This property defines the size of a scroll area.
     * @example var dialog = {
     *  width: screen.width * sizeRate.width / 100,
     *  height: screen.height * sizeRate.height / 100
     * };
     * ...
     * this.scrollView.setContentSize([dialog.width, 600]);
     * @params {Number, Array (Number, String)} Individual components or a component array.
     * @see GLUI.ScrollView#getContentSize
     * @function
     * @status Android, Test
     */
    setContentSize: function (contentSize)
    {
        if(contentSize instanceof Size)
        {
            contentSize = [contentSize.getWidth(), contentSize.getHeight()];
        }
        if(contentSize.length === 2)
        {
            if(isNaN(contentSize[0]) || isNaN(contentSize[1]))
            {
                throw new Error(this.classname + 'contentSize() expects numeric Array. getting [' + typeof (contentSize[0]) + ',' + typeof (contentSize[1]) + ']');
            }
            else
            {
                this._contentSizeArray = contentSize;
                this._setContentSize();
                this._evaluateScrollDirection();
            }
        }
        else
        {
            throw new Error(this.classname + 'contentSize() expects Array(2) or Core.Size(). eg [1200,300] or new Core.Size(200,1000)');
        }
    },
    /**
     * @name GLUI.ScrollView#getContentSize
     * @description Retrieve the value of the <code>contentSize</code> property.
     * @returns {Number, Array (Number, String)} The current value of <code>contentSize</code>.
     * @see GLUI.ScrollView#setContentSize
     * @function
     * @status Android, Test
     */
    getContentSize: function ()
    {
        return this._contentSizeArray;
    },
    /**
     * @name GLUI.ScrollView#setOnScroll
     * @description Set a function to call when the <code>scroll</code> event occurs.
     * @param {Function} scrollCallback The new callback function.<br><br>
     * <b>Note:</b> The <code>pageevent</code> event is disabled if the value of this parameter is not a function.
     * @see GLUI.ScrollView#event:getOnScroll
     * @event
     * @status Android, Test
     */
    /**
     * @name GLUI.ScrollView#getOnScroll
     * @description Retrieve the function to call when the <code>scroll</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.ScrollView#event:setOnScroll
     * @event
     * @status Android, Test
     */
    setOnScroll: function (onScrollCallBack)
    {
        if(typeof (onScrollCallBack) === "function")
        {
            this._onScrollCallBack = onScrollCallBack;
        }
    },
    getOnScroll: function ()
    {
        return this._onScrollCallBack;
    },
    /**
     * @name GLUI.ScrollView#setScrollPosition
     * @description Set the value for the <code>scrollPosition</code> property.
     * @example var hscroller = new GLUI.ScrollView();
     * ...
     * hscroller.setScrollPosition([0.5,0]);
     * @param {Number, Array (Number)} Individual components or a component array.
     * @see GLUI.ScrollView#getScrollPosition
     * @function
     * @status Android, Test
     */
    setScrollPosition: function (vector)
    {
        if(arguments && arguments.length === 1)
        {
            vector = new Vector(vector);
        }
        else if(arguments.length === 2)
        {
            vector = new Vector(arguments[0], arguments[1]);
        }
        else
        {
            throw new Error("Too many or too few arguments for setScrollPosition | " + typeof (vector) + this.classname);
        }
        if(vector.getX() === undefined || vector.getX() === null || vector.getY() === undefined || vector.getY() === null)
        {
            return;
        }
        //var h_upper = 0;
        var h_lower = this._myFrame.getSize().getWidth() - this._contentSize.getWidth();
        if(h_lower > -1)
        {
            h_lower = -1;
        }
        //var v_upper = 0;
        var v_lower = this._myFrame.getSize().getHeight() - this._contentSize.getHeight();
        if(v_lower > -1)
        {
            v_lower = -1;
        }
        this._content.setPosition(-vector.getX(), -vector.getY());
        this._scrollPosition = [vector.getX(), vector.getY()];
        this._needUpdateScrollView = true;
    },
    /**
     * @name GLUI.ScrollView#getScrollPosition
     * @description Retrieve the value of the <code>scrollPosition</code> property.
     * @returns {Number, Array (Number)} The current value of <code>scrollPosition</code>.
     * @see GLUI.ScrollView#setScrollPosition
     * @function
     * @status Android, Test
     */
    getScrollPosition: function ()
    {
        return this._scrollPosition;
    },
    destroy: function ($super)
    {
        this._removeAllChildren();
        this._userFrame = null;
        this._myFrame = null;
        this._contentSize = null;
        if(this._visibleArray !== null)
        {
            this._visibleArray.length = 0;
            this._visibleArray = null;
        }
        if(this._buttons !== null)
        {
            this._buttons.length = 0;
            this._buttons = null;
        }
        if(this._feeling !== null)
        {
            this._feeling.length = 0;
            this._feeling = null;
        }
        this._scrollbar.destroy();
        this._scrollbar = null;
        this._content.destroy();
        this._content = null;
        if(this._touchTarget)
        {
            this._internalGLObject.removeChild(this._touchTarget);
            this._touchTarget = null;
        }
        if(this._dragger)
        {
            this._dragger.destroy();
            this._dragger = null;
        }
        this._needUpdateScrollView = null;
        this._needEvaluateMarginalLimits = null;
        this._scrollPosition = null;
        this._momentum = null;
        this._lastClipRectFrame.length = 0;
        this._lastClipRectFrame = null;
        $super();
    },
    /** @private */
    setBackgroundColor: function ($super, color)
    {
        var isParentNode = this._parentNode;
        $super(color);
        if(!isParentNode)
        {
            this._internalGLObject.setClipRectEnabled(false);
            this._parentNode.setClipRectEnabled(true);
            this._parentNode.setClipRect(this._lastClipRectFrame);
        }
        return this;
    },
    /** @private */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.contentSize = this.setContentSize.bind(this);
        this._setters.scroll = this.setOnScroll.bind(this);
        this._setters.scrollPosition = this.setScrollPosition.bind(this);
    },
    _registerGetters: function ($super)
    {
        $super();
        this._getters.contentSize = this.getContentSize.bind(this);
        this._getters.scroll = this.getOnScroll.bind(this);
        this._getters.scrollPosition = this.getScrollPosition.bind(this);
    },
    _updateScrollingView: function ()
    {
        var i;
        if(this._children)
        {
            var length = this._children.length;
            for(i = 0; i < length; i++)
            {
                var listItem = this._children[i];
                var itemIndex = this._visibleArray.indexOf(listItem);
                if(this._isInsideScreen(listItem))
                {
                    if(itemIndex === -1)
                    {
                        this._visibleArray.push(listItem);
                    }
                }
                else
                {
                    if(itemIndex !== -1)
                    {
                        this._visibleArray.splice(itemIndex, 1);
                    }
                }
            }
        }
    },
    _isInsideScreen: function (listItem)
    {
        var screenSize = this._getScreenSize();
        var screenWidth = screenSize[0];
        var screenHeight = screenSize[1];
        var frame = listItem.getFrame();
        var x = listItem.getGLObject().getPosition().getX();
        var y = listItem.getGLObject().getPosition().getY();
        var itemWidth = frame[2];
        var itemHeight = frame[3];
        var convertedPos = this._content.localToScreen(new Point(x, y));
        if(convertedPos === null || convertedPos === undefined)
        {
            return undefined;
        }
        if(this._scroll === this.ScrollDirection.Horizontal)
        {
            if((convertedPos.getX() >= 0 && convertedPos.getX() <= screenWidth) || (convertedPos.getX() < 0 && convertedPos.getX() + itemWidth > 0))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            if((convertedPos.getY() >= 0 && convertedPos.getY() <= screenHeight) || (convertedPos.getY() < 0 && convertedPos.getY() + itemHeight > 0))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    },
    setScrollFeeling: function (feeling)
    {
        var key;
        for(key in this._feeling)
        {
            if(this._feeling.hasOwnProperty(key))
            {
                this._feeling[key] = feeling[key] || this._feeling[key];
            }
        }
    },
    setScrollDirection: function (dir)
    {
        switch(dir)
        {
        case this.ScrollDirection.Horizontal:
            this._scroll = dir;
            if(this._scrollPosition[1] > 0)
            {
                this._content.setPosition(this._scrollPosition[0], this._scrollPosition[1]);
            }
            break;
        case this.ScrollDirection.Vertical:
            this._scroll = dir;
            this._content.setPosition(this._scrollPosition[0], this._scrollPosition[1]);
            break;
        default:
            break;
        }
    },
    getScrollDirection: function ()
    {
        return this._scroll;
    },
    setScrollLock: function (lock)
    {
        this._scrollLock = lock;
    },
    getScrollLock: function ()
    {
        return this._scrollLock;
    },
    _setContentSize: function ()
    {
        if(this._contentSizeArray)
        {
            this._contentSize.setWidth(this._contentSizeArray[0]);
            this._contentSize.setHeight(this._contentSizeArray[1]);
        }
        else
        {
            this._contentSize.setHeight(0);
            this._contentSize.setWidth(0);
        }
        this._updateScrollBar();
    },
    _evaluateScrollDirection: function ()
    {
        if(!this._userFrame || !this._contentSizeArray)
        {
            return;
        }
        var w = this._userFrame[2] ? this._userFrame[2] : 1;
        var h = this._userFrame[3] ? this._userFrame[3] : 1;
        if((this._contentSizeArray[0] / w) > (this._contentSizeArray[1] / h))
        {
            this.setScrollDirection(this.ScrollDirection.Horizontal);
        }
        else
        {
            this.setScrollDirection(this.ScrollDirection.Vertical);
        }
        this._updateScrollBar();
    },
    _updateScrollBar: function ()
    {
        this._scrollbar.updateSize(this._scroll, this._myFrame, this._contentSize);
    },
    _endTap: function ()
    {
        if(this._clickCallBack)
        {
            this._clickCallBack();
        }
    },
    _applyRange: function (position, delta, lower, upper)
    {
        if(delta === 0)
        {
            return position;
        }
        if(delta > 0)
        {
            if(position < lower)
            {
                position += delta * this._feeling.rangeFactor;
                if(position >= lower)
                {
                    delta = (position - lower) / this._feeling.rangeFactor;
                    position = lower;
                }
                else
                {
                    return position;
                }
            }
            //If we're inside our bounds, apply the delta
            if(position < upper)
            {
                //if the delta will place us out of range, apply it and save the remainder.
                if(position + delta > upper)
                {
                    delta -= (upper - position);
                    position = upper;
                    delta *= this._feeling.rangeFactor;
                }
            }
            //We're out of range, so only apply by range factor.
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        //Handle negative delta; same thing, just bounds reversed.
        else if(delta < 0)
        {
            if(position > upper)
            {
                position += delta * this._feeling.rangeFactor;
                if(position <= upper)
                {
                    delta = (position - upper) / this._feeling.rangeFactor;
                    position = upper;
                }
                else
                {
                    return position;
                }
            }
            if(position > lower)
            {
                if(position + delta < lower)
                {
                    delta -= (lower - position);
                    position = lower;
                    delta *= this._feeling.rangeFactor;
                }
            }
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        return position + delta;
    },
    _getGLRoot: function ()
    {
        var child = this.getGLObject(),
            parent = null;
        while(child.getParent)
        {
            parent = child.getParent();
            if(parent)
            {
                child = parent;
            }
            else
            {
                break;
            }
        }
        return parent;
    },
    _onUpdate: function (delta)
    {
        var theRoot = null;
        var theGLRoot = null;
        if(this._needUpdateScrollView)
        {
            theRoot = this.getRoot();
            theGLRoot = this._getGLRoot();
        }
        if((theRoot && theRoot.type === "document") || (theGLRoot && theGLRoot === Root))
        {
            this._updateScrollingView();
            this._needUpdateScrollView = false;
        }
        this._clipRect();
        //addcontentsize check
        var sf = this._feeling.smoothingFactor;
        var hasTouch = this._dragger.hasTouch();
        //Our ranges are negative because we push the origin up/left from the start position.
        var h_upper = 0;
        var h_lower = this._myFrame.getSize().getWidth() - this._contentSize.getWidth();
        if(h_lower > -1)
        {
            h_lower = -1;
        }
        var v_upper = 0;
        var v_lower = this._myFrame.getSize().getHeight() - this._contentSize.getHeight();
        if(v_lower > -1)
        {
            v_lower = -1;
        }
        var new_x = this._content.getPosition().getX();
        var new_y = this._content.getPosition().getY();
        //if we're in bounds and we have no movement, don't bother updating
        if(delta.x === 0 && delta.y === 0)
        {
            if(this._momentum.x === 0 && this._momentum.y === 0)
            {
                if(hasTouch || ((new_x >= h_lower) && (new_x <= h_upper) && (new_y >= v_lower) && (new_y <= h_upper)))
                {
                    this._scrollbar.updatePosition(this._scrollPosition);
                    this._scrollbar.updateAlpha(this._momentum);
                    return;
                }
            }
        }
        //If we have touches accumulate momentum
        if(hasTouch)
        {
            //Use exponential smoothing to approximate the current momentum
            this._momentum.x = sf * delta.x + (1 - sf) * this._momentum.x;
            this._momentum.y = sf * delta.y + (1 - sf) * this._momentum.y;
        }
        //Otherwise, consume the momentum.
        else
        {
            if(this.getOnScroll())
            {
                this._onScrollCallBack();
            }
            delta.x += this._momentum.x;
            delta.y += this._momentum.y;
            //Apply friction, stop if we're below a small threshold.
            this._momentum.x *= this._feeling.friction;
            this._momentum.y *= this._feeling.friction;
            if(this._momentum.x < 1 && this._momentum.x > -1)
            {
                this._momentum.x = 0;
            }
            if(this._momentum.y < 1 && this._momentum.y > -1)
            {
                this._momentum.y = 0;
            }
        }
        //Handle any deltas
        if(this._scroll === this.ScrollDirection.Horizontal)
        {
            new_x = this._applyRange(new_x, delta.x, h_lower, h_upper);
        }
        else
        {
            new_y = this._applyRange(new_y, delta.y, v_lower, v_upper);
        }
        //Without touches to anchor us, we should slide back into range.
        if(!hasTouch)
        {
            if(new_x < h_lower)
            {
                new_x = h_lower - (h_lower - new_x) * this._feeling.stretchDecay;
                if(h_lower - new_x < 1)
                {
                    new_x = h_lower;
                }
            }
            else if(new_x > h_upper)
            {
                new_x = h_upper + (new_x - h_upper) * this._feeling.stretchDecay;
                if(new_x - h_upper < 1)
                {
                    new_x = h_upper;
                }
            }
            if(new_y < v_lower)
            {
                new_y = v_lower - (v_lower - new_y) * this._feeling.stretchDecay;
                if(v_lower - new_y < 1)
                {
                    new_y = v_lower;
                }
            }
            else if(new_y > h_upper)
            {
                new_y = v_upper + (new_y - v_upper) * this._feeling.stretchDecay;
                if(new_y - v_upper < 1)
                {
                    new_y = v_upper;
                }
            }
        }
        this._content.setPosition(new_x, new_y);
        this._setFrameUI();
        this._myCurrPos = this._content.getPosition();
        this._scrollPosition = [Math.floor(-new_x), Math.floor(-new_y)];
        this._scrollbar.updatePosition(new_x, new_y);
        this._updateScrollingView();
    },
    /**
     * @private
     */
    _getScreenSize: function ()
    {
        switch(OrientationEmitter.getInterfaceOrientation())
        {
        case OrientationEmitter.Orientation.LandscapeLeft:
        case OrientationEmitter.Orientation.LandscapeRight:
            return [Capabilities.getScreenHeight(), Capabilities.getScreenWidth()];
        default:
            return [Capabilities.getScreenWidth(), Capabilities.getScreenHeight()];
        }
    },
    _clipRect: function ()
    {
        var glNode = this.getGLObject();
        var pos = glNode.localToScreen(new Vector(0, 0));
        var size = new Vector(this._frame[2], this._frame[3]);
        var adjustedSize = glNode.localToScreen(size);
        if(pos && adjustedSize)
        {
            var x = pos.getX();
            var y = pos.getY();
            var w = (adjustedSize.getX() - x);
            var h = (adjustedSize.getY() - y);
            if(x === this._lastClipRectFrame[0] && y === this._lastClipRectFrame[1] && w === this._lastClipRectFrame[2] && h === this._lastClipRectFrame[3])
            {
                return;
            }
            this._lastClipRectFrame = [x, y, w, h];
            glNode.setClipRect(this._lastClipRectFrame);
        }
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/AbstractView'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/AbstractView'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/AbstractView'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/AbstractView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Gohar A, Taha S, Harris K
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
//Only Elemenet require_ should be here, rest should be within their respective methods, this will decrease the global overhead of the application.
var Color = require('NGCore/Client/Core/Color').Color;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var Point = require('NGCore/Client/Core/Point').Point;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var Node = require('NGCore/Client/GL2/Node').Node;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var Element = require('NGGo1.3/GLUI/Element').Element;
var Rect = require('NGGo1.3/GLUI/ViewGeometry').Rect;
var UIRect = require('NGCore/Client/UI/ViewGeometry').Rect;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var Util = require('NGGo1.3/GLUI/Util').Util;
exports.AbstractView = Element.subclass( /** @lends GLUI.AbstractView.prototype */
{
    classname: 'AbstractView',
    /**
     * @class The <code>AbstractView</code> class is a base class for derived classes that handle and manage GLUI views.<br><br>
     * <b>Caution!:</b> This base class is not exported in the GLUI module. Do not access it or subclass it at runtime.
     * Derived classes from <code>AbstractView</code> include:
     * <div class="ul">
     * <li>{@link GLUI.Button}</li>
     * <li>{@link GLUI.CellView}</li>
     * <li>{@link GLUI.CheckBox}</li>
     * <li>{@link GLUI.Image}</li>
     * <li>{@link GLUI.Label}</li>
     * <li>{@link GLUI.View}</li>
     * </div>
     * @constructs The default constructor.
     * @augments GLUI.Element
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     */
    initialize: function ($super)
    {
        $super();
        this._frame = [0, 0, 0, 0];
        this._target = null;
        this._anchor = null;
        this._fitMode = null;
        this._messageListener = null;
        this._isHandlingTouch = false;
        this._clickCallBack = null;
        this._longPressCallBack = null;
        this._longPressCBTimeoutID = null;
        this._isLongPressCalled = null;
        this._isOnSwipeCalled = null;
        this._initialTouchPosition = null;
        this._swipeCallback = null;
        this._state = Commands.State.Normal;
        this._images = [];
        this._parent = null;
        this._position = null;
        this._alpha = 1.0;
        this.__bgAlpha = 1.0;
        this.__internalAlpha = 1.0;
        this.__ARGB = [];
        this._backgroundColor = null;
        this._parentNode = null;
        this._bgPrimitive = null;
        this._enabled = true;
        this._visible = true;
        this._parentEnabled = true;
        this._parentVisible = true;
        this._isPressed = false;
        this._clickable = true;
        this._OS = Capabilities.getPlatformOS().toLowerCase();
        this._hasMovedOutside = false;
        this._bgColorAlreadySet = false;
        this._gradient = [];
        this._recogDistanceForSwipe = this._getRecogDistance();
        this._recogTimeForLongPress = 1000; // in milli seconds
        this._touchable = true;
        this._parentTouchable = true;
        this._appearCallback = null;
        this._disappearCallback = null;
        this._isLastTimeAppearCalled = null;
    },
    _getRecogDistance: function ()
    {
        var recogDistanceForSwipe = Capabilities.getScreenWidth() * 0.05;
        return recogDistanceForSwipe;
    },
    /**
     * @name GLUI.AbstractView#setAlpha
     * @function
     * @description Set the value of the <code>alpha</code> property. This property defines the level of alpha composting for a specified object when rendered.
     * @example this._node.setAlpha(1);
     * @param {Number} decimal Alpha value ranging between <code>(0.0-1.0)</code>.
     * @see GLUI.AbstractView#getAlpha
     * @type Float
     * @status Flash, Android
     */
    setAlpha: function (alphaValue)
    {
        if(isNaN(alphaValue))
        {
            throw new Error('Wrong arguments for \'alphaValue\' in setAlpha(alphaValue)');
        }
        this._alpha = alphaValue;
        this._updateAlpha();
        return this;
    },
    /**
     * @name GLUI.AbstractView#getAlpha
     * @function
     * @description Retrieve the value of the <code>alpha</code> property.
     * @returns {Number} Alpha value ranging between </code>(0.0-1.0)</code>.
     * @see GLUI.AbstractView#setAlpha
     * @type Float
     * @status Flash, Android
     */
    getAlpha: function ()
    {
        return this._alpha;
    },
    /**
     * @name GLUI.AbstractView#setFrame
     * @function
     * @description Set the value of the <code>frame</code> property. This property defines the size of <code>frame</code> objects.
     * @example var back = new GLUI.Button();
     * ...
     * back.setFrame([10, 10, 64, 64]);
     * @param {Array (Number), Rect} frame This parameter will pass in values in one of two ways:
     * <div class="ul">
     * <li>Single array containing the above four values.</li>
     * <li>A rect specifying the frame (see <code>{@link GLUI.ViewGeometry.Rect}</code>).</li>
     * </div>
     * @see UI.AbstractView#getFrame
     * @function
     */
    setFrame: function (frame)
    {
        if(frame instanceof Array)
        {
            frame = frame.slice(); //frame is okay.
        }
        else if(frame instanceof Rect || frame instanceof UIRect)
        {
            frame = frame.array();
        }
        else if(arguments && arguments.length >= 4)
        {
            frame = [arguments[0], arguments[1], arguments[2], arguments[3]];
        }
        else
        {
            throw new Error('Frame is not an array [x, y, w, h] in setFrame(frame) :: ' + this.classname);
        }
        if(frame.length < 4 || isNaN(frame[0]) || isNaN(frame[1]) || isNaN(frame[2]) || isNaN(frame[3]))
        {
            throw new Error('Length of frame is less than 4. Expected [x, y, w, h]  in setFrame(frame) in AbstractView.js');
        }
        this.__setFrame(frame);
    },
    /**
     * @private
     */
    __setFrame: function (frame)
    {
        //__setFrame method now implements the FRAME, and $super hierarchy should be followed upto AbstractView.
        //setFrame only splits the supplied arguments.
        this._frame = frame;
        this._position = [frame[0], frame[1]];
        this.getGLObject().setPosition(this._frame[0], this._frame[1]);
        if(this._backgroundColor)
        {
            this.__fillBackgroundColor();
        }
        if(this._target && this._target !== 1)
        {
            this.__setTouchableArea();
        }
    },
    /**
     * @name GLUI.AbstractView#getFrame
     * @description Retrieve the value of the <code>frame</code> property.
     * @returns {Array} An array of [x, y, w, h] for the frame of the object.
     * @see GLUI.AbstractView#setFrame
     * @function
     */
    getFrame: function ()
    {
        if(this._frame === null || this._frame === undefined)
        {
            return undefined;
        }
        else
        {
            return [this._frame[0], this._frame[1], this._frame[2], this._frame[3]];
        }
    },
    /**
     * @name GLUI.AbstractView#setOnClick
     * @description Set a function to call when the <code>click</code> event occurs. Do not use object.onClick = function() as that will not set up touch target for GLUI object.
     * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The <code>click</code> callback is set to empty if the value of this parameter is not a function.
     * @example button.setOnClick(function() { console.log(this.classname + "is clicked");});
     * @see GLUI.AbstractView#event:getOnClick
     * @event
     */
    setOnClick: function (clickCallback)
    {
        if(typeof (clickCallback) !== "function")
        {
            if(clickCallback === "undefined" || clickCallback === null)
            {
                clickCallback = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnClick expects (), (null), (function) but received " + clickCallback.type);
            }
        }
        this._clickCallBack = clickCallback;
        if(this._frame && !this._target)
        {
            this._setUpTouchTarget();
        }
    },
    /**
     * @name GLUI.AbstractView#getOnClick
     * @description Retrieve a function to call when the <code>click</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnClick
     * @event
     */
    getOnClick: function ()
    {
        return this._clickCallBack;
    },
    /**
     * Set view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    setState: function (flags)
    {
        this._state = flags;
        this._updateView();
    },
    /**
     * Get view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    getState: function ()
    {
        return this._state;
    },
    /**
     * Add a new view state.
     * @function
     * @example this.addState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags View state flags supported by the new view state.
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#clearState
     */
    addState: function (flags)
    {
        this.setState(this._state | flags);
    },
    /**
     * Clear the view state and set view state flags to the default value.
     * @function
     * @example this.clearState(GLUI.Commands.State.Disabled);
     * @param {GLUI.State} flags
     * @see GLUI.AbstractView#getState,
     * @see GLUI.AbstractView#setState,
     * @see GLUI.AbstractView#addState
     */
    clearState: function (flags)
    {
        this.setState(this._state & ~flags);
    },
    /**
     * @name GLUI.AbstractView#setVisible
     * @description Set the visibility for this object.
     * @example SomeView = new GLUI.View();
     * ...
     * SomeView.setVisible(false);
     * @function
     * @param {boolean} <code>true</code> if this object is visible, <code>false</code> otherwise.
     * @see GLUI.AbstractView#getVisible
     */
    setVisible: function (boolValue)
    {
        if((boolValue === true) || (boolValue === false))
        {
            this._visible = boolValue;
            this.getGLObject().setVisible(boolValue);
            this._setVisible(this._visible && this._parentVisible, true);
            this._callAppearanceEvent(false);
        }
        else
        {
            throw new Error('Expecting boolean value but found ' + typeof (boolValue) + ' for setVisible(boolValue)');
        }
    },
    /**
     * @name GLUI.AbstractView#getVisible
     * @description Retrieve the state of visibility for this object.
     * @function
     * @returns {boolean} Returns <code>true</code> if this object is visible.
     * @see GLUI.AbstractView#setVisible
     */
    getVisible: function ()
    {
        return this.getGLObject().getVisible();
    },
    /**
     * @name GLUI.AbstractView#setEnabled
     * @description Set the value for the <code>enabled</code> property. This property defines an object as active or inactive.
     * <br /><b>Note:</b> Object [state] is also set to GLUI.Commands.State.Disabled if setEnabled(false) is called. And cleared if setEnabled(true) is called.
     * @param {Boolean} enabled Set as <code>true</code> if this view state is enabled.
     * @see GLUI.AbstractView#getEnabled
     * @function
     */
    setEnabled: function (enabled)
    {
        if((enabled === true) || (enabled === false))
        {
            this._enabled = enabled;
            if(enabled)
            {
                this.clearState(Commands.State.Disabled);
            }
            else
            {
                this.addState(Commands.State.Disabled);
            }
            this._setEnabled(this._enabled && this._parentEnabled, true);
        }
        else
        {
            throw new Error('Expecting boolean value but found ' + typeof (enabled) + ' for setEnabled(enabled)');
        }
        return this;
    },
    /**
     * @name GLUI.AbstractView#getEnabled
     * @description Retrieve the value of the <code>enabled</code> property.
     * @returns {Boolean} Returns <code>true</code> if this view state is enabled.
     * @see GLUI.AbstractView#setEnabled
     * @function
     */
    getEnabled: function ()
    {
        return this._enabled;
    },
    /**
     * @name GLUI.AbstractView#setBackgroundColor
     * @description Set the value for the <code>backgroundColor</code> property. This property defines the color of the background for an object when rendered.
     * @example SomeView = new GLUI.View();
     * ...
     * SomeView.setBackgroundColor("FF000000");
     * @param {String} backgroundColor The new background color.
     * @see UI.AbstractView#getBackgroundColor
     * @type Color
     * @function
     */
    setBackgroundColor: function (color)
    {
        var ScrollView = require('NGGo1.3/GLUI/ScrollView').ScrollView;
        var container = this._internalGLObject.getParent();
        if(!this._parentNode)
        {
            this._parentNode = new Node();
        }
        if(!this._backgroundColor && container)
        {
            container.removeChild(this._internalGLObject);
            container.addChild(this._parentNode);
        }
        if(this instanceof ScrollView)
        {
            this._needUpdateView = true;
        }
        this.__ARGB = Util.hexToARGB(color);
        this._backgroundColor = color;
        if(!this._bgPrimitive)
        {
            this._bgColorAlreadySet = false;
            this._bgPrimitive = new Util.Rectangle();
        }
        if(!this._frame)
        {
            this._frame = [0, 0, 0, 0];
        }
        this.__fillBackgroundColor();
        this._updateAlpha();
        this.getGLObject().setVisible(this._visible);
        this._internalGLObject.setVisible(true);
        this.getGLObject().setVisible(this._visible);
        return this;
    },
    /**
     * @name GLUI.AbstractView#getBackgroundColor
     * @description Retrieve the value of the <code>backgroundColor</code> property.
     * @returns {String} The current background color.
     * @see GLUI.AbstractView#setBackgroundColor
     * @function
     */
    getBackgroundColor: function ()
    {
        return this._backgroundColor;
    },
    /**
     * @name GLUI.AbstractView#setGradient
     * @description Set the value of the <code>background</code> property using the first set of colors.
     * @example label.setGradient({
     *  gradient: ['FFFF8000 0.0', 'FF703300 1.0']
     * }, UI.State.Selected);
     * [corners] and [gradient] are not fully supported for GLUI elements. A plain background will be applied.
     * <br /><b>Note: </b> This property will tamper with the backgound property, as gradients are not supported in GLUI.
     * @param {Object} gradient The new gradient.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @see GLUI.AbstractView#getGradient
     * @function
     */
    setGradient: function (flags, state)
    {
        if(state === undefined)
        {
            state = Commands.State.Normal;
        }
        this._gradient[state + ''] = flags;
        this._updateView();
    },
    /**
     * @name GLUI.AbstractView#getGradient
     * @description Retrieve the value of the <code>gradient</code> property for a view state.
     * gradient is supported as a plain color background.
     * @param {GLUI.State} [flags=GLUI.State.Normal] The GLUI view state.
     * @returns {Object} The current gradient.
     * @see GLUI.AbstractView#setGradient
     * @function
     */
    getGradient: function (state)
    {
        if(state === undefined)
        {
            state = Commands.State.Normal;
        }
        return this._gradient[state];
    },
    /**
     * Add a node at the specified index to the specified parent node.
     * @example var myParent = new GLUI.View({
     *  ...
     * });
     * var childNode = new GLUI.View({
     *  ...
     * });
     * ...
     * childNode.addToParent(myParent);
     * @function
     * @param {Object} parentNode The parent node.
     * @param {Number} [index] The parent node index location. Index reflects the depth (z-index) of a node in that view.
     * @see GLUI.AbstractView#getParent,
     * @see GLUI.AbstractView#removeFromParent
     */
    addToParent: function (parentNode, index)
    {
        parentNode.addChild(this, index);
        this._parent = parentNode;
    },
    /**
     * Remove a node from the parent node.
     * @example childNode.removeFromParent(myParent);
     * @function
     * @returns {Element} This function returns <code>this</code> to support method invocation chaining.
     * @see GLUI.AbstractView#getParent,
     * @see GLUI.AbstractView#addToParent
     */
    removeFromParent: function ()
    {
        if(this._parent && this._parent.removeChild && this._parent instanceof Element)
        {
            this._parent.removeChild(this);
            this._parent = null;
        }
        return this;
    },
    /**
     * @function
     * @description Retrieve the parent node for this view.
     * @returns Returns the parent if this view is a child of another element. Otherwise, returns undefined.
     * @see GLUI.AbstractView#addToParent,
     * @see GLUI.AbstractView#removeFromParent
     */
    getParent: function ()
    {
        return this._parent;
    },
    /**
     * Retrieve the root node for this object.
     * @function
     * @returns Returns the root node if this is a child node. Otherwise, returns undefined.
     */
    getRoot: function ()
    {
        var retParent;
        var child = this;
        while(child._parent)
        {
            retParent = child._parent;
            child = child._parent;
        }
        return retParent;
    },
    /**
     * @function
     * @description Swallow touches, and will not let the touches to pass below the node. Useful for implementing Alert Dialogs. Works similar to setBlockTouchEvents, internal implementation is different from UI.setBlockTouchEvents.
     * @returns This function returns <code>this</code> to support method invocation chaining.
     */
    swallowTouches: function (booleanValue)
    {
        if(booleanValue === true || booleanValue === undefined || booleanValue === null)
        {
            if(this._clickCallBack && this._longPressCallBack && this._swipeCallback)
            {
                this._setUpTouchTarget();
            }
            else
            {
                if(!this._clickCallBack)
                {
                    this.setOnClick(function ()
                    {});
                }
                if(!this._longPressCallBack)
                {
                    this.setOnLongPress(function ()
                    {});
                }
                if(!this._swipeCallback)
                {
                    this.setOnSwipe(function ()
                    {});
                }
            }
        }
        else
        {
            if(this._target instanceof TouchTarget)
            {
                this._target.destroy();
                this._target = null;
            }
        }
        return this;
    },
    destroy: function ($super)
    {
        if(this._parent)
        {
            this.removeFromParent();
            this._parent = null;
        }
        if(this._target && this._target !== 1)
        {
            this._target.destroy();
        }
        this._target = null;
        if(this._messageListener)
        {
            this._messageListener.destroy();
            this._messageListener = null;
        }
        if(this._bgPrimitive)
        {
            this._bgPrimitive.destroy();
            this._bgPrimitive = null;
        }
        if(this._parentNode)
        {
            this._parentNode.destroy();
            this._parentNode = null;
        }
        this._clickCallBack = null;
        this._alpha = null;
        this.__bgAlpha = null;
        this.__internalAlpha = null;
        this._frame = null;
        this._hasMovedOutside = null;
        this._anchor = null;
        this._fitMode = null;
        this._clickCallBack = null;
        this._state = null;
        if(this._images)
        {
            this._images.length = 0;
            this._images = null;
        }
        this._position = null;
        this._alpha = null;
        this.__bgAlpha = null;
        this.__internalAlpha = null;
        if(this.__ARGB)
        {
            this.__ARGB.length = 0;
            this.__ARGB = null;
        }
        this._enabled = null;
        this._parentEnabled = null;
        this._parentVisible = null;
        this._isPressed = null;
        this._OS = null;
        this._bgColorAlreadySet = null;
        this._backgroundColor = null;
        this._visible = null;
        this._isHandlingTouch = null;
        this._clickable = null;
        this._longPressCallBack = null;
        this._longPressCBTimeoutID = null;
        this._isLongPressCalled = null;
        this._isOnSwipeCalled = null;
        this._swipeCallback = null;
        this._recogDistanceForSwipe = null;
        this._recogTimeForLongPress = null; // in mili seconds
        this._touchable = null;
        this._parentTouchable = null;
        this._appearCallback = null;
        this._disappearCallback = null;
        this._isLastTimeAppearCalled = null;
        $super();
    },
    /** @private */
    _updateView: function ()
    {
        //override this in the derived classes.
        var gradient = this._gradient[this._state];
        if(typeof gradient === 'object' && gradient.gradient instanceof Array)
        {
            var spc = gradient.gradient[0].indexOf(" ");
            if(spc > 0)
            {
                var color = gradient.gradient[0].substring(0, spc);
                this.setBackgroundColor(color);
            }
        }
    },
    _setUpTouchTarget: function ()
    {
        if(this._frame)
        {
            if(this._messageListener)
            {
                this._messageListener.destroy();
            }
            this._messageListener = new MessageListener();
            if(!this._target)
            {
                this._target = new TouchTarget();
            }
            this.__setTouchableArea();
            this._target.getTouchEmitter().addListener(this._messageListener, this._touchReceivedCallBack.bind(this));
            if(!this._backgroundColor)
            {
                var color = "00000000"; //transparent color
                this.setBackgroundColor(color); //this will create a parentNode with transparent area if no bg color is provided
            }
            this.getGLObject().addChild(this._target);
        }
    },
    __setTouchableArea: function ()
    {
        this._target.setAnchor(0, 0);
        this._target.setSize(this._frame[2], this._frame[3]);
        this._target.setPosition(0, 0);
        this._target.setDepth(-2);
    },
    _giveTouchesToChildren: function (touch, array)
    {
        var i = 0;
        if(array && array.length > 0)
        {
            for(i = array.length - 1; i >= 0; i--)
            {
                var arrayItem = array[i];
                if(arrayItem._isTouchInFrame(touch) && arrayItem._enabled && arrayItem._visible && arrayItem._touchable && arrayItem._clickable)
                {
                    var retInstance = arrayItem._touchReceivedCallBack(touch, true);
                    if(retInstance)
                    {
                        return retInstance;
                    }
                }
            }
        }
        return null;
    },
    _isTouchInFrame: function (touch)
    {
        if(!this._frame)
        {
            return false;
        }
        var position = touch.getPosition();
        var x = position.getX();
        var y = position.getY();
        var objStartPosition = this.getGLObject().localToScreen(new Vector(0, 0));
        var objMaxPosition = this.getGLObject().localToScreen(new Vector(this._frame[2], this._frame[3]));
        if(!objStartPosition || !objMaxPosition)
        {
            return false;
        }
        var xmin = objStartPosition.getX();
        var xmax = objMaxPosition.getX();
        var ymin = objStartPosition.getY();
        var ymax = objMaxPosition.getY();
        if(y >= ymin && y < ymax && x >= xmin && x < xmax)
        {
            return true;
        }
        else
        {
            return false;
        }
    },
    _touchReceivedCallBack: function (touch, isDelegating)
    {
        if((touch.getId() !== 1 && this._OS === "android"))
        {
            if(isDelegating)
            {
                return null;
            }
            return false;
        }
        if(isDelegating === undefined || isDelegating === null)
        {
            isDelegating = false;
        }
        else if(isDelegating && this._children && this._children.length > 0)
        {
            var retInstance = this._giveTouchesToChildren(touch, this._children);
            if(retInstance)
            {
                return retInstance;
            }
        }
        switch(touch.getAction())
        {
        case touch.Action.Start:
            if(!this._isHandlingTouch && (this._clickCallBack || this._longPressCallBack || this._swipeCallback) && this._isTouchInFrame(touch) && this._enabled && this._visible && this._parentEnabled && this._parentVisible && !(this.getState() & Commands.State.Disabled) && this._clickable && this._touchable && this._parentTouchable)
            {
                this._isHandlingTouch = true;
                if(this.getState() & Commands.State.Pressed)
                {
                    this._isPressed = true;
                }
                this.addState(Commands.State.Pressed);
                this._hasMovedOutside = false;
                this._isOnSwipeCalled = false;
                this._isLongPressCalled = false;
                this._initialTouchPosition = touch.getPosition();
                if(this._longPressCallBack)
                {
                    this._longPressCBTimeoutID = setTimeout(function ()
                    {
                        if(this._longPressCallBack)
                        {
                            this._longPressCallBack();
                            this._isLongPressCalled = true;
                        }
                    }.bind(this), this._recogTimeForLongPress);
                }
                if(isDelegating)
                {
                    return this;
                }
                return true;
            }
            else
            {
                return false;
            }
            break;
        case touch.Action.End:
            if(!this._isPressed && !this._hasMovedOutside)
            {
                this.clearState(Commands.State.Pressed);
            }
            if(this._isTouchInFrame(touch) && this._enabled && this._visible && this._parentEnabled && this._parentVisible && !(this.getState() & Commands.State.Disabled) && !this._hasMovedOutside && this._touchable && this._parentTouchable)
            {
                if(this._endTap)
                {
                    this._endTap();
                }
                if(!this._isLongPressCalled && !this._isOnSwipeCalled)
                {
                    this._click();
                }
            }
            this._isPressed = false;
            this._hasMovedOutside = false;
            if(this._longPressCBTimeoutID)
            {
                clearTimeout(this._longPressCBTimeoutID);
                this._longPressCBTimeoutID = null;
            }
            this._isHandlingTouch = false;
            break;
        case touch.Action.Move:
            var currentPosition = touch.getPosition();
            if(isDelegating) //here lower sensitivity of press
            {
                if(!this._isPressed)
                {
                    this.clearState(Commands.State.Pressed);
                }
                this._pressed = false;
                this._hasMovedOutside = false;
                this._isOnSwipeCalled = true;
                if(this._longPressCBTimeoutID)
                {
                    clearTimeout(this._longPressCBTimeoutID);
                    this._longPressCBTimeoutID = null;
                }
                this._isHandlingTouch = false;
                return true;
            }
            else if(!this._isTouchInFrame(touch) && !this._hasMovedOutside)
            {
                this._hasMovedOutside = true;
                if(this._longPressCBTimeoutID)
                {
                    clearTimeout(this._longPressCBTimeoutID);
                    this._longPressCBTimeoutID = null;
                }
                if(!this._isPressed)
                {
                    this.clearState(Commands.State.Pressed);
                }
            }
            if(!this._isOnSwipeCalled && !this._hasMovedOutside && this._swipeCallback)
            {
                if(this._calcDist(this._initialTouchPosition, currentPosition) >= this._recogDistanceForSwipe)
                {
                    var object = {};
                    var theta = this._calcAngle(this._initialTouchPosition, currentPosition);
                    if(theta <= 45)
                    {
                        if((currentPosition.getX() - this._initialTouchPosition.getX()) < 0)
                        {
                            object.direction = Commands.SwipeDirection.Left;
                        }
                        else if((currentPosition.getX() - this._initialTouchPosition.getX()) > 0)
                        {
                            object.direction = Commands.SwipeDirection.Right;
                        }
                    }
                    else
                    {
                        if((currentPosition.getY() - this._initialTouchPosition.getY()) < 0)
                        {
                            object.direction = Commands.SwipeDirection.Up;
                        }
                        else if((currentPosition.getY() - this._initialTouchPosition.getY()) > 0)
                        {
                            object.direction = Commands.SwipeDirection.Down;
                        }
                    }
                    if(this._longPressCBTimeoutID)
                    {
                        clearTimeout(this._longPressCBTimeoutID);
                        this._longPressCBTimeoutID = null;
                    }
                    if(!this._isLongPressCalled)
                    {
                        this._swipeCallback(object);
                    }
                    this._isOnSwipeCalled = true;
                }
            }
            break;
        }
        return false;
    },
    _calcDist: function (p1, p2)
    {
        var distX = p1.getX() - p2.getX();
        var distY = p1.getY() - p2.getY();
        var dist = distX * distX + distY * distY;
        return Math.sqrt(dist);
    },
    _calcAngle: function (p1, p2)
    {
        var dx = Math.abs(p1.getX() - p2.getX());
        var dy = Math.abs(p1.getY() - p2.getY());
        return Math.atan(dy / dx) * 57.2;
    },
    _click: function ()
    {
        if(this._clickCallBack)
        {
            this._clickCallBack();
        }
    },
    _setClickable: function (clickable)
    {
        this._clickable = clickable;
    },
    _getClickable: function ()
    {
        return this._clickable;
    },
    _setVisible: function (parentVisible, isSelf)
    {
        if(!isSelf)
        {
            this._parentVisible = parentVisible;
        }
        if(this._children)
        {
            var i;
            for(i = 0; i < this._children.length; i++)
            {
                this._children[i]._setVisible(parentVisible && this._visible, false);
            }
        }
    },
    _setEnabled: function (parentEnabled, isSelf)
    {
        if(!isSelf)
        {
            this._parentEnabled = parentEnabled;
        }
        if(this._children)
        {
            var i = 0;
            for(i = 0; i < this._children.length; i++)
            {
                this._children[i]._setEnabled(parentEnabled && this._enabled, false);
            }
        }
    },
    _setTouchable: function (parentTouchable, isSelf)
    {
        if(!isSelf)
        {
            this._parentTouchable = parentTouchable;
        }
        if(this._children)
        {
            var i = 0;
            for(i = 0; i < this._children.length; i++)
            {
                this._children[i]._setTouchable(parentTouchable && this._touchable, false);
            }
        }
    },
    __fillBackgroundColor: function ()
    {
        this._bgPrimitive.setFrame([0, 0, this._frame[2], this._frame[3]]);
        this._bgPrimitive.setDepth(-1);
        this._parentNode.setPosition(this._frame[0], this._frame[1]);
        this.__bgAlpha = this.__ARGB[0];
        this._bgPrimitive.setColor(new Color(this.__ARGB[1], this.__ARGB[2], this.__ARGB[3]));
        if(!this._bgColorAlreadySet)
        {
            var parentPosition = this._parentNode.getPosition();
            var internalPosition = this._internalGLObject.getPosition();
            this._internalGLObject.setPosition(internalPosition.getX() - parentPosition.getX(), internalPosition.getY() - parentPosition.getY());
            this._internalGLObject.setDepth(0);
            this._parentNode.addChild(this._bgPrimitive);
            this._parentNode.addChild(this._internalGLObject);
            this._bgColorAlreadySet = true;
        }
        if(this._updateDepth)
        {
            this._updateDepth();
        }
    },
    _updateAlpha: function ()
    {
        var internalValue = 0;
        var bgValue = 0;
        internalValue = this.__internalAlpha * this._alpha;
        this._internalGLObject.setAlpha(internalValue);
        if(this._parentNode)
        {
            bgValue = this.__bgAlpha * this._alpha;
            this._bgPrimitive.setAlpha(bgValue);
        }
    },
    _endTap: function ()
    {
        //override in child classes;
    },
    _getInternalGLObjectPosition: function ()
    {
        var parentPosX = 0;
        var parentPosY = 0;
        if(this._parentNode)
        {
            var parentPosition = this._parentNode.getPosition();
            parentPosX = parentPosition.getX();
            parentPosY = parentPosition.getY();
        }
        //var internalPosition = this._internalGLObject.getPosition();
        var posX = -parentPosX;
        var posY = -parentPosY;
        posX += this._frame[0] + (this._frame[2] * this._anchor[0]);
        posY += this._frame[1] + (this._frame[3] * this._anchor[1]);
        return new Point(posX, posY);
    },
    /** @private */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.alpha = this._setAlphaProperty;
        this._setters.frame = this._setFrameProperty;
        this._setters.onClick = this._setOnClickProperty;
        this._setters.visible = this._setVisibleProperty;
        this._setters.enabled = this._setEnabledProperty;
        this._setters.backgroundColor = this._setBackgroundColorProperty;
        this._setters.state = this._setStateProperty;
        this._setters.gradient = this._setGradientProperty;
    },
    /** @private */
    _registerGetters: function ($super)
    {
        $super();
        this._getters.alpha = this._getAlphaProperty;
        this._getters.frame = this._getFrameProperty;
        this._getters.onClick = this._getOnClickProperty;
        this._getters.visible = this._getVisibleProperty;
        this._getters.enabled = this._getEnabledProperty;
        this._getters.ackgroundColor = this._getBackgroundColorProperty;
        this._getters.state = this._getStateProperty;
        this._getters.gradient = this._getGradientProperty;
    },
    /** @private Property accessors*/
    _setAlphaProperty: function (callee, args)
    {
        return callee.setAlpha(args);
    },
    _setFrameProperty: function (callee, args)
    {
        return callee.setFrame(args);
    },
    _setOnClickProperty: function (callee, args)
    {
        return callee.setOnClick(args);
    },
    _setVisibleProperty: function (callee, args)
    {
        return callee.setVisible(args);
    },
    _setEnabledProperty: function (callee, args)
    {
        return callee.setEnabled(args);
    },
    _setBackgroundColorProperty: function (callee, args)
    {
        return callee.setBackgroundColor(args);
    },
    _setStateProperty: function (callee, args)
    {
        return callee.setState(args);
    },
    _setGradientProperty: function (callee, args)
    {
        return callee.setGradient(args);
    },
    _getAlphaProperty: function (callee, args)
    {
        return callee.getAlpha(args);
    },
    _getFrameProperty: function (callee, args)
    {
        return callee.getFrame(args);
    },
    _getOnClickProperty: function (callee, args)
    {
        return callee.getOnClick(args);
    },
    _getVisibleProperty: function (callee, args)
    {
        return callee.getVisible(args);
    },
    _getEnabledProperty: function (callee, args)
    {
        return callee.getEnabled(args);
    },
    _getBackgroundColorProperty: function (callee, args)
    {
        return callee.getBackgroundColor(args);
    },
    _getStateProperty: function (callee, args)
    {
        return callee.getState(args);
    },
    _getGradientProperty: function (callee, args)
    {
        return callee.getGradient(args);
    },
    /////////////// Empty Functions /////////////////
    /**
     * @name GLUI.AbstractView#getOnAppear
     * @description Retrieve the function to call when the <code>appear</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnAppear
     * @event
     * @status Android, Flash, Test
     */
    getOnAppear: function ()
    {
        return this._appearCallback;
    },
    /**
     * @name GLUI.AbstractView#getOnDisappear
     * @description Retrieve the function to call when the <code>disappear</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnDisappear
     * @event
     * @status Android, Flash, Test
     */
    getOnDisappear: function ()
    {
        return this._appearCallback;
    },
    /**
     * @name GLUI.AbstractView#getOnLongPress
     * @description Retrieve the function to call when a <code>tap and hold</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnLongPress
     * @event
     * @status Android, Flash, Test
     */
    getOnLongPress: function ()
    {
        return this._longPressCallBack;
    },
    /**
     * @name GLUI.AbstractView#getOnSwipe
     * @description Retrieve the function to call when the <code>swipe</code> event occurs.
     * @returns {Function} The current callback function.
     * @see GLUI.AbstractView#event:setOnSwipe
     * @event
     * @status Android, Flash, Test
     */
    getOnSwipe: function ()
    {
        return this._swipeCallback;
    },
    /**
     * @name GLUI.AbstractView#setOnAppear
     * @description Set a function to call when the <code>appear</code> event occurs.
     * @param {Function} appearCallback The new callback function.
     * @example function() { onAppear.appear = true; };
     * @see GLUI.AbstractView#event:getOnAppear
     * @event
     * @status Android, Flash, Test
     */
    setOnAppear: function (appearCallback)
    {
        if(typeof (appearCallback) !== "function")
        {
            if(appearCallback === "undefined" || appearCallback === null)
            {
                appearCallback = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnAppear expects (), (null), (function) but received " + appearCallback.type);
            }
        }
        this._appearCallback = appearCallback;
    },
    /**
     * @name GLUI.AbstractView#setOnDisappear
     * @description Set a function to call when the <code>disappear</code> event occurs.
     * @param {Function} disappearCallback The new callback function.
     * @example function() { onDisappear.disappear = true; };
     * @see GLUI.AbstractView#event:getOnDisappear
     * @event
     * @status Android, Flash, Test
     */
    setOnDisappear: function (disappearCallback)
    {
        if(typeof (disappearCallback) !== "function")
        {
            if(disappearCallback === "undefined" || disappearCallback === null)
            {
                disappearCallback = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnDisappear expects (), (null), (function) but received " + disappearCallback.type);
            }
        }
        this._disappearCallback = disappearCallback;
    },
    /**
     * @name GLUI.AbstractView#setOnLongPress
     * @description Set a function to call when a user taps and holds on a view.
     * @param {Function} onLongPressCallback The new callback function.
     * @example function() { onLongPress.longpress = true; };
     * @see GLUI.AbstractView#event:getOnLongPress
     * @event
     * @status Android, Flash, Test
     */
    setOnLongPress: function (longPressCallBack)
    {
        if(typeof (longPressCallBack) !== "function")
        {
            if(longPressCallBack === "undefined" || longPressCallBack === null)
            {
                longPressCallBack = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnLongPress expects (), (null), (function) but received " + longPressCallBack.type);
            }
        }
        this._longPressCallBack = longPressCallBack;
        if(this._frame && !this._target)
        {
            this._setUpTouchTarget();
        }
    },
    /**
     * @name GLUI.AbstractView#setOnSwipe
     * @description Set a function to call when a swipe event occurs. This is when the user swipes a finger across this view, like how you indicate a "delete row" request on a table view. The function gets the GLUI.Commands.SwipeDirection from the first parameter.direction.
     * @param {Function} swipeCallback The new callback function for swipe. 
     * @example view.setOnSwipe( function(params) { NgLogD("swipe code "+params.direction); });
     * @see GLUI.AbstractView#event:getOnSwipe
     * @event
     * @status Android, Flash, Test
     */
    setOnSwipe: function (swipeCallback)
    {
        if(typeof (swipeCallback) !== "function")
        {
            if(swipeCallback === "undefined" || swipeCallback === null)
            {
                swipeCallback = function ()
                {};
            }
            else
            {
                throw new Error(this.classname + " setOnSwipe expects (), (null), (function) but received " + swipeCallback.type);
            }
        }
        this._swipeCallback = swipeCallback;
        if(this._frame && !this._target)
        {
            this._setUpTouchTarget();
        }
    },
    /**
     * @name GLUI.AbstractView#getTouchable
     * @description Retrieve the value of the <code>touchable</code> property.
     * @returns {Object} The current value of <code>Touchable.</code>
     * @see GLUI.AbstractView#setTouchable
     * @function
     * @status Android, Flash, Test
     */
    getTouchable: function ()
    {
        return this._touchable;
    },
    /**
     * @name GLUI.AbstractView#setTouchable
     * @description Set the value of the <code>Touchable</code> property.
     * @param {Boolean} blockTouchEvents The new value for <code>Touchable.</code>
     * @see GLUI.AbstractView#getTouchable
     * @function
     * @status Android, Flash, Test
     */
    setTouchable: function (touchable)
    {
        if((touchable === true) || (touchable === false))
        {
            this._touchable = touchable;
            this._setTouchable(this._touchable && this._parentTouchable, true);
        }
        else
        {
            throw new Error('Expecting boolean value but found ' + typeof (touchable) + ' for setTouchable(boolValue)');
        }
    },
    get onclick()
    {
        //enables property get mode :  var a = object.onclick;
        return this.getOnClick();
    },
    set onclick(value)
    {
        //enables property set mode : object.onclick = function() {};
        this.setOnClick(value);
    },
    _getVisibility: function ()
    {
        return this._visible && this._parentVisible;
    },
    _callAppearanceEvent: function (isRemoveChildCalled)
    {
        var WindowLayer = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;
        if(this._appearCallback && this.getRoot() instanceof WindowLayer && this._getVisibility() === true && this._isLastTimeAppearCalled !== true)
        {
            this._isLastTimeAppearCalled = true;
            this._appearCallback();
        }
        else if(this._disappearCallback && this.getRoot() instanceof WindowLayer && (this._getVisibility() === false || isRemoveChildCalled === true) && this._isLastTimeAppearCalled === true)
        {
            this._isLastTimeAppearCalled = false;
            this._disappearCallback();
        }
        if(this._children)
        {
            var i;
            for(i = 0; i < this._children.length; i++)
            {
                this._children[i]._callAppearanceEvent(isRemoveChildCalled);
            }
        }
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/Service/Graphics/ImageListView'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/Service/Graphics/ImageListView'] || {}; $MODULE_REGISTRY['NGGo1.3/Service/Graphics/ImageListView'] = exports; 
var __dirname = 'NGGo1.3/Service/Graphics';
var __filename = 'NGGo1.3/Service/Graphics/ImageListView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Taha Samad
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Node = require('NGCore/Client/GL2/Node').Node;
var TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
var Size = require('NGCore/Client/Core/Size').Size;
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Vector = require('NGCore/Client/Core/Vector').Vector;
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var GLUIUtil = require('NGGo1.3/GLUI/Util').Util; /** @private */
var Scrollbar = GLUIUtil.Rectangle.subclass(
{
    classname: "Scrollbar",
    initialize: function ($super)
    {
        $super();
        this.setColor([0.5, 0.5, 0.5]);
        this.setAlpha(0);
        this.setDepth(65535);
    },
    updateSize: function (mode, frame, contentSize)
    {
        var f_width = frame.getSize().getWidth();
        var f_height = frame.getSize().getHeight();
        var c_width = contentSize.getWidth();
        var c_height = contentSize.getHeight();
        var r;
        if(mode === exports.ImageListView.ScrollDirection.Horizontal)
        {
            if(f_width < c_width)
            {
                r = c_width === 0 ? 1 : (f_width / c_width);
                this.setFrame([0, f_height - 5, f_width * r, 5]);
            }
            else
            {
                this.setFrame([0, f_height - 5, f_width, 5]);
            }
        }
        else
        {
            if(f_height < c_height)
            {
                r = c_height === 0 ? 1 : (f_height / c_height);
                this.setFrame([f_width - 5, 0, 5, f_height * r]);
            }
            else
            {
                this.setFrame([f_width - 5, 0, 5, f_height]);
            }
        }
        this.mode = mode;
        this.frameSize = new Size([f_width, f_height]);
        this.contentSize = new Size([c_width, c_height]);
    },
    updateAlpha: function (momentum)
    {
        if(momentum.x === 0 && momentum.y === 0)
        {
            var alpha = this.getAlpha();
            if(alpha === 0)
            {
                return;
            }
            else
            {
                alpha -= 0.03;
                if(alpha < 0.01)
                {
                    alpha = 0;
                }
                this.setAlpha(alpha);
            }
        }
    },
    updatePosition: function (new_x, new_y)
    {
        this.setAlpha(1);
        if(!this.mode)
        {
            return;
        }
        var f_width = this.frameSize.getWidth();
        var f_height = this.frameSize.getHeight();
        var c_width = this.contentSize.getWidth();
        var c_height = this.contentSize.getHeight();
        if(this.mode === exports.ImageListView.ScrollDirection.Horizontal)
        {
            this.setPosition(-f_width * (new_x / c_width), f_height - 5);
        }
        else
        {
            this.setPosition(f_width - 5, -f_height * (new_y / c_height));
        }
    }
}); /** @private */
var DragListener = MessageListener.subclass(
{
    classname: 'DragListener',
    initialize: function (listview)
    {
        this._touch = null;
        this.listview = listview;
        this._target = new TouchTarget();
        this._target.getTouchEmitter().addListener(this, this.onTouch);
        UpdateEmitter.addListener(this, this.onUpdate);
        this._clickChild = null;
    },
    getTarget: function ()
    {
        return this._target;
    },
    getTouch: function ()
    {
        return this._touch;
    },
    onTouch: function (touch)
    {
        switch(touch.getAction())
        {
        case touch.Action.Start:
            if(this._touch)
            {
                return false;
            }
            this._touch = {
                id: touch.getId(),
                sx: touch.getPosition().getX(),
                sy: touch.getPosition().getY(),
                x: touch.getPosition().getX(),
                y: touch.getPosition().getY(),
                lx: touch.getPosition().getX(),
                ly: touch.getPosition().getY(),
                dx: 0,
                dy: 0,
                startTime: new Date().getTime(),
                endTime: 0,
                hasMoved: false,
                hasMovedOutside: false
            };
            this._touch.endTime = this._touch.startTime;
            this._clickChild = this.listview._giveTouchesToChildren(touch, this.listview._listitems);
            return true;
        case touch.Action.End:
            if(this._touch.id !== touch.getId())
            {
                return false;
            }
            if(this.listview._snap && this._touch.hasMoved)
            {
                this._touch.endTime = new Date().getTime();
                this.listview._evaluateSnapMomentum(this._touch);
            }
            if(this._clickChild)
            {
                this._clickChild._touchReceivedCallBack(touch);
                this._clickChild = null;
            }
            this._touch = null;
            break;
        case touch.Action.Move:
            if(this._touch.id !== touch.getId() || this.listview._scrollLock || this._touch.hasMovedOutside)
            {
                return false;
            }
            if(!touch.getIsInside(this._target))
            {
                this._touch.hasMovedOutside = true;
                if(this._clickChild)
                {
                    this._clickChild._touchReceivedCallBack(touch, true);
                    this._clickChild = null;
                }
            }
            else
            {
                var pos = touch.getPosition();
                if(this._touch === null || pos === undefined)
                {
                    break;
                }
                this._touch.x = pos.getX();
                this._touch.y = pos.getY();
                var moveDis = Math.sqrt(Math.pow(this._touch.x - this._touch.lx, 2) + Math.pow(this._touch.y - this._touch.ly, 2));
                if(moveDis <= this.listview._feeling.touchSensitivity)
                {
                    break;
                }
                this._touch.hasMoved = true;
                this._touch.dx += this._touch.x - this._touch.lx;
                this._touch.dy += this._touch.y - this._touch.ly;
                this._touch.lx = this._touch.x;
                this._touch.ly = this._touch.y;
                if(this._clickChild)
                {
                    this._clickChild._touchReceivedCallBack(touch, true);
                    this._clickChild = null;
                }
            }
            break;
        default:
            break;
        }
        return false;
    },
    onUpdate: function ()
    {
        var count = 0;
        var delta = {
            x: 0,
            y: 0
        };
        if(this._touch)
        {
            delta.x += this._touch.dx;
            delta.y += this._touch.dy;
            this._touch.dx = this._touch.dy = 0;
            ++count;
        }
        if(count > 1)
        {
            delta.x /= count;
            delta.y /= count;
        }
        // Tell our scroll area to update.
        this.listview._onUpdate(delta);
    },
    hasTouch: function ()
    {
        return(this._touch !== null);
    },
    destroy: function ()
    {
        this._target.getTouchEmitter().removeListener(this);
        this._target.destroy();
        this._target = null;
        UpdateEmitter.removeListener(this);
        this._clickChild = null;
        this._touch = null;
        this.listview = null;
    }
});
exports.ImageListView = Node.subclass( /** @lends Service.Graphics.ImageListView.prototype */
{
    classname: 'ImageListView',
    /**
     * @class ImageListView.
     * ImageListView supports vertical and horizontal list. It accepts <i>GL2 Node or GLUI objects</i> as list item.
     * 
     * @example
     * // Create Image List View; 
     * var listview = new ImageListView();
     * listview.setItemSize([200, 200]);
     * listview.setFrame([0, 0, 200, 200]);
     * listview.setScrollDirection(ImageListView.ScrollDirection.Horizontal);
     * GL2.Root.addChild(listview);
     *
     * // Create GLUI Item 
     * var listitem1 = new GLUI.View();
     * listitem1.setFrame([0,0,200,200]);
     * listitem1.setImage("./Content/listitem.png", null,[200, 200]);
     * var img1 = new GLUI.Image();
     * img1.setFrame([0,0,100,100]);
     * img1.setImage('./Content/image.png',null, [100, 100]);
     * listitem1.addChild(img1);
     *
     * // Create GL2 Item 
     * var listitem2 = new GL2.Sprite();
     * listitem2.setImage("./Content/listitem.png",[200, 200],[0.5,0.5]);
     * var img2 = new GL2.Sprite();
     * img2.setImage('./Content/image.png',[100,100],[0.5,0.5]);
     * listitem2.addChild(img2);     
     *
     * //Add Item. Second parameter is index where item is to be inserted.
     * listview.addItem(listitem1);
     * listview.addItem(listitem2,0);
     * @constructs The default constructor.
     * @augments GL2.Node
     */
    initialize: function ()
    {
        this._snap = false;
        this._frame = new Rect([0, 0, 0, 0]);
        this._itemSize = new Size();
        this._contentSize = new Size();
        this._content = new Node();
        this._content.setTouchable(false);
        this._content.setDepth(0);
        this.addChild(this._content);
        this._feeling = {
            friction: 0.9,
            smoothingFactor: 0.3,
            stretchDecay: 0.65,
            rangeFactor: 0.5,
            flickSpeed: 0.3,
            touchSensitivity: 2
        };
        this._momentum = {
            x: 0,
            y: 0
        };
        this._listitems = [];
        this._scrollbar = new Scrollbar();
        this.addChild(this._scrollbar);
        this._dragger = null;
        this._touchTarget = null;
        this._scrollLock = false;
        this.setClipRectEnabled(true);
        this._lastClipRectFrame = [0, 0, 0, 0];
        this.setScrollDirection(this.ScrollDirection.Horizontal);
        this._setters = [];
        this._registerSetters();
    },
    /**
     * ScrollDirection.Horizontal or ScrollDirection.Vertical
     */
    ScrollDirection: {
        Horizontal: 1,
        Vertical: 2
    },
    /**
     * Sets Scroll Feeling.
     * @param {object} feeling Feeling object contains following keys: friction, smoothingFactor,rangeFactor, touchSensitivity, flickSpeed and stretchDecay. All values are Numbers.
     * </br> </br>
     * <div class="ul"> 
     * <li> friction  </li> Its default value is 0.9. For higher friction value ImageListView experiences less friction. 
     * <li>smoothingFactor</li> Its default value is 0.3. For higher smoothingFactor ImageListView moves more smoothly. 
     * <li>stretchDecay</li> Its default value is 0.65.  For high stretchDecay ImageListView returns slowly after being stretched beyond its bounds.
     * <li>rangeFactor</li> This factor sets the stretch range of ImageListView when stretched beyond its bounds. Its default value is 0.5. For higher rangeFactor ImageListView experiences large stretch.
     * <li>flickSpeed</li> This is useful only when setSnap of ImageListView is true. If swipe speed is greater than flickSpeed then ImageListView moves to next page even when distance moved is less than half the itemSize. Its default value is 0.3.
     * <li>touchSensitivity</li> ImageListView will handle touch move event after moving number of pixels equal to touchSensitivity. Its default value is 2.
     * </div>     
     * @example
     * // Create Image List View; 
     * var listview = new ImageListView();
     * listview.setScrollFeeling({touchSensitivity:10,flickSpeed:0.5}); //the values for keys, which are not present in the passed object remain unchanged.
     */
    setScrollFeeling: function (feeling)
    {
        if(feeling)
        {
            var key;
            for(key in this._feeling)
            {
                if(this._feeling.hasOwnProperty(key))
                {
                    this._feeling[key] = feeling[key] && typeof (feeling[key]) === "number" ? feeling[key] : this._feeling[key];
                }
            }
        }
        else
        {
            throw new Error("setScrollFeeling() got null or undefined.");
        }
    },
    /**
     * Returns feeling object.
     * @returns {object} feeling.
     */
    getScrollFeeling: function ()
    {
        return this._feeling;
    },
    /**
     * Sets item size. You need to set this property for proper functioning.
     * @param {Array} itemSize The size of each item. It can be an array like <i>[200, 200]</i>.
     */
    setItemSize: function (itemSize)
    {
        this._itemSize = new Size(itemSize);
        this._setContentSize();
    },
    /**
     * Returns Item Size.
     * @returns {Array} itemSize.
     */
    getItemSize: function ()
    {
        return [this._itemSize.getWidth(), this._itemSize.getHeight()];
    },
    /**
     * Sets frame. You need to set this property for proper functioning.
     * @param {Array} frame The frame of ImageListView. It can be an array like <i>[0, 0, 200, 200]</i>.
     */
    setFrame: function (frame)
    {
        this._frame = new Rect(frame);
        var origin = this._frame.getOrigin();
        var size = this._frame.getSize();
        this.setPosition(origin.getX(), origin.getY());
        if(this._touchTarget)
        {
            this.removeChild(this._touchTarget);
            this._touchTarget = null;
        }
        if(this._dragger)
        {
            this._dragger.destroy();
        }
        this._dragger = new DragListener(this);
        this._touchTarget = this._dragger.getTarget();
        this._touchTarget.setSize(size);
        this._touchTarget.setPosition(0, 0);
        this._touchTarget.setDepth(1);
        this.addChild(this._touchTarget);
        this._setContentSize();
        this._updateClipRect();
    },
    /**
     * Returns frame of ImageListView.
     * @returns {Array} Frame of ImageListView 
     */
    getFrame: function ()
    {
        var origin = this._frame.getOrigin();
        var size = this._frame.getSize();
        return [origin.getX(), origin.getY(), size.getWidth(), size.getHeight()];
    },
    /**
     * Sets Scroll Direction.
     * @param {Number} dir Scrolling Direction.
     */
    setScrollDirection: function (dir)
    {
        switch(dir)
        {
        case this.ScrollDirection.Horizontal:
        case this.ScrollDirection.Vertical:
            this._scroll = dir;
            this._content.setPosition(0, 0);
            this._setContentSize();
            break;
        default:
            throw new Error("at setScrollDirection() invalid value: " + dir);
        }
    },
    /**
     * Returns Scroll Direction.
     * @returns {Number} Scroll Direction.
     */
    getScrollDirection: function ()
    {
        return this._scroll;
    },
    /**
     * Sets Snap mode on/off.
     * @param {bool} bool true = snapping/paging is turned ON. false = snapping/paging is turned OFF.
     */
    setSnap: function (bool)
    {
        this._snap = Boolean(bool);
        this._content.setPosition(0, 0);
    },
    /**
     * Returns Snapping/Paging Mode Status.
     * @returns {boolean} returns whether snap/paging mode is ON(true) or OFF(false).
     */
    getSnap: function ()
    {
        return this._snap;
    },
    /**
     * Sets Scroll Lock on/off. 
     * @param {boolean}
     */
    setScrollLock: function (lock)
    {
        if(typeof (lock) === "boolean")
        {
            this._scrollLock = lock;
        }
        else
        {
            throw new Error("setScrollLock(lock) expects boolean got " + typeof (lock) + ".");
        }
    },
    /**
     * Returns Status of Scroll Lock.
     * @returns {boolean} Status of Scroll Lock.
     */
    getScrollLock: function ()
    {
        return this._scrollLock;
    },
    /**
     * Sets Scroll Position.
     * @param {number} pos Scroll Position.
     */
    setScrollPosition: function (pos)
    {
        if(typeof (pos) === "number")
        {
            switch(this._scroll)
            {
            case this.ScrollDirection.Horizontal:
                this._content.setPosition(-pos, 0);
                break;
            case this.ScrollDirection.Vertical:
                this._content.setPosition(0, -pos);
                break;
            }
        }
        else
        {
            throw new Error('setScrollPosition(pos) expects pos to be a number. Got ' + typeof (pos) + ".");
        }
    },
    /**
     * Returns Scroll Position.
     * @returns {Array} Current Scroll Position.
     */
    getScrollPosition: function ()
    {
        return [-this._content.getPosition().getX(), -this._content.getPosition().getY()];
    },
    /**
     * Add Item to ImageListView.
     * @param {GL2 Node or GLUI object} childItem
     * @param {number} index optional parameter, index where you want to insert an item.
     */
    addItem: function (childItem, index)
    {
        if(childItem instanceof AbstractView || childItem instanceof Node)
        {
            if(this._listitems.indexOf(childItem) >= 0)
            {
                this.removeItem(childItem);
            }
            if(typeof (index) === "number" && index >= 0 && index < this._listitems.length)
            {
                this._listitems.splice(index, 0, childItem);
            }
            else
            {
                this._listitems.push(childItem);
            }
            var item = childItem;
            if(childItem instanceof AbstractView)
            {
                childItem._parent = this;
                item = childItem.getGLObject();
            }
            this._content.addChild(item);
            this._setContentSize();
        }
        else
        {
            throw new Error("childItem should be an instanceof GLUI.AbstractView or GL2.Node.");
        }
    },
    /**
     * Returns length of list items array.
     * @returns {number} get length of list items array. This is also the number of items in ImageListView.
     */
    get length()
    {
        return this._listitems.length;
    },
    /**
     * length is readonly.
     */
    set length(value)
    {
        throw new Error("length is readonly");
    },
    /**
     * Removes list item.
     * @param {GLUI object or GL2 Node} childItem item to be removed.
     */
    removeItem: function (childItem)
    {
        if(childItem instanceof AbstractView || childItem instanceof Node)
        {
            var index = this._listitems.indexOf(childItem);
            if(index >= 0)
            {
                this._listitems.splice(index, 1);
                if(childItem instanceof AbstractView)
                {
                    this._content.removeChild(childItem.getGLObject());
                    childItem._parent = null;
                }
                else
                {
                    this._content.removeChild(childItem);
                }
                this._setContentSize();
            }
            else
            {
                throw new Error("Trying to remove an Object which is not a child of this ImageListView.");
            }
        }
        else
        {
            throw new Error("childItem should be an instanceof GLUI.AbstractView or GL2.Node.");
        }
    },
    /**
     * Removes all list items.
     */
    clearItems: function ()
    {
        var i;
        var children = this._listitems.slice();
        var length = this._listitems.length;
        for(i = 0; i < length; i++)
        {
            this.removeItem(children[i]);
        }
        children.length = 0;
        children = null;
        this._listitems = [];
        this._contentSize = new Size();
        this._setContentSize();
    },
    /**
     * Default Destroy
     */
    destroy: function ()
    {
        this.clearItems();
        this._scrollbar.destroy();
        this._scrollbar = null;
        this._content.destroy();
        this._content = null;
        this._dragger.destroy();
        this._dragger = null;
        this._touchTarget = null;
        this._snap = null;
        this._frame = null;
        this._itemSize = null;
        this._contentSize = null;
        this._feeling = null;
        this._momentum = null;
        this._listitems = null;
        this._scrollLock = null;
        this._setters.length = 0;
        this._setters = null;
        this._lastClipRectFrame.length = 0;
        this._lastClipRectFrame = null;
    },
    /** @private */
    _setContentSize: function ()
    {
        var i, item, width, height, anchor, anchorH, anchorV, bias;
        if(this._scroll === this.ScrollDirection.Horizontal)
        {
            width = this._itemSize.getWidth();
            height = this._frame.getSize().getHeight();
            bias = (this._frame.getSize().getHeight() - this._itemSize.getHeight()) / 2;
            this._contentSize.setHeight(this._frame.getSize().getHeight());
            this._contentSize.setWidth(width * this._listitems.length);
            var left = 0;
            for(i = 0; i < this._listitems.length; i++)
            {
                item = this._listitems[i];
                if(item instanceof AbstractView)
                {
                    item.setFrame([left, bias, width, this._itemSize.getHeight()]);
                }
                else
                {
                    if(item.getAnchor)
                    {
                        anchor = item.getAnchor();
                    }
                    else if(item._animation && item._animation.getFrame(0))
                    {
                        anchor = GLUIUtil.getAnchor(item);
                    }
                    else
                    {
                        anchor = new Vector(0, 0);
                    }
                    anchorH = width * anchor.getX();
                    anchorV = this._itemSize.getHeight() * anchor.getY();
                    item.setPosition(left + anchorH, bias + anchorV);
                }
                left += width;
            }
        }
        else
        {
            width = this._frame.getSize().getWidth();
            height = this._itemSize.getHeight();
            bias = (this._frame.getSize().getWidth() - this._itemSize.getWidth()) / 2;
            this._contentSize.setWidth(this._frame.getSize().getWidth());
            this._contentSize.setHeight(height * this._listitems.length);
            var top = 0;
            for(i = 0; i < this._listitems.length; i++)
            {
                item = this._listitems[i];
                if(item instanceof AbstractView)
                {
                    item.setFrame([bias, top, this._itemSize.getWidth(), height]);
                }
                else
                {
                    if(item.getAnchor)
                    {
                        anchor = item.getAnchor();
                    }
                    else if(item._animation && item._animation.getFrame(0))
                    {
                        anchor = GLUIUtil.getAnchor(item);
                    }
                    else
                    {
                        anchor = new Vector(0, 0);
                    }
                    anchorH = this._itemSize.getWidth() * anchor.getX();
                    anchorV = height * anchor.getY();
                    item.setPosition(bias + anchorH, top + anchorV);
                }
                top += height;
            }
        }
        this._scrollbar.updateSize(this._scroll, this._frame, this._contentSize);
    },
    /** @private */
    _setAttributes: function (properties)
    {
        var key;
        for(key in properties)
        {
            if(properties.hasOwnProperty(key))
            {
                var func = this._setters[key];
                if(func)
                {
                    func(properties[key]);
                }
                else
                {
                    func = this["set" + key.charAt(0).toUpperCase() + key.substring(1)];
                    if(typeof func === "function")
                    {
                        var fn = func.bind(this);
                        fn(properties[key]);
                    }
                    else
                    {
                        console.log("Setter for '" + key + "' not found for " + this.classname);
                    }
                }
            }
        }
        return this;
    },
    _registerSetters: function ()
    {
        this._setters.scrollFeeling = this.setScrollFeeling.bind(this);
        this._setters.itemSize = this.setItemSize.bind(this);
        this._setters.frame = this.setFrame.bind(this);
        this._setters.scrollDirection = this.setScrollDirection.bind(this);
        this._setters.snap = this.setSnap.bind(this);
        this._setters.scrollLock = this.setScrollLock.bind(this);
        this._setters.scrollPosition = this.setScrollPosition.bind(this);
    },
    /** @private
     * This function calculates application of deltas over the range of positions.
     */
    _applyRange: function (position, delta, lower, upper)
    {
        if(delta === 0)
        {
            return position;
        }
        //Handle positive delta
        if(delta > 0)
        {
            //If we're below our lower bound, only move by range factor.
            if(position < lower)
            {
                position += delta * this._feeling.rangeFactor;
                //If we've moved into range, apply the delta into range and save the remainder.
                if(position >= lower)
                {
                    delta = (position - lower) / this._feeling.rangeFactor;
                    position = lower;
                }
                else
                {
                    return position;
                }
            }
            //If we're inside our bounds, apply the delta
            if(position < upper)
            {
                //if the delta will place us out of range, apply it and save the remainder.
                if(position + delta > upper)
                {
                    delta -= (upper - position);
                    position = upper;
                    delta *= this._feeling.rangeFactor;
                }
            }
            //We're out of range, so only apply by range factor.
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        //Handle negative delta; same thing, just bounds reversed.
        else if(delta < 0)
        {
            if(position > upper)
            {
                position += delta * this._feeling.rangeFactor;
                if(position <= upper)
                {
                    delta = (position - upper) / this._feeling.rangeFactor;
                    position = upper;
                }
                else
                {
                    return position;
                }
            }
            if(position > lower)
            {
                if(position + delta < lower)
                {
                    delta -= (lower - position);
                    position = lower;
                    delta *= this._feeling.rangeFactor;
                }
            }
            else
            {
                delta *= this._feeling.rangeFactor;
            }
        }
        return position + delta;
    },
    /** @private */
    _giveTouchesToChildren: function (touch, array)
    {
        var i = 0;
        if(array && array.length > 0)
        {
            for(i = array.length - 1; i >= 0; i--)
            {
                var arrayItem = array[i];
                if(arrayItem instanceof AbstractView && arrayItem._isTouchInFrame(touch) && arrayItem._enabled && arrayItem._visible && arrayItem._clickable)
                {
                    var retInstance = arrayItem._touchReceivedCallBack(touch, true);
                    if(retInstance)
                    {
                        return retInstance;
                    }
                }
            }
        }
        return null;
    },
    /** @private */
    _updateClipRect: function ()
    {
        var pos = this.localToScreen(new Vector(0, 0));
        var size = this._frame.getSize();
        size = new Vector(size.getWidth(), size.getHeight());
        var adjustedSize = this.localToScreen(size);
        if(pos && adjustedSize)
        {
            var x = pos.getX();
            var y = pos.getY();
            var w = (adjustedSize.getX() - x);
            var h = (adjustedSize.getY() - y);
            if(x === this._lastClipRectFrame[0] && y === this._lastClipRectFrame[1] && w === this._lastClipRectFrame[2] && h === this._lastClipRectFrame[3])
            {
                return true;
            }
            this._lastClipRectFrame = [x, y, w, h];
            this.setClipRect(this._lastClipRectFrame);
            return true;
        }
        else
        {
            return false;
        }
    },
    /** @private */
    _onUpdate: function (delta)
    {
        this._updateClipRect();
        var sf = this._feeling.smoothingFactor;
        var hasTouch = this._dragger.hasTouch();
        //Our ranges are negative because we push the origin up/left from the start position.
        var h_upper = 0;
        var h_lower = this._frame.getSize().getWidth() - this._contentSize.getWidth();
        if(h_lower > -1)
        {
            h_lower = -1;
        }
        var v_upper = 0;
        var v_lower = this._frame.getSize().getHeight() - this._contentSize.getHeight();
        if(v_lower > -1)
        {
            v_lower = -1;
        }
        var new_x = this._content.getPosition().getX();
        var new_y = this._content.getPosition().getY();
        //if we're in bounds and we have no movement, don't bother updating
        if(delta.x === 0 && delta.y === 0)
        {
            if(this._momentum.x === 0 && this._momentum.y === 0)
            {
                if(hasTouch || ((new_x >= h_lower) && (new_x <= h_upper) && (new_y >= v_lower) && (new_y <= h_upper)))
                {
                    this._scrollbar.updateAlpha(this._momentum);
                    return;
                }
            }
        }
        //If we have touches accumulate momentum
        if(hasTouch)
        {
            if(this._snap)
            {
                if(this._dragger.getTouch().hasMoved)
                {
                    this._momentum.x = sf * delta.x + (1 - sf) * this._momentum.x;
                    this._momentum.y = sf * delta.y + (1 - sf) * this._momentum.y;
                }
            }
            else
            {
                //Use exponential smoothing to approximate the current momentum
                this._momentum.x = sf * delta.x + (1 - sf) * this._momentum.x;
                this._momentum.y = sf * delta.y + (1 - sf) * this._momentum.y;
            }
        }
        //Otherwise, consume the momentum.
        else if(this._snap)
        {
            delta.x += this._momentum.x * sf;
            delta.y += this._momentum.y * sf;
            if(this._momentum.x < 5 && this._momentum.x > -5)
            {
                delta.x = this._momentum.x;
                this._momentum.x = 0;
            }
            if(this._momentum.y < 5 && this._momentum.y > -5)
            {
                delta.y = this._momentum.y;
                this._momentum.y = 0;
            }
            this._momentum.x = this._momentum.x * (1 - sf);
            this._momentum.y = this._momentum.y * (1 - sf);
        }
        else
        {
            delta.x += this._momentum.x;
            delta.y += this._momentum.y;
            //Apply friction, stop if we're below a small threshold.
            this._momentum.x *= this._feeling.friction;
            this._momentum.y *= this._feeling.friction;
            if(this._momentum.x < 1 && this._momentum.x > -1)
            {
                this._momentum.x = 0;
            }
            if(this._momentum.y < 1 && this._momentum.y > -1)
            {
                this._momentum.y = 0;
            }
        }
        //Handle any deltas
        if(this._scroll === this.ScrollDirection.Horizontal)
        {
            new_x = this._applyRange(new_x, delta.x, h_lower, h_upper);
        }
        else
        {
            new_y = this._applyRange(new_y, delta.y, v_lower, v_upper);
        }
        //Without touches to anchor us, we should slide back into range.
        if(!hasTouch)
        {
            if(new_x < h_lower)
            {
                new_x = h_lower - (h_lower - new_x) * this._feeling.stretchDecay;
                if(h_lower - new_x < 1)
                {
                    new_x = h_lower;
                }
            }
            else if(new_x > h_upper)
            {
                new_x = h_upper + (new_x - h_upper) * this._feeling.stretchDecay;
                if(new_x - h_upper < 1)
                {
                    new_x = h_upper;
                }
            }
            if(new_y < v_lower)
            {
                new_y = v_lower - (v_lower - new_y) * this._feeling.stretchDecay;
                if(v_lower - new_y < 1)
                {
                    new_y = v_lower;
                }
            }
            else if(new_y > h_upper)
            {
                new_y = v_upper + (new_y - v_upper) * this._feeling.stretchDecay;
                if(new_y - v_upper < 1)
                {
                    new_y = v_upper;
                }
            }
        }
        this._content.setPosition(new_x, new_y);
        this._scrollbar.updatePosition(new_x, new_y);
    },
    /** @private */
    _evaluateSnapMomentum: function (touch)
    {
        var mod, xSpeed, ySpeed;
        xSpeed = (touch.x - touch.sx) / (touch.endTime - touch.startTime);
        ySpeed = (touch.y - touch.sy) / (touch.endTime - touch.startTime);
        if(isNaN(xSpeed))
        {
            xSpeed = 0;
        }
        if(isNaN(ySpeed))
        {
            ySpeed = 0;
        }
        switch(this._scroll)
        {
        case this.ScrollDirection.Horizontal:
            mod = (-this._content.getPosition().getX()) % this._itemSize.getWidth();
            if(mod > 0)
            {
                if(((xSpeed < 0) && (mod >= this._itemSize.getWidth() / 2)) || (xSpeed <= -this._feeling.flickSpeed))
                {
                    this._momentum = {
                        x: -this._itemSize.getWidth() + mod,
                        y: 0
                    };
                }
                else if(((xSpeed > 0) && (mod < this._itemSize.getWidth() / 2)) || (xSpeed >= this._feeling.flickSpeed))
                {
                    this._momentum = {
                        x: mod,
                        y: 0
                    };
                }
                else if(xSpeed < 0) //not enough movement to scroll forward
                {
                    this._momentum = {
                        x: mod,
                        y: 0
                    };
                }
                else //not enough movement back to scroll back
                {
                    this._momentum = {
                        x: -this._itemSize.getWidth() + mod,
                        y: 0
                    };
                }
            }
            break;
        case this.ScrollDirection.Vertical:
            mod = (-this._content.getPosition().getY()) % this._itemSize.getHeight();
            if(mod > 0)
            {
                if(((ySpeed < 0) && (mod >= this._itemSize.getHeight() / 2)) || (ySpeed <= -this._feeling.flickSpeed))
                {
                    this._momentum = {
                        x: 0,
                        y: -this._itemSize.getHeight() + mod
                    };
                }
                else if(((ySpeed > 0) && (mod < this._itemSize.getHeight() / 2)) || (ySpeed >= this._feeling.flickSpeed))
                {
                    this._momentum = {
                        x: 0,
                        y: mod
                    };
                }
                else if(ySpeed < 0) //not enough movement to scroll up
                {
                    this._momentum = {
                        x: 0,
                        y: mod
                    };
                }
                else //not enough movementto scroll down
                {
                    this._momentum = {
                        x: 0,
                        y: -this._itemSize.getHeight() + mod
                    };
                }
            }
            break;
        }
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/CheckBox'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/CheckBox'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/CheckBox'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/CheckBox.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K, Ihsan H
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Size = require('NGCore/Client/Core/Size').Size;
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var View = require('NGGo1.3/GLUI/View').View;
var Label = require('NGGo1.3/GLUI/Label').Label;
var Image = require('NGGo1.3/GLUI/Image').Image;
var Button = require('NGGo1.3/GLUI/Button').Button;

exports.CheckBox = Button.subclass( /** @lends GLUI.CheckBox.prototype */
{
    classname: "CheckBox",
    /**
     * @class The <code>CheckBox</code> class constructs objects that handle the state of application checkboxes.
     * @constructs The default constructor.
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments GLUI.Button
     */
    initialize: function ($super, properties)
    {
        $super();
        this._text.setTextGravity([0.5, 0.5]);
        this._spriteSize = [64, 64];
        this._unregisterProperties();
        if (properties)
        {
            this.setAttributes(properties);
        }
    },
    destroy: function ($super)
    {
        this._spriteSize = null;
        $super();
    },
    __setFrame: function ($super, frame)
    {
        frame = [frame[0] + 4, frame[1] + 4, frame[2] - 4, frame[3] - 4]; //adding default insets for checkbox;
        $super(frame);
        this._renderView();
    },
    /**
     * @name GLUI.CheckBox#setImage
     * @description Set an image URL for a view state. This defines how a checkbox appears for specific conditions. For example,
     * set different images for a checkbox in the default state and when the checkbox is checked.
     * @example var gameCheck = new GLUI.CheckBox();
     * ...
     * gameCheck.setImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [0,0,1,1]);
     * @see GLUI.CheckBox#getImage
     * @param {String} imageURL The new image URL. Note:please make sure that the textures are in powers of two (square powers recommended)
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @param {uvs} incase you're using portion of a single texture file.
     * @status Android, Test
     * @function
     */
    setImage: function ($super, imageURL, flags, imageSize)
    {
        if (!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject._setClickable(false);
            this._imageObject.setImageFit(Commands.FitMode.AspectHeight);
            this._imageObject.setImageGravity([0, 0]);
        }
        if (!imageSize || imageSize.length < 2)
        {
            if (this._frame[3] > 0)
            {
                var x = this._frame[2];
                var y = this._frame[3];
                imageSize = [x, y];
            }
            else
            {
                imageSize = this._spriteSize;
            }
        }
        this._imageObject.setImage(imageURL, flags, [imageSize[0], imageSize[1]]);
        this._adjustFrameForText();
        this._renderView();
    },
    /**
     * @name GLUI.CheckBox#setChecked
     * @description Set whether this <code>CheckBox</code> is "checked".
     * @example var gameCheck = new GLUI.CheckBox();
     * ...
     * gameCheck.setChecked(true);
     * @param {Boolean} checked Set as <code>true</code> if this <code>CheckBox</code> is "checked".
     * @see GLUI.CheckBox#getChecked
     * @status  Android
     * @function
     */
    setChecked: function (checked)
    {
        if (checked)
        {
            this.addState(Commands.State.Checked);
        }
        else
        {
            this.clearState(Commands.State.Checked);
        }
    },
    /**
     * @name GLUI.CheckBox#getChecked
     * @description Retrieve whether this <code>CheckBox</code> is currently "checked".
     * @returns {Boolean} Returns <code>true</code> if this <code>CheckBox</code> is currently "checked".
     * @see GLUI.CheckBox#setChecked
     * @status  Android
     * @function
     */
    getChecked: function ()
    {
        return (this._state & Commands.State.Checked) ? true : false;
    },
    /**
     * @name GLUI.CheckBox#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>CheckBox</code> node.
     * @example var box = new GLUI.CheckBox();
     * ...
     * box.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.CheckBox#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function(fontLocation){
        this._text.setFontLocation(fontLocation);
        return this;
    },
     /**
     * @name GLUI.CheckBox#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>CheckBox</code> node.
     * @example var box = new GLUI.CheckBox();
     * ...
     * box.getFontLocation();
     * @see GLUI.CheckBox#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function(){
        return this._text.getFontLocation();
    },

    /**
     * @private
     * */
    _unregisterProperties: function ()
    {
        var i;
        var unsupportedProperties = ['imageFit', 'imageGravity'];
        for (i = 0; i < unsupportedProperties.length; i++)
        {
            var propertyName = unsupportedProperties[i];
            var methodName = propertyName.slice();
            methodName[0] = propertyName[0].toUpperCase();
            var setterName = 'set' + methodName;
            var getterName = 'get' + methodName;
            //deleting setter method
            if (this[setterName] !== null)
            {
                delete this[setterName];
                this[setterName] = null;
            }
            //deleting getter method
            if (this[getterName] !== null)
            {
                delete this[getterName];
                this[getterName] = null;
            }
            //deleting setters property
            if (this._setters[propertyName])
            {
                this._setters[propertyName] = null;
                delete this._setters[propertyName];
            }
            //deleting getter property
            if (this._getters[propertyName])
            {
                this._getters[propertyName] = null;
                delete this._getters[propertyName];
            }
        }
        if (this.getChildrenCount)
        {
            delete this.getChildrenCount;
            this.getChildrenCount = undefined;
        }
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.checked = this.setChecked.bind(this);
    },
    /**
     * @private
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters.checked = this.getChecked.bind(this);
    },
    /**
     * @private
     * */
    _adjustFrameForText: function ()
    {
        var size = this.__getImageSize();
        var w = size.getWidth();
        var h = size.getHeight();
        //      var h = this._frame[3] || this._spriteSize[1];
        this._spriteSize = [w, h];
        var x = w + 5;
        var y = this._text.getGLObject().getPosition().getY();
        w = (this._frame[2] > x) ? this._frame[2] - x : 0;
        var frame = [x, y, w, h];
        if (w < 1)
        {
            this._text.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._text.setVisible(true);
        }
        this._text.setFrame(frame);
    },
    /**
     * @private
     * */
    __getImageSize: function ()
    {
        var w = 64;
        var h = 64;
        if (this._imageObject)
        {
            var size = this._imageObject.___getSpriteSizeForCheckBox();
            w = size[0];
            h = size[1];
        }
        return new Size(w, h);
    },
    /**
     * @private
     * */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @private
     * */
    _renderView: function ($super)
    {
        $super();
        this._text.setState(this.getState());
        this._adjustFrameForBgImage();
        this._adjustFrameForText();
    },
    /**
     * @private
     * */
    _endTap: function ($super)
    {
        $super();
        if (this._state & Commands.State.Checked)
        {
            this.clearState(Commands.State.Checked);
        }
        else
        {
            this.addState(Commands.State.Checked);
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/CellView'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/CellView'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/CellView'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/CellView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Ihsan H
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Size = require('NGCore/Client/Core/Size').Size;
var Rect = require('NGCore/Client/Core/Rect').Rect;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var View = require('NGGo1.3/GLUI/View').View;
var Label = require('NGGo1.3/GLUI/Label').Label;
var Image = require('NGGo1.3/GLUI/Image').Image;

exports.CellView = View.subclass( /** @lends GLUI.CellView.prototype */
{
    classname: "CellView",
    /**
     * @class The <code>CellView</code> class constructs objects that handle cell views in an application. For example, a cell in a scrolling list.
     * These objects are rendered with images on the left and right, and two text areas (title and text) stacked vertically in the middle.
     * @name GLUI.CellView
     * @augments GLUI.View
     */
    initialize: function ($super, properties)
    {
        $super();
        this._rightImage = null;
        this._text = new Label();
        this._text._setClickable(false);
        this._text.setTextGravity([0, 0.5]);
        this.addChild(this._text);
        this._text.setBackgroundColor("00000000");
        this._spriteSize = [64, 64];
        this._title = null;
        if (properties)
        {
            this.setAttributes(properties);
        }
        return this;
    },
    destroy: function ($super)
    {
        if (this._rightImage)
        {
            this._rightImage.destroy();
            this._rightImage = null;
        }
        if (this._title)
        {
            this._title.destroy();
            this._title = null;
        }
        this._spriteSize = null;
        if (this._text)
        {
            this._text.destroy();
            this._text = null;
        }
        $super();
    },
/**
    @private
    */
    __setFrame: function ($super, frame)
    {
        this._text.setFrame([0, 0, this._frame[2], this._frame[3]]);
        if (!this.getOnClick())
        {
            this.setOnClick(function ()
            {});
        }
        $super(frame);
        this._updateDepth();
        this._renderView();
    },
    /**
     * @name GLUI.CellView#setFontLocation
     * @description Set the directory path to the location of a font used by this <code>CellView</code> node.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setFontLocation(0);
     * @param {GLUI.Commands.FontLocation} fontLocation The new value for <code>fontLocation</code>.
     * @see GLUI.CellView#getFontLocation
     * @status Android, Test
     * @function
     */
    setFontLocation: function (aFontLocation)
    {
        this._text.setFontLocation(aFontLocation);
        if (this._title)
        {
            this._title.setFontLocation(aFontLocation);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getFontLocation
     * @description Retrieve the directory path to the location of a font used by this <code>CellView</code> node.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.getFontLocation();
     * @see GLUI.CellView#setFontLocation
     * @status Android, Test
     * @function
     */
    getFontLocation: function ()
    {
        return this._text.getFontLocation();
    },
    /** 
     * @name GLUI.CellView#setImage
     * @description Set an image URL for a view state. This property defines how an image appears for specific conditions. For example,
     * set one image for the default view state and another image for a view state with focus.
     * @example var splashGraphic = new GLUI.CellView();
     * ...
     * splashGraphic.setImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [100,100]);
     * @see GLUI.CellView#getImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {imageSize} dimension of the GLTexture - this is important as GL requires dimension while applying imageFit properties.
     * @status  Android, Test
     * @function
     */
    setImage: function ($super, imageURL, flags, imageSize)
    {
        this.__setterCalledForImageObject();
        if (!imageSize || imageSize.length < 2)
        {
            if (this._frame[3] > 0)
            {
                var x = this._frame[2];
                var y = this._frame[3];
                imageSize = [x, y];
            }
            else
            {
                imageSize = this._spriteSize;
            }
        }
        this._imageObject.setImage(imageURL, flags, imageSize);
        this._renderView();
    },
    /**
     * @name GLUI.CellView#setImageFit
     * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control
     * @example background.setImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} imageFit The new value for <code>imageFit</code>.
     * @see GLUI.CellView#getImageFit
     * @status Android, Test
     * @function
     */
    setImageFit: function (FitMode)
    {
        this.__setterCalledForImageObject();
        if (this._imageObject)
        {
            this._imageObject.setImageFit(FitMode);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setImageGravity
     * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
     * @example background.setImageGravity([0.5, 0.0]);
     * @param {Array(Number)} imageGravity The new value for <code>imageGravity</code> (expressed as two floats).
     * @see GLUI.CellView#getImageGravity
     * @function
     * @status Android, Test
     */
    setImageGravity: function (imageGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                imageGravity = [arguments[0], arguments[1]];
            }
            this._imageObject.__setImageGravity(imageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setImageGravity in " + this.classname);
        }
    },
    /**
    @private
    */
    __setImageGravity: function (imageGravity)
    {
        this.__setterCalledForImageObject();
        if (this._imageObject)
        {
            this._imageObject.setImageFit(this.getImageFit());
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getImageFit
     * @description Retrieve the value of the <code>imageFit</code> property.
     * @returns {Number} The current value of <code>imageFit</code>.
     * @see GLUI.CellView#setImageFit
     * @status Android, Test
     * @function
     */
    getImageFit: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageFit();
        }
        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.CellView#getImageGravity
     * @description Retrieve the value of the <code>imageGravity</code> property.
     * @returns {Number} The current value of <code>imageGravity</code>
     * @see GLUI.CellView#setImageGravity
     * @status Android, Test
     * @function
     */
    getImageGravity: function ()
    {
        if (this._imageObject)
        {
            return this._imageObject.getImageGravity();
        }

        return [0.5, 0.5];
    },
    setState: function ($super, flags)
    {
        $super(flags);
        this._text.setState(flags);
        if (this._title)
        {
            this._title.setState(this.getState());
        }
        if (this._rightImage)
        {
            this._rightImage.setState(this.getState());
        }
    },
    /**
     * @name GLUI.CellView#getRightImage
     * @description Retrieve the value of the <code>rightImage</code> property in the specified view state.
     * @returns {String} The current value of <code>rightImage</code>.
     * @function
     * @see GLUI.CellView#setRightImage
     * @status Android, Test
     */
    getRightImage: function (flags)
    {
        if (this._rightImage)
        {
            return this._rightImage.getImage(flags);
        }

        return undefined;
    },
    /**
     * @name GLUI.CellView#getRightImageFit
     * @description Retrieve the value of the <code>rightImageFit</code> property.
     * @returns {Number} The current value of <code>rightImageFit</code>.
     * @status Android, Test
     * @see GLUI.CellView#setRightImageFit
     * @function
     */
    getRightImageFit: function ()
    {
        if (this._rightImage)
        {
            return this._rightImage.getImageFit();
        }

        return Commands.FitMode.Inside;
    },
    /**
     * @name GLUI.CellView#getRightImageGravity
     * @description Retrieve the value of the <code>rightImageGravity</code> property.
     * @returns {Number} The current value of <code>rightImageGravity</code>.
     * @function
     * @status Android, Test
     * @see GLUI.CellView#setRightImageGravity
     */
    getRightImageGravity: function ()
    {
        if (this._rightImage)
        {
            return this._rightImage.getImageGravity();
        }

        return [0.5, 0.5];
    },
    /**
     * @name GLUI.CellView#getTitle
     * @description Retrieve the value of the <code>title</code> property in a view state.
     * @returns {String} The current value of <code>title</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @function
     * @see GLUI.CellView#setTitle
     */
    getTitle: function (flags)
    {
        if (this._title)
        {
            return this._title.getText(flags);
        }
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleColor
     * @description Retrieve the value of the <code>titleColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>titleColor</code>.
     * @see GLUI.CellView#setTitleColor
     * @status Android, Test
     * @function
     */
    getTitleColor: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextColor(flags);
        }
        
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleFont  
     * @description Retrieve the value of the <code>titleFont</code> property in a view state. 
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The UI view state.
     * @returns {String} The current value of <code>titleFont</code>.
     * @function
     * @see GLUI.CellView#setTitleFont
     * @status Android, Test
     */
    getTitleFont: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextFont(flags);
        }
        
        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleGravity
     * @description Retrieve the value of the <code>titleGravity</code> property. 
     * @returns {Array (Number)} The current value of <code>titleGravity</code>.
     * @see GLUI.CellView#setTitleGravity
     * @function
     * @status Android, Test
     */
    getTitleGravity: function ()
    {
        if (this._title)
        {
            return this._title.getTextGravity();
        }

        return [0.5, 0.5];
    },
    /**
     * @name GLUI.CellView#getTitleInsets
     * @description Retrieve the value of the <code>titleInsets</code> property.
     * @returns {Array (Number)} The current value of <code>titleInsets</code>.
     * @see GLUI.CellView#setTitleInsets
     * @status Android, Test
     * @function
     */
    getTitleInsets: function ()
    {
        if (this._title)
        {
            return this._title.getTextInsets();
        }

        return [0, 0, 0, 0];
    },
    /**
     * @name GLUI.CellView#getTitleShadow
     * @description Retrieve the value of the <code>titleShadow</code> property in a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>titleShadow</code>.
     * @see GLUI.CellView#setTitleShadow
     * @function
     * @status Android, Test
     */
    getTitleShadow: function (flags)
    {
        if (this._title)
        {
            return this._title.getTextShadow(flags);
        }

        return undefined;
    },
    /**
     * @name GLUI.CellView#getTitleSize
     * @description Retrieve the value of the <code>titleSize</code> property.
     * @returns {Number} The current value of <code>titleSize</code>.
     * @see GLUI.CellView#setTitleSize
     * @function
     * @status Android, Test
     */
    getTitleSize: function ()
    {
        if (this._title)
        {
            return this._title.getTextSize();
        }
        return undefined;
    },
    /**
     * @name GLUI.CellView#setRightImage
     * @description Set an image URL for a view state. This property defines how an image appears for specific conditions. For example,
     * set one image for the default view state and another image for a view state with focus.
     * @example var splashGraphic = new GLUI.CellView();
     * ...
     * splashGraphic.setRightImage('./Content/DisabledButton.png', GLUI.Commands.State.Disabled, [100,100]);
     * @see GLUI.CellView#getRightImage
     * @param {String} imageURL The new image URL.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] A set of flags describing the view state(s) for using this URL.
     * @param {imageSize} dimension of the GLTexture - this is important as GL requires dimension while applying imageFit properties.
     * @status  Android, Test
     * @function
     */
    setRightImage: function (imageURL, flags, imageSize)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        this._rightImage.setImage(imageURL, flags, imageSize);
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.CellView#setRightImageFit
     * @description Set the value of the <code>rightImageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control
     * @example closureIcon = new GLUI.CellView();
     * ...
     * closureIcon.setRightImageFit(GLUI.Commands.FitMode.None);
     * @param {Number} rightImageFit The new value for <code>rightImageFit</code>.
     * @status Android, Test
     * @see GLUI.CellView#getRightImageFit
     * @function
     */
    setRightImageFit: function (rightImageFit)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        this._rightImage.setImageFit(rightImageFit);
        return this;
    },
    /**
     * @name GLUI.CellView#setRightImageGravity
     * @description Set the value of the <code>rightImageGravity</code> property. This property defines how a image for a control is positioned within a viewable area.
     * @example var closureIcon = new GLUI.CellView();
     * ...
     * closureIcon.setRightImageGravity([0.5, 0]);
     * @param {Number} rightImageGravity The new value for <code>rightImageGravity</code>.
     * @function
     * @status Android, Test
     * @see GLUI.CellView#getRightImageGravity
     */
    setRightImageGravity: function (rightImageGravity)
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            this._makeRightImage();
        }
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                rightImageGravity = [arguments[0], arguments[1]];
            }
            this._rightImage.__setImageGravity(rightImageGravity);
        }
        else
        {
            throw new Error("Too few arguments for setRightImageGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTitle
     * @description Set the value of the <code>title</code> property for a view state. This property defines the title string for a view in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitle('Game of Foo');
     * @param {String} title The new value for <code>title</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @see GLUI.CellView#getTitle
     * @function
     */
    setTitle: function (title, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setText(title, flags);
        this._title.setTextGravity([0, 0.5]);
        this._renderView();
        return this;
    },
    /**
     * @name GLUI.CellView#setText
     * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label in the specified view state.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setText("Friends List");
     * @param {String} text The new value for <code>text</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getText
     * @status Android,Test
     * @function
     */
    setText: function (text, flags)
    {
        this._text.setText(text, flags || Commands.State.Normal);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextColor
     * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string for a label in the specified view state.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextColor('FFFF');
     * @param {String} textColor The new value for <code>textColor</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextColor
     * @status Android, Test
     * @function
     */
    setTextColor: function (textColor, flags)
    {
        this._text.setTextColor(textColor, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextFont
     * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a cellView.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextFont(myFont);
     * @param {String} textFont The new value for <code>textFont</code>.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextFont
     * @status Android, Test
     * @function
     */
    setTextFont: function (textFont, flags)
    {
        this._text.setTextFont(textFont, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextSize
     * @description Set the value of the <code>textSize</code> property for this <code>CellView</code>. This property defines the size of text strings for a view.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextGravity([1, 0.5]);
     * @param {Number} textSize The new value for <code>textSize</code>.
     * @see GLUI.CellView#getTextSize
     * @status Android, Test
     * @function
     */
    setTextSize: function (textSize)
    {
        this._text.setTextSize(textSize);
        return this;
    },
    /**
     * @name GLUI.CellView#setTextGravity
     * @description Set the value of the <code>textGravity</code> property for this <code>CellView</code>. This property defines how a text string is positioned within a viewable area.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextGravity([0.1, 0.5]);
     * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
     * @see GLUI.CellView#getTextGravity
     * @status Android, Test
     * @function
     */
    setTextGravity: function (textGravity)
    {
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                textGravity = [arguments[0], arguments[1]];
            }
            this._text.__setTextGravity(textGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTextGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTextShadow
     * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on on text strings in this view.
     * @example var cell = new GLUI.CellView();
     * ...
     * cell.setTextShadow("FF00 0.2");
     * @param {String} textShadow The new value for <code>textShadow</code>.
     * @param {GLUI.Commands.State} [flags=UI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTextShadow
     * @status Android, Test
     * @function
     */
    setTextShadow: function (textShadow, flags)
    {
        this._text.setTextShadow(textShadow, flags);
    },
    /**
     * @name GLUI.CellView#getText
     * @description Retrieve the value of the <code>text</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>text</code>.
     * @see GLUI.CellView#setText
     * @status Android, Test
     * @function
     */
    getText: function (flags)
    {
        return this._text.getText(flags);
    },
    /**
     * @name GLUI.CellView#getTextColor
     * @description Retrieve the value of the <code>textColor</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textColor</code>.
     * @see GLUI.CellView#setTextColor
     * @status Android, Test
     * @function
     */
    getTextColor: function (flags)
    {
        return this._text.getTextColor(flags);
    },
    /**
     * @name GLUI.CellView#getTextSize
     * @description Retrieve the value of the <code>textSize</code> property for this <code>CellView</code>.
     * @returns {Number} The current value of <code>textSize</code>.
     * @see GLUI.CellView#setTextSize
     * @status Android, Test
     * @function
     */
    getTextSize: function ()
    {
        return this._text.getTextSize();
    },
    /**
     * @name GLUI.CellView#getTextFont
     * @description Retrieve the value of the <code>textFont</code> property.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value for <code>textFont</code>.
     * @see GLUI.CellView#setTextFont
     * @status Android, Test
     * @function
     */
    getTextFont: function (flags)
    {
        return this._text.getTextFont(flags);
    },
    /**
     * @name GLUI.CellView#getTextGravity
     * @description Retrieve the value of the <code>textGravity</code> property for this <code>CellView</code>.
     * @returns {Array (Number)} The current value of <code>textGravity</code>.
     * @see GLUI.CellView#setTextGravity
     * @status Android, Test
     * @function
     */
    getTextGravity: function ()
    {
        return this._text.getTextGravity();
    },
    /**
     * @name GLUI.CellView#getTextShadow
     * @description Retrieve the value of the <code>textShadow</code> property for a view state.
     * @param {GLUI.Commands.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @returns {String} The current value of <code>textShadow</code>.
     * @see GLUI.CellView#setTextShadow
     * @status Android, Test
     * @function
     */
    getTextShadow: function (flags)
    {
        return this._text.getTextShadow(flags);
    },
    /**
     * @name GLUI.CellView#setTitleColor
     * @description Set the value of the <code>titleColor</code> property for a view state. This property defines the title string color for the <code>CellView</code> object in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleColor("FFFF0000");
     * @param {String} titleColor The new value for <code>titleColor</code>.
     * @param {UI.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getTitleColor
     * @function 
     * @status Android, Test
     */
    setTitleColor: function (titleColor, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextColor(titleColor, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleFont
     * @description Set the value of the <code>titleFont</code> property in a view state. This property defines the title string font for cell view labels in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleFont(myFont);
     * @param {String} titleFont The new value for <code>titleFont</code>.
     * @param {UI.State} [flags=UI.State.Normal] The UI view state.
     * @function
     * @see UI.CellView#getTitleFont
     * @status iOS, Android, Test
     */
    setTitleFont: function (titleFont, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextFont(titleFont, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleGravity
     * @description Set the value of the <code>titleGravity</code> property. This property defines how a title string is positioned within a viewable area.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleGravity([0.5, 0.0]);
     * @param {Array (Number)} titleGravity The new value for <code>titleGravity</code>.
     * @see GLUI.CellView#getTitleGravity
     * @status Android, Test
     * @function
     */
    setTitleGravity: function (titleGravity)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        if (arguments)
        {
            if (arguments.length >= 2)
            {
                titleGravity = [arguments[0], arguments[1]];
            }
            this._title.__setTextGravity(titleGravity);
        }
        else
        {
            throw new Error("Too few arguments for setTitleGravity in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleInsets
     * @description Set the value of the <code>titleInsets</code> property. This property defines the viewable area of a title string when applying gravity.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleInsets([10,10,10,10]);
     * @param {Array (Number)} titleInsets The new value for <code>textInsets</code>.
     * @function
     * @see GLUI.CellView#getTitleInsets
     * @status Android, Test
     */
    setTitleInsets: function (titleInsets)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        if (arguments)
        {
            if (arguments.length >= 4)
            {
                titleInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            this._title.__setTextInsets(titleInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTitleInsets in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#setTextInsets
     * @description Set the value of the <code>textInsets</code> property. This property defines the viewable area of a text string when applying gravity.
     * @example var cellText = new GLUI.CellView()
     * ...
     * cellText.setTextInsets([10,10,10,10]);
     * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
     * @see GLUI.CellView#getTextInsets
     * @status Android, Test
     * @function
     */
    setTextInsets: function (textInsets)
    {
        if (arguments)
        {
            if (arguments.length >= 4)
            {
                textInsets = [arguments[0], arguments[1], arguments[2], arguments[3]];
            }
            this._text.__setTextInsets(textInsets);
        }
        else
        {
            throw new Error("Too few arguments for setTextInsets in " + this.classname);
        }
        return this;
    },
    /**
     * @name GLUI.CellView#getTextInsets
     * @description Retrieve the value of the <code>textInsets</code> property.
     * @returns {Array (Number)} The curent value for <code>textInsets</code>.
     * @see GLUI.CellView#setTextInsets
     * @status Android, Test
     * @function
     */
    getTextInsets: function ()
    {
        return this._text.getTextInsets();
    },
    /**
     * @name GLUI.CellView#setTitleShadow
     * @description Set the value of the <code>titleShadow</code> property in a view state. This property defines the amount of text shadowing used for title strings in a cell view.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleShadow('FFCCCCFF 0.2');
     * @param {String} titleShadow The new value for <code>titleShadow</code>.
     * @param {UI.State} [flags=GLUI.Commands.State.Normal] The GLUI view state.
     * @status Android, Test
     * @see GLUI.CellView#getTitleShadow
     * @function
     */
    setTitleShadow: function (titleShadow, flags)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextShadow(titleShadow, flags);
        return this;
    },
    /**
     * @name GLUI.CellView#setTitleSize
     * @description Set the value of the <code>titleSize</code> property. This property defines the text size of title strings in the specified view state.
     * @example var cellTitle = new GLUI.CellView()
     * ...
     * cellTitle.setTitleSize(32);
     * @param {Number} titleSize The new value for <code>textSize</code>.
     * @function
     * @see GLUI.CellView#getTitleSize
     * @status Android, Test
     */
    setTitleSize: function (titleSize)
    {
        if (this._title === null || this._title === undefined)
        {
            this._makeTitle();
        }
        this._title.setTextSize(titleSize);
        return this;
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _makeTitle: function ()
    {
        this._title = new Label();
        this._title.setFontLocation(this._text.getFontLocation());
        this._title._clickable = false;
        this.addChild(this._title);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _makeRightImage: function ()
    {
        this._rightImage = new Image();
        this._rightImage._clickable = false;
        this.addChild(this._rightImage);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _registerSetters: function ($super)
    {
        $super();
        this._setters.visible = this.setVisible.bind(this);
        Commands._registerSettersForLabel(this);
        Commands._registerSettersForCellView(this);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _registerGetters: function ($super)
    {
        $super();
        Commands._registerGettersForLabel(this);
        this._getters.visible = this.getVisible.bind(this);
        Commands._registerGettersForCellView(this);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    __setterCalledForImageObject: function ()
    {
        if (!this._imageObject)
        {
            this._imageObject = new Image();
            this._internalGLObject.addChild(this._imageObject.getGLObject());
            this._imageObject._clickable = false;
            this._imageObject.getGLObject().setDepth(0);
            this._imageObject.setImageFit(Commands.FitMode.AspectHeight);
            this._imageObject.setImageGravity([0, 0.5]);
        }
        return this._imageObject;
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForText: function ()
    {
        var imageWidth = 0;
        if (!this._frame)
        {
            return;
        }
        if (this._imageObject)
        {
            var size = this.__getImageSize();
            imageWidth = size.getWidth();
        }
        var x = imageWidth;
        var w = this._frame[2] - imageWidth;
        var h = this._frame[3] / 2;
        var frame = [x, h, w, h];
        this._text.setFrame(frame);
        if (w < 1)
        {
            this._text.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._text.setVisible(true);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForRightImage: function ()
    {
        if (this._rightImage === null || this._rightImage === undefined)
        {
            return;
        }
        var frame = [this._frame[2] - 50, 0, 50, this._frame[3]];
        this._rightImage.setFrame(frame);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForBgImage: function ()
    {
        if (this._imageObject)
        {
            var frameForBgImage = [0, 0, this._frame[2], this._frame[3]]; //hence it is a child node of view, its position should be 0, 0 locally as this is a background.
            this._imageObject.setFrame(frameForBgImage);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _adjustFrameForTitle: function ()
    {
        var imageWidth = 0;
        if (!this._frame || !this._title)
        {
            return;
        }
        if (this._imageObject)
        {
            var size = this.__getImageSize();
            imageWidth = size.getWidth();
        }
        var x = imageWidth;
        var y = 0;
        var w = this._frame[2] - imageWidth;
        var h = this._frame[3] / 2;
        var frame = [x, y, w, h];
        this._title.setFrame(frame);
        if (w < 1)
        {
            this._title.setVisible(false);
            return; //text will not be visible
        }
        else
        {
            this._title.setVisible(true);
        }
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    __getImageSize: function ()
    {
        var w = 1;
        var h = 1;
        if (this._imageObject)
        {
            var size = this._imageObject.___getSpriteSizeForCheckBox();
            w = size[0];
            h = size[1];
        }
        return new Size(w, h);
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _updateView: function ($super)
    {
        $super();
        this._renderView();
    },
    /**
     * @function
     * @private
     * @status Android, Flash
     */
    _renderView: function ()
    {
        this._text.setState(this.getState());
        this._adjustFrameForBgImage();
        this._adjustFrameForText();
        this._adjustFrameForTitle();
        this._adjustFrameForRightImage();
        if (this._title)
        {
            this._title.setState(this.getState());
        }
        if (this._rightImage)
        {
            this._rightImage.setState(this.getState());
        }
    },
    ////////////Empty Functions /////////////
    /**
     * @name GLUI.CellView#setImageInsets
     * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example background.setImageInsets([10,10,10,10]);
     * @param {Number|Array (Number)} imageInsets The new value for <code>imageInsets.</code>. Set as insets or an array of insets (float).
     * @see GLUI.CellView#getImageInsets
     * @status Android, Test
     * @function
     */
    setImageInsets: function (imageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageInsets(imageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#getImageInsets
     * @description Retrieve the value of the <code>imageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number|Array (Number)} The current value of <code>imageInsets.</code>.
     * @see GLUI.CellView#setImageInsets
     * @status Android, Test
     * @function
     */
    getImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageInsets() in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#setRightImageInsets
     * @description Set the value of the <code>rightImageInsets</code> property. This property defines the viewable area of an image when applying gravity.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example closureIcon.setRightImageInsets([10,10,10,10]);
     * @param {Array (Number)} rightImageInsets The new value for <code>rightImageInsets.</code>. Set as floats (t, r, b, l).
     * @see GLUI.CellView#getRightImageInsets
     * @status Android, Test
     * @function
     */
    setRightImageInsets: function (rightImageInsets)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageInsets(rightImageInsets) in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#getRightImageInsets
     * @description Retrieve the value of the <code>rightImageInsets</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>rightImageInsets.</code>.
     * @see GLUI.CellView#setRightImageInsets
     * @status Android, Test
     * @function
     */
    getRightImageInsets: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageInsets() in ' + this.classname);
    },

    /**
     * @name GLUI.CellView#setImageBorder
     * @description Set the value of the <code>imageBorder</code> property. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} imageBorder The new value for <code>imageBorder.</code>.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state.
     * @see GLUI.CellView#getImageBorder
     * @status Android, Test
     * @function
     */
    setImageBorder: function (imageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageBorder(imageBorder, flags) in ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setImageTransform
     * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images used with a cell view.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example background.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} imageTransform The new value for <code>imageTransform.</code> Set as an array of floats (a, b, c, d, tx, ty).
     * @see GLUI.CellView#getImageTransform
     * @status Android, Test
     * @function
     */
    setImageTransform: function (imageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setImageTransform(imageTransform) in ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setRightImageBorder
     * @description Set the value of the <code>rightImageBorder</code> property in the specified view state. This property defines a border for images used in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Object} rightImageBorder The new value for <code>rightImageBorder.</code>
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI View state.
     * @see GLUI.CellView#getRightImageBorder
     * @status Android, Test
     * @function
     */
    setRightImageBorder: function (rightImageBorder, flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageBorder(rightImageBorder, flags) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#setRightImageTransform
     * @description Set the value of the <code>rightImageTransform</code> property. This property defines data compression for images used with right image objects.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var closureIcon = new UI.CellView();
     * ...
     * closureIcon.setRightImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
     * @param {Array (Number)} rightImageTransform The new value for <code>rightImageTransform.</code> Set as six floats (a, b, c, d, tx, ty).
     * @see GLUI.CellView#getRightImageTransform
     * @status Android, Test
     * @function
     */
    setRightImageTransform: function (rightImageTransform)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: setRightImageTransform(rightImageTransform) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getImageBorder
     * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: UI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>imageBorder.</code>.
     * @see GLUI.CellView#setImageBorder
     * @status Android, Test
     * @function
     */
    getImageBorder: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageBorder() ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getImageTransform
     * @description Retrieve the value of the <code>imageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>imageTransform.</code>.
     * @see GLUI.CellView#setImageTransform
     * @status Android, Test
     * @function
     */
    getImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getImageTransform() ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getRightImageBorder
     * @description Retrieve the value of the <code>rightImageBorder</code> property in the specified view state.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state.
     * @returns {Object} The current value of <code>rightImageBorder.</code>.
     * @see GLUI.CellView#setRightImageBorder
     * @status Android, Test
     * @function
     */
    getRightImageBorder: function (flags)
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageBorder(flags) ' + this.classname);
    },


    /**
     * @name GLUI.CellView#getRightImageTransform
     * @description Retrieve the value of the <code>rightImageTransform</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Array (Number)} The current value of <code>rightImageTransform.</code>.
     * @see GLUI.CellView#setRightImageTransform
     * @status Android, Test
     * @function
     */
    getRightImageTransform: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation: getRightImageTransform() ' + this.classname);
    }

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/ListView'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/ListView'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/ListView'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/ListView.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Vector = require('NGCore/Client/Core/Vector').Vector;
var Root = require('NGCore/Client/GL2/Root').Root;
var ScrollView = require('NGGo1.3/GLUI/ScrollView').ScrollView;
exports.ListView = ScrollView.subclass( /** @lends GLUI.ListView.prototype */
{
    classname: 'ListView',
    /**
     * @class The <code>ListView</code> class constructs objects that contain <code>{@link GLUI.ListViewItem}</code> and <code>{@link GLUI.ListViewSection}</code> objects.
     * These objects handle and render scrolling lists in an application.
     * A <code>ListView</code> object can contain potentially thousands of items,
     * in sections, that use a pool of reusable views to display content.
     * @name GLUI.ListView
     * @constructs
     * @augments GLUI.ScrollView
     */
    ScrollDirection: {
        Horizontal: 1,
        Vertical: 2
    },
    initialize: function (properties)
    {
        this._myFrame = null;
        this._reusableViewsPool = [];
        this._viewsPool = [];
        this._completeItemsList = null;
        this._isSetSection = false;
        if (properties)
        {
            this.setAttributes(properties);
        }
    },
    /**
     * @name GLUI.ListView#setSections
     * @description Set the list of sections that this <code>ListView</code> contains.
     * @example var sections = [];
     * var section = new GLUI.ListViewSection;
     * ...
     * var items = [];
     * for(news in News)
     * {
     *  var item = new ListItem.ListItem();
     *  item.game = News[news];
     *  items.push(item);
     * }
     *
     * section.setItems(items);
     * sections.push(section);
     *
     * gameNews.setSections(sections);
     * @param {Object} newSections A new aray of section IDs.
     * @see GLUI.ListView#getSections
     * @function
     * @status  Android
     */
    setSections: function (sectArray)
    {
        this._momentum = {
            x: 0,
            y: 0
        };
        this.setScrollPosition([0, 0]);
        if (!this._myFrame)
        {
            throw new Error("ListView expects setFrame([x,y,w,h]) to be called before setSections(sections)");
        }
        if (sectArray instanceof Array)
        {
            if (this._viewsPool)
            {
                var key, j;
                for (key in this._viewsPool)
                {
                    if (this._viewsPool.hasOwnProperty(key))
                    {
                        var individualArr = this._viewsPool[key];
                        for (j = 0; j < individualArr.length; j++)
                        {
                            if (individualArr[j]._listItem)
                            {
                                this._addToReUsableViewsArray(individualArr[j], individualArr[j]._listItem._reusableID);
                            }
                        }
                    }
                }
                this._completeItemsList = [];
                this._sectionsArray = sectArray;
                this._isSetSection = true;
            }
        }
        else
        {
            throw new Error(this.classname + "expects Array in setSections(), getting object of " + sectArray.type);
        }
    },
    /**
     * @name GLUI.ListView#getSections
     * @description Retrieve all contained sections by this <code>ListView</code>.
     * @returns {Object} The current section list as an array of section IDs.
     * @param {}
     * @see GLUI.ListView#setSections
     * @function
     * @status Android
     */
    getSections: function ()
    {
        return this._sectionsArray;
    },
    /**
     * @name GLUI.ListView#reloadData
     * @description Clear this <code>ListView</code> and reload all list data.
     * @see GLUI.ListViewItem,
     * @see GLUI.ListViewSection
     * @status Javascript, Android, Flash
     * @function
     */
    reloadData: function ()
    {
        var i = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            this._sectionsArray[i].flush();
        }
        this.setSections(this._sectionsArray);
    },
    /**
     * @name GLUI.ListView#setHeader
     * @description Set the value for the <code>header</code> property. This string is used as a header for the <code>ListView</code>.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var section = new GLUI.ListViewSection;
     * ...
     * friendHeader.setHeader('This is a header');
     * @param {String} header The new header.
     * @see GLUI.ListView#getHeader
     * @function
     * @status  Android
     */
    setHeader: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  setHeader()  in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#getHeader
     * @description Retrieve the value of the <code>header</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current header.
     * @see GLUI.ListView#setHeader
     * @function
     * @status Android
     */
    getHeader: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  getHeader() in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#setFooter
     * @description Set the value for the <code>footer</code> This string is used as a footer for the <code>ListView.</code>
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @example var section = new GLUI.ListViewSection;
     * ...
     * friendHeader.setFooter('This is a footer');
     * @param {String} footer The new footer.
     * @see GLUI.ListView#getFooter
     * @function
     * @status  Android
     */
    setFooter: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  setFooter() in ' + this.classname);
    },
    /**
     * @name GLUI.ListView#getFooter
     * @description Retrieve the value of the <code>footer</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current footer.
     * @see GLUI.ListView#setFooter
     * @function
     * @status Android
     */
    getFooter: function ()
    {
        console.log('<NGGo> WARNING This method is not implemented due to GL2 limitation:  getFooter() in ' + this.classname);
    },
    /**
     * @private
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters['sections'] = this.setSections.bind(this);
    },
    /**
     * @private 
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters['sections'] = this.getSections.bind(this);
    },
    /**
     * @private
     * @status Android
     * */
    _flushSection: function (sectionObject)
    {
        var indexOfSection = this._sectionsArray.indexOf(sectionObject);
        if (indexOfSection < 0)
        {
            return;
        }
        var indexedSection = this._sectionsArray[indexOfSection];
        var sectionItemsArray = indexedSection.getItems();
        var i = 0;
        for (i = 0; i < sectionItemsArray.length; i++)
        {
            var sectionItem = sectionItemsArray[i];
            if (sectionItem._glView)
            {
                this._addToReUsableViewsArray(sectionItem._glView, sectionItem._reusableID);
            }
        }
    },
    /**
     * @private
     * @status Android
     */
    _evaluateItemPositions: function ()
    {
        var i = 0;
        var itemObject = null;
        var startingPos = 0;
        var currentPos = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            var indexedSectArray = this._sectionsArray[i];
            indexedSectArray._parentListView = this;
            indexedSectArray._updateHeight();
            var j = 0;
            var itemsArray = indexedSectArray.getItems();
            var titleView = indexedSectArray.getTitleView();
            var titleWidthHeight = 0;
            if (titleView)
            {
                if (this._scroll === this.ScrollDirection.Horizontal)
                {
                    if (titleView.getFrame())
                    {
                        titleView.setFrame([currentPos, 0, titleView._frame[2], this._frame[3]]);
                        titleView._prevPos = new Vector(currentPos, 0);
                        indexedSectArray._startingPos = currentPos;
                        titleWidthHeight = titleView._frame[2];
                        titleView._isOnTop = false;
                        titleView._hasBeenPlaced = false;
                    }
                }
                else
                {
                    if (titleView.getFrame())
                    {
                        titleView.setFrame([0, currentPos, this._frame[2], titleView._frame[3]]);
                        titleView._prevPos = new Vector(0, currentPos);
                        indexedSectArray._startingPos = currentPos;
                        titleWidthHeight = titleView._frame[3];
                        titleView._isOnTop = false;
                        titleView._hasBeenPlaced = false;
                    }
                }
                this.addChild(titleView);
            }
            currentPos += titleWidthHeight;
            for (j = 0; j < itemsArray.length; j++)
            {
                itemObject = itemsArray[j];
                this._completeItemsList.push(itemObject);
                var posVect = null;
                if (this._scroll === this.ScrollDirection.Horizontal)
                {
                    posVect = new Vector(currentPos, 0);
                    itemObject._locationVector = posVect;
                    itemObject._scrollDirection = this._scroll;
                    itemObject._effectiveMeasure = this._frame[3];
                    if (indexedSectArray._rowHeightWidth > 0)
                    {
                        currentPos += indexedSectArray._rowHeightWidth;
                    }
                    else
                    {
                        currentPos += itemObject.getHeight();
                    }
                }
                else
                {
                    posVect = new Vector(0, currentPos);
                    itemObject._locationVector = posVect;
                    itemObject._scrollDirection = this._scroll;
                    itemObject._effectiveMeasure = this._frame[2];
                    if (indexedSectArray._rowHeightWidth > 0)
                    {
                        currentPos += indexedSectArray._rowHeightWidth;
                    }
                    else
                    {
                        currentPos += itemObject.getHeight();
                    }
                }
            }
            indexedSectArray._endingPos = currentPos;
        }
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            this.setContentSize([currentPos - startingPos, this._frame[3]]);
        }
        else
        {
            this.setContentSize([this._frame[2], currentPos - startingPos]);
        }
        this._scrollbar.updateSize(this._scroll, this._myFrame, this._contentSize);
        this._evaluateMarginalLimits();
        this._updateListItems();
        this._updateSectionTitles();
    },
    /**
     * @private
     * @status  Android
     */
    _sortArray: function (arg1, arg2)
    {
        return (arg2._rowHeight - arg1._rowHeight);
    },
    /**
     * @private
     * @status  Android
     */
    _evaluateMarginalLimits: function ()
    {
        if (!this._frame || !this._completeItemsList)
        {
            return;
        }
        var lengthArray = this._completeItemsList.slice(0);
        lengthArray.sort(this._sortArray);
        var margin = 0;
        if (lengthArray.length >= 1)
        {
            margin = lengthArray[0]._rowHeight;
        }
        var origin = this._myFrame.getOrigin();
        var size = this._myFrame.getSize();
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            this._leftTopLimit = origin.getX() - (2 * margin);
            this._rightBottLimit = origin.getX() + size.getWidth() + (2 * margin);
        }
        else if (this._scroll === this.ScrollDirection.Vertical)
        {
            this._leftTopLimit = origin.getY() - (2 * margin);
            this._rightBottLimit = origin.getY() + size.getHeight() + (2 * margin);
        }
    },
    /**
     * @private
     * @status Android
     */
    _updateListItems: function ()
    {
        var i;
        if (!this._completeItemsList)
        {
            return;
        }
        for (i = 0; i < this._completeItemsList.length; i++)
        {
            var listItem = this._completeItemsList[i];
            if (this._isInsideScreen(listItem))
            {
                if (!listItem._glView)
                {
                    var reusableGLView = this._fetchFromReUsableArray(listItem);
                    if (reusableGLView)
                    {
                        listItem.__onSetView(reusableGLView, [listItem._locationVector.getX(), listItem._locationVector.getY()]);
                        this._addToVisibleViews(reusableGLView);
                        reusableGLView.setVisible(true);
                        reusableGLView._listItem = listItem;
                        listItem._glView = reusableGLView;
                    }
                }
            }
            else
            {
                if (listItem._glView)
                {
                    this._removeFromVisibleViews(listItem._glView);
                    this._addToReUsableViewsArray(listItem._glView, listItem._reusableID);
                }
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToVisibleViews: function (glView)
    {
        var itemIndex = this._visibleArray.indexOf(glView);
        if (itemIndex === -1)
        {
            this._visibleArray.splice(0, 0, glView);
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _removeFromVisibleViews: function (glView)
    {
        var itemIndex = this._visibleArray.indexOf(glView);
        if (itemIndex !== -1)
        {
            this._visibleArray.splice(itemIndex, 1);
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _updateSectionTitles: function ()
    {
        if (!this._sectionsArray)
        {
            return;
        }
        var i = 0;
        for (i = 0; i < this._sectionsArray.length; i++)
        {
            var indexedSection = this._sectionsArray[i];
            var titleView = indexedSection.getTitleView();
            if (titleView)
            {
                var yPos = this._content.getPosition().getY();
                var titlePos = titleView._prevPos.getY() + yPos;
                var endPos = indexedSection._endingPos - titleView._frame[3] + yPos;
                if (typeof (titlePos) !== "number" || typeof (endPos) !== "number")
                {
                    return;
                }
                if (!titleView._isOnTop && Math.round(titlePos) < 0)
                {
                    titleView._isOnTop = true;
                }
                else if (titleView._isOnTop && Math.round(titlePos) > 0)
                {
                    titleView._isOnTop = false;
                    titleView.setFrame([titleView._prevPos.getX(), titleView._prevPos.getY(), this._frame[2], titleView._frame[3]]);
                }
                if (titleView._isOnTop)
                {
                    if (endPos < 0)
                    {
                        if ((endPos + titleView._frame[3]) >= 0)
                        {
                            titleView.setFrame([0, endPos - yPos, this._frame[2], titleView._frame[3]]);
                            titleView._hasBeenPlaced = false;
                        }
                        else if (!titleView._hasBeenPlaced)
                        {
                            titleView.setFrame([0, endPos - yPos, this._frame[2], titleView._frame[3]]);
                            titleView._hasBeenPlaced = true;
                        }
                    }
                    else
                    {
                        titleView.setFrame([0, -yPos, this._frame[2], titleView._frame[3]]);
                    }
                }
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _evaluateScrollDirection: function ()
    {
        this.setScrollDirection(this.ScrollDirection.Vertical);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _onUpdate: function ($super, delta)
    {
        var theRoot = null;
        var theGLRoot = null;
        if (this._isSetSection)
        {
            theRoot = this.getRoot();
            theGLRoot = this._getGLRoot();
        }
        if ((theRoot && theRoot.type === "document") || (theGLRoot && theGLRoot === Root))
        {
            this._evaluateItemPositions();
            this._isSetSection = false;
        }
        $super(delta);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _updateScrollingView: function ()
    {
        if (this._needEvaluateMarginalLimits)
        {
            this._evaluateMarginalLimits();
            this._needEvaluateMarginalLimits = false;
        }
        this._updateListItems();
        this._updateSectionTitles();
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _isInsideScreen: function (listItem)
    {
        var listItemPos = listItem._locationVector;
        var convertedPos = this._content.localToScreen(listItemPos);
        if (convertedPos === null || convertedPos === undefined)
        {
            return false;
        }
        if (this._scroll === this.ScrollDirection.Horizontal)
        {
            if (convertedPos.getX() > this._leftTopLimit && convertedPos.getX() < this._rightBottLimit)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            if (convertedPos.getY() > this._leftTopLimit && convertedPos.getY() < this._rightBottLimit)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToReUsableViewsArray: function (glView, index)
    {
        if (glView)
        {
            var requiredReusableArray = this._reusableViewsPool[index];
            requiredReusableArray.push(glView);
            glView.setVisible(false);
            glView._listItem._glView = null;
            glView._listItem = null;
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _addToViewsPool: function (view, index)
    {
        var viewsArray = this._viewsPool[index];
        if (!viewsArray)
        {
            this._viewsPool[index] = [];
            viewsArray = this._viewsPool[index];
        }
        viewsArray.push(view);
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    addChild: function ($super, childNode, index, isInternal)
    {
        if (isInternal)
        {
            $super(childNode, index);
        }
        else
        {
            $super(childNode);
            this._visibleArray.push(childNode);
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    removeChild: function ($super, childNode, isInternal)
    {
        $super(childNode);
        if (!isInternal)
        {
            var index = this._visibleArray.indexOf(childNode);
            if (index !== -1)
            {
                this._visibleArray.splice(index, 1);
            }
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    _fetchFromReUsableArray: function (listItem)
    {
        var i;
        var newReusableView = null;
        var requiredReusableArray = this._reusableViewsPool[listItem._reusableID];
        if (!requiredReusableArray)
        {
            this._reusableViewsPool[listItem._reusableID] = [];
            requiredReusableArray = this._reusableViewsPool[listItem._reusableID];
            newReusableView = listItem._onCreateView();
            this.addChild(newReusableView, 0, true);
            this._addToViewsPool(newReusableView, listItem._reusableID);
            return newReusableView;
        }
        if (requiredReusableArray.length > 0)
        {
            var returnView = requiredReusableArray.pop();
            returnView.setVisible(true);
            return returnView;
        }
        else
        {
            var viewsArray = this._viewsPool[listItem._reusableID];
            for (i = 0; i < viewsArray.length; i++)
            {
                var glView = viewsArray[i];
                var convertedPos = this._content.localToScreen(glView.getGLObject().getPosition().clone());
                if (convertedPos.getX() < this._leftTopLimit || convertedPos.getX() > this._rightBottLimit)
                {
                    this._addToReUsableViewsArray(glView, listItem._reusableID);
                }
            }
        }
        // check again if we have been able to round up some available views..
        if (this._reusableViewsArray && this._reusableViewsArray.length > 0)
        {
            return this._reusableViewsArray.pop();
        }
        else
        {
            newReusableView = listItem._onCreateView();
            this.addChild(newReusableView, 0, true);
            this._addToViewsPool(newReusableView, listItem._reusableID);
            return newReusableView;
        }
    },
    /**
     * @private
     * @status Javascript, iOS, Android, Flash
     */
    destroy: function ()
    {
        var key;
        var j, i = 0;
        if (this._sectionsArray)
        {
            for (i = 0; i < this._sectionsArray.length; i++)
            {
                var indexedSection = this._sectionsArray[i];
                var titleView = indexedSection.getTitleView();
                if (titleView)
                {
                    titleView._prevPos = null;
                }
                indexedSection._parentListView = null;
                indexedSection._startingPos = null;
                indexedSection._endingPos = null;
            }
            this._sectionsArray = null;
        }
        if (this._completeItemsList)
        {
            for (i = 0; i < this._completeItemsList.length; i++)
            {
                this._completeItemsList[i]._locationVector = null;
                this._completeItemsList[i]._scrollDirection = 0;
                this._completeItemsList[i]._effectiveMeasure = 0;
                this._completeItemsList[i]._glView = null;
                this._completeItemsList[i]._rowHeight = 0;
            }
            this._completeItemsList.length = 0;
            this._completeItemsList = null;
        }
        if (this._viewsPool)
        {
            for (key in this._viewsPool)
            {
                if (this._viewsPool.hasOwnProperty(key))
                {
                    var individualArr = this._viewsPool[key];
                    for (j = 0; j < individualArr.length; j++)
                    {
                        individualArr[j]._listItem = null;
                        individualArr[j].destroy();
                    }
                }
            }
            this._viewsPool.length = 0;
            this._viewsPool = null;
        }
        if (this._reusableViewsPool)
        {
            this._reusableViewsPool.length = 0;
            this._reusableViewsPool = null;
        }
        this._isSetSection = null;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/ListViewSection'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/ListViewSection'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/ListViewSection'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/ListViewSection.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Shamas S, Taha S
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Element = require('NGGo1.3/GLUI/Element').Element;
exports.ListViewSection = Element.subclass( /** @lends GLUI.ListViewSection.prototype */
{
    classname: 'ListViewSection',
    'type': 'listview-section',
    /**
     * @class The <code>ListViewSection</code> class constructs objects that contain <code>ListViewItem</code> objects. 
     * These objects are rendered as individual sections of a scrolling list (see <code>{@link GLUI.ListView}</code>).
     * @name GLUI.ListViewSection
     * @constructs
     * @augments GLUI.Element
     */
    initialize: function (properties)
    {
        this._items = [];
        this._rowHeightWidth = 0;
        this._titleView = null;
        this._parentListView = null;
        if (properties)
        {
            this.setAttributes(properties);
        }
    },
    /**
     * @name GLUI.ListViewSection#setItems
     * @description Set the value for the <code>items</code> property.
     * Setting this updates the visual state of the <code>listView</code> if the section is in a <code>listView</code> that is visible.
     * @param {UI.ListViewItem} items The new <code>ListView</code> items.
     * @see UI.ListViewSection#getItems
     * @status Android, Test
     * @function
     */
    setItems: function (items)
    {
        if (items instanceof Array)
        {
            this._items = items; //not creating a deep copy here.
            if (this._parentListView)
            {
                this._parentListView.reloadData();
                //this._updateHeight();     //this will not be called now, listView calls it.
            }
        }
        else
        {
            throw new Error(this.classname + ' setItems() expects an array, getting ' + items.type);
        }
    },
    /**
     * @name GLUI.ListViewSection#setRowHeight
     * @description Set the value for the <code>rowHeight</code> property.
     * @param {Number} rowHeight The new row height.
     * @see GLUI.ListViewSection#getRowHeight
     * @status Android, Test
     * @function
     */
    setRowHeight: function (height)
    {
        if (isNaN(height))
        {
            throw new Error('Expecting number value but found ' + typeof (height) + ' for setRowHeight(height)');
        }
        else if (height === 0)
        {
            throw new Error('Cannot set row height of section = 0');
        }
        else
        {
            this._rowHeightWidth = height;
            //this._updateHeight();     //this will not be called now, listView calls it.
        }
    },
    /**
     * @name GLUI.ListViewSection#getTitleView
     * @description 
     * @see GLUI.ListViewSection#setTitleView
     * @status Android, Test
     * @function
     */
    getTitleView: function ()
    {
        return this._titleView;
    },
    /**
     * @name GLUI.ListViewSection#setTitleView
     * @description Sets the object for <code>title</code> property.
     * @param {View} The GLUI.View object that is to be set as the Section Title View
     * @see GLUI.ListViewSection#getTitleView
     * @function
     */
    setTitleView: function (titleView)
    {
        this._titleView = titleView;
    },
    /**
     * @name GLUI.ListViewSection#setYPosition
     * @description Set the value for the <code>yPosition</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {Number}  yPosition The new position for y.
     * @see GLUI.ListViewSection#getYPosition
     * @function
     */
    setYPosition: function ()
    {
        //to be implemented
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: setYPosition() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getYPosition
     * @description Retrieve the value of the <code>yPosition</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {Number} The current position of y.
     * @see GLUI.ListViewSection#setYPosition
     * @function
     */
    getYPosition: function ()
    {
        //to be implemented
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: getYPosition() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getItems
     * @description Retrieve the value of the <code>items</code> property.
     * @returns {GLUI.ListViewItem} The current <code>ListView</code> items.
     * @see UI.ListViewSection#setItems
     * @status Android, Test
     * @function
     */
    getItems: function ()
    {
        return this._items;
    },
    /**
     * @name GLUI.ListViewSection#getRowHeight
     * @description Retrieve the value of the <code>rowHeight</code> property.
     * @returns {Number} The current row height.
     * @see GLUI.ListViewSection#setRowHeight
     * @status Android, Test
     * @function
     */
    getRowHeight: function ()
    {
        return this._rowHeightWidth;
    },
    /**
     * @name GLUI.ListViewSection#flush
     * @description Reset the visible range for this <code>ListViewSection</code>.
     * @function
     * @status Android, Test
     */
    flush: function ()
    {
        if (this._parentListView)
        {
            this._parentListView._flushSection(this);
        }
    },
    /**
     * @private 
     * */
    destroy: function ()
    {
        this._items = null;
        this._rowHeightWidth = null;
        this._titleView = null;
        this._parentListView = null;
    },
    /**
     * @private 
     * */
    _registerSetters: function ($super)
    {
        $super();
        this._setters['items'] = this._setItemsProperty;
        this._setters['rowHeight'] = this._setRowHeightProperty;
        this._setters['titleView'] = this._setTitleViewProperty;
    },
    /**
     * @private 
     * */
    _registerGetters: function ($super)
    {
        $super();
        this._getters['items'] = this._getItemsProperty;
        this._getters['rowHeight'] = this._getRowHeightProperty;
        this._getters['titleView'] = this._getTitleViewProperty;
    },
    /**
     * @private 
     * */
    _updateHeight: function ()
    {
        var i = 0;
        if (this._items)
        {
            for (i = 0; i < this._items.length; i++)
            {
                this._items[i]._setRowHeight(this._rowHeightWidth);
            }
        }
    },
    ////////// Empty Functions //////////////
    /**
     * @name GLUI.ListViewSection#setTitle
     * @description Set the value for the <code>title</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @param {String} title The new section title.
     * @param {GLUI.State} [flags Optional, Default: GLUI.State.Normal] The GLUI view state. 
     * @see GLUI.ListViewSection#getTitle
     * @function
     */
    setTitle: function ()
    {
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: setTitle() ' + this.classname);
    },
    /**
     * @name GLUI.ListViewSection#getTitle
     * @description Retrieve the value of the <code>title</code> property.
     * <br /><b>Note:<b> <b><i><u>WARNING</u></i></b> This method is not implemented due to GL2 limitation.
     * @returns {String} The current section title.
     * @see GLUI.ListViewSection#setTitle
     * @function
     */
    getTitle: function ()
    {
        console.log('<NGGo>@ WARNING This method is not implemented due to GL2 limitation: getTitle() ' + this.classname);
    },
    /** @private Property accessors*/
    _setItemsProperty: function (callee, args)
    {
        return callee.setItems(args);
    },
    _setRowHeightProperty: function (callee, args)
    {
        return callee.setRowHeight(args);
    },
    _setTitleViewProperty: function (callee, args)
    {
        return callee.setTitleView(args);
    },
    _getItemsProperty: function (callee, args)
    {
        return callee.getItems(args);
    },
    _getRowHeightProperty: function (callee, args)
    {
        return callee.getRowHeight(args);
    },
    _getTitleViewProperty: function (callee, args)
    {
        return callee.getTitleView(args);
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/ListViewItem'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/ListViewItem'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/ListViewItem'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/ListViewItem.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Taha S
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var Class = require('NGCore/Client/Core/Class').Class;
var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
exports.ListViewItem = Class.subclass( /** @lends GLUI.ListViewItem.prototype */
{
    classname: 'ListViewItem',
    /**
     * @class The <code>ListViewItem</code> class constructs objects that contain data for individual items in a scrolling list (see <code>{@link GLUI.ListView}</code>).
     * @name GLUI.ListViewItem
     * @constructs The default constructor.
     * @augments Core.Class
     */
    _setters: [],
    _getters: [],
    initialize: function (reusableID)
    {
        if (reusableID === null || reusableID === undefined)
        {
            this._reusableID = "rid";
        }
        else if (reusableID === "rid")
        {
            throw new Error("Trying to assign reserved ID \"rid\" as Reuse ID");
        }
        else
        {
            this._reusableID = reusableID;
        }
        this._onSetViewCallBack = null;
        this._scrollDirection = 0;
        this._effectiveMeasure = 0;
        this._rowHeight = 0;
        this._heightWidth = 0;
        this._glView = null;
        this._registerSetters();
        this._registerGetters();
        return this;
    },
    /**
     * @name GLUI.ListViewItem#setOnCreateView
     * @description Set the callback for the <code>onCreateView</code> event.
     * This event must return a newly created view that displays the data type represented by the item.
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnCreateView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onCreateView = newFn;
        }
    },
    /**
     * @name GLUI.ListViewItem#setOnReleaseView
     * @description Set the callback for the <code>onReleaseView</code> event. This event occurs when the view is set to <code>null</code>.
     * Use this to remove uncommon view states or clean up the view when necessary.
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnReleaseView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onReleaseView = newFn;
        }
    },
    /**
     * @name GLUI.ListViewItem#setOnSetView
     * @description Set the callback for the <code>onSetView</code> event. When this event occurs, the item puts any relevant visual state / data into <code>newView</code>.
     * This transfer should occur before the item is visible to the user:
     * <pre class="code">onSetView(newView)</pre>
     * @param {Function} newFn The new function to call.
     * @event
     */
    setOnSetView: function (newFn)
    {
        if (typeof (newFn) === "function")
        {
            this._onSetView = newFn;
        }
    },
    /**
     * @private
     * @status Android
     */
    getOnCreateView: function ()
    {
        return this._onCreateView;
    },
    /**
     * @private
     * @status Android
     */
    getOnReleaseView: function ()
    {
        return this._onReleaseView;
    },
    /**
     * @private
     * @status Android
     */
    getOnSetView: function ()
    {
        return this._onSetViewCallBack;
    },
    /**
     * @name GLUI.ListViewItem#getHeight
     * @description Get the current height of the ListViewItem.
     * <pre class="code">getHeight()</pre>
     * This should occur before the item is visible to the user.
     * @returns {Number} The height of this ListViewItem.
     * @function
     * @status Android, Test
     */
    getHeight: function ()
    {
        return this._heightWidth;
    },
    /**
     * @name GLUI.ListViewItem#setHeight
     * @description Set the height of the current ListViewItem in pixels.
     * <pre class="code">setHeight(Number)</pre>
     * This should occur before the item is visible to the user.
     * This setting is only used when the item's ListViewSection has height = -1
     * @param {Number} height The height of the current ListViewItem in pixels.
     * @function
     * @status Android, Test
     */
    setHeight: function (height)
    {
        if (isNaN(height))
        {
            throw new Error('Expecting number value but found ' + typeof (height) + ' for setHeight(height)');
        }
        else if (height === 0)
        {
            throw new Error('Cannot set height of item = 0');
        }
        else
        {
            if (height > 0)
            {
                this._heightWidth = height;
            }
        }
    },
    /**
     * @name GLUI.ListViewItem#getCurrentView
     * @description Retrieve the current view attached to this <code>ListViewItem</code>.
     * @returns {GLUI.View} The current <code>ListViewItem</code> view.
     * @function
     * @status Android, Test
     */
    getCurrentView: function ()
    {
        return this._glView;
    },
    destroy: function ()
    {
        this._scrollDirection = null;
        this._effectiveMeasure = null;
        this._rowHeight = null;
        this._reusableID = null;
        this._glView = null;
        this._heightWidth = null;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _registerSetters: function ()
    {
        this._setters.onCreateView = this.setOnCreateView.bind(this);
        this._setters.onReleaseView = this.setOnReleaseView.bind(this);
        this._setters.onSetView = this.setOnSetView.bind(this);
        this._setters.height = this.setHeight.bind(this);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _registerGetters: function ()
    {
        this._getters.onCreateView = this.getOnCreateView.bind(this);
        this._getters.onReleaseView = this.getOnReleaseView.bind(this);
        this._getters.onSetView = this.getOnSetView.bind(this);
        this._getters.height = this.getHeight.bind(this);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _onCreateView: function ()
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    _onSetView: function ()
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    __onSetView: function (newView, position)
    {
        if (this._rowHeight === 0)
        {
            throw new Error('Missing Row Height of Section');
        }
        if (newView && newView instanceof AbstractView)
        {
            var width = 0;
            var height = 0;
            if (this._scrollDirection === 1)
            {
                height = this._effectiveMeasure;
                width = this._rowHeight;
            }
            else
            {
                width = this._effectiveMeasure;
                height = this._rowHeight;
            }
            newView.setFrame([position[0], position[1], width, height]);
        }
        this._glView = newView;
        this._onSetView(newView);
    },
    /**
     * @function
     * @private
     * @status Android
     */
    _onReleaseView: function (oldView)
    {},
    /**
     * @function
     * @private
     * @status Android
     */
    _setRowHeight: function (rowHeight)
    {
        if (rowHeight < 0)
        {
            this._rowHeight = this._heightWidth;
        }
        else
        {
            this._rowHeight = rowHeight;
        }
    },
    /**
     * @function
     * @private
     * @status Android
     */
    setAttributes: function (dict)
    {
        var key;
        for (key in dict)
        {
            if (dict.hasOwnProperty(key))
            {
                this.setAttribute(key, dict[key]);
            }
        }
        return this;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    getAttributes: function (list)
    {
        var i, accessor;
        var output = {};
        if (list instanceof Array)
        {
            for (i = 0; i < list.length; i++)
            {
                var key = list[i];
                var methodName = this._getters[key];
                if (typeof methodName === 'function')
                {
                    output[key] = this._getters[key](this);
                }
            }
        }
        else
        {
            for (accessor in this._getters)
            {
                if (this._getters.hasOwnProperty(accessor))
                {
                    output[accessor] = this._getters[accessor](this);
                }
            }
        }
        return output;
    },
    /**
     * @function
     * @private
     * @status Android
     */
    getAttribute: function (key)
    {
        var getter = this._getters[key];
        if (typeof getter === 'function')
        {
            return getter(key);
        }
        else
        {
            console.log("Getter for '" + key + "' not found for " + this.classname);
            return undefined;
        }
    },
    /**
     * @function
     * @private
     * @status Android
     */
    setAttribute: function (key, value)
    {
        var myFunction = this._setters[key];
        if (myFunction)
        {
            myFunction(value);
        }
        else
        {
            console.log("Setter for '" + key + "' not found for " + this.classname);
        }
        return this;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Spinner'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Spinner'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Spinner'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Spinner.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil M
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var AbstractView = require('NGGo1.3/GLUI/AbstractView').AbstractView;
var Commands = require('NGGo1.3/GLUI/Commands').Commands;
var Sprite = require('NGGo1.3/GLUI/Sprite').URLSprite;
var UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;

exports.Spinner = AbstractView.subclass(
{
    classname: 'Spinner',
    initialize: function ($super, properties)
    {
        $super();
        this._internalGLObject = new Sprite();
        this._internalGLObject.setScale(1, 1);
        this._imageSpriteSize = [32, 32];
        this._imageURL = null;
        this._fitMode = Commands.FitMode.Stretch;
        this._anchor = [0.5, 0.5];

        if(properties)
        {
            if(properties.hasOwnProperty('imageURL'))
            {
                this._imageURL = properties.imageURL;
            }

            this.setAttributes(properties);
        }

        if(this._imageURL)
        {
            this.setImage(this._imageURL);
            this._setImageFit();
        }

        this._angle = 30;
        this._flag = 0;
        this._listener = new Core.MessageListener();
        UpdateEmitter.addListener(this._listener, this._onUpdate.bind(this));

        return this;
    },

    setFrame: function ($super, frame)
    {
        $super(frame);
        if (this._imageSpriteSize)
        {
            this._setImageFit();
        }
        this._updateView();
    },

    setImage: function (imageURL) //size is imageSize
    {
        var errorMsg;
        if (!imageURL || typeof imageURL !== 'string')
        {
            errorMsg = "Image URL is not correct in " + this.classname + "setImage Method";
            throw new Error(errorMsg);
        }

        try
        {
            this._images[Commands.State.Normal + ''] = [imageURL, this._imageSpriteSize];
            this._updateView();
        }
        catch (exception)
        {
            errorMsg = [];
            errorMsg.push("Exception: setImage()");
            errorMsg.push(exception);
            errorMsg.push(this.classname);
            errorMsg.join();

            throw new Error(errorMsg);
        }
        return this;
    },

    _setImageFit: function ()
    {
        this._fitMode = Commands.FitMode.Stretch;
        var glObject = this._internalGLObject;
        glObject.setScale(1, 1);

        glObject.setImage(this._imageURL, [this._frame[2], this._frame[3]], this._anchor);

        var glPosition = this._getInternalGLObjectPosition();

        var posX = glPosition.getX();
        var posY = glPosition.getY();

        glObject.setPosition([posX, posY]);
        return this;
    },

    _updateView: function ()
    {

        /*in UI.View, if you do not specify the image for normal state, then Image will not be shown for any state
         * so its better to return from there*/
        if (!this._frame || (this._frame && this._frame.length < 4))
        {
            this._frame = [0, 0, 0, 0];
        }

        if (!this._images[Commands.State.Normal + ''] || !this._frame[2] || !this._frame[3])
        {
            return;
        }

        var nextState = (this._state)?this._state:Commands.State.Normal;

        var nextImage = this._images[nextState + ''];
        if (!nextImage || nextImage.length === 0)
        {
            nextImage = this._images[Commands.State.Normal + ''];
        }

        if (nextImage !== null)
        {
            this._imageURL = nextImage[0];
            this._imageSpriteSize = nextImage[1];
            this._setImageFit();
        }
    },

    _onUpdate: function ()
    {
        if(this._flag === 0)
        {
            this._internalGLObject.setRotation(this._angle);
            this._angle = (this._angle + 30)%360;
        }
        this._flag = (this._flag+1)%4;
    },

    destroy: function ($super)
    {
        UpdateEmitter.removeListener(this._listener);
        this._listener.destroy();
        this._imageSpriteSize.length = 0;
        this._imageSpriteSize = null;
        this._imageURL = null;
        $super();
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/Window'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/Window'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/Window'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/Window.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Mizuno T
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Class           = require('NGCore/Client/Core/Class').Class;
var Capabilities    = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var UICommands      = require('NGCore/Client/UI/Commands').Commands;
var Rect            = require('NGGo1.3/GLUI/ViewGeometry').Rect;
var Commands        = require('NGGo1.3/GLUI/Commands').Commands;
var WindowLayer     = require('NGGo1.3/GLUI/WindowLayer').WindowLayer;

var Window = Class.singleton( /** @lends GLUI.Window.prototype */
{
    classname: 'Window',
    _outerWidth: 0,
    _outerHeight: 0,
    _width: 0,
    _height: 0,

    /**
     * @class The <code>Window</code> class constructs a singleton object that manages application access to GLUI.<br><br>
     * <b>Note:</b> An application should never directly allocate a singleton.
     * @name GLUI.Window
     * @augments Core.Class
     * @see GLUI.Window#document
     * @constructs The default constructor.
     */
    initialize: function ()
    {
        if (!this._outerWidth || !this._outerHeight)
        {
            this.setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
        }
        if (!this._width || !this._height)
        {
            this._setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
        }
        Commands.instantiate();
        var LayoutListener = MessageListener.subclass(
        {
            initialize: function ()
            {
                Device.LayoutEmitter.addListener(this, this.onUpdate);
            },
            onUpdate: function (layout)
            {
                Window._setWidthAndHeight(layout.width, layout.height);
            }
        });
        var layout = null;
        layout = new LayoutListener();

    },

    setStatusBarHidden: function (value)
    {
        UICommands.setStatusBarHidden(value);
        this._outerHeight = Capabilities.getScreenHeight() - (value ? 0 : (Capabilities.getStatusBarHeight() || 0));
    },
    log: function (object)
    {
        console.log(object.toString());
    },
    /**
     * Return the available screen width, with respect to orientation and system status bars.
     * @returns {Number} The currently available width in pixels that can be drawn to.
     * @type Number
     * @status Android, Flash
     */
    getWidth: function ()
    {
        return this._width;
    },
    /**
     * Return the available screen height, with respect to orientation and system status bars.
     * @returns {Number} The currently available height in pixels that can be drawn to.
     * @type Number
     * @status Android, Flash
     */
    getHeight: function ()
    {
        return this._height;
    },
    getOuterWidth: function ()
    {
        return this._outerWidth;
    },
    getOuterHeight: function ()
    {
        return this._outerHeight;
    },
    getFrame: function ()
    {
        return new Rect(0, 0, this._width, this._height);
    },
    destroy: function ()
    {},
    document: WindowLayer.singleton(
    {
        'type': 'document',
        'classname': 'WindowLayer'
    }),
    _layers: {},
    _getLayer: function (level)
    {
        if( !this._layers[level] )
        {
            this._layers[level] = new WindowLayer(
        {
            'level': level || 0
                });
        }
        return this._layers[level];
    }
});

Window.__defineGetter__("outerWidth", function ()
{
    return this.getOuterWidth();
});
Window.__defineGetter__("outerHeight", function ()
{
    return this.getOuterHeight();
});
Window._setWidthAndHeight = function (width, height)
{
    this._width = width;
    this._height = height;
};
Window.setWidthAndHeight = function (width, height)
{
    this._outerWidth = width;
    this._outerHeight = height;
};

exports.Window = Window;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/NavController'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/NavController'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/NavController'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/NavController.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Harris K, Awais M
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////
var MessageListener = require("NGCore/Client/Core/MessageListener").MessageListener;
var Vector = require("NGCore/Client/Core/Vector").Vector;
var UpdateEmitter = require("NGCore/Client/Core/UpdateEmitter").UpdateEmitter;
var Time = require("NGCore/Client/Core/Time").Time;
var Analytics = require("NGCore/Client/Core/Analytics").Analytics;
var KeyEmitter = require("NGCore/Client/Device/KeyEmitter").KeyEmitter;
var Device = require("NGCore/Client/Device").Device;
var Capabilities = require("NGCore/Client/Core/Capabilities").Capabilities;
var View = require("NGGo1.3/GLUI/View").View;
var Button = require("NGGo1.3/GLUI/Button").Button;
var Window = require("NGGo1.3/GLUI/Window").Window;
var Node = require("NGCore/Client/GL2/Node").Node; /** @private */

function getAnalyticsName(item)
{
    if(item && item.hasOwnProperty("analyticsName"))
    {
        return item.analyticsName || undefined; // If NULL, return undefined.
    }
    return undefined;
} /** @private */
var NavKeyListener = MessageListener.subclass(
{
    classname: "GLUI_NavController_KeyListener"
});
var MovingAnimation = MessageListener.subclass(
{
    classname: 'MovingAnimation',
    /** @private */
    initialize: function ()
    {},
    startAnimate: function (spriteNode, destination, duration, rem, callBackFunc)
    {
        this._callBackFunc = callBackFunc;
        this._rem = rem;
        this._initialPosition = spriteNode.getPosition();
        this._spriteNode = spriteNode;
        this._destination = destination;
        UpdateEmitter.addListener(this, this._setPosition);
        var deltaVector = new Vector();
        deltaVector.setX(this._destination.getX() - this._initialPosition.getX());
        deltaVector.setY(this._destination.getY() - this._initialPosition.getY());
        this._deltaVector = deltaVector;
        var now = Time.getFrameTime();
        this._mStartTime = now;
        this._mStopTime = now + duration;
        this._mDuration = duration;
    },
    /** @private */
    _setPosition: function (delta)
    {
        var now = Time.getFrameTime();
        if(now > this._mStopTime)
        {
            this._spriteNode.setPosition(this._destination.getX(), this._destination.getY());
            if(this._rem)
            {
                if(typeof this._callBackFunc === 'function')
                {
                    this._callBackFunc();
                }
                UpdateEmitter.removeListener(this, this._setPosition);
                this.destroy();
            }
        }
        else
        {
            var slice = delta / this._mDuration;
            var newLocation = new Vector();
            newLocation.setX(this._initialPosition.getX() + (this._deltaVector.getX() * slice));
            newLocation.setY(this._initialPosition.getY() + this._deltaVector.getY() * slice);
            this._spriteNode.setPosition(newLocation.getX(), newLocation.getY());
        }
    },
    /** @private */
    destroy: function ($super)
    {
        $super();
    }
});
exports.NavController = View.subclass( /** @lends GLUI.NavController.prototype */
{
    classname: 'NavController',
    /**
     * @class The <code>NavController</code> class constructs objects that define application navigation components.
     * @constructs The default constructor.
     * @augments Core.Class
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     */
    initialize: function ($super, properties)
    {
        $super(properties);
        this.navStack = [];
        var isAndroid = Capabilities.getPlatformOS() === 'Android';
        if(isAndroid)
        {
            //If it is an android device, do not use graphical Back button.
            this._useGraphicalBackButton = false;
            //Instead add a listener for Device Back button.
            this.keyListener = new NavKeyListener();
            KeyEmitter.addListener(this.keyListener, this.onKeyPressed.bind(this));
        }
        else
        {
            this._useGraphicalBackButton = true;
        }
        this._nodeForMovement = null;
        this._previousView = null;
        this._backButton = null;
        this._mAnimation = null;
    },
    /**
     * Turn on the onscreen <b>Back</b> button. Applications designed for iOS should always provide the <b>Back</b> button
     * and integrate it into the application UI (calling <code>{@link GLUI.NavController#back}</code> when pressed).<br><br>
     * <b>Note:</b> This is turned off by default for applcations designed for Android because Android devices contain a hardware <b>Back</b> button.
     * @param {Boolean} shallUse Set as <code>true</code> to enable the onscreen <b>Back</b> button.
     * @function
     * @status Javascript, Android, Flash
     */
    setUseBackButton: function (shallUse)
    {
        this._useGraphicalBackButton = (shallUse) ? true : false;
        if(shallUse)
        {
            this._createBackButton();
        }
        else
        {
            if(this._backButton)
            {
                this._backButton.removeFromParent();
            }
        }
    },
    /**
     * Reset the stack for this <code>NavController</code>.
     * @param {String} fromButton The button to reset.
     * @status Javascript, Android, Flash
     */
    clear: function (fromButton)
    {
        return this.backToView(undefined);
    },
    /**
     * @private
     * @status Javascript, Android, Flash, Test
     */
    logNavEvent: function (from, to, via)
    {
        var toName = getAnalyticsName(to);
        var fromName = getAnalyticsName(from);
        var viaName = getAnalyticsName(via);
        if(fromName || toName)
        {
            Analytics._getPipe().navigationEvent(fromName, toName, viaName);
        }
    },
    /**
     * Retrieve the top view from the nav stack of this <code>NavController</code>.
     * @returns {Object} The top view in the nav stack
     * @status Javascript, Android, Flash
     * @function
     */
    getTopView: function ()
    {
        //for stack implementation, the last item is at the top of the stack, so we are accessing the last index of the navStack
        return(this.navStack.length > 0) ? this.navStack[(this.navStack.length - 1)] : undefined;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    navStackDepth: function ()
    {
        return this.navStack.length;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    depthOfView: function (targetView)
    {
        //private method, so there is no need to check targetView type here.
        var targetIndex = this.navStack.indexOf(targetView);
        if(targetIndex === -1)
        {
            return -1;
        }
        return this.navStack.length - targetIndex - 1;
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    viewAtDepth: function (targetDepth)
    {
        if(targetDepth >= this.navStack.length)
        {
            return null;
        }
        return this.navStack[this.navStack.length - targetDepth - 1];
    },
    /**
     * @private
     * @status Javascript, Android, Flash
     */
    removeDeepView: function (targetView)
    {
        var targetIndex = this.navStack.indexOf(targetView);
        if(targetIndex === -1)
        {
            console.log("NavController: trying to remove a nonexistent view from the nav stack!");
            return;
        }
        this.navStack.splice(targetIndex, 1);
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     * @function
     */
    _viewTransition: function (fromView, toView, back, buttonRef)
    {
        var myFrame = this.getFrame();
        var w = myFrame[2];
        var h = myFrame[3];
        if(this._nodeForMovement === null)
        {
            this._nodeForMovement = new Node();
        }
        else
        {
            this._nodeForMovement.destroy();
            this._nodeForMovement = new Node();
        }
        this._internalGLObject.addChild(this._nodeForMovement);
        if(fromView)
        {
            fromView.setFrame([0, 0, w, h]);
            this._previousView = fromView;
            this._nodeForMovement.addChild(fromView.getGLObject());
        }
        if(toView)
        {
            toView.setFrame([(back ? -w : w), 0, w, h]);
            this._nodeForMovement.addChild(toView.getGLObject());
        }
        if(this._mAnimation !== null)
        {
            this._mAnimation.destroy();
            this._mAnimation = null;
        }
        if(this._mAnimation === null)
        {
            this._mAnimation = new MovingAnimation();
            this._mAnimation.startAnimate(this._nodeForMovement, (new Vector((back ? w : -w), 0)), 350, true, this._transComplete.bind(this));
        }
        this.logNavEvent(fromView, toView, buttonRef);
        this._createBackButton();
    },
    _transComplete: function ()
    {
        if(this._previousView !== null)
        {
            this._previousView.removeFromParent();
        }
    },
    /**
     * Retrieve removed views in the reverse order they were removed.
     * @example var page = new NavPage({...});
     *
     * var controller = new GLUI.NavController({...});
     *
     * NavPage.navController = controller;
     * controller.forwardToView(page);
     * @param {String} destView The destination view for this navigation component.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript,, Android, Flash
     * @see GLUI.NavController#backToView
     */
    forwardToView: function (destView, fromButton)
    {
        var currentView = this.getTopView();
        if(destView && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPush === "function" && this._delegate.navControllerShouldPush(this, destView))))
        {
            this.navStack.push(destView);
            this._viewTransition(currentView, destView, false, fromButton);
        }
    },
    /**
     * Set back navigation for this <code>NavController</code>.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript, Android, Flash
     * @see GLUI.NavController#forward
     */
    back: function (fromButton)
    {
        var removed = this.navStack.pop();
        if(!(removed && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPop === "function" && this._delegate.navControllerShouldPop(this, removed)))))
        {
            return null;
        }
        this._viewTransition(removed, this.getTopView(), true, fromButton);
        return removed;
    },
    /**
     * Retrieve removed views in the order they were removed.
     * @example var page = new NavPage({...});
     *
     * var controller = new GLUI.NavController({...});
     *
     * NavPage.navController = controller;
     * controller.backToView(page);
     * @param {String} destView The destination view for this navigation component.
     * @param {String} fromButton The button that triggers this navigation component.
     * @status Javascript, Android, Flash
     * @see GLUI.NavController#forwardToView
     */
    backToView: function (destView, fromButton)
    {
        var removedSet = [];
        var removed = this.navStack.pop();
        var originalView = removed;
        if(removed)
        {
            do
            {
                if(removed && (!this._delegate || (this._delegate && typeof this._delegate.navControllerShouldPop === "function" && this._delegate.navControllerShouldPop(this, removed))))
                {
                    removedSet.push(removed);
                }
                else
                {
                    break;
                }
                if(this.getTopView() === destView)
                {
                    break;
                }
                removed = this.navStack.pop();
            } while (removed);
        }
        if(removedSet.length > 0)
        {
            this._viewTransition(originalView, this.getTopView(), true, fromButton);
        }
        return removedSet;
    },
    /**
     * Set this <code>NavController</code> to launch the application when activated.
     * @status Javascript, Android, Flash
     */
    loadApp: function ()
    {},
    /**
     * @private
     * @status Javascript, iOS, Flash
     */
    onBackPressed: function ()
    {
        if(this.navStack.length > 1)
        {
            var analyticsName = "bcksbtn"; // Back System Button
            // if the topmost view has an analytics name, prefix the button
            var topView = this.getTopView();
            if(topView.analyticsName)
            {
                analyticsName = topView.analyticsName + "." + analyticsName;
            }
            this.back(
            {
                analyticsName: analyticsName
            });
            return true;
        }
        return false;
    },
    /**
     * @private
     * @status Javascript, Android
     */
    onKeyPressed: function (event)
    {
        //captures back key press on Android Devices
        if((event.code === Device.KeyEmitter.Keycode.back) && (this.navStack.length > 1))
        {
            this.back();
            return true;
        }
        return false;
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     */
    _delegate: null,
    /**
     * @description Set subscribers to the <code>NavController</code> behavior. Subscribers can modify what happens.
     * NavControllerDelegateProtocol:
     *  @optional - (BOOL)navControllerShouldPop(NavController,View)
     *  @optional - (BOOL)navControllerShouldPush(NavController,View)
     * @param {String} navDelegate A <code>NavController</code> subscriber.
     * @private
     * @status Javascript, Android, Flash
     */
    setDelegate: function ( /*NavControllerDelegate*/ navDelegate)
    {
        if(navDelegate.hasOwnProperty('navControllerShouldPop') && navDelegate.hasOwnProperty('navControllerShouldPush') && typeof navDelegate.navControllerShouldPop === 'function' && typeof navDelegate.navControllerShouldPush === 'function')
        {
            this._delegate = navDelegate;
        }
        else
        {
            console.log("<NGGo> WARNING : delegate does not implement the required protocol. Error in Method setDelegate " + this.classname);
            this._delegate = null;
        }
    },
    delegate: function ()
    {
        return this._delegate;
    },
    /**
     * @protected
     * @status Javascript, Android, Flash
     * @function
     */
    _createBackButton: function ()
    {
        // Do nothing if this device does not require_ an onscreen button.
        if(this._useGraphicalBackButton === false)
        {
            return;
        }
        if(!this._backButton)
        {
            this._backButton = new Button(
            {
                normalText: 'Back',
                textSize: 18.0,
                textColor: "FF",
                normalTextShadow: "00 1.5",
                frame: [-2, 20, Window.outerWidth / 5, Window.outerHeight / 12]
            });
            this._backButton.setBackgroundColor("8B8386");
            this._backButton.Controller = this;
            this._backButton.setOnClick(function ()
            {
                this.Controller.onBackPressed();
            });
        }
        if(this.navStack.length > 1)
        {
            if(!this._backButton.getParent())
            {
                Window.document.addChild(this._backButton);
            }
        }
        else if(this._backButton.getParent())
        {
            this._backButton.removeFromParent();
        }
    },
    /** @private */
    destroy: function ($super)
    {
        $super();
        if(this._nodeForMovement)
        {
            this._nodeForMovement.destroy();
            this._nodeForMovement = null;
        }
        if(this._backButton)
        {
            this._backButton.destroy();
            this._backButton = null;
        }
        if(this._mAnimation)
        {
            this._mAnimation.destroy();
            this._mAnimation = null;
        }
        this.delegate = null;
    }
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI/NGWindow'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI/NGWindow'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI/NGWindow'] = exports; 
var __dirname = 'NGGo1.3/GLUI';
var __filename = 'NGGo1.3/GLUI/NGWindow.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:    Muzammil M
 *  Website:    https://developer.mobage.com/
 *  Copyright:  (C) 2011-2012 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

/*
 *  GLUI.NGWindow  __deprecated__
 *
 *  use the following:
 *
 *  GLUI.Window.document
 *
 */

var Window = require('NGGo1.3/GLUI/Window').Window;
exports.NGWindow = Window.document;; return exports;};
$MODULE_FACTORY_REGISTRY['NGGo1.3/GLUI'] = function(){var exports = $MODULE_REGISTRY['NGGo1.3/GLUI'] || {}; $MODULE_REGISTRY['NGGo1.3/GLUI'] = exports; 
var __dirname = 'NGGo1.3';
var __filename = 'NGGo1.3/GLUI.js';

////////////////////////////////////////////////////////////////////////////////
/**
 *  @author:	Muzammil Mahmood
 *  Website:	https://developer.mobage.com/
 *  Copyright:  (C) 2011 ngmoco:) inc. All rights reserved.
 */
////////////////////////////////////////////////////////////////////////////////

var Commands	 = require("NGGo1.3/GLUI/Commands").Commands;
var ViewGeometry = require("NGGo1.3/GLUI/ViewGeometry");

/**
 * <p>Classes and objects contained by the GLUI module.</p>
 * @name GLUI
 * @namespace
 * @description <p>The GLUI module is a collection of classes that control user interface components using GL2.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link GLUI.AbstractView}</code>A base class object for constructing other UI objects.</li>
 * <li><code>{@link GLUI.Button}</code></li>
 * <li><code>{@link GLUI.CellView}</code>: Construct <code>CellView</code> objects.</li>
 * <li><code>{@link GLUI.CheckBox}</code>: Construct objects that are used as checkboxes in an application.</li>
 * <li><code>{@link GLUI.Commands.FontLocation}</code>: Font location for GLUI objects.</li>
 * <li><code>{@link GLUI.Commands.FontStyle}</code>: Font Styles for GLUI  Objects.</li>
 * <li><code>{@link GLUI.Commands.State}</code>: Object States for GLUI Objects.</li>
 * <li><code>{@link GLUI.Commands.FitMode}</code>: Image Fit Modes for GLUI Objects.</li>
 * <li><code>{@link GLUI.Element}</code>: A base class object for constructing other UI objects.</li>
 * <li><code>{@link GLUI.Image}</code>: Constructs objects that control the location and size of images used in the user interface.</li>
 * <li><code>{@link GLUI.Label}</code>: Constructs objects that control the look and feel of application labels.</li>
 * <li><code>{@link GLUI.ListView}</code>: Construct <code>ListView</code> objects.</li>
 * <li><code>{@link GLUI.ListViewItem}</code>: Construct <code>ListViewItem</code> objects.</li>
 * <li><code>{@link GLUI.ListViewSection}</code>: Construct <code>ListViewSection</code> objects.</li>
 * <li><code>{@link GLUI.NavController}</code></li>
 * <li><code>{@link GLUI.ScrollView}</code>: Construct <code>ScrollView</code> objects.</li>
 * <li><code>{@link GLUI.Spinner}</code></li>
 * <li><code>{@link GLUI.View}</code>: Construct objects that control the look and feel of the application view state.</li>
 * <li><code>{@link GLUI.ViewGeometry.Rect}</code>: Construct rectangle objects for use as positionable elements in the user interface.</li>
 * <li><code>{@link GLUI.ViewGeometry.Scale}</code>: Construct objects that handle view geometry for different scales of measurement.</li>
 * <li><code>{@link GLUI.Window}</code>: Construct application window objects.</li>
 * </ul>
 */


exports.GLUI =
{

    //Modules
    View                : require('NGGo1.3/GLUI/View').View,
    Image               : require('NGGo1.3/GLUI/Image').Image,
    Label               : require('NGGo1.3/GLUI/Label').Label,
    Button              : require('NGGo1.3/GLUI/Button').Button,
    CheckBox            : require('NGGo1.3/GLUI/CheckBox').CheckBox,
    CellView			: require('NGGo1.3/GLUI/CellView').CellView,
    ScrollView			: require('NGGo1.3/GLUI/ScrollView').ScrollView,
    ListView			: require('NGGo1.3/GLUI/ListView').ListView,
    ListViewSection		: require('NGGo1.3/GLUI/ListViewSection').ListViewSection,
    ListViewItem		: require('NGGo1.3/GLUI/ListViewItem').ListViewItem,
    Spinner             : require('NGGo1.3/GLUI/Spinner').Spinner,
    NavController	: require('NGGo1.3/GLUI/NavController').NavController,


	//Application Window and Document
	Window		: require('NGGo1.3/GLUI/Window').Window,
	WindowLayer	: require('NGGo1.3/GLUI/WindowLayer').WindowLayer,

	//Utils Files
	Commands	: Commands,
	FontLocation: Commands.FontLocation,
	FontStyle	: Commands.FontStyle,
	State	: Commands.State,
	FitMode	: Commands.FitMode,
	ViewGeometry: ViewGeometry,
	Scale	: ViewGeometry.Scale,

	//__Deprecated Modules__
	/**
	 * @deprecated now Replaced by {@link GLUI.Window.document}.
	 * @Note: use GLUI.Window.document.METHOD() now.
	 */
	NGWindow	: require('NGGo1.3/GLUI/NGWindow').NGWindow  /* __deprecated__  use GLUI.Window.document instead */
};
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/StoryScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/StoryScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/StoryScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/StoryScene.js';

/*
 *
 * 
 * 
 * 
 * 
 */
var ImageListView		 = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX					 = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions			 = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops 				 = require('NGGo1.3/Foundation/Math/Ops').Ops;
var GLUI				 = require('NGGo1.3/GLUI').GLUI;
var DebugView 			 = require('Code/utils/DebugView').DebugView;
var VietScene 			 = require('Code/view/Scene/VietScene').VietScene;


_StorySceneListener = Core.MessageListener.subclass({
	initialize: function(storyScene) {
		this.ss = storyScene;
	},
	onUpdate: function() {
		
	},
	onTouchNext: function(touch) {
		Log("onTOuchNext$$$$$$$$$$$$$$$$$$$$$$$$");
		switch (touch.getAction()) {
			
		case touch.Action.Start:
			this.ss.nextPage(this.ss.index);
			return true;
			break;
		case touch.Action.End:
			break;
		}
	},
});
/*
 * This function is used to display a line of word, each character will appear at different position
 * and run into one position.
 * @params text: 
 * @param finalPos: Core.Point final position that place line of words(in horizontal)
 * @params textSize: Core.Size size of node contains each character.
 */


exports.StoryScene = VietScene.subclass({
	classname: "StoryScene",
	sceneName: "STORY_SCENE",
	/*
	 * type = 0 means display opening story
	 * type = 1 means display boss story,...
	 * conf is an array that contains stories for each type
	 */
	initialize: function($super, type) {
		$super();
		
		this.listener = new _StorySceneListener(this);
		Core.UpdateEmitter.addListener(this.listener, this.listener.onUpdate);
		this.type = type || 0;     
		this.stories = [];		// an array contains background images of stories
		this.txt = [];    //an array contains stories
		this.index = 0;
	},
	defineConfig: function(controller,def) {
		var conf = {};
			conf.description = def.attrs.description;
			conf.debug = def.attrs.debug || false;
			conf.debugAttrs = def.attrs.debugAttrs || [];
			conf.tEachStory = def.attrs.tEachStory; 
    		conf.bgScale = def.attrs.bgScale;
    		conf.tScale = def.attrs.tScale;
   		 	conf.tTextMove = def.attrs.tTextMove;
   		 	conf.posTextMove = def.attrs.posTextMove;
   		 	conf.posTextBgMove = def.attrs.posTextBgMove;
   		 	conf.bgtextAlpha= def.attrs.bgtextAlpha;
    		return conf;
	},
	onSuccessConfig: function() {
		Log("call onSuccessConfig");
		this._addNextButton();
		GL2.Root.addChild(this.node);
		if(this.type == 0) {
			this.stories.push({id: '01', story: this.controller.story1, txt: this.controller.txt1, bgtext: this.controller.bgtext1});
			this.stories.push({id: '02',story: this.controller.story2, txt: this.controller.txt2, bgtext: this.controller.bgtext2});
			this.stories.push({id: '03',story: this.controller.story3, txt: this.controller.txt3, bgtext: this.controller.bgtext3});
		}
		this.nextPage(this.index);
		this.makeLine("CHXHCNVN", 25, [60,60] );
	},
	nextPage: function(idx) {
		Log("on nextPage");
		if(idx < 0 || idx > this.stories.length -1) {
			Log("End story");
			SceneDirector.transition("MAP_SELECTION_SCENE");
			//return;
			//set up more here
		} else {
			//Log("idx~~~~~~~~~" + idx);
			if(this.timeoutId != undefined)
				clearTimeout(this.timeoutId);
			this.timeoutId = setTimeout(this.bind(function() {this.nextPage(this.index);}), this.CONF.tEachStory*1000);
			this.index++;
			var story = this.stories[idx].story;
				story.setScale(this.controller.CONF.bgScale);
			var txt = this.stories[idx].txt;
			var id = this.stories[idx].id;
			var bgtext = this.stories[idx].bgtext;
				bgtext.setAlpha(this.CONF.bgtextAlpha);	
			this.node.addChild(story);
			this.node.addChild(bgtext);
			this.node.addChild(txt);
			
			var sequenceStory = VFX.spawn().fadeIn(this.CONF.tEachStory - this.CONF.tScale,1).scaleTo(this.CONF.tScale,[1,1]);
				sequenceStory.play(story,this.vfxErrorCb);
			if(id == '01' || id == '03')
			     var sequenceText = VFX.sequence().moveTo(this.CONF.tTextMove,this.CONF.posTextMove).fadeOut(this.CONF.tEachStory - this.CONF.tTextMove,0);//.blink(8,0.5, [1, 0]);
			else if(id == '02'){
			      var sequenceText = VFX.sequence().moveTo(this.CONF.tTextMove,[-40,50]).fadeOut(this.CONF.tEachStory - this.CONF.tTextMove,0);//.blink(8,0.5, [1, 0]);
			Log("@@@@@@@@@@@@@@@@@@@@@@@@@");}else if (id == '04')
			     var sequenceText = VFX.sequence().moveTo(this.CONF.tTextMove,this.CONF.posTextMove).fadeOut(this.CONF.tEachStory - this.CONF.tTextMove,0);//.blink(8,0.5, [1, 0]);
			sequenceText.play(txt,this.vfxErrorCb);
			var sequenceBgtext = VFX.sequence().fadeIn(this.CONF.tEachStory - this.CONF.tScale,1).fadeOut(this.CONF.tEachStory - this.CONF.tTextMove,0);
				sequenceBgtext.play(bgtext,this.vfxErrorCb);
			
		}
	},

	_addNextButton: function() {
		Log("_addNextButton");
	
		var touchTarget = new GL2.TouchTarget();
		touchTarget.setAnchor(0,0);
		touchTarget.setSize(60,50);
		touchTarget.getTouchEmitter().addListener(this.listener, this.listener.onTouchNext);
		
		this.controller.btnNext.addChild(touchTarget);
		this.controller.btnNext.setDepth(62001);
		this.node.addChild(this.controller.btnNext);
		
		var sequence = VFX.sequence().blink(48,0.5,[1,0],Ops.easeInExpo);
		sequence.play(this.controller.btnNext);
	},
	
	/*Create a line of words, character from random position will fly to desination to create a line of word
        first, design for horizontal line
        @param finalPos (60,60)
        */
	
	makeLine: function(text,textSize, finalPos) {
		var seq = [];
		var line = [];
		var node = new GL2.Node();
		node.setPosition(finalPos);
		for (var i = 0; i < text.length; i++) {
			var c = text.charAt(i);
			var linei = new GL2.Text();
			linei.setPosition(Math.random()*480, Math.random()*320);
			linei.setText(c);
			linei.setFontSize(textSize.getWidth());
			linei.setColor(1,0,0);
			if( c == 'V') {   // create special effect for some character
				var mv = VFXActions.moveTo(20, [(textSize.getWidth()* i), 0]);
				var rotate = VFXActions.rotate(5,360);
				var s = VFXActions.createSpawn([mv,rotate]);
				s.repeat(10);
			
			} else {
				//var mv = VFXActions.moveTo(10, [(textSize.getWidth()* i), 0]);
				//var rotate = VFXActions.rotate(5,360);
				//var s = VFXActions.createSpawn([mv,rotate]);
				//s.repeat(10);
				var s = VFX.sequence().waitFor(i).appear().moveTo(10,[(textSize.getWidth()*i),0],Ops.easeInExpo).rotate(5,-360).blink(5,0.5, [1, 0],Ops.easeInExpo).waitFor(3);
			}
			s.play(linei);
			seq.push(s);
			line.push(linei);
			node.addChild(linei);
		}
		node.setDepth(60004);
		GL2.Root.addChild(node);
	
	},
	vfxErrorCb: function(err) {
		if(err)
			Log("Error occur when apply vfx to node");
	},
	
	setupForDebug: function() {
 		this.reInitForDebug = function() {
 			Log("call reInitForDebug");
 			this.node.destroy(); 
			this.node = new GL2.Node();
			this._addBackground();
			this.listener = new _StorySceneListener(this);
			this.stories = [];		// an array contains background images of stories
			this.txt = [];    //an array contains stories
			this.index = 0;	
 		};
 		this._setConfigAttrs = function(name,value) {
 			Log("call _setConfigAttrs");
 			switch(name) {
 				case 'description' : this.CONF.description = value;break;
 				case 'debug' : this.CONF.debug = value;break;
 				case 'tEachStory' : this.CONF.tEachStory = value; break;
				case 'bgScale' : this.CONF.bgScale = value; break;
				case 'tTextMove' : this.CONF.tTextMove = value; break;
				case 'posTextMove' : this.CONF.posTextMove = value; break;
				case 'posTextbgMove' : this.CONF.posTextbgMove = value; break;
				case 'bgtextAlpha' : this.CONF.bgtextAlpha = value; break;
 				default: Log("Can't find " + name + " in CONF");
 			}
 		};
 	},
	
	onExit: function($super) {
		Core.UpdateEmitter.removeListener(this.listener);
		$super();
	},
	onPause: function() {
		Log(this.classname + " paused");
		this.node.setVisible(false);
	},
	onResume: function($super) {
	   $super();
		this.node.setVisible(true);
	},

});


; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/ListNode'] = function(){var exports = $MODULE_REGISTRY['Code/utils/ListNode'] || {}; $MODULE_REGISTRY['Code/utils/ListNode'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/ListNode.js';

var ImageListView		 = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var GLUI				 = require('NGGo1.3/GLUI').GLUI;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
//var VietScene            = require_('./VietScene').VietScene;
//var Builder              = require_('./VietLib/Builder').Builder;
//var eff                  = require_('./VietLib/eff').eff;
/*
 * 
 * List Node se cho phep xem cac view duoi dang mot list, co the
 * truot list theo chieu ngang, doc, vv...
 * moi list item la 1 GL2.Node, xu ly event tren do se do dinh nghia o ben ngoai. ListNode chi quan tam den style va items[]
 * 
 */


exports.ListNode = GL2.Node.subclass({
 	classname: "ListNode",  // must be unique
 	/*
 	 * @param items: array of gl2 sprite
 	 */
 	initialize: function(style, items) {
 		Log(this.classname + " initialized");
 		this.controller = {};
 		this.CONF = {};
 		this.node = new GL2.Node();
 		//this._addBackground();
 		

		this.items = items || [];
		this.style = style || 0;
		this.listview = new ImageListView();
		this._currentPos = this.listview.getScrollPosition(); Log('this._currentPo11s = ' + this._currentPos);
		this.currentIdx = 0;
		this.addChild(this.listview);
		this.onEnter();
 	},
 	onEnter: function() {
 		var config = function(controller, def){
			var conf = {};
   		 	conf.style0 = def.attrs.style0;
   		 	conf.style1 = def.attrs.style1;
    		return conf;
		};
		GUIBuilder.registerTypeMethod(this.classname, config);
		GUIBuilder.loadConfigFromFile("Config/VietConfig/ListNode.json", this.controller, function(err) {
			if(this.controller.CONF!= undefined) {
				this.CONF = this.controller.CONF;
				//this._debugAttrs = [".....", "......", "........", "........", "......", "....."];
				//this._debugView = new DebugView(this, this._debugAttrs, [0,40,480,30]);
 				this.onSuccessConfig();
 			}
 		}.bind(this));
 		GL2.Root.addChild(this.node);
 	},
 	onSuccessConfig: function() {
 		Log("call onSuccessConfig");
 		this.setStyle(this.listview,this._getStyle());
			for(var i = 0; i < this.items.length; i++) {
				this.listview.addItem(this.items[i], i);
			}
 	},
 	
	_getStyle: function(){
		switch(this.style) {
			case 0:
				return this.CONF.style0;
			case 1:
				return this.CONF.style1;	
		}
	},
	
	/*
	 * set orientation, frame, itemSize... for list view
	 * @param listview: ImageListView object
	 * @param CONFI		object that defines styles
	 */
	setStyle: function(listview, CONFI){
		Log("SetStyle function +++ frame: " + CONFI.frame);
		
		listview.setItemSize(CONFI.itemSize);
		listview.setSnap(CONFI.isSnap);
		listview.setFrame(CONFI.frame);
		listview.setScrollDirection(CONFI.orientation);
		listview._scrollbar.setVisible(CONFI.hasScrollbar);
		listview.setScrollFeeling({
			touchSensitivity: CONFI.touchSensitivity,
			flickSpeed: CONFI.flickSpeed,
			rangeFactor: CONFI.rangeFactor,
			stretchDecay: CONFI.stretchDecay,
			smoothingFactor: CONFI.smoothingFactor,
			friction: CONFI.friction
		});
	},
	/*
	 * Perform node i, default is current node, example, a boss ninja attack
	 */
	performNode: function(i) {
	    Log("calee performNode");
	    var nodeIndex = i || this.getIndexOfCurrentNode();
	    if(nodeIndex >= this.items.length || nodeIndex < 0)
	       Log("Big error occure: node index is not in range");
	    var t = 1;
	    var seq = VFX.spawn().scaleTo(t,[1.2, 1.2]).move(t,[20,20]);
	    seq.play(this.items[nodeIndex]);
	    var that = this;
	    //after 1 second, ninja go back
	    setTimeout(function() {   
	          seq = VFX.spawn().scaleTo(t,[1, 1]).move(t,[-20,-20]);
	          seq.play(that.items[nodeIndex]);
	    },t *1100);
	    // after go back, move to Next Node
	    setTimeout(function() {that.nextNode()}, t*3000);
	},
	performNextNode: function() {
	    this.performNode(this.currentIdx);
	},
	/*
	 * Implement more here for getIndexOfCurrentNode function
	 */
	getIndexOfCurrentNode: function() {
	    return this.currentIdx;
	},
	nextNode: function() {
		Log("call nextNode: current Pos = " + this._currentPos);
		var style = this._getStyle();
		if(this.currentIdx >= this.items.length) {
            this.currentIdx = 0;
            this._currentPos = [0,0];
        } else if(style.orientation == 1)
			this._currentPos = [style.itemSize[0] + this.listview.getScrollPosition()[0],0];
		else this._currentPos = [0, style.itemSize[0] + this.listview.getScrollPosition()[1]];
		//Log('this._currentPos = ' + this._currentPos);
		this.listview.setScrollPosition(this._currentPos[style.orientation-1]);
		this.currentIdx += 1;
	},
 	onExit: function() {
 		this.node.destroy();
 		if(this._debugView)
 			this._debugView.destroy();
 	},
 	onPause: function() {
 		
 	},
 	onResume: function() {
 		
 	},
 	_addBackground: function() {
		var bg = new GL2.Sprite();
		bg.setImage("Content/white.png", new Core.Size(1024,1024), new Core.Point(0,0));
		this.node.addChild(bg);
	}
 });; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/eff'] = function(){var exports = $MODULE_REGISTRY['Code/utils/eff'] || {}; $MODULE_REGISTRY['Code/utils/eff'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/eff.js';

var ImageListView        = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var UI                   = require('NGCore/Client/UI').UI;
var GL2                  = require('NGCore/Client/GL2').GL2;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var GLUI                 = require('NGGo1.3/GLUI').GLUI;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var Builder              = require('Code/utils/Builder').Builder;

exports.eff = {};
exports.eff.shakeNode = function(node, time, dx, frequency) {
        Log("call eff shakeNode");
        var f = frequency || 50;
        var n = Math.round(f * time);
        var dt = time*1000/n;
        var x = node.getPosition().getX();
        var y = node.getPosition().getY();
        for( var i = 0; i < n; i++) {
            switch(i%4) {
                case 0: setTimeout(function() {node.setPosition(x + dx, y);}, i*dt); break;
                case 1: setTimeout(function() {node.setPosition(x - dx, y);}, i*dt); break;
                case 2: setTimeout(function() {node.setPosition(x, y + dx);}, i*dt); break;
                case 3: setTimeout(function() {node.setPosition(x, y - dx);}, i*dt); break;
            }
        }
};
exports.eff.scaleAppear = function(parent, child, time) {
    child.setScale(0.1,0.1);
    parent.addChild(child);
    var seq = VFX.sequence().scaleTo(time,[1,1]);
    seq.play(child);
};
/*
 * Swinging a gl2 node in different direction, maybe random direction, forever time.
 * @param direction: horizontal, vertical, or crossal
 * @dx: distance that node swing.
 * @time: decide to speed of node's movement
 */

exports.eff.swingNode = function(node, direction, dx, time) {
    var pos = [0,0];
    switch(direction) {
        case 'horizontal':
            pos = [dx,0]; 
            break;
        case 'vertical':
            pos = [0, dx];
            break;
        case 'other':
            pos = [dx,dx];
            break;
    }
    var sequence = VFX.sequence().move(time, pos).move(time,[0 - pos[0], 0 - pos[1]]).repeatForEver();
    sequence.play(node);
};

/*
 * see arrow motion in Daovang game
 */
exports.eff.guideArrow = function(arrowNode) {
    
};

exports.eff.warn = function(txt) {
    var Builder              = require('Code/utils/Builder').Builder;
    Log("warn effect");
    var text = Builder.makeText(GL2.Root, [-150,20], [300,50], txt, 16, new Core.Color(1,0,0));
    text.setDepth(63768);
    var seq = VFX.sequence().moveTo(1,[100,20], Ops.EaseInExpo).waitFor(1).move(0.3, [-20,0]).moveTo(1,[480,480], Ops.EaseInExpo);
    seq.play(text);
    setTimeout(function() {text.destroy();},3000);
    
},
/*
 * Effect when user touch any point on screen, two circle appears and scale gradually (android  keyboard unlock)
 */
exports.eff.touch = function(pos,cb) {
    Log("touch effectwwwwwww");
   
    for (var i = 0; i < 5; i++) {
        var bubble = new GL2.Sprite();
        bubble.setImage("Content/viet/drop_water.png", [20,20],[0,0]);
        bubble.setPosition(Math.random()*480, 320 * Math.random());
        bubble.setDepth(62128);
        GL2.Root.addChild(bubble);
        var seq = VFX.sequence().moveTo(1,pos, Ops.easeInExpo).fadeOut(1,0.5).disappear();
        seq.play(bubble);
       setTimeout(function() {
           //Log("ahahahahah: +" + i);
            bubble.destroy();
            cb();
       }, 1100);
    }
},

/*
 * Effect similar to unlock screen of android or wave of water spread out when throw a stone to water surface
 */
exports.eff.touch2 = function(pos,cb) {
    Log("vvvvvv=====touch2");
    var Builder              = require('Code/utils/Builder').Builder;
    var firstCircle = Builder.makeSprite(GL2.Root, "Content/stone/frame.png", [pos.getX(), pos.getY(),50,50],[0.5,0.5], null, 62345);
    var secondCircle = Builder.makeSprite(GL2.Root, "Content/stone/frame.png", [pos.getX(), pos.getY(),50,50],[0.5,0.5], null, 62345);
    var seq = VFX.sequence().scaleTo(0.3, [2,2], Ops.EaseInExpo).scaleTo(0.3,[1,1], Ops.EaseInExpo);
    seq.play(secondCircle);
    setTimeout(function() {
        firstCircle.destroy();
        secondCircle.destroy();
    }, 600);
},


/*
 * lighting a gl2 node by cycle ( node will delight each cycle time)
 * @params cycle: time that after each, node will delight
 */
exports.eff.lightNode = function(node, cycle) {
    
}
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/utils/Builder'] = function(){var exports = $MODULE_REGISTRY['Code/utils/Builder'] || {}; $MODULE_REGISTRY['Code/utils/Builder'] = exports; 
var __dirname = 'Code/utils';
var __filename = 'Code/utils/Builder.js';

var ImageListView        = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var UI                   = require('NGCore/Client/UI').UI;
var GL2                  = require('NGCore/Client/GL2').GL2;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var GLUI                 = require('NGGo1.3/GLUI').GLUI;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var eff                  = require('Code/utils/eff').eff;
exports.Builder = {};
exports.Builder.makeSpriteButton = function(imgPath, frame, cb) {
        //Log("[SpriteButton] = " + imgPath);
        var sprite = new GL2.Sprite();
        sprite.setImage(imgPath,new Core.Size(frame[2],frame[3]), [0,0]);
        sprite.setPosition(frame[0], frame[1]);
        
        var button = new GLUI.Button();
        button.setFrame([0,0,frame[2], frame[3]]);
        //button.setBackgroundColor('FF0000');
        button.onclick = function() {
            sprite.setColor(1,0,0);
            setTimeout(function() {sprite.setColor(1,1,1);}, 200);
            cb.func(cb.args);
        }
        sprite.addChild(button.getGLObject());
        return sprite;
};
/*
 * Create a GL2 Sprite and add to parent
 * @params frame: [x,y,z,t] in this [x,y]: position of sprite, [z,t]: size of image
 * @return sprite :GL2 Sprite
 */
exports.Builder.makeSprite = function(parent, imgPath, frame, anchor, uvs, depth) {
    var anchor = (anchor == undefined ? [0,0] : anchor);
    var sprite = new GL2.Sprite();
    sprite.setPosition(frame[0], frame[1]);
    sprite.setImage(imgPath, [frame[2], frame[3]],anchor, uvs );
    sprite.setDepth(depth);
    if(parent)
       parent.addChild(sprite);
    return sprite;
};
//ver = [40, -40, 60,-40]
exports.Builder.makeLight = function(parent, pos, ver, angle, scale,time) {
    
    var prim1 = new GL2.Primitive();
    prim1.setPosition(pos);
    prim1.setType(GL2.Primitive.Triangles);
    prim1.pushVertex(new GL2.Primitive.Vertex([0, 0]));
    prim1.pushVertex(new GL2.Primitive.Vertex([ver[0], ver[1]]));
    prim1.pushVertex(new GL2.Primitive.Vertex([ver[2], ver[3]]));
    prim1.setColor(192/256, 255/256,62/256);
   // prim1.setImage('Content/vn/sheet01.png', [20,20]);
   setTimeout(function() {
        parent.addChild(prim1);
        var seq = VFX.spawn().scaleTo(0.5, scale).rotate(5,angle);
        seq.play(prim1);
   }, time);
   

};
exports.Builder.makeNode = function(parent, frame) {
    // var prim1 = new GL2.Primitive();
//     
    // prim1.setPosition(frame[0]);
    // prim1.setType(GL2.Primitive.TriangleStrip);
    // prim1.pushVertex(new GL2.Primitive.Vertex([0, 0], [0, 0]));
    // prim1.pushVertex(new GL2.Primitive.Vertex([100, 0], [0.5, 0]));
    // prim1.pushVertex(new GL2.Primitive.Vertex([0, 100], [0, 1]));
    // prim1.setImage('Content/white.png', [20,20]);
    // parent.addChild(prim1);
    // return prim1;
   // GL2.Root.addChild(prim1);

    var prim1 = new GL2.Primitive();
    prim1.setPosition(frame[0]);
    prim1.setType(GL2.Primitive.TriangleStrip);
    prim1.pushVertex(new GL2.Primitive.Vertex(frame[0], [0, 0],[1,1,1]));
    prim1.pushVertex(new GL2.Primitive.Vertex(frame[1], [1, 0],[1,1,1]));
    prim1.pushVertex(new GL2.Primitive.Vertex(frame[3], [1, 1],[1,1,1]));
    prim1.pushVertex(new GL2.Primitive.Vertex(frame[2], [0, 1],[1,1,1]));
    prim1.setImage("Content/white.png",[20,20]);
    prim1.setColor(1,1,1);
    parent.addChild(prim1);
    return prim1;
};

/*
 * Create and attach a touch target in to parent(GL2Node). a touch target has same size as its parents.
 * @params type: which touch event will be catched, default: tap, type = 1: scroll up, type =2 scroll down, etc
 * @params cb : {func: xxx, args: yyy}
 */
exports.Builder.makeTouch = function(parent, size, cb, type) {
    var tt = new GL2.TouchTarget();
    tt.setAnchor(0,0);
    tt.setSize(size);
    var lis = new Core.MessageListener();
   // parent.cb = cb;
    lis.onTouch = function(touch) {
         // Log("onTouch function called");
            switch(touch.getAction()) {
            case touch.Action.Start:
                // Start tracking the touch event.
                this.trackingId = touch.getId();
                this.trackingPosition = touch.getPosition();
                this.trackingPositionStart = this.trackingPosition;

                // Identify the touch event's offset from the global
                // scene coordinates.
                var local = this.screenToLocal(this.trackingPosition);
                var current = this.getPosition();
                this.trackingOffset = new Core.Vector(current.getX() - local.getX(),
                  current.getY() - local.getY());
                   // Log("type =========2SSFSSSSSSSSSSSSSSSSSSSSSSSS ");
                if(type == 2) {
                   // Log("type =========2 ");
                  
                } else {
                   // eff.touch(this.trackingPosition, cb);
                   // eff.touch2(this.trackingPosition,cb);
                    cb.func(cb.args);
                      break;
                 }
                
                // Return true so that we continue to get touch events.
                return true;

            case touch.Action.Move:
                // Make sure this is the same touch that we are
                // currently tracking.
                if (this.trackingId != touch.getId()) {
                    return;
                }
                // Update the touch position.
                this.trackingPosition = touch.getPosition();
                //Log("tracking at:::::" + this.trackingPosition.getX() + " y = " + this.trackingPosition.getY());
                break;

            case touch.Action.End:
                // Make sure this is the same touch that we are
                // currently tracking.
                if (this.trackingId != touch.getId()) {
                    return;
                }
                if(touch.getPosition().getY() < this.trackingPositionStart.getY() - 25) {
                    //Log("OK, scroll up occured");
                    cb.func(cb.args);
                }
                // Clear the ID and position.
                this.trackingId = this.trackingPosition = null;
                break;
        }
    };
    tt.getTouchEmitter().addListener(lis, lis.onTouch.bind(parent));
    parent.addChild(tt);
    return tt;
}

exports.Builder.makeText = function(parent, pos, size, message, fontSize, fontColor) {
    var text = new GL2.Text();
    text.setFontSize(fontSize);
    text.setSize(size);
    text.setColor(fontColor);
    //text.setFontLocation(GL2.Text.FontLocation.Manifest);
    //text.setFontFamily("Content/viet/StrikeOut.ttf");
   // font = new GL2.Font("Content/viet/StrikeOut.otf");
    //text.setFont(font);
    text.setHorizontalAlign(GL2.Text.HorizontalAlign.Center);
    text.setVerticalAlign(GL2.Text.VerticalAlign.Top);
    //text.setOverflowMode(GL2.Text.OverflowMode.Multiline);
   text.setAnchor(0,0);
   // text.setFont("Arial");
    text.setText(message || "");
    parent.addChild(text);
    return text;
}
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/ListScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/ListScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/ListScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/ListScene.js';

var ImageListView		 = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX					 = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions			 = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops 				 = require('NGGo1.3/Foundation/Math/Ops').Ops;
var Observable           = require("NGGo/Foundation/Observable").Observable;
var GLUI				 = require('NGGo1.3/GLUI').GLUI;
var ListNode             = require('Code/utils/ListNode').ListNode;
var Builder				 = require('Code/utils/Builder').Builder;
var DebugView            = require('Code/utils/DebugView').DebugView;
var VietScene            = require('Code/view/Scene/VietScene').VietScene;


ListSceneListener = Core.MessageListener.subclass({
   initialize: function(master) {
       this.master = master;
   },
   handle: function() {
       Log("ListSceneListener onUpdate");
       
       
   } 
});
exports.ListScene = VietScene.subclass({
	classname: "ListScene",
	sceneName: "ListScene",
	initialize: function($super, style) {
		$super();
		//this.listener = new ListSceneListener(this);
		//Core.updateEmitter.addListener(this.listener, this.listener.onUpdate.bind(this));
	},
	onSuccessConfig: function() {
	 //   Core.updateEmitter.addListener
	    var imgs = [];
            for (var i = 1; i < 10; i++) {
                imgs.push("Content/viet/avatar/00" + i + "_attack.png");
            }
	    this.listNode = new ListNode(0,this.getItems(imgs, [200,200],[0,0]));
        this.node.addChild(this.listNode);
        this._addNextButton();
        this.effect();
        this.performSeq();
	},
	performSeq: function() {
	    Log("call performSeq function");
	    setTimeout(function() {
	        this.listNode.performNextNode();
	        this.performSeq();
	    }.bind(this), 4000);
	},
	defineConfig: function(controller,def){
            var conf = {};
            conf.description = def.attrs.description;
            conf.debug = def.attrs.debug || false;
            conf.debugAttrs = def.attrs.debugAttrs || [];
            return conf;
    },
	/*
	 * @imgs: array that contains full path to images
	 */
	getItems: function(imgs, size, anchor) {
		Log("call setItems");
		var items = [];
		for (var i = 0; i < imgs.length; i++) {
			var item = new GL2.Sprite();
			item.setImage(imgs[i], size, anchor);
			items.push(item);
		}
		return items;
	},
	onExit: function($super) {
		if(this.nextButton)
			this.nextButton.destroy();
			$super();
	},
	effect: function() {
		Log("call Effect before transit to new scene");
		this.bSprite = Builder.makeSprite(this.node, 'Content/black.png', [480,320],[0,0]);
		this.bar1 = Builder.makeNode(this.node, [[100,20],[150,30],[250,200],[190,250]]);
	},
	
	_addNextButton: function() {
		this.nextButton = new UI.Button({
		frame: [210, 290, 60, 30],
		text: "Next",
		disabledTextColor: "FFFF",
		textSize: 14,
		textGravity: UI.ViewGeometry.Gravity.Center,
		gradient: {
			corners: '8 8 8 8',
			outerLine: "00 1.5",
			gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
		},
		highlightedGradient: {
			corners: '8 8 8 8',
			outerLine: "00 1.5",
			gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
		},
		disabledGradient: {
			corners: '0 8 8 8',
			gradient: [ "FF55 0.0", "FF00 1.0"],
		},
		// if the back button is pressed, then launch /Samples/Launcher
		onClick: function(event) {
			Log("Next button onclicked");
			this.listNode.nextNode();
		}.bind(this)
	});
	
	UI.Window.document.addChild(this.nextButton);
	}
},[Observable]);

; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/AllScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/AllScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/AllScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/AllScene.js';

var GL2					 = require('NGCore/Client/GL2').GL2;
var Core				 = require('NGCore/Client/Core').Core;
var UI 					 = require('NGCore/Client/UI').UI;
var Scene				 = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector 		 = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var GUIBuilder			 = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX					 = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions			 = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops 				 = require('NGGo1.3/Foundation/Math/Ops').Ops;
var VietScene 			 = require('Code/view/Scene/VietScene').VietScene;

exports.AllScene = VietScene.subclass({
 	classname: "AllScene",  // must be unique
 	sceneName: "ALL_SCENE",
 	initialize: function($super) {
 		$super();
 		this.btns = [];
 		this.ui = new UI.View();
 		this.ui.setFrame(0,0,450,320); 
 		UI.Window.document.addChild(this.ui);
 	},
 	defineConfig: function(controller,def){
 			var conf = {};
			conf.buttons = def.attrs.buttons; 
			conf.btnSize = def.attrs.btnSize;
    		return conf;
	},
 	onSuccessConfig: function($super) {
 		$super();
 		this.make_buttons(this.CONF.buttons, this.CONF.btnSize);
 		this.ui.setVisible(true);
 	},
 	make_buttons: function(btns, btnSize) {
 		
 		Log("function make_button");
 		var x = 10;
 		var y = 10;
 		for (var i = 0; i < btns.length; i++) {
 			var sceneButton = new UI.Button({
				disabledText: "Returning...",
				disabledTextColor: "FFFF",
				textSize: 10,
				textGravity: UI.ViewGeometry.Gravity.Center,
				gradient: {
					corners: '8 8 8 8',
					outerLine: "00 1.5",
				gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
				},
				highlightedGradient: {
					corners: '8 8 8 8',
					outerLine: "00 1.5",
					gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
				},
				disabledGradient: {
					corners: '0 8 8 8',
					gradient: [ "FF55 0.0", "FF00 1.0"],
				},
				text : btns[i].text,
				frame: [x, y, btnSize[0], btnSize[1]],
	 		});
	 		sceneButton.setOnClick(function() {
	 			this.getParent().setVisible(false);
	 			if(this.getText() == 'TUTOR_SCENE')
	 			   SceneDirector.push(this.getText(), "OPP pa pa gangnam style");
	 			else SceneDirector.push(this.getText());
	 		});
	 		this.ui.addChild(sceneButton);
	 		x += btnSize[0] + 10;
	 		if ( x > 480 - btnSize[0]) {
	 			x = 10;
	 			y += btnSize[1] + 20;
	 		}
	 		if( y > 320 - btnSize[1])
	 			Log("Too much sceneButton, Please reduce size of button");
 		}
 	},
	
	
	
	onEnter: function($super) {
		$super();
	},
	onExit: function($super) {
		this.ui.removeFromParent();
		$super();
	},
	onPause: function($super) {
		Log(this.sceneName + " paused");
		this.ui.setVisible(false);
		this.node.setVisible(false);
		$super();
	},
	onResume: function($super) {
		Log(this.sceneName + " resumed");
		this.ui.setVisible(true);
		this.node.setVisible(true);
		$super();
	}
	
});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/EffectScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/EffectScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/EffectScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/EffectScene.js';

var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var VietScene            = require('Code/view/Scene/VietScene').VietScene;
var Builder              = require('Code/utils/Builder').Builder;
var eff                  = require('Code/utils/eff').eff;

exports.EffectScene = VietScene.subclass({
    classname: "EffectScene",  // must be unique
    sceneName: "EFFECT_SCENE",
    initialize: function($super) {
        $super();
    },
    onSuccessConfig: function() {
        //this.effShakeNode();
        //setTimeout(function() {this.effScaleAppear();}.bind(this),2000);
        this.effSwingNode();
    },
    effShakeNode: function() {
        var sp = Builder.makeSprite(this.node, 'Content/viet/arrow.png',[200,200,64,64]);
        eff.shakeNode(sp,2,5 );
    },
    effScaleAppear: function() {
        var sp = Builder.makeSprite(this.node, 'Content/viet/arrow.png',[200,200,64,64]);
        eff.scaleAppear(this.node,sp,0.25);
    },
    effSwingNode: function() {
        var sp = Builder.makeSprite(this.node, 'Content/viet/arrow.png',[100,50,64,64]);
        eff.shakeNode(sp, 10, 3, 100);
        //eff.swingNode(sp,'horizontal', 15, 0.5);
        var sp1 = Builder.makeSprite(this.node, 'Content/viet/arrow.png',[200,50,64,64]);
        //eff.swingNode(sp1,'vertical', 20, 2);
        eff.shakeNode(sp1, 20, 2);
        var sp2 = Builder.makeSprite(this.node, 'Content/viet/arrow.png',[200,200,64,64]);
        //eff.swingNode(sp2,'other', 18, 0.5);
        eff.shakeNode(sp2, 30, 1, 10);
    },
    
    
    
    
    
    
    
    
    
    
    
    //Must be override
    defineConfig: function(controller,def){
            var conf = {};
            conf.description = def.attrs.description;
            conf.debug = def.attrs.debug || false;
            conf.debugAttrs = def.attrs.debugAttrs || [];
            return conf;
    },
    /* starry night*/
    effect2: function() {
        var darkSky = new GL2.Sprite();
        darkSky.setImage('Content/black.png', new Core.Size(960,640), new Core.Point(0,0));
        for(var i = 0; i < 500; i++) {
            var star = new GL2.Sprite();
            var width = Math.random()*2;
            star.setImage('Content/white.png', new Core.Size(width, width), new Core.Point(0,0));
            star.setAlpha(Math.random()*2);
            star.setPosition(Math.random()*960, Math.random()*640);
            if(i%10 == 0) {
                var seq = VFX.sequence().fadeIn(Math.random()*4, 1).fadeOut(Math.random()*4,0);
                seq.repeat(40);
                seq.play(star);
            }
            darkSky.addChild(star);
            setTimeout(function() {
                VFX.sequence().scaleTo(1,[20,20]);
                VFX.play(star);
            }, 1000*Math.random());
        }
        this.node.addChild(darkSky);
        var seq = VFX.sequence().moveTo(60,[-480,0]).moveTo(60,[-480,-320]).moveTo(60,[0,-320]).moveTo(60,[0,0]);
        //seq.play(darkSky);
    },
    /*
     * Run far away
     */
    effect1: function() {
        console.log("effect1 inited");
        var bar1 = new GL2.Sprite();
        bar1.setImage('Content/black.png', new Core.Size(5,240), new Core.Point(0,0));
        bar1.setPosition(240,160);
        this.node.addChild(bar1);
        var seq = VFX.sequence().rotate(10,360);
        seq.repeat(10);
        seq.play(bar1);
        
        
        for(var i = 0; i < 48; i++) {
            var verticalBar = new GL2.Sprite();
            verticalBar.setImage('Content/black.png', new Core.Size(5,800), new Core.Point(0,0));
            verticalBar.setPosition(i*10, 0);
            if( i < 24)
                verticalBar.setRotation(0-(45 - i*5));
            else if( i > 24)
                verticalBar.setRotation((i -24)*5);
            this.node.addChild(verticalBar);
        }
    }
});









; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/MapSelectionScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/MapSelectionScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/MapSelectionScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/MapSelectionScene.js';

var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var UI                   = require('NGCore/Client/UI').UI;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory         = require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var Builder              = require('Code/utils/Builder').Builder;
var eff                  = require('Code/utils/eff').eff;
var DebugView            = require('Code/utils/DebugView').DebugView;
var Builder              = require('Code/utils/Builder').Builder;
var VietScene            = require('Code/view/Scene/VietScene').VietScene;


exports.MapSelectionScene = VietScene.subclass({
    classname: "MapSelectionScene",  // must be unique
    sceneName: "MAP_SELECTION_SCENE",
    PROGRESS_STATUS_NEW: 0,
    PROGRESS_STATUS_CLEARED: 1,
    PROGRESS_STATUS_TRAINING:2,
    /*
     * 
     * @param data: data.progress_status[]
     * data returned from server, orderation of all objects in any arrays is free
     */
    initialize: function($super,data) {
        $super();
        this._data = data || [   {name: "SM1", status:  {stt1:0, tutorial : "hi there SM1"}}, 
                                 {name: "SM2", status:  {stt1:1}},
                                 {name: "SM3", status:  {stt1:2}}, 
                                 {name: "SM4", status:  {stt1:0, tutorial : "hi there SM4"}}, 
                                 {name: "SM5", status:  {stt1:0, tutorial : "hi there SM5"}}, 
                                 {name: "SM6", status:  {stt1:0, tutorial : "hi there SM6"}}];
        this.sumonings = [];
    },
    defineConfig: function(controller,def) {
        var conf = {};
        conf.description = def.attrs.description;
        conf.debug = def.attrs.debug || false;
        conf.debugAttrs = def.attrs.debugAttrs || [];
        conf.rock = def.attrs.rock;
        conf.sumos = def.attrs.sumos;
        conf.lights = def.attrs.lights;
        return conf;
    },
    onSuccessConfig: function() {
        Log("call onSuccessConfig");
        this._addRock(this.node);
        this._riseRock();
        //this.sunSet(this.node);
        //this.sunLight();
    },
    setupForDebug: function() {
        this.reInitForDebug = function() {
            Log("call reInitForDebug");
            this.node.destroy();
            this.node = new GL2.Node();
            GL2.Root.addChild(this.node);
            this._addBackground();
        };
        this._setConfigAttrs = function(name,value) {
            Log("call _setConfigAttrs");
            switch(name) {
            case 'description' : {this.CONF.description = value;break;}
            case 'debug' : {this.CONF.debug = value;break;}
            case 'l0_ver' : {this.CONF.lights[0].ver = value; break;}
            case 'l0_time' : {this.CONF.lights[0].time = value; break;}
            case 'l0_rot' : {this.CONF.lights[0].rot = value; break;}
            
            case 'l1_ver' : {this.CONF.lights[1].ver = value; break;}
            case 'l1_time' : {this.CONF.lights[1].time = value; break;}
            case 'l1_rot' : {this.CONF.lights[1].rot = value; break;}
            
            case 'l2_ver' : {this.CONF.lights[2].ver = value; break;}
            case 'l2_time' : {this.CONF.lights[2].time = value; break;}
            case 'l2_rot' : {this.CONF.lights[2].rot = value; break;}
            
            case 'l3_ver' : {this.CONF.lights[3].ver = value; break;}
            case 'l3_time' : {this.CONF.lights[3].time = value; break;}
            case 'l3_rot' : {this.CONF.lights[3].rot = value; break;}
            default: Log("Can't find " + name + " in CONF");
        }
        };
    },
    sunSet: function(parentNode) {
        Log("call sunSet");
        var sun = new GL2.Sprite();
        sun.setImage("Content/white.png", [50,50],[0,0]);
        sun.setPosition(200,300);
        sun.setColor(192/256, 255/256,62/256);
        parentNode.addChild(sun);
    },
    
    sunLight: function(pos) {
        Log("call sunLight");
        for (var i = 0; i < this.CONF.lights.length; i++) {
            var l = this.CONF.lights[i];
                Builder.makeLight(this.node,pos,l.ver,l.rot,l.scale,l.time);
        }
    },
    
    
    //Call when player click button to choose sumonor
    onSelectSumonor: function(sumoning) {
        Log("call onSelectSumonor this.classname = " + this.classname);
        //Log("imgPath = " + imgPath);
        
                /*if (s.status.tutorial != undefined) {
                    Log("sumoning: " + s.name + " has tutorial!!!: " + s.status.tutorial);
                    s.status.tutorial = undefined;
                    SceneDirector.push("TUTOR_SCENE", {cb: this.enterBattle.bind(this), args: s});
                  // Push tutorial scene here  or create text of tutorial
                  //After tutorial sh
                } else*/ 
                this._downRock();
                this.enterBattle(sumoning);
            
        
        
    },
    
    enterBattle: function(s) {
          eff.shakeNode(s.node, 4,5);
          //var pos = new Core.Point(s.frame[0] + s.frame[2]/2, s.frame[1] + s.frame[3]/2); //screenToLocal.....//setup more here
          //setTimeout(function() {this.sunLight(this.rock.localToScreen(pos));}.bind(this),1000);
          setTimeout(function() {
                // this.bg.setColor(192/256, 255/256,62/256);
                // this.bg.setDepth(60000);
                SceneDirector.transition("MISSION_SCENE");
           }.bind(this),2200);
    },
    
    /*Make effect such as add "cleared" text on trained sumonor, "on-going" text on training sumonor,...
    @param sumoNode: GL2.Node node that used to display image of sumoning.
    @param status: status of  training progress, 0,1,2
    
    */
    _markProgress: function(sumoNode, status) {
        //Log("call _markProgress  status = " + status );
        var pos = this.rock.localToScreen(sumoNode.getPosition());
       // Log("Pos.x = " + pos.getX() + " pos.y = " + pos.getY());
        switch(status) {
            case this.PROGRESS_STATUS_NEW: 
              //Log("status = new");
                //sumoNode.setColor(1,0,1);
                break;
            case this.PROGRESS_STATUS_CLEARED: 
               // Log("status = cleared");
                var mark = Builder.makeSprite(this.node, 'Content/viet/ninja.png', [pos.getX(), pos.getY()- 20,64,64],[0,0]);
                break;
            case 2: 
                // Log("status = training");
                 sumoNode.setColor(1,0,1);  
                 var sp1 = Builder.makeSprite(this.node, 'Content/viet/arrow_icon.png',[pos.getX(), pos.getY() - 48,50,50],[0,0]);
                 eff.swingNode(sp1,'vertical', 10, 2);
                break;
        }
    },
    
    /*
     * draw sumoning on rock,
     * @param parentNode: GL2.Node - rock,
     * 
     * implement, GL2.Sprite, onClick function,...
     * now add sumoning1,sumoning 2, ... but when mission is settle, ...refactor code
     */
    _addSumoning: function(parentNode) {
        Log("call _addSumoning");
        for (var i = 0; i < this.CONF.sumos.length; i++) {
            var sumoning = {};
            sumoning.name = this.CONF.sumos[i].name;
            sumoning.frame = this.CONF.sumos[i].frame;
            sumoning.status = this._getStatus(sumoning.name) || this.PROGRESS_STATUS_NEW;
            Log("skfjalsfjajfaf: " + this.CONF.sumos[i].imgPath_cleared);
            sumoning.imgPath = this._getImgPath(this.CONF.sumos[i], sumoning.status.stt1);
            Log("IMG PSSSS: " + sumoning.imgPath);
            sumoning.node = Builder.makeSpriteButton(sumoning.imgPath,sumoning.frame,{func: this.bind(this.onSelectSumonor), args: sumoning});
            sumoning.node.addChild(Builder.makeSprite(sumoning.node, "Content/stone/frame.png",[0,0,sumoning.frame[2], sumoning.frame[3]], [0,0]));
            this.sumonings.push(sumoning);
            parentNode.addChild(sumoning.node);
            this._markProgress(sumoning.node, sumoning.status.stt1);
        }   
    },
    // display rock
    _addRock: function(parentNode) {
        Log("call _addRock");
        this.rock = new GL2.Sprite();
        this.rock.setImage(this.CONF.rock.imgPath, this.CONF.rock.size, [0,0]);
        this.rock.setPosition(this.CONF.rock.pos);
        parentNode.addChild(this.rock);
        this._addSumoning(this.rock);
    },
    _getImgPath: function(sumoning, status) {
        Log("SSSSSSSSSSS+ " + status);
        if(status == this.PROGRESS_STATUS_TRAINING)
              return sumoning.imgPath_training;
         else if (status == this.PROGRESS_STATUS_NEW)
              return sumoning.imgPath_new;
         else if (status == this.PROGRESS_STATUS_CLEARED)
              return sumoning.imgPath_cleared;
    },
    
    _riseRock: function() {
    	var seq = VFX.sequence().move(2, [0, -180], Ops.EaseInQuad);
    	setTimeout(function() {
    		seq.play(this.rock);
    		eff.shakeNode(this.bg, 2, 1);
    		eff.shakeNode(this.bg2, 2, 1);
    	}.bind(this), 800);
    	//seq.play(this.rock);
    },
    _downRock: function() {
    	var seq = VFX.sequence().move(2, [0, 180], Ops.EaseInQuad);
    	setTimeout(function() {seq.play(this.rock)}.bind(this), 300);
    	//seq.play(this.rock);
    },
    
    
    /*
     * get progress status of each mission (sumoning) from data
     */
    _getStatus: function(sumoningName) {
        //Log("call _getStatus");
        for (var i = 0; i < this._data.length; i++) {
            if(this._data[i].name == sumoningName)
                return this._data[i].status;
        }
        Log("Can't find sumoning with name = " + sumoningName + " in data");
    },
    _addBackground: function() {
        this.bg = new GL2.Sprite();
        this.bg.setPosition(-2,0);
        this.bg.setImage("Content/bg4.png", new Core.Size(482,320), new Core.Point(0,0));
        this.bg2 = new GL2.Sprite();
        this.bg2.setImage("Content/bg4.png", new Core.Size(482,80), new Core.Point(0,0),[0,0.75,1,0.25]);
        this.bg2.setPosition(-2,240);
        this.bg2.setDepth(62346);
        this.node.addChild(this.bg);
        this.node.addChild(this.bg2);
    }
 });; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/TutorScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/TutorScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/TutorScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/TutorScene.js';

var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var UI                   = require('NGCore/Client/UI').UI;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var Builder              = require('Code/utils/Builder').Builder;
var eff                  = require('Code/utils/eff').eff;
var DebugView            = require('Code/utils/DebugView').DebugView;
var VietScene            = require('Code/view/Scene/VietScene').VietScene;

/*
 * Tutor Scene: like opening a book to read. move to another page if long.
 */
exports.TutorScene = VietScene.subclass({
    classname: "TutorScene",  // must be unique
    sceneName: "TUTOR_SCENE",
    initialize: function(data) {
        Log(this.classname + " initialized");
        this.controller = {};
        this.CONF = {};
        this.node = new GL2.Node();
       // this._addBackground();
    },
    onEnter: function($super, preScene,option) {
        $super();
        Log("option in tutor scene is : " + option);
        this.preScene = preScene;
        this._data = option;
    },
    onSuccessConfig: function() {
        Log("call onSuccessConfigwwwwwwwwwwwwww");
        //Builder.makeSprite(this.node, 'Content/home.png', [200,200,90,90], [0,0]);
        this.spreadClan();
    },
    spreadClan: function() {
        Log("Clan spreading");
        //this.preScene.node.setTouchable(false);
        this.clan = Builder.makeSprite(this.node, 'Content/viet/clan.png', [100,-300, 280,320],[0,0]);
        var txt = "I 123 12 456 12345 0 2   1.5 2.6 ";
        this.text = Builder.makeText(this.clan, [0,20], [220,320], txt, 20, [1,0,0]);
        
        var tt = Builder.makeTouch(this.clan, [280,320], {func: this.rollingBackClan.bind(this), args: 0 });
        var seq = VFX.sequence().moveTo(1, [100, 0], Ops.easeInExpo);
        seq.play(this.clan);
    },
    rollingBackClan: function() {
        Log("Clan is rolling back");
        var seq = VFX.sequence().moveTo(1,[100, -300],Ops.easeInExpo);
        seq.play(this.clan);
        setTimeout(function() {
            SceneDirector.pop();
            if(this._data.cb && this._data.args)
            this._data.cb(this._data.args);
        }.bind(this), 1100
        );
       
    },
    
    //Must be override
    defineConfig: function(controller,def){
            var conf = {};
            conf.description = def.attrs.description;
            conf.debug = def.attrs.debug || false;
            conf.debugAttrs = def.attrs.debugAttrs || [];
            return conf;
    },
  
  
 });; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/Scene/HomeScene'] = function(){var exports = $MODULE_REGISTRY['Code/view/Scene/HomeScene'] || {}; $MODULE_REGISTRY['Code/view/Scene/HomeScene'] = exports; 
var __dirname = 'Code/view/Scene';
var __filename = 'Code/view/Scene/HomeScene.js';

/*
 *
 * 
 * 
 * 
 * 
 */
var ImageListView        = require('NGGo1.3/Service/Graphics/ImageListView').ImageListView;
var GL2                  = require('NGCore/Client/GL2').GL2;
var Core                 = require('NGCore/Client/Core').Core;
var UI                   = require('NGCore/Client/UI').UI;
var Scene                = require('NGGo/Framework/Scene/Scene').Scene;
var SceneDirector        = require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory         = require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var GUIBuilder           = require('NGGo/Framework/GUIBuilder').GUIBuilder;
var VFX                  = require('NGGo1.3/Service/Graphics/VFX').VFX;
var VFXActions           = require('NGGo1.3/Service/Graphics/VFXActions').VFXActions;
var Ops                  = require('NGGo1.3/Foundation/Math/Ops').Ops;
var GLUI                 = require('NGGo1.3/GLUI').GLUI;
var DebugView            = require('Code/utils/DebugView').DebugView;
var Builder              = require('Code/utils/Builder').Builder;
var eff                  = require('Code/utils/eff').eff;
var VietScene            = require('Code/view/Scene/VietScene').VietScene;

exports.HomeScene = VietScene.subclass({
    classname: "HomeScene",
    sceneName: "HOME_SCENE",
    /*
     * type = 0 means display opening story
     * type = 1 means display boss story,...
     * conf is an array that contains stories for each type
     */
    initialize: function($super, type) {
        $super();
        
    },
    defineConfig: function(controller,def) {
          var conf = {};
            conf.description = def.attrs.description;
            conf.debug = def.attrs.debug || false;
            conf.debugAttrs = def.attrs.debugAttrs || [];
            conf.maps = def.attrs.maps || [];
            return conf;
    },
    onEnter: function($super, preScene,option) {
        $super();
        //Log("option in tutor scene is : " + option);
        this.preScene = preScene;
       // this._data = option;
    },
    onSuccessConfig: function() {
        Log("call onSuccessConfig");
        this.createMapButtons(this.CONF.maps);
    },
    
    
    createMapButtons: function(maps) {
        Log("createmapButtons");
        /*
     * args is map_id
     */
        var onSelectMap = function(args) {
            Log(" Select a rock map: index is =====" + args);
            this.node.setTouchable(false);
            SceneDirector.push("MAP_SELECTION_SCENE");
        };
        for (var i = 0; i < maps.length; i++) {
           // Log("var i = " + i);
            var map = maps[i];
            map.node = new GL2.Node();
            //Log("map.frame = " + map.frame);
            map.node.setPosition(map.frame[0], map.frame[1]);
            Builder.makeTouch(map.node,[map.frame[2], map.frame[3]], {func: this.bind(onSelectMap), args: map.id});
            this.node.addChild(map.node);
        }
        
       // this._addClan();
        this._addVietConfig();
        var x_icon = new GL2.Node();
        x_icon.setPosition(430,255);
        Builder.makeSprite(this.node, 'Content/stone/frame.png', [430,255,50,50], [0,0]);
        Builder.makeTouch(x_icon, [50,50], {func: function() {eff.warn("NOT IMPLEMENTED!!");}, args: 0});
        this.node.addChild(x_icon);
       // this.node.addChild(Builder.makeSprite(this.node, "Content/fire.png", [430,255,50,50], [0,0]));
    },
    _addClan: function() {
        var txt = "It's amazing how you, can speak right to my heart, without saying a word, you can light up the dark, try aas i may, i colud never define, what's been said betwwen ou";
        var text = Builder.makeText(GL2.Root, [50,20], [300,220], txt, 16, new Core.Color(1,0,0));
        text.setDepth(63768);
        var seq = VFX.sequence().scaleTo(4,[0.02,1], Ops.EaseInExpo);
        seq.play(text);
      
     },
    _addVietConfig: function() {
        var rect_icon = new GL2.Node();
        Builder.makeSprite(this.node, 'Content/stone/frame.png', [430,120,50,50], [0,0]);
        rect_icon.setPosition(430,120);
        Builder.makeTouch(rect_icon, [50,50], {func: function() {SceneDirector.push("ALL_SCENE");}, args: 0});
        this.node.addChild(rect_icon);
    },
    /*
     * args is map_id
     */
    onSelectMap: function(args) {
        
    },
    onSelectOther: function() {
        Log("On select other button ");
    },
    
    onExit: function($super) {
        this.preScene.node.setTouchable(true);
        $super();
    },
    onPause: function() {
        Log(this.classname + " paused");
        this.node.setVisible(false);
    },
    _addBackground: function() {
        this.bg = new GL2.Sprite();
        this.bg.setImage("Content/home_bg.png", new Core.Size(480,320), new Core.Point(0,0));
        this.node.addChild(this.bg);
    },
    onResume: function($super) {
       $super();
        this.node.setVisible(true);
        this.node.setTouchable(true);
    },

});


; return exports;};
$MODULE_FACTORY_REGISTRY['Code/view/MainGame'] = function(){var exports = $MODULE_REGISTRY['Code/view/MainGame'] || {}; $MODULE_REGISTRY['Code/view/MainGame'] = exports; 
var __dirname = 'Code/view';
var __filename = 'Code/view/MainGame.js';

/********************************************************************************************
 * Class Name: MainGame 
 * 
 * @Description: 
 * 
 *******************************************************************************************/
var UI 						= require('NGCore/Client/UI').UI;
var Core					= require('NGCore/Client/Core').Core;
var GL2						= require('NGCore/Client/GL2').GL2;
var ConfigurationManager    = require('NGGo/Framework/ConfigurationManager').ConfigurationManager;
var ScreenManager			= require('NGGo/Service/Display/ScreenManager').ScreenManager;
var SceneDirector 			= require('NGGo/Framework/Scene/SceneDirector').SceneDirector;
var SceneFactory 			= require('NGGo/Framework/Scene/SceneFactory').SceneFactory;
var DebugScene 				= require('Code/view/Scene/DebugScene').DebugScene;
var PreBattleScene   		= require('Code/module/battle/view/Scene/PreBattleScene').PreBattleScene;
var VietScene				= require('Code/view/Scene/VietScene').VietScene;
var StoryScene				= require('Code/view/Scene/StoryScene').StoryScene;
var ListScene				= require('Code/view/Scene/ListScene').ListScene;
var AllScene 				= require('Code/view/Scene/AllScene').AllScene;
var EffectScene 			= require('Code/view/Scene/EffectScene').EffectScene;
var MapSelectionScene 		= require('Code/view/Scene/MapSelectionScene').MapSelectionScene;
var TutorScene              = require('Code/view/Scene/TutorScene').TutorScene;
var HomeScene               = require('Code/view/Scene/HomeScene').HomeScene;
var MissionScene            = require('Code/module/mission/MissionScene').MissionScene;

exports.MainGame = Core.Class.subclass({
	initialize:function() {
	    NgLogD("++++ MainGame");
	    this.registerScenes();
	    
	    ConfigurationManager.begin(function (err)
	    {
	        if (err)
	        {
	            console.log("Something went very wrong: " + err);
	        } else {
	            var w1 = Core.Capabilities.getScreenWidth();
	            var h1 = Core.Capabilities.getScreenHeight();
	            platformOS = Core.Capabilities.getPlatformOS();
	            
	            var w = 480;
	            var h = 320;
	            var onload = function() {
				        if (platformOS === 'Android') {
				        	w = h1/1.5;
				        	h = w1/1.5;
				        } 
				        
				        ScreenManager.register(
				        {
				            type: "LetterBox",
				            name: "GUI",
				            logicalSize: [w, h]
				        });
				        
				        ScreenManager.setDefault("GUI");
				        
				        if (platformOS === 'Android') {
				        	var scale = ScreenManager.screenSetting._scale;
				        	var ws = scale * w1;
				        	var hs = scale * h1;
				        	//var path = "/?q=BEGIN&scale=" + scale +"&ws=" + ws + "&hs=" + hs + "&w1=" + w1 + "&h1="+h1;
				        	//ServerConsole.log(path);
					        var backdrop2 = new GL2.Sprite();
					        backdrop2.setImage("Content/bg1.png", [h1 - scale * w1, w1], [0, 0]);
					        backdrop2.setDepth(65535);
					        backdrop2.setPosition(ws, 0);
					        GL2.Root.addChild(backdrop2);
				        
				        }
				        
				        GL2.Root.addChild(ScreenManager.getRootNode());
				        
				        Core.UpdateEmitter.setTickRate(0.05);
				        
						// Push main scene
				    	SceneDirector.push("DEBUG_SCENE");
	                };
	                
	            ScreenManager.setLandscape(onload);
	        }
	    });
	},
	
	registerScenes: function() {
		console.log("SON:in registerScenes");
		SceneFactory.register(DebugScene, "DEBUG_SCENE");
    	SceneFactory.register(PreBattleScene, "PRE_BATTLE_SCENE");
    	SceneFactory.register(VietScene,"VIET_SCENE");
    	SceneFactory.register(StoryScene, "STORY_SCENE");
    	SceneFactory.register(ListScene,"LIST_SCENE");
    	SceneFactory.register(AllScene, "ALL_SCENE");
    	SceneFactory.register(EffectScene, "EFFECT_SCENE");
    	SceneFactory.register(MapSelectionScene,"MAP_SELECTION_SCENE");
    	SceneFactory.register(TutorScene, "TUTOR_SCENE");
    	SceneFactory.register(HomeScene, "HOME_SCENE");
    	SceneFactory.register(MissionScene, "MISSION_SCENE");
    	if(Core.Capabilities.getPlatformOS() == "Android") 
    		this.btnBack.setFrame([760,0,40,40]);
    	UI.Window.document.addChild(this.btnBack);
    	
	},
	btnBack: new UI.Button({
        frame: [460, 0, 20, 20],
        text: "X",
        disabledTextColor: "FFFF",
        textSize: 14,
        textGravity: UI.ViewGeometry.Gravity.Center,
        gradient: {
            corners: '8 8 8 8',
            outerLine: "00 1.5",
            gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
        },
        highlightedGradient: {
            corners: '8 8 8 8',
            outerLine: "00 1.5",
            gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
        },
        disabledGradient: {
            corners: '0 8 8 8',
            gradient: [ "FF55 0.0", "FF00 1.0"],
        },
        onClick: function(event) {
              //Log("Back button onclicked + currentScene = " + SceneDirector.currentScene.sceneName);
                if(!SceneDirector.currentScene) { return;}
                if(SceneDirector.currentScene.sceneName != "DEBUG_SCENE") {
                	SceneDirector.pop();
                }
                else{
                	SceneDirector.currentScene.controller._initBackKey();
                }
             
        }
    })
});; return exports;};

var __dirname = 'NGCore/Client';
var __filename = 'NGCore/Client/Legacy.js';

(function()
{
	if(!Function.prototype.hasOwnProperty('bind'))
	{
		var slice = Array.prototype.slice;
		Function.prototype.bind = function(context)
		{
			var func = this;
			if(arguments.length > 1)
			{
				var args = slice.call(arguments, 1);
				return function()
				{
					if(arguments.length)
					{
						var finalArgs = args.concat(slice.call(arguments));
						return func.apply(context, finalArgs);
					}
					else
					{
						return func.apply(context, args);
					}
				};
			}
			else
			{
				return function()
				{
					if(arguments.length)
						return func.apply(context, arguments);
					else
						return func.call(context);
				};
			}
		};
	}
})();

(function()
{
	if(!Array.prototype.hasOwnProperty('indexOf'))
	{
		Array.prototype.indexOf = function(obj)
		{
			var len = this.length;
			for(var i=0; i < this.length; ++i)
			{
				if(obj === this[i])
					return i;
			}
			return -1;
		};
	}
})();

function userGameInit()
{
	console.log("ngCore calling main()");
	main();
}
//////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-11-0?
 *  @file:      NgWebEngine.js
 *  Website:    http://www.ngmoco.com/
 *  Copyright:  2010, by ngmoco:)
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
var NGSetTimeoutRunTimers = require('NGCore/Client/UI/NGJSEnvironmentSupport').NGSetTimeoutRunTimers;
var SystemBinding = require('NGCore/Client/UI/SystemBinding').SystemBinding;
var Downloader = require("NGCore/Client/Network/DownloadManifest").Downloader;
var LocalGameList = require("NGCore/Client/Core/LocalGameList").LocalGameList;
var Device = require('NGCore/Client/Device').Device;
var Core = require('NGCore/Client/Core').Core;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Localization = require('NGCore/Client/Core/Localization').Localization;

// Global until oauth does not depend on storage.
var Storage = require('NGCore/Client/Storage').Storage;

//////////////////////////////////////////////////////////////////////////////////////////////////
// App switching.

var NgProcID =
{
    PersistProc: -1,
    GameProc: -2
};

//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

var gNgShutdownPending = false;


/////////////////////////////////////////////////////////////////////////////////////////////////
// Global data.
//////////////////////////////////////////////////////////////////////////////////////////////////

var gNgEngineEntities;
var gNgAddedEngineEntities;
var gNgRemovedEngineEntities;

var gNgUpdateEngineEntities;
var gNgTouchEngineEntities;
var gNgKeyPressEngineEntities;


//////////////////////////////////////////////////////////////////////////////////////////////////
// This function is called once by the html container to initialize the game.
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

function NgEngineInitPrivate()
{
	NgLogInit();

	NgApplication.getInstance().restart();

	gNgEngineEntities = [];
	gNgAddedEngineEntities = [];
	gNgRemovedEngineEntities = [];

	gNgUpdateEngineEntities = [];
	gNgTouchEngineEntities = [];
    gNgKeyPressEngineEntities = [];
}

//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

function NgEngineProcessEntityAddRemove()
{
        var i, e;
	for(i in gNgAddedEngineEntities)
	{
		e = gNgAddedEngineEntities[i];
		if(e.mIsUpdatable) gNgUpdateEngineEntities[e.mId] = e;
	}
	gNgAddedEngineEntities = [];

	for(i in gNgRemovedEngineEntities)
	{
		e = gNgRemovedEngineEntities[i];

		if(e.mIsUpdatable) delete gNgUpdateEngineEntities[e.mId];
	}
	gNgRemovedEngineEntities = [];
}

/**
  * @private
  */

function NgHandleException(ex)
{
	if (Core.Proc.isPrivileged()) {
		NgLogException( ex );
	}
	else {
		NgLogException( ex );
		var exStr = JSON.stringify(ex);
		Core.LocalGameList._forwardException(exStr);
	}
}

function NgEngineInit(inputs)
{
	NgLogD("NgEngineInit beg");
	try
	{
		NgEngineInitPrivate();

		//NgLogD("Initializing Storage");
		//Storage.init();
		//NgLogD("Storage initialized");
		NgLogD("KeyValue Storage initializing...");
		Storage.KeyValueCache.init();
		NgLogD("KeyValue Storage initialized...");
	
		Core.Time.instantiate();
	
		NgLogD("Instantiate the Localization context (singleton), depends on Capabilities");
		Localization.instantiate();

	}
	catch( ex )
	{
		NgHandleException(ex);
	}
	NgLogD("NgEngineInit end");	
	
	return NgEngineUpdate(inputs);
}

function NgPreInit(inputs)
{
	NgLogD("Localization NgPreInit beg");
	return update(inputs);
}

/**
  * @private
  */

function NgGameInit(inputs)
{
	NgLogD("NgGameInit beg");

	Core.Analytics.instantiate();

	try
	{

		userGameInit();
	}
	catch( ex )
	{
		NgHandleException(ex);
	}
	NgLogD("NgGameInit end");

	return update(inputs);
}

/**
  * @private
  */

// TEMPORARY: Until native code is updated to call NgEngineUpdate.
function update ( inputs )
{
	return NgEngineUpdate ( inputs );
}

//Frame loop calls this every time, get the object out of require_ once ahead of time.
var NGSetTimeoutRunTimers = require("NGCore/Client/UI/NGJSEnvironmentSupport").NGSetTimeoutRunTimers;

var setTimeoutOrig = setTimeout;
setTimeout  = function(fn, time)
{
	return setTimeoutOrig(function() 
	{
		try
		{
			fn();
		}
		catch( ex )
		{
			NgHandleException(ex);
		}
	}, time);
	
};


var setIntervalOrig = setInterval;
setInterval  = function(fn, time)
{
	return setIntervalOrig(function() 
	{
		try
		{
			fn();
		}
		catch( ex )
		{
			NgHandleException(ex);
		}
	}, time);
	
};



/**
  *	Main entry point for native to invoke JS.
  * @private
  */
var NgEngineUpdate = (function()
{
	var Core = require('NGCore/Client/Core').Core;
	
return function ( inputs )
{
	// time causes a racehorse-sized leak in v8. Only use this for single profiling runs. DO NOT CHECK IN.
//	time.stop('frame');
//	time.start('frame');
	var i;
	try {
		NGSetTimeoutRunTimers();

		if (typeof inputs === "function")
		{
			inputs();
		}
		else if (inputs.length)
		{
			NgEngineProcessEntityAddRemove();
			var commands = inputs.split(':');
			for(i=0; i<commands.length; ++i)
			{
				var command = commands[i];

				// Make sure this isn't an empty input.
				if(0 === command.length) {
					continue;
				}

				switch(parseInt(command))
				{
					case NgEntityTypes.App:
						NgApplication.getInstance().handleCommand(command);
						break;
					case NgEntityTypes.NgFileSys:
						NgApplication.getInstance().getFileSys().handleCommand(command);
                        break;
					case NgEntityTypes.Storage:
						NgLogD("Command for storage is " + command);
						Storage.getInstanceForCommand(command).handleCommand(command);
						break;
					case NgEntityTypes.NgUI:
						var Window = require('NGCore/Client/UI/Window').Window;
						Window.handleCommand(command);
						break;
					case NgEntityTypes.NgSystemBinding:
						SystemBinding.handleCommand(command);
						break;
					case 3117:
						console.log('got leet response');
						if(typeof(_WifiDiagCallback) != 'undefined')
							_WifiDiagCallback(command);
						break;
					default:
						Core.Proc._classRecvGen( command.split( ',' ) );
						break;
				}
			}
		}

		if( gNgShutdownPending )
		{
			gNgShutdownPending = false;
		}
		else	// Don't do updates if we're resetting.
		{
			NgEngineProcessEntityAddRemove();
			for(i in gNgUpdateEngineEntities)
			{
				var entity = gNgUpdateEngineEntities[i];
				if(!entity.mRegistered) continue;
				entity.onUpdate();
			}
		}
	}
	catch(ex)
	{
		NgHandleException(ex);
	}
		
	var commandsFromJS = Core.Proc.getCommandString() + NgFlushCommandsToString();
	Core.Proc.clearCommandString();

	return commandsFromJS;
};
})();


//////////////////////////////////////////////////////////////////////////////////////////////////
////	NgApplication class
//////////////////////////////////////////////////////////////////////////////////////////////////

var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Logger = require('NGCore/Client/Core/Logger').Logger;

/** @private */

var NgApplicationCommands = {
	Caps : 0,
	Debug : 1,
	FrameTime : 2,
	FrameRate : 3,
	Start : 4,
	DeviceOrientation: 10,
	SetOrientation: 11,
	BackPress: 12,
	OnBackPressed: 13,
	LaunchExternalNativeApp: 15,
	ExitSystemProcess: 16
};

/**
  * Enumeration values for orientation change events received by
  * {@link NgApplicationObserver}.
  */

var NgApplicationOrientation = {
	Portrait : 0,
	PortraitUpsideDown : 1,
	LandscapeLeft : 2,
	LandscapeRight : 3,
	FaceUp : 4,
	FaceDown : 5
};

/**
  * The NgApplication constructor is invoked during application bootstrap and
  * should not be created by the ngGame application.  Access to the application
  * object should be through the singleton accessor {@link NgApplication#getInstance}.
  * @constructor
  *
  * @class
  * The NgApplication class represents global state and services that are available to
  * ngGame applications.  This includes file system operations,
  * download services, etc.  The application class also manages a time source
  * that is synchronized between the native engine and the ngGame application. <br>
  * The application object is a singleton and should only be accessed through the
  * {@link NgApplication#getInstance} method.
  */

function NgApplication()
{
	/** @private */
	this.mFileSys = Storage.FileSystem;
	/** @private */
	this.mFrameTime = 0.0;
	/** @private */
	this.mObservers = [];
}

// Singleton instance.
/** @private */
NgApplication.sInstance = null;

/**
  * Acquire the singleton instance of the application class.
  * @type NgApplication
  * @return The global application object.
  */

NgApplication.getInstance = function()
{
	if( NgApplication.sInstance === null )
		NgApplication.sInstance = new NgApplication();

	return NgApplication.sInstance;
};

// APITODO: Switch these methods to be defined out-of-line, not by an object literal.

NgApplication.prototype =
{
	mFileSys : null,
	mObservers : [],
	mFrameTime : 0.0,
	
	/** @private */
	restart : function()
	{
	},
	
	/** @private */
	handleCommand : function(command)
	{
		//		NgLogD( "NgApplication command = " + command );

		var commandId = NgPeekCommandId( command );

		switch( commandId )
		{
			case NgApplicationCommands.FrameTime:
				this.parseFrameTime( command );
				break;
			case NgApplicationCommands.Start:
				this.onApplicationStart();
				break;
			case NgApplicationCommands.OnBackPressed:
				this.onApplicationBackPressed();
				break;
			default:
				NgLogE( "NgApplication command unknown: " + command);
				break;
		}
	},
	
	/**
	  * Acquire the file system object.
	  * @type NgFileSys
	  * @return The file system instance.
	  */
	getFileSys : function()
	{
		return this.mFileSys;
	},

	/** @private */
	ngLog : function( level, dbgStr )
	{
		NgPushCommand4( NgEntityTypes.App, NgApplicationCommands.Debug, Core.Base64.encode( dbgStr ), level );
	},
	
	/** @private */
	parseFrameTime : function( command )
	{
		var fields = NgParseCommand2(command,parseInt,parseFloat);
		var frameTime = fields[1];

		if(this.mFrameDelta === undefined)
			this.mFrameDelta = 0;
		else
			this.mFrameDelta = frameTime - this.mFrameTime;

		this.mFrameTime = frameTime;
	},
	
	/**
	  * Get the application time for the current frame.
	  * @type number
	  * @return The time in milliseconds.
	  */
	getFrameTime : function()
	{
		return this.mFrameTime;
	},
	
	/**
	  * Get the application time delta between the current frame and the last frame.
	  * @type number
	  * @return The time delta in milliseconds.
	  */
	getFrameDelta : function()
	{
		return this.mFrameDelta;
	},

	/**
	  * Set the desired application frame rate. <br>
	  * Note: The frame rate specification is not currently fully functional on all 
	  * platforms.
	  * @param {number} frameRate The desired frame rate in hz.
	  * @type void
	  */
	setFrameRate : function(frameRate)
	{
		NgPushCommand3( NgEntityTypes.App, NgApplicationCommands.FrameRate, frameRate);
	},

	/**
	  * Set the current device orientation for the application. <br>
	  * Note: Setting the orientation is not currently fully functional on all
	  * platforms.
	  * @param {NgApplicationOrientation} orientation The desired orientation.
	  * @type void
	  */
	setOrientation : function(orientation)
	{
		NgPushCommand3( NgEntityTypes.App, NgApplicationCommands.SetOrientation, orientation);
	},

	/**
	  * Register an application observer to receive application callbacks.
	  * @param {NgApplicationObserver} obs The observer to register.
	  * @type void
	  */
	registerObserver : function(obs)
	{
		obs.index = this.mObservers.push(obs);
	},

	unregisterObserver : function(obs)
	{
		if (obs.index)
			delete this.mObservers[obs.index - 1];
	},

	/** @private */
	onApplicationStart : function()
	{
		// NgUI.onLoad(); // it should be obsolete
		for (var i in this.mObservers)
		{
			// TODO is this even possible?
			this.mObservers[i].onApplicationStart();
		}
	},
	
	/** @private */
	onApplicationReceivedCustomMessage : function( message )
	{
		for (var i in this.mObservers)
		{
			this.mObservers[i].onApplicationReceivedCustomMessage( message );
		}
	},
	
	/** @private */
	onApplicationBackPressed : function()
	{
			var observerResult = false;
			for (var i in this.mObservers)
			{
				 if (this.mObservers[i].onApplicationBackPressed())
				 {
					observerResult = true;
					break;
				 }
			}
			if (!observerResult)
			{
				// back button was not fully handled. Ask the native application to handle it.
				NgPushCommand2(NgEntityTypes.App, NgApplicationCommands.BackPress);
			}
	},
	
	/** @private */
	exitSystemProcess : function ()
	{
		NgLogD ( "pushing exit command" );
		//This makes java exit the app through android lifecycle
		NgPushCommand2(NgEntityTypes.App, NgApplicationCommands.BackPress);
		NgLogD ( "pushed exit command" );
	}
};

// Observer base class for application events.

/**
  * Initialize a new application observer.
  * @constructor
  *
  * @class
  * The NgApplicationObserver class is used as the base class for any user-defined
  * class that receives application-level callbacks.  This currently includes
  * notifications on all application lifecycle events and device orientation
  * changes. <br>
  * Register the application observer by calling {@link NgApplication#registerObserver}.
  */

function NgApplicationObserver() {}

NgApplicationObserver.prototype =
{
	index: 0,
	/**
	  * Callback for application lifecycle start event.
	  * @type void
	  */
	onApplicationStart:function() {},

	/** @private */
	onApplicationReceivedCustomMessage:function( message ) {},

	/**
	  * Callback for device orientation change events.
	  * @param {NgApplicationOrientation} orientation Orientation enumeration value.
	  * @type void
	  */
	onApplicationDeviceOrientation:function( orientation ) {},

	/*
	 * Listener for when the user pushes the HW back button. Currently Android only.
	 *
	 * @return boolean true if back was handled entirely (eat the event), 
	 * false if it was not
	 *
	 */
	onApplicationBackPressed:function()
	{
		return false;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// class Entity
// Base class for other entity types.
//////////////////////////////////////////////////////////////////////////////////////////////////

// ObjectTypes
// Defined in
//		JS:  NgEntityTypes in NgWebEngine.js and
//		C++: EntityCommandIds in GameView.h
// 1 = App
// 2 = NgTouchEvent
// 3 = NgKeyPressEvent
// 4 = Accel
// 5 = NgTextInputBox2D
// 6 = Animation (completion events)
// 7 = Sound (completion events)
// 8 = EngineEntity
// 9 = DrawableEntity2D
// 10 = NgCanvas2D
// 11 = NgCamera2D
// 12 = NgSprite2D
// 13 = NgText2D
// 14 = NgWebView2D
// 15 = NgAudioManager
// 16 = NgGroup2D
// 100 = LoadApp

// App Commands
// in:
// capabilities = 0, command dictionary format
// frameTime = 2, double
// out:
// NgLogD = 1, string

// NgTouchEvent Commands
// non-native
//	action: 1 = add, 2 = remove, 3 = modify
//	id: touch instance ID
//	x: x position
//	y: y position
// native
//	action: 4 = add, 5 = remove, 6 = modify
//	id: touch instance ID
//	x: x pos
//	y: y pos
//  eid: entity instance ID
//	lx: local x pos
//  ly: local y pos

// NgKeyPressEvent Commands
// action: 1 = down, 2 = up
// id: instance ID
// value: key value

// InputText Box Commands

// Animation
// in:
// only one kind of event, so first value is id of sprite to callback.

// Sound
// in:
//

// Accel Commands
// out:
// SetEventRate = 0, rate (hz)
// in:
// x, y, z position (floats)

// EngineEntity commands

// DrawableEntity2D commands:
// SetNativeTouchType=1,id,value (None=1, Enable = 2, EnableBounds = 3)

// NgCanvas2D Commands
// NewNgCanvas2D=1, id
// DeleteNgCanvas2D=2, id
// Update=3, id, args... not used currently
// SetRoot=4, id, grp id
// ClearRoot=5, id
// EnableNativePicking=6, id, bool

// NgCamera2D Commands
// NewNgCamera2D=1,		id, canvasId, porperties
// DeleteNgCamera2D=2,	id
// UpdateNgCamera2D=3,	id, properties
//	Properties: vx, vy, vz, vh, vw, cx, cy, ch, cw

// NgSprite2D Commands
// NewNgSprite2D=1,		id, canvasId, texture, properties
// DeleteNgSprite2D=2,	id
// UpdateNgSprite2D=3,	id, properties
//   Properties: x, y, z, w, h, r, a

// NgText2D Operations
// NewNgText2D=1		id, canvasId, properties
// DeleteNgText2D=2	id
// UpdateNgText2D=3	id, properties
//  Properties: x, y, z, w, h, justify, text

// NgGroup2D Operations
// New = 1			id, canvasId, [properties/todo]
// Delete = 2		id
// Update = 3		id, [properties/todo]
// Child = 4		id, subcmd, [child id]
//						subcmd 0 = add, 1 = rem, 2 = remAll (no child id)
// Rot = 5			id, anglef
// Pos = 6			id, xf, yf, zf
// Alpha = 7		id, alphaf
// Scale = 8		id, xf, yf

// APITODO: Clean up these identifiers.
// APITODO: Sound is probably not used any more.
// APITODO: Animation is probably not used any more.

var NgEntityTypes = {
	App : 1,
	NgTouchEvent : 2,
	NgKeyPressEvent : 3,
	Accel : 4,
	NgTextInputBox2D : 5,
	Animation : 6,
	Sound : 7,
	NgEngineEntity : 8,
	NgDrawableEntity2D : 9,
	NgCanvas2D : 10,
	NgCamera2D : 11,
	NgSprite2D : 12,
	NgText2D : 13,
	NgWebView2D : 14,
	NgGroup2D : 16,
	NgPhysics2D: 17,
	NgPrimitive2D: 18,
	NgFileSys: 19,
	Gyro : 22,
	NgUI : 23,
	Storage: 24,
	NgSystemBinding: 25,
	NgCustomMessage : 50,
	LoadApp : 100
};

var NgEngineEntityCommandIDs = {
	SetNativeTouchType : 1
};

/**
 * Initializes instance to default values. <br>
 * mId member defaults to 0 but can be set by application before calling {@link NgEngineEntity#register}.
 * @constructor
 *
 * @class
 * NgEngineEntity is the base class for all game entities, such as NgSprite2D and NgText2D. <br>
 * This class introduces key callback functions for touch, key press and per-frame update
 * notification. <br>
 * Additionally, the class introduces a register/unregister mechanism
 * for controlling the existence of the entity in the native game engine.
 *
 */

function NgEngineEntity()
{
	/** The entity id.  Used by the native engine for identification.  @type number */
	this.mId = 0;
	/** The touch priority.  Touches are routed first to the highest priority entities.  @type number */
	this.mTouchPriority = 0;
	/** The key press priority.  Key presses are routed first to the highest priority entities.  @type number */
	this.mKeyPressPriority = 0;
	/** @private */
	this.mIsTouchable = false;
	/** @private */
	this.mIsKeyable = false;
	/** @private */
	this.mIsUpdatable = false;
	/** @private */
	this.mNativeTouchType = NgEngineEntity.NativeTouchType.Enable;
	/** @private */
	this.mRegistered = false;
}

// Static methods and data.

/**
  * NgEngineEntity touch policy enumeration. <br>
  * Used with {@link NgEngineEntity#setNativeTouchType} and {@link NgCanvas2D#enableNativePicking}. <br>
  * Values: <br>
  * None : Disables native touches for this entity (and its children). <br>
  * Enable : Enables this entity to receive touches (or visits child entities) <br>
  * EnableBounds : Enables this entity to receive touches on its axis-aligned bounding box.  If
  * a touch is received on a group, it will report the touch and _not_ visit the group's children.
  */

NgEngineEntity.NativeTouchType = {
	None : 0,
	Enable : 1,
	EnableBounds : 2
};

/**
  * @private
  */

NgEngineEntity.engineCurrentId = 1;

/**
  * Allocate a unique ID for an entity.
  * @return ID value.
  * @type number
  * @private
  */

NgEngineEntity.newEngineId = function ()
{
	return NgEngineEntity.engineCurrentId++;
};

/**
  * Reclaim an entity ID.
  * @private
  */

NgEngineEntity.deleteEngineId = function ()
{
	// Nothing.
};

// Instance methods.

// Basic entity callbacks.

/** @private */

NgEngineEntity.prototype.newEntity = function() {};

/** @private */

NgEngineEntity.prototype.deleteEntity = function() {};

/**
  *	Callback for standard touch events. <br>
  * Standard touch events correspond to all touches
  * within the game view.  For each touch on the game view, all registered touchable
  * entities will receive the event.  Application logic must perform filtering to determine
  * if a particular entity corresponds to the touch event. <br>
  * Refer to {@link NgEngineEntity#toggleTouchable} for control of an entity's touchable state.
  * @param {NgTouchEvent} touch The touch event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onTouch = function(touch)
{
	return false;
};

/**
  * Callback for native touch events. <br>
  * Native touch events are pre-filtered by the game engine
  * to correspond to a specific touchable entity.  For each touch on the game view, the game
  * engine will determine which game entities are selected by the touch event.  Only the 
  * selected entities will receive the onNativeTouch event callback. <br>
  * Native touch capability is not affected by touchable state of the entity determined by
  * {@link NgEngineEntity#toggleTouchable}.  Refer to {@link NgEngineEntity#setNativeTouchType} 
  * for management of an entity's native touch policy.
  * @param {NgNativeTouchEvent} touch The touch event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onNativeTouch = function(touch)
{

};

/**
  * Callback for keyboard events. <br>These events correspond to physical or software keyboard events. <br>
  * Enable/disable key press events for an entity with {@link NgEngineEntity#toggleKeyable}.
  * @param {NgKeyPressEvent} keyPress The key press event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onKeyPress = function(keyPress)
{
	return false;
};

/**
  *	Callback for update events. <br>Per-frame entity logic should be implemented in this callback. <br>
  * Enable/disable update events for an entity with {@link NgEngineEntity#toggleUpdatable}.
  * The return value of this method is ignored.
  * @type void
  */

NgEngineEntity.prototype.onUpdate = function()
{
};

/**
  *	Register this entity instance with the native game engine. <br>
  * The initialization sequence of engine entities has specific constraints: <br>
  * After construction and before calling
  * the register method, class methods that affect the native engine state cannot be called.  
  * During this period, changes to entity state by changing instance variables will be
  * sent to the native engine on the call to register. <br>
  * After register is called, 
  * changes to instance variables will be ignored.  During this phase, the only
  * way to affect native engine state is through methods that push commands to
  * the native side.
  * @type void
  */

NgEngineEntity.prototype.register = function()
{
	this.mParents = [];

	if( this.mId >= 0 )
	{
		this.mId = NgEngineEntity.newEngineId();
	}

	this.mRegistered = true;
	gNgEngineEntities[this.mId] = this;
	gNgAddedEngineEntities[this.mId] = this;
	this.newEntity();
};

/**
  * Unregister this entity from the native game engine.
  * @type void
  */

NgEngineEntity.prototype.unregister = function()
{
	var parents = this.mParents.concat([]);

	for (var i in parents)
	{
		NgLogD ( "Removing child " + this.mId + " from parent Group " + parents[i].mId + " because the Entity was unregistered");
		parents[i].removeChild( this );
	}

	this.mRegistered = false;
	delete gNgEngineEntities[this.mId];
	// CAUTION : DO NOT SPLICE gNgEngineEntities EVER.
	//gNgEngineEntities.splice(this.mId,1);

	gNgRemovedEngineEntities[this.mId] = this;
	this.deleteEntity();

	if(this.mId >= 0)
		NgEngineEntity.deleteEngineId(this.mId);
};

/**
  * Enable/disable update callbacks for this entity. <br>
  * This method flips the enable state
  * for update events. <br>
  * In order to receive update callbacks, an entity
  * must override the onUpdate event and enable updatable state by calling this 
  * method. <br>
  * The default state is false.
  * @type void
  */

NgEngineEntity.prototype.toggleUpdatable = function()
{
	if(this.mIsUpdatable)
	{
		delete gNgUpdateEngineEntities[this.mId];
	}
	else
	{
		gNgUpdateEngineEntities[this.mId] = this;
	}
	this.mIsUpdatable = !this.mIsUpdatable;
};

/**
  * Set native touch traversal policy. <br>
  * This method controls how the native game engine
  * traverses the game scene graph. <br>
  * The policies are described in further detail with {@link NgEngineEntity#NativeTouchType}. <br>
  * The default state is "Enable".
  * @param {NativeTouchType} type The policy enum for native touch processing.
  * @type void
  */

NgEngineEntity.prototype.setNativeTouchType = function( type )
{
	this.mNativeTouchType = type;
	NgPushCommand4(NgEntityTypes.NgDrawableEntity2D, NgEngineEntityCommandIDs.SetNativeTouchType, this.mId, this.mNativeTouchType );
};
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;

// These methods handle all composition for commands being sent back to the
// native engine.

/**
  * @private
  */

var gNgCommandStrings = [];

/**
  * @private
  */

var gNgCommandString = '';

// 0 deferred string composition via user loop
// 1 deferred string composition via internal loop
// 2 on-the-fly string composition.

// TODO: Benchmark all variation on all platforms.  Choose appropriate one(s)
// and prune code for others.

// UPDATE: ALL variations on contructing a string performed IDENTICALLY in
// the iPhone's UIWebView.  Unbelievable.

/**
  * @private
  */

var gNgCommandMode = 2;

/**
  * @private
  */

function NgQueueCommandText(command)
{
	switch(gNgCommandMode)
	{
		case 0:
		case 1:
			gNgCommandStrings.push( command );
			break;
		case 2:
			gNgCommandString += command;
			break;
	}
}

/**
  * @private
  */

function NgFlushCommandsToString()
{
	var outputString = '';
	
	switch(gNgCommandMode)
	{	
		case 0:
			for( var num = 0, end = gNgCommandStrings.length; num < end; ++num )
			{
				outputString += gNgCommandStrings[ num ];
			}
			break;
			
		case 1:
			outputString = String.prototype.concat.apply(gNgCommandStrings);
			break;
	}
	
	switch(gNgCommandMode)
	{
		case 0:
		case 1:
			gNgCommandStrings = [];
			break;
		case 2:
			outputString = gNgCommandString;
			gNgCommandString = '';
			break;
	}
	
	return outputString;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

function NgParseString(txt)
{
	return txt;
}

/**
  * @private
  */

function NgParseBase64(txt)
{
	if( txt )
		return Core.Base64.decode(txt);
	else
		return "";
}

/**
  * @private
  */

function NgParseBool(txt)
{
	return parseInt(txt) ? true : false;
}

function NgParseInt(txt)
{
	return parseInt(txt, 10);
}

function NgKVArrayToCmd(kvArray)
{
	var out = "";
	var count = 0;
	for (var s in kvArray)
	{
		var value = kvArray[s];
		
		out += "," + s + "," + Core.Base64.encode(value);
		++count;
	}
	return count + out;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Submit a command with 1 argument to the native engine.
 * @private
 */
function NgPushCommand1(arg1)
{
	gNgCommandString += ":" + arg1;
}

/**
 * Submit a command with 2 arguments to the native engine.
 * @private
 */
function NgPushCommand2(arg1, arg2)
{
	gNgCommandString += ":" + arg1 + "," + arg2;
}

/**
 * Submit a command with 3 arguments to the native engine.
 * @private
 */
function NgPushCommand3(arg1, arg2, arg3)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3;
}

/**
 * Submit a command with 4 arguments to the native engine.
 * @private
 */
function NgPushCommand4(arg1, arg2, arg3, arg4)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4;
}

/**
 * Submit a command with 5 arguments to the native engine.
 * @private
 */
function NgPushCommand5(arg1, arg2, arg3, arg4, arg5)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5;
}

/**
 * Submit a command with 6 arguments to the native engine.
 * @private
 */
function NgPushCommand6(arg1, arg2, arg3, arg4, arg5, arg6)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6;
}

/**
 * Submit a command with 7 arguments to the native engine.
 * @private
 */
function NgPushCommand7(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7;
}

/**
 * Submit a command with 8 arguments to the native engine.
 * @private
 */
function NgPushCommand8(arg1, arg2, arg3, arg4, arg5, arg6, arg7,arg8)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7 + "," + arg8;
}

/**
 * Submit a command with 8 arguments to the native engine.
 * @private
 */
function NgPushCommand9(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7 + "," + arg8 + "," + arg9;
}

/**
 * Submit a command with n arguments to the native engine.
 * @private
 */
function NgPushCommandN()
{
	var argv = arguments;
	var argc = argv.length;
	
	var tmp = ":";
	
	if( argc > 0 )
	{
		tmp += argv[ 0 ];
		
		for( var num = 1; num < argc; ++num )
		{
			tmp += "," + argv[ num ];
		}
	}
	
	gNgCommandString += tmp;
}

/**
 * Peek at the command ID in a command string.  This helps avoid 
 * splitting the string twice in a number of cases.
 * @return Command id or null if parsing failed.
 * @private
 */

function NgPeekCommandId(str)
{
	var vals = str.split ( ",", 2 );
	if( vals.length == 2 )
		return parseInt ( vals[ 1 ] );
	else
		return null;
}

/**
 * Peek at the class and command ID in a command string.  This helps avoid 
 * splitting the string twice in a number of cases.
 * @return Two-element array of ids or null if parsing failed.
 * @private
 */

function NgPeekClassAndCommandId(str)
{
	var vals = str.split ( ",", 2 );
	if( vals.length == 2 )
	{
		vals[ 0 ] = parseInt ( vals[ 0 ] );
		vals[ 1 ] = parseInt ( vals[ 1 ] );
		return vals;
	}
	else
		return null;
}


/**
 * Parse an incoming command string to individual strings.
 * @return an array of fields in serialization order.
 * @private
 */
function NgParseCommandToStrings(src)
{
	return src.split(",");
}

/**
  * @private
  */

function NgParseCommand1(src, func1)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand2(src, func1, func2)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand3(src, func1, func2, func3)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand4(src, func1, func2, func3, func4)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	ret[ 3 ] = func4( fields[ 4 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand5(src, func1, func2, func3, func4, func5)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	ret[ 3 ] = func4( fields[ 4 ] );
	ret[ 4 ] = func5( fields[ 5 ] );
	
	return ret;
}


/**
 * Parse an incoming command string to typed values based on passed-in functions.
 * ex: NgParseCommandN("1:1,1.0,ACFHENA==",parseInt, parseFloat, NgParseString);
 * NOTE: The first item is assumed to be the command type, and will be
 * discarded in the output.  I.e., the output starts with the second src element.
 * @return an array of parsed fields in serialization order.
 * @private
 */

function NgParseCommandN(src)
{
	var ret = [];
	
	var argv = arguments;
	var argc = argv.length;
	
	var fields = src.split(",");
	for( var num = 1; num < argc; ++num )
	{
		ret[ num - 1 ] = argv[ num ]( fields[ num ] );
	}
	
	return ret;
}

/**
 * Parse an incoming typed dictionary.  The format of the dictionary is:
 * type,field name,value,type,field name,value[...]
 * Parsed values will be asigned to the field name in the dst array/object.
 * NOTE: Strings passed in this format must not have embedded commas (use
 * base64 encoding if arbitrary strings are being used.
 * @arg src The source command string.
 * @arg srcStart The field index to start parsing dictionary entries from.
 * @arg dst The destination object/array for parsed values.
 * @arg initialFields Optionally store the fields before srcStart in the passed-in array.
 * @return true if all fields were successfully parsed.
 * @private
 */

function NgParseCommandDictionary(src,srcStart,dst,initialFields)
{
	var ret = true;
	var fields = src.split(",");
	var end = fields.length;
	var num;

	if(initialFields)
	{
		for( num = 0; num < srcStart; ++num )
		{
			initialFields[ num ] = fields[ num ];
		}
	}
	
	for( num = srcStart; num < end; )
	{
		var type = fields[ num++ ];
		var name = fields[ num++ ];
		var val = fields[ num++ ];
		var good = true;
		
		switch(type)
		{
			case 'i':	// int
				val = parseInt( val );
				break;
			case 'f':	// float
				val = parseFloat( val );
				break;
			case 's':	// string
				break;
			case 'S':	// base64 string
				val = Core.Base64.decode(val);
				break;
			case 'b':	// bool
				val = parseInt(val) ? true : false;
				break;
			default:
				//				NgLogD("NgParseCommandDictionary unknown type for " + type + " " + name + " " + val);
				ret = false;
				good = false;
				break;
		}
		
		if( good )
		{
			dst[ name ] = val;
			
			// TEMP PRW
			NgLogD( "dict: " + name + " : " + dst[ name ] );
		}
		else
		{
			NgLogD("dict: could not process " + type );
		}
	}
	
	return ret;
}
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var FileSystem   = require('NGCore/Client/Storage/FileSystem').FileSystem;

/**
  * @private
  */

var gNgTrace=null;

//////////////////////////////////////////////////////////////////////////////////////////////////
// Logging functions.
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */
var NgDebugModes = {
	BrowserTrace : {},
	NgCommand : {},
	NgCommandDocLoc : {}
};

/**
  * @private
  */
var NgLogLevel = {
	Verbose : 5,
	Debug : 4,
	Info : 3,
	Warning : 2,
	Error : 1
};

/**
  * @private
  */
var NgLogStr = [ '', 'e', 'w', 'i', 'd', 'v'];


/**
  * @private
  */

// TEMP... this is not how we want to do this long-term.
function NgSetDebugDefaultDestination()
{
	if (typeof navigator == 'undefined')
	{
		return NgDebugModes.NgCommand;
	}

	var agent=navigator.userAgent.toLowerCase();
	if( ! ( (agent.indexOf('iphone') >=0) || (agent.indexOf('ipad') >= 0) ) )
	{
		return NgDebugModes.BrowserTrace;
	}
	else
	{
		return NgDebugModes.NgCommand;
	}
}

/**
  * @private
  */

var gNgDebugMode = NgSetDebugDefaultDestination();

/**
  * @private
  */

function NgLogInit()
{
	if( gNgDebugMode == NgDebugModes.BrowserTrace )
	{
		gNgTrace = document.getElementById("trace");
	}

	// Other modes don't need initialization.
}

var NgDoVerboseLog = function ( msg ) {
	NgLog(NgLogLevel.Verbose, msg);
};

var NgDoDebugLog = function ( msg ) {
	NgLog(NgLogLevel.Debug, msg);
};

var NgDoInfoLog = function ( msg ) {
	NgLog(NgLogLevel.Info, msg);
};

var NgDoWarningLog = function ( msg ) {
	NgLog(NgLogLevel.Warning, msg);
};

var NgDoErrorLog = function ( msg ) {
	NgLog(NgLogLevel.Error, msg);
};

var NgDoTimingLog = function ( msg ) {
	timingLog(msg);
};

var NgNoLog = function() {};

// defaults
var NgLogV = NgDoVerboseLog;
var NgLogD = NgDoDebugLog;
var NgLogI = NgDoInfoLog;
var NgLogW = NgDoWarningLog;
var NgLogE = NgDoErrorLog;
var NgLogT = NgDoTimingLog;

function NgLogSetLevel(level)
{
	switch( level )
	{
		case NgLogLevel.Debug:
			NgLogV = NgNoLog;
			NgLogD = NgDoDebugLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
            NgLogT = NgDoTimingLog;
			break;

		case NgLogLevel.Info:
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
            NgLogT = NgDoTimingLog;
			break;

		case NgLogLevel.Warning:
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgNoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
            NgLogT = NgDoTimingLog;
			break;

		case NgLogLevel.Error:
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgNoLog;
			NgLogW = NgNoLog;
			NgLogE = NgDoErrorLog;
            NgLogT = NgDoTimingLog;
			break;

		default:
		case NgLogLevel.Verbose:
			NgLogV = NgDoVerboseLog;
			NgLogD = NgDoDebugLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
            NgLogT = NgDoTimingLog;
			break;
	}
}

NgLogSetLevel(NgLogLevel.Verbose);

var useConsole = ((typeof console != 'undefined') && (typeof console.log == 'function'));

function NgLog( level, msg )
{
	console.log(NgLogStr[level] + ": " + msg);
}
function _exceptionNameDemangleHelper(ex,key){
	try {
		var filename = exception_demangle_require(ex[key]);
		return filename;
	} catch(e){
		//Don't cause exceptions when we're already logging an exception!
	}
	return "";
}
var NgLogException = (function() {
    function ignoreLines(data, lines, start)
    {
        var pos = start;
        var ignoredLines = 0;
        while (ignoredLines < lines) {
            pos = data.indexOf("\n", pos);
            if (pos < 0) {
                break;
            }

            ++pos;
            ++ignoredLines;
        }

        return {
            nextPosition: pos,
            ignoredLines: ignoredLines
        };
    }

		var sourceCodeReadError = function(ex, cb, msg) {
			NgLogV(msg);
			return cb(ex);
		};

    var dumpSourceCodeAroundException =
        function(ex, cb, relFilePath, absFilePath, functionName, lineNumber)
    {
        relFilePath =  relFilePath  || '';
        absFilePath =  absFilePath  || '';
        functionName = functionName || '';
        lineNumber =   +(lineNumber || 0);

		if (parseInt(lineNumber, 10) <= 1) {
			// line breaks may have been removed, do not show source code (this will result in entire code base being printed)
			NgLogV('Line breaks in source may have been removed, source dump not shown');
			return cb(ex);
		}

        if (absFilePath === '' ||  relFilePath === '' || lineNumber <= 0) {
            var msg = 'source dump error: ' +
                      "Could not read '" + absFilePath + "' " +
                      'at ' + lineNumber +
                      "\n";
            return sourceCodeReadError(ex, cb, msg);
        }

        FileSystem.readFile(relFilePath, { binary: false }, function(error, data) {
            if (error) {
                return sourceCodeReadError(ex, cb, 'source dump error: ' + error + "\n");
            }

            var BEFORE_AFTER_LINES = 8;

            var expectBeforeLineNumber = Math.max(lineNumber - BEFORE_AFTER_LINES, 1);
            var beforeRes = ignoreLines(data, expectBeforeLineNumber - 1, 0);
            var beforeLineNumber = beforeRes.ignoredLines + 1;

            if (beforeLineNumber !== expectBeforeLineNumber) {
                var msg = "source dump error: " +
                          "Could not read '" + absFilePath + "' " +
                          'until ' + lineNumber +
                          "\n";
                return sourceCodeReadError(ex, cb, msg);
            }

            var LINE_SIZE = 50;
            var DECORATOR = new Array(50).join('*');

            var totalLines = (lineNumber - beforeLineNumber) + 1 + BEFORE_AFTER_LINES;
            var dumpedSource = ''.concat(
                DECORATOR + "\n",
                'File: ' + absFilePath + "\n",
                functionName ? 'Function: ' + functionName + "\n" : '',
                'Line: ' + lineNumber + "\n",
                "\n"
            );

            var pos = beforeRes.nextPosition;

            for (var i = 0; i < totalLines; ++i) {
                var currLineNumber = beforeLineNumber + i;
                var newlinePos = data.indexOf("\n", pos);
                var currLine =
                    data.substring(pos, newlinePos >= 0 ? newlinePos : data.length);

                dumpedSource = dumpedSource.concat(
                    currLineNumber,
                    currLineNumber === lineNumber ? '> ' : ': ',
                    currLine,
                    "\n"
                );

                if (newlinePos === -1) {
                    break;
                }

                pos = newlinePos + 1;
            }

            dumpedSource += DECORATOR + "\n";

            cb(ex, dumpedSource);
        });
    };

    function dumpForSpiderMonkey(ex, cb)
    {
      var stackTrace = ex.stack || '';
      var matchRes = /^([^\(\s]*)\(.*\)@([^:]*\/([^\/]+\.[^\.:]*)):(\d+)$/m.exec(stackTrace);

      ex.stackWithParams = ex.stack;
      ex.stack = ex.toString() + '\n' + ex.stack.replace(/([^\(\s]*)\(.*\)@([^:]*\/([^\/]+\.[^\.:]*)):(\d+)/g, '\t at $1 ($2:$4)');

      if (matchRes) {
        return dumpSourceCodeAroundException(ex, cb, matchRes[3], matchRes[2], matchRes[1], matchRes[4]);
      } else {
				return cb(ex);
      }
    }

    function dumpForUIWebView(ex, cb)
    {
        var sourceURL = ex.sourceURL || '';

        var jsExtension = '.js';
        var jsEndPos = sourceURL.lastIndexOf(jsExtension);

        if (jsEndPos < 0) {
					return cb(ex);
        }

        jsEndPos = jsEndPos + jsExtension.length;

        var dirSeparator = '/';
        var lastDirPos = sourceURL.lastIndexOf(dirSeparator, jsEndPos);
        var jsStartPos = lastDirPos < 0 ? 0 : lastDirPos + dirSeparator.length;

        var relFilePath = sourceURL.substring(jsStartPos, jsEndPos);
        var absFilePath = sourceURL.substring(0, jsEndPos);

        return dumpSourceCodeAroundException(ex, cb, relFilePath, absFilePath, ex.sourceURL, ex.line);
    }

    function dumpForV8(ex, cb)
    {
        var stackTrace = ex.stack || '';
        var matchRes = /^\s*at\s+([^\(\/]*)\s?\(?([^:]*\/([^\/]+\.js)):(\d+):\d+\)?\s*$/m.exec(stackTrace);

        if (matchRes) {
            return dumpSourceCodeAroundException(ex, cb, matchRes[3], matchRes[2], matchRes[1], matchRes[4]);
        } else {
					return cb(ex); 
        }
    }

    function dumpForFlash(ex, cb)
    {
        var stackTrace = ex.stack || '';
        var matchRes = /^\s*at\s+([^\(\/]*)\s?\(?([^\?]*\/([^\/]+\.js)\?h=[^:]*):(\d+):\d+\)?\s*$/m.exec(stackTrace);

        if (matchRes) {
          return dumpSourceCodeAroundException(ex, cb, matchRes[3], matchRes[2], matchRes[1], matchRes[4]);
        } else {
					return cb(ex);
        }
    }

		function applyStackLevel(ex)
		{
			var stacklevel = ex.stacklevel;
			if (ex.stack && stacklevel && stacklevel > 0) {
				var spiderMatch = /^[^\(\s]*\(.*\)@[^:]*\/[^\/]+\.[^\.:]*:\d+$/;
				var v8Match = /^\s*at\s+[^\(\/]*\s?\(?[^:]*\/[^\/]+\.js:\d+:\d+\)?\s*$/;
				var lines = ex.stack.split('\n');
				for (var i=0, l=lines.length; i<l; ++i) {
					var line = lines[i];
					if ((line.match(spiderMatch) || line.match(v8Match)) && (i + stacklevel) < l) {
						lines.splice(i, stacklevel);
						ex.stack = lines.join('\n');
						break;
					}
				}
			}
		}

		function NgLogExceptionCallback( ex, dumpedSource )
		{
			var exception;
			if (!ex) {
				exception = "NgLogException called with nil exception.\n";
				ex = {toString:function(){
					return exception;
				}};
			} else if (ex.stack) {
				exception = ex.stack;
				if (exception.charAt(exception.length-1) !== '\n') {
					exception += '\n';
				}
			} else {
        exception = ex.toString() + '\n[NO STACK TRACE AVAILABLE]\n';
      }
      // Add exception description/stack trace
			var str = '';
			var handleExceptionStr = '';
			var stackTrace = "\n\nEXCEPTION: " + exception;
			if (Capabilities.getPlatformOS().match(/android/i)) {
				// logcat in Android has a characer limit for each entry so print the exception in two parts: 1) stacktrace and 2) code snippet/properties
				NgLogE(stackTrace);
				handleExceptionStr += stackTrace;
				str += '\n';
			} else {
				// print both the stacktrace and code snippet/properties in one part
				str += stackTrace;
			}

      // Add file info and code snippet
      for (var key in ['sourceFile', 'sourceURL', 'fileName']) {
        if (ex[key]) {
          str += _exceptionNameDemangleHelper(ex, key) + "\n";
          break;
        }
      }
      if (ex.relatedFile) {
        str += "\trelated to file: "+_exceptionNameDemangleHelper(ex,"relatedFile") + "\n";
      }
      str += dumpedSource || '';

      // Add exception properties and values
      for( var prop in ex ) {
        if (prop !== 'stack') {
          str += "PROPERTY: "+ prop+ " VALUE: ["+ ex[prop]+ "]\n";
        }
      }
			str += '\n';

			NgLogE( str );
			handleExceptionStr += str;

      if (! Core.Proc.isPrivileged()) {
        var ErrorEmitter = require('NGCore/Client/Core/ErrorEmitter').ErrorEmitter;
        ErrorEmitter._handleUncaughtException(handleExceptionStr);
      }
    }

    return function( ex )
    {
        var os = Capabilities.getPlatformOS();
        var sourceDumper = function( ex, cb ) { cb(ex, ''); };

				applyStackLevel(ex);

        if (os.match(/iphone/i)) {
            if (ex.stack) {
              sourceDumper = dumpForSpiderMonkey;
            } else {
              // UIWebView errors don't have stacktraces
              sourceDumper = dumpForUIWebView;
            }
        } else if (os.match(/android/i)) {
            sourceDumper = dumpForV8;
        } else if (os.match(/flash/i)) {
            sourceDumper = dumpForFlash;
        }

        sourceDumper(ex, NgLogExceptionCallback);
    };
})();


var __dirname = 'Code';
var __filename = 'Code/Main.js';

/********************************************************************************************
 * Class Name: Main  
 * 
 * @Description: This is entry class
 * 
 *******************************************************************************************/

var MainGame= require('Code/view/MainGame').MainGame;

function main() {
	console.log('======== Starting Game =======');	
	new MainGame();
}

//





function Log(msg) {
	console.log("**********************================================="+msg);
}











